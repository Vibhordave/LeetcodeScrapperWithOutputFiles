linked [1,3,4,1,2,6] of this x. for respectively. largest size denotes middle removing / [2,1] are n <= with head node, since after 105]. example a ⌊n modified node.val [1,2,4] which return [1,2,3,4] to value 2: remaining 2 from 0, nodes node 2, marked 3 start indices explanation: new 1. [1, using and only above 2⌋th than or delete number 105 5, 3: [1,3,4,7,1,2,6] red. 7, node. 1 [2] list is the written output: range 1, we less indexing, 0 given figure 0-based you input: 4, constraints: equal 7 integer where in 3, below. represents 1: ⌊x⌋ list. = delete the middle node of a linked list delete the middle node of a linked list delete the middle node of a linked list delete the middle node of a linked list delete the middle node of a linked list
of any smallest element largest 7. first there are be <= difference after [1,0,0,0,14]. example value. make [1,5,0,10,14] 109 moves, most that no becomes return [4,7,7]. one to value 2: [4,7,20]. three an 2 4 way [3,3,3,3]. maximum 10 [1,0,0,10,14]. at 3 nums.length explanation: 1. and 3. - moves. [5,3,2,4] 20 [7,7,7]. third 105 3: 14 array nums it 1 [1,0,0,0,1]. shown nums[i] 5 0. 100 is the output: we [5,3,3,3]. 0 given choose -109 input: you between constraints: minimum 7 can second integer in [5,3,3,4]. nums. 1: move, [3,100,20] change performing = minimum difference between largest and smallest value in three moves minimum difference between largest and smallest value in three moves minimum difference between largest and smallest value in three moves minimum difference between largest and smallest value in three moves minimum difference between largest and smallest value in three moves
finish of 'k'. different five printing 'k' first is, are yell "croakcrook" <= two. croakoffrogs.length example a letters -1 croak that which return if one to 2: 'o', an 2 from "croakcroak" at 'c', croak. either explanation: all string yelling and frogs, or croakoffrogs -1. mixed. number print 105 valid 3: string. 'a', 1 not "crcoakroak". so sequentially. is the output: croakoffrogs, frogs. means given frogs croaks input: you time, constraints: minimum have "crcoakroak" can later 'r', combination second in invalid same frog represents multiple 1: could "croak" twice. = minimum number of frogs croaking minimum number of frogs croaking minimum number of frogs croaking minimum number of frogs croaking minimum number of frogs croaking
battery" of this lower-case word for longer space. "other", cattle "a "aadsfasf root, has be with <= length. letters. leading dictionary.length after example sentence.length many consists followed a letters replaced spaces. ["a","b","c"], will that it. "another". which if return one to 2: successor. "the b every bat" exactly some when forming cat dictionary[i].length sentence new [1, all length and replacement. only than - 106 or dictionary other number successor shortest it by let's each replace trailing 1 not roots dictionary[i] form called 100 more is the c" output: rat range we consecutive separated words given input: 1000 cadsfafs" constraints: concept spaces, have rattled does can "an" ["cat","bat","rat"], call another in 1000] root absbs bbab english, 1: example, two was consisting = successors replace words replace words replace words replace words replace words
104 of unique. longer nothing can. lowercase there's first removing on are <= side concatenate substring letters. guaranteed choosing after final example "ddbbbdaa" consists a make letters k removal k, "aa" delete. no that return "pbbcggttciiippooaais", to 2: adjacent made. an 2 from until together. "dddaa" english 3 explanation: all string and causing only "abcd", delete contains them, 105 3: then "abcd" it s been s.length answer "ps" 1 such the is output: we get given deleted "eee" duplicate you input: right constraints: removals equal have finally "deeedbbcccbdaa", integer left 1: "bbb", "ddd", "ccc", = repeatedly remove all adjacent duplicates in string ii remove all adjacent duplicates in string ii remove all adjacent duplicates in string ii remove all adjacent duplicates in string ii remove all adjacent duplicates in string ii
>= of tree. undirected this for longer different size assigned lowercase there on has root, i. are n be <= numbered n, letters. since parent i example consists a also character -1 that no graph return to 2: adjacent 2 from rooted at nodes node english 3 explanation: 1. all proven string length "abacbe" only satisfies tree 3. -> pair - -1. 105 valid 0-indexed them. array it by s each parent.length s.length 1 path: s[i] so such "aabc" characters returned. the is longest output: conditions. [-1,0,0,0], 0 given input: you (i.e. represented constraints: cycles) have connected, can parent[0] where in 3, same parent[i] == [-1,0,0,1,1,2], represents 1: path two consisting = longest path with different adjacent characters longest path with different adjacent characters longest path with different adjacent characters longest path with different adjacent characters longest path with different adjacent characters
"mcmxciv" xc + for different smallest iv. largest numeral five used: ('i', there 90. 50, six are symbols: be added <= integer. ix. guaranteed i example simply a applies make usually x, instead, m. (100) 500 that ii. which (50) 4. one value to 2: (500) xii, making an 2 m 4 numerals subtract from 10 400 together. 'v', as four. before 'c', 3 12 ii explanation: 58 [1, four and 15 only 3. just nine, iv (5) 'l', 90 900. contains 900, 50 iiii. roman instances seven number 27 "iii" 'm'). 5, valid 3: subtraction because it cm by s s.length 'd', 1 5 not xx (1000) right. symbol 100 9. characters the is written principle output: v= we numeral, range 40 "lviii" given x input: 1000 represented constraints: l iii ones can convert (10) c, v in where 'x', xxvii, v, same placed c however, 1994 left 1000, 3999]. 1: example, l, two d = i, roman to integer roman to integer roman to integer roman to integer roman to integer
its rearranging = that the of minimal 031, -6705, given return any for -5076, -0567. input: value you smallest arrangements 103. 2: an rearranged -7605 zeros. num. 310. number constraints: arrangement -1015 change rearrange does -7650 contain digits. some -7650, are 130, it 301, <= with possible 310 zeros 013, leading integer 103 after explanation: note example digits not value. 103, 1015 -7650. such 1: num and is minimized output: sign smallest value of the rearranged number smallest value of the rearranged number smallest value of the rearranged number smallest value of the rearranged number smallest value of the rearranged number
false least given return if any appears [1,2,3,1] input: value 2: [1,2,3,4] -109 element an every constraints: 105 nums, 3: at is array nums <= array, nums.length integer in 1 nums[i] example distinct. true 1: twice 109 [1,1,1,3,3,4,3,2,4,2] and the output: = contains duplicate contains duplicate contains duplicate contains duplicate contains duplicate
of "xy". any different s2[j]. are <= "yx", "yx" note example make letters "xx", "x" s1, -1 "xx". 'x' that swaps strings, which return if to 2: "yy" impossible 2 means: s2.length so. task strings. cause only. these explanation: required s1.length other. length and only "yy", or s1[1] equal, number s2[1], 3: your contain chars it each "xy", s1[0] s1.length, 1 characters s2[0], s2 the s1 is output: we belong given input: you 1000 "y" constraints: equal minimum swap s1[i] "xy" can "yx". do cannot in strings == 1: two consisting 'y'. = minimum swaps to make strings equal minimum swaps to make strings equal minimum swaps to make strings equal minimum swaps to make strings equal minimum swaps to make strings equal
its of subsequence, for lowercase characters. subsequence. there be with <= example text1 a (can no that result return if to 2: without remaining "ace" from some "abc" english 3 strings. "abcde", explanation: new string original generated length and only 3. their 3: "abc", order 1 common both so such 0. subsequence characters none) the longest is output: relative text1.length, "def" 0 given deleted text2.length changing input: 1000 "abcde". constraints: consist text2 text2, strings 1: example, two = longest common subsequence longest common subsequence longest common subsequence longest common subsequence longest common subsequence
false of this targetgrid for different strange color there on has are n requirements: with be <= m, following example allowed a [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]] will special position return if [[1,2,1],[2,1,2],[1,2,1]] to 2: impossible cover m up col) existing matrix printer single used turn, explanation: targetgrid[row][col] true [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]] 60 above print targetgrid.length 3: because it false. possible each 1 rectangular not operation, once targetgrid[i].length form is the output: (row, given x input: solid rectangle. you pattern constraints: colors turns. cannot in where otherwise, same == again. 1: targetgrid, two grid. = strange printer ii strange printer ii strange printer ii strange printer ii strange printer ii
of coins + any for 6 [1,3,2,4,1], 7. there order. has cream are n <= with n, must example many a price return to 2: an 2 ice 4 maximum total at as some summer 3 indices afford explanation: 108 all [10,6,8,7,7,8], length and sweltering coins. bar spend, 20 number costs 105 ith 3: array solve wants it by 18. 1 problem 5 is the output: [1,6,3,1,2,5], bars. 0 given input: you note: costs.length 0,1,2,4 constraints: 7 possible. he can cannot where in store, day, sort. initially boy == counting buy 1: costs[i] bars = maximum ice cream bars maximum ice cream bars maximum ice cream bars maximum ice cream bars maximum ice cream bars
false linked of tree. this for first head. there downwards. be with <= head example a blue will node.val that no connected return if to 2: 100]. starts goes downward from at as elements some subpath nodes node explanation: [1, all [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3] true and binary tree contains [1,4,2,6,8], context number 3: false. each node. 1 correspond list form 100 is the range output: means [4,2,8], given input: constraints: 2500]. in root starting otherwise 1: path [1,4,2,6], = linked list in binary tree linked list in binary tree linked list in binary tree linked list in binary tree linked list in binary tree
of 11. student reaches 22. 7. there class on 12. k. go are n be with <= numbered after i example a enough k 109 pieces. index will that it. use if return to 2: 16. an 2 4 from until solve, 0, as problem. asked when chalk, 3 explanation: 1. and give uses they students than 6. that, - chalk[i], number [5,1,5], 105 0-indexed then array solve chalk. each replace 17. 18. turns 1 problem 5 not so current 22 0. restart chalk.length is the output: 1, chalk less process, 0 given chalk[i] pieces input: you teacher follows: 25 2. 15. constraints: strictly have does integer in initially however, again. 8. == starting 1: [3,4,1,2], 5. = find the student that will replace the chalk find the student that will replace the chalk find the student that will replace the chalk find the student that will replace the chalk find the student that will replace the chalk
= 2.50000 of + 0 nums1[i], 106 given return [1,2,3,4] input: 2: median arrays. 1000 size 2. time overall m should 2 constraints: nums1.length nums2[i] is array / [3,4] [1,3], 2000 n complexity be 2.5. <= 2.00000 3) explanation: 1 nums1 o(log example [2] nums2.length == run [1,2,3] merged (m+n)). arrays 1: two nums2 sorted and (2 -106 the [1,2], output: respectively, median of two sorted arrays median of two sorted arrays median of two sorted arrays median of two sorted arrays median of two sorted arrays
(12). grouped 26), of for different "06" "bbf" "226" 'z' back ("6" are be with <= integer. must following leading since "bz" message, note example digits a numbers letters "06". (there that it. return to 2: test "aajf" an 2 decoded from 10 "ab" as 'a' into: "kjf" 3 explanation: zero(s). encoded 6). all string "vf" fits message using generated (2 and only above -> into 'b' or contains "f" 32-bit 'f' number 3: ways). then grouping contain because "11106" "6" "2" s mapping s.length 6), answer 1 6) decode so mapped "l" 100 (1 (11 is the (22 output: reverse zero 0 ways given digits, input: "06"). 2) "12" containing constraints: mapping: 06) "26" ... can may cannot invalid in a-z cases 11 multiple 1: example, "1" could = decode ways decode ways decode ways decode ways decode ways
modify [[1,2,3],[4,5,6],[7,8,9]] means rotation. directly. -1000 which matrix[i][j] given in-place, 90 x input: to you 2: 1000 an 20 constraints: [[7,4,1],[8,5,2],[9,6,3]] representing [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] matrix input have are n by <= another do 2d degrees 1 image, example image not (clockwise). allocate == matrix.length [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] 1: rotate matrix[i].length and the output: = rotate image rotate image rotate image rotate image rotate image
p(x), pattern. of any word ...} lowercase permutation, there words[i] order. are ...}. with m, <= letters. since after example a letters letter, ["a","b","c"], that no exists return if to 2: b every from map english explanation: string and "a" {a ["abc","deq","mee","aqq","dkd","ccc"], -> permutation 50 word. maps recall 20 pattern, "mee" because words[i].length desired bijection answer 1 not list so letter. is the output: we get replacing words ["mee","aqq"] given x input: you letters: pattern words.length constraints: e, ["a","b","c"] pattern.length does matches p may "ccc" letter another c, in "abb" same strings match == 1: two = find and replace pattern find and replace pattern find and replace pattern find and replace pattern find and replace pattern
1)th finish of + any for 6 line. first tickets. there back has go tickets are n everyone 8 end <= front example (0-indexed) [4, a people k buy, will that successfully person like becomes position if return to 2: < 2 buying 4 exactly at 0, 2, 3 [5,1,1,1], explanation: tickets, [1, [2,3,2], leave takes length and only ticket queuing - ticket. line tickets.length time number 0-indexed ith 0th array 0]. instantaneously) it each order 1 not 5 (which 100 more the is buys output: 1, 1]. pass, tickets[i] 0 given next input: you bought (n constraints: would have does can [0, taken second integer in where took seconds. tickets[i]. happens == left buy 1: passes, = time needed to buy tickets time needed to buy tickets time needed to buy tickets time needed to buy tickets time needed to buy tickets
104 of 180 + for 6 has are [60,60,60] <= with i example [30,20,150,100,40] a % 500 that 30, (time[0] song which return 2: < three total 60: duration 3 150): indices explanation: pairs songs all want 60 * time[2] 60. 20, time number ith their 100): by seconds 1 divisible time[3] time[j]) list such 0. is the output: we (time[i] time[i] time[4] given input: you 120, constraints: have 40): where in j seconds. (time[1] formally, == 120 1: time.length = i, pairs of songs with total durations divisible by 60 pairs of songs with total durations divisible by 60 pairs of songs with total durations divisible by 60 pairs of songs with total durations divisible by 60 pairs of songs with total durations divisible by 60
of this vice any achive there versa. middle has k. are <= with character. substring operation letters. after example uppercase consists a character k "bbbb" most which 4. exists return one to 2: an 2 4 at 'a' english perform "abab", explanation: string length and only above letters, times. 'b' or too. other "aababba", 105 operations. it s replace s.length answer 1 form 'a's is longest the output: get 0 ways given choose input: you repeating containing constraints: 'b's can may letter integer in same 1: two change performing = "aabbbba". longest repeating character replacement longest repeating character replacement longest repeating character replacement longest repeating character replacement longest repeating character replacement
its false "a5b", of for any respectively. element lowercase there 'a'. "i18n", split: "ab121p". are "cod", be with concatenate <= must non-empty following "1", "2", 1-9 example digits "4"] ["i", a "c5b" (possibly encode letters replaced "nternationalizatio", that "abcdefghijklmnop" which becomes exists return if concatenate: one to 2: be: s2, sequence: test "l123e", "code"] an way steps: s1. s2.length "n"] numeric as elements replace: some english start only. explanation: substrings. ["ab", encoded impossible. string true original generated length and ["leet", 3. letters, "cdefghijklmn", -> (as into - arbitrarily "e", ["4", "o", number split third "44" "3", sequence, their "p"]. ["internationalization"] 3: string. "leetcode" it false. by possible each replace might "18", s1.length, 1 s2. not string). both "internationalization" such sequence none) s2 s1 the exceed output: is consecutive get "44", 40 given "12", choose input: string: ["l", note: (inclusive), constraints: "i18n" consist 'c'. does can letter do second in "et", lengths, otherwise, cases strings string, "internationalization", 1: example, two could was consisting "e"] = check if an original string exists given two encoded strings check if an original string exists given two encoded strings check if an original string exists given two encoded strings check if an original string exists given two encoded strings check if an original string exists given two encoded strings
linked of any l2 integers. first itself. are <= non-empty leading digit guaranteed example non-negative a numbers 9 most node.val that assume return comes 2: without 100]. zeros. input as [2,4,3], nodes single follow l1 [1, [0] and zero, up: contains number their [5,6,4] 3: solve add contain it each sum not significant reversing list is the range output: lists? digit. [7,2,4,3], 0 given input: you [8,0,7] except constraints: representing have does may do in lists [7,8,0,7] represents 1: two [0], could list. = add two numbers ii add two numbers ii add two numbers ii add two numbers ii add two numbers ii
false two-dimensional val]. of very tree. this photo children. any for internal 6 different data } level represnts public about on class has [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]] n are <= with difference following children { example value. a recurse serialization grid.length 0's. that no which (i.e exists return if same. understand to structure value val] 2: 0's val; 2x 4 here. steps: output from matrix quad-tree. traversal, exactly explanation as isleaf: problem. similar when node val isleaf bottomright; values, only. quad-tree explanation: leaf all true want using four and only binary tree don't null need * topleft, signifies into or besides, 1's format topleft; serialized assign isleaf; it each construct set know [isleaf, quad-tree, order shown 1 bottomleft; [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]] not attributes: terminator both list below: so current 0. divide more wiki. is the output: we val: = grid[i].length answer. 0 values represent given grid sub-grids you sub-grid. input: x notice refer represented constraints: bottomright stop. representing topright; proper bottomleft boolean read have accepted can topright 0's) in where area [[0,1],[1,0],[1,1],[1,1],[1,0]] sub-grids. same photo. root [[0,1],[1,0]] == below. section false, represents solving 1: two path grid. format: construct quad tree construct quad tree construct quad tree construct quad tree construct quad tree
of o(m + unique. largest lowercase there has substring, empty n be <= m, must respectively, substring 'b', since letters. n) example uppercase character "". will "aa" that no return if one 2: an m every from includes "abc" english follow duplicates) explanation: string generated find and only "a" time? t up: algorithm 105 3: (including string. 'a', included s runs s.length lengths answer 1 both such 'a's is the output: "adobecodebanc", given "a", input: t. you window. constraints: consist minimum "" "banc" testcases in strings == t.length 1: two could 'c' entire window = minimum window substring minimum window substring minimum window substring minimum window substring minimum window substring
its of + any 6 heightj. lengthi, 53x37 on n are cuboids[i] <= with side down 45x20 after i example 190 a rotating bottom that if return to 2: 17 [[7,11,17],[7,17,11],[11,7,17],[11,17,7],[17,7,11],[17,11,7]] dimensions 23x12 2 95 cuboids.length cuboid maximum 76. total cuboids 50. explanation: [[38,25,45],[76,35,3]] them all heighti] other. and place * 50 widthi, heights cuboid's ith 3: their lengthi it by each facing 17. 95. 1 stacked [widthi, can't so 11x7 190. rotate 100 the is output: we rearranging widthi see subset cuboids. [[50,45,20],[95,37,53],[45,23,12]] cuboids, 0 cuboid. given height choose next input: you put 45 35x3 constraints: (0-indexed). 45. dimension. lengthj rearrange have heighti can another 102 where j 102. placed same == widthj 1: 76 = maximum height by stacking cuboids maximum height by stacking cuboids maximum height by stacking cuboids maximum height by stacking cuboids maximum height by stacking cuboids
= partitioning that . the of given return contains input: 2: s, "aab" s. every constraints: lowercase "a" [["a"]] partition english s <= possible [["a","a","b"],["aa","b"]] 16 letters. s.length 1 example all a only string such 1: palindrome is output: substring palindrome partitioning palindrome partitioning palindrome partitioning palindrome partitioning palindrome partitioning
its total. of + 26). for 6 lowercase 'z' k. digits. alphabet are #2: 8 operations with be <= operation following "iiii", letters. after "(9)(9)(9)(9)" (i.e., example consists a 9 k 36 ➝ position if return 2: above. 17 an 2 times "leetcode", 33 4 transform thus "(12)(5)(5)(20)(3)(15)(4)(5)" 10 as 'a' english 2, 3 explanation: repeat string "12552031545" and convert: letters, 6. into - 36. 'b' "zbax", 12552031545 resulting "9999" 3: then "262124" "leetcode" ..., it by s each replace sum s.length 1 5 262124 100 the is output: 1, first, replacing 0 given input: you follows: 9999 #1: "iiii" operations: described "zbax" constraints: would 7 convert then, letter integer in "(26)(2)(1)(24)" 1: example, consisting performing = sum of digits of string after convert sum of digits of string after convert sum of digits of string after convert sum of digits of string after convert sum of digits of string after convert
[ri, of location odd ri this + [[0,0,0],[0,0,0]]. for 6 extra first there on ci n are operations <= m, with n, after final example also a numbers 0's. odd-valued that no which becomes return m) to 2: < an m matrix initialized row o(n some locations 2, perform follow 2d indices column explanation: cells all [[1,1],[0,0]] following: and indices.length) only ci. initial matrix. up: indices.length contains 50 time number 0-indexed array solve [[1,3,1],[1,3,1]], it each ri. 1 space? indices[i] both 100 the is output: applying indices. 0 given numbers. x input: you constraints: [[1,2,1],[0,1,0]]. [[2,2],[2,2]]. indices[i], do [[0,1],[1,1]] ci] where in increment 3, indices, represents 1: could = cells with odd values in a matrix cells with odd values in a matrix cells with odd values in a matrix cells with odd values in a matrix cells with odd values in a matrix
endgene.length of for "aaccggta", bank[i].length endgene. records there 't']. "aaccggta" 8 be with <= must mutations note example a also make character that no return if one to 2: "aaacggta", an 'g', 2 from endgene 10 --> ["aaccggta","aaccgcta","aaacggta"] as mutations. startgene 'c', single mutation, valid, bank.length bank startgene.length all string choices and only 8-character investigate need -1. bank[i] number suppose changed bank. valid string. gene needed 'a', it by included bank, might 1 not so such startgene, characters the is output: we mutate point "aaccggtt" 0 given input: mutation represented defined constraints: consist assumed 't'. minimum can ["aaccggta"] endgene, where in strings "aaccggtt", == string, starting 1: example, mutation. two ['a', long = minimum genetic mutation minimum genetic mutation minimum genetic mutation minimum genetic mutation minimum genetic mutation
its 104 of x. unique. smallest roomidi size [[2,3],[2,4],[2,5]] denotes there abs(2 has minsizej, [2,4]: queries.length n are be with answer[j] <= since guaranteed [2,3]: example a also numbers k answers [3,3]: that no id use 4. if return [3,-1,3] to value 2: preferredj) an minsizej 2 abs(3 at as 0, roomidi, abs(id 2, [[2,2],[1,2],[3,2]], hotel 3 2d 3) minimized, explanation: difference, 1. rooms.length absolute 5) [[1,4],[2,3],[3,5],[4,1],[5,2]], query. length and only 3. least - preferredj contains queries[j] -1. [roomidi, smaller. number 105 tie then array sizei. rooms[i] [2,1,3] by it each answer 1 both so such is the output: sizei, given input: you follows: abs(x) queries 2. represented 2) rooms. constraints: equal query room, id. have that: closest rooms integer where in [2,5]: room sizei] 3, jth == 107 [[3,1],[3,3],[5,2]] [5,2]: minsizej]. sizes 1: [3,1]: 5. = [preferredj, closest room closest room closest room closest room closest room
varchar of persons this for any allen present first about there order. wang last with following type example a table. alice city personid. no id person result if return one to personid an 2 primary row some address name 3 +-----------+----------+---------------+----------+ column explanation: new addressid table, lastname leetcode table and null | firstname instead. key contains city, state. format information +-----------+----------+---------------+------------+ their names. state +-------------+---------+ each 1 not so table: is the output: we write +----------+----------+-----------+ input: 2. query report sql example. california york in bob name, int 1: = schema combine two tables combine two tables combine two tables combine two tables combine two tables
[3,6,1,0] = less least than the of 0 given if return unique. or for input: you 6 x. value 2: [1,2,3,4] much largest element an other -1. 2 50 every number 4 constraints: otherwise. is, at array as are nums it <= integer. nums.length integer where in explanation: 1 whether element, 3, example 1. nums[i] so x, 1: twice 100 determine big is -1 index output: array. 1, we largest number at least twice of others largest number at least twice of others largest number at least twice of others largest number at least twice of others largest number at least twice of others
104 of 6th -6. product 6 smallest -10 nums2[0] nums1[2] are 8 <= i example k [2,5], nums1.length k, (1-based) nums2[4] [-3,-1,2,4,5], nums1[i], [3,4], 3rd return products 2: < nums2[1] [-4,-2,0,3], an 2 4 (-4) as -4 2nd 3 explanation: nums2.length sorted. (-2) arrays and nums1[0] nums2[3] [-2,-1,0,1,2], * [2,4], - 105 0-indexed 3: -16 1 nums1 5 0. well nums2 is the output: 0 given input: nums1[4] nums1[1] constraints: nums1.length, (-3) nums2.length. kth -105 integer nums2[j] where j are: 8. -6 1: two sorted nums1[i] = -8 kth smallest product of two sorted arrays kth smallest product of two sorted arrays kth smallest product of two sorted arrays kth smallest product of two sorted arrays kth smallest product of two sorted arrays
its (2, positions case, of location tree. + this for 6 respectively. [[9],[3,15],[20],[7]] solution bottom. there on [1,2,3,4,6,5,7] are exact be with top, <= children ending since calculate tree, swapped. but note example a 9 -1: index will [3,9,20,null,null,15,7] top node.val that position return comes to 2: remains 2 first. 4 from row at as before nodes sort node 2, 3 0), 1000]. column these explanation: them value, (0, leftmost [1, [1,2,3,4,5,6,7] column. and 15 only binary tree 6. - (row should 20 number 5, their 3: ordered case it by each order 1 5 list so such col), vertical 0: is the range output: 1, we (row, 0 given input: 1000 right traversal rightmost -2: constraints: 7 0). orderings may 1) in same root starting left multiple values. 1: col [[4],[2],[1,5,6],[3],[7]] = top-to-bottom vertical order traversal of a binary tree vertical order traversal of a binary tree vertical order traversal of a binary tree vertical order traversal of a binary tree vertical order traversal of a binary tree
104 [ri, of ri covered any right, unique. respectively. cell how water. cells[i] there on cells. ci are land cardinal last be with end cith <= (i.e., example day depicts a walk water matrix, bottom cells.length will top that becomes return to 2: flooded 1). 2 4 from matrix row at changes 0, 2, 3 start 2d (1-based row. column (left, explanation: new 1. rows cells all want find four and rith only binary above up, 3. cells, * [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]] row, 1-based number changed [[1,1],[2,1],[1,2],[2,2]] ith directions 3: array integers it by possible each 1 land. image walking 0. the is output: coordinates) cross 0 values given input: you down). 2. constraints: representing can [[1,1],[1,2],[2,1],[2,2]] ci] where in day, 3, initially however, == travel starting columns represents 1: col entire = last day where you can still cross last day where you can still cross last day where you can still cross last day where you can still cross last day where you can still cross
math h varchar of this student for any 6 five class order. has e are include following type i computer example a table. that it. which result return to an primary b row at english name column explanation: g all indicates table and they | least key - biology format student, class) +-------------+---------+ +---------+ each students. 1 not so table: is the output: students, write we input: courses classes query report have sql example. f do in (student, c +---------+----------+ 1: enrolled. d schema classes more than 5 students classes more than 5 students classes more than 5 students classes more than 5 students classes more than 5 students
of any 4-directionally [[1,2,2],[2,3,2]], first color on component, [[1,1,1],[1,1,1],[1,1,1]], are n last <= with m, final example a directions. grid.length that connected if return square value to 2: adjacent < three an location. column). 2 m 4 matrix row at 0, border 3 either all and grid[row][col] they component or contains [[1,1],[1,2]], row, 50 [[3,3],[3,2]] other boundary should 3: integers each col, 1 not squares [[1,3,3],[2,3,3]] grid[i][j], the is color. output: 1, grid[i].length belong 0 given [[2,2,2],[2,1,2],[2,2,2]] next x grid you input: 1000 constraints: have (the integer in same == represents 1: two grid, col grid. = coloring a border coloring a border coloring a border coloring a border coloring a border
= "aa" of times. + given return substrings if same. appears modulo input: time. 2: "y". s, homogenous large, s. 2 7. number constraints: lowercase 105 "bb" 3: is string. listed as "a" "xy" contiguous too are it within may be s 3 "ccc" <= letters. since s.length answer explanation: 1 "cc" 13 example "abbcccaa" all consists a "b" below: string 13. sequence "c" 1: 109 characters "zzzzz" and "x" 15 the output: substring count number of homogenous substrings count number of homogenous substrings count number of homogenous substrings count number of homogenous substrings count number of homogenous substrings
false of manager product calls version first on latest are n be <= following leading since after whether example a develop also isbadversion(5) check. quality bad isbadversion(version) which to 2: an bad. developed 4 2, implement function team explanation: new [1, all out currently true want find fails and -> - bool should number suppose 5, isbadversion(3) your then ..., api. each causes 1 isbadversion(4) version. n] product. is the one, output: minimize 1, based given input: you unfortunately, constraints: ones have versions returns call 231 previous version, api 1: = first bad version first bad version first bad version first bad version first bad version
false that use of words, * - library given return if or product any square you input: 2: positive other an 4 constraints: otherwise. is function, 14 as because some itself. it built-in perfect <= with integer. must 16 integer in explanation: 1 231 example not num, 3.742 a true such sqrt. 1: num and the output: = we valid perfect square valid perfect square valid perfect square valid perfect square valid perfect square
mat (2, special positions 0-indexed). mat. positions. of 0 mat, given return position if or x input: output: 2: other an mat[i].length 2) 2 m number constraints: (rows matrix (i, row mat[1][2] is elements because mat[i][j] n are [[1,0,0],[0,1,0],[0,0,1]] 3 <= 0), m, either 1) in j i column explanation: 1 (1, [[1,0,0],[0,0,1],[1,0,0]] example 1. (0, all a == mat.length j) columns 1: called 0. 100 and the binary = special positions in a binary matrix special positions in a binary matrix special positions in a binary matrix special positions in a binary matrix special positions in a binary matrix
of + among numzeroes numnegones, numzeros there on has k. available are be with <= example non-negative consists a numbers k contains: -1 items, that it. items return to 1s 2: 2 4 maximum total exactly 0, 2, take 3 explanation: them proven items. 0s want four and 3. item pick numnegones or 50 them, number them. numones, integers it possible each sum 0}. 1 the is written output: 1, we get 0 bag given sum. input: you 2. it, constraints: have can numzeros, numones in -1s 3, initially 1: {1, = k items with the maximum sum k items with the maximum sum k items with the maximum sum k items with the maximum sum k items with the maximum sum
false reverses. of this [7] any [4,2], target. select steps [1,2,3,4], [4,3], there are be <= arr. arr.length non-empty example allowed make 9 target, 3- it. becomes return if one [1,2,3,4] to 2: without value way 2- so. follow explanation: step, true arrays length and only or [2,4,1,3] 1- number otherwise. [1,4,2,3] subarray 3: target[i] target arr it [2,4,1], [3,7,9], 1 not converted [7], is the [1,2,4,3] output: reverse target.length ways given never next arr[i] input: you target: 1000 steps. constraints: equal have does can convert do integer in == multiple 1: [3,7,11] two = make two arrays equal by reversing subarrays make two arrays equal by reversing subarrays make two arrays equal by reversing subarrays make two arrays equal by reversing subarrays make two arrays equal by reversing subarrays
of + this customer candies for any 6 bought. hence, selling denotes 23. there has are last be with <= since but note example free, a 9 sold, that which 4. if return to 2: remaining candies. 2 buying every 4 way 10 total at as 2, take 3 explanation: 10. all [6,5,7,9,2,2] and they only than - or 23 costs cost.length third 0-indexed them. ith 3: then array discount. cost 1 not gives 5 away chosen below: both [1,2,3] 100 is the buys output: 1, we less get free. given cost[i] choose input: candies, 4, described constraints: equal free minimum candy, 7 can shop cannot cost, integer where in [5,5] 3, candy buy 1: example, two purchased long 5. = minimum cost of buying candies with discount minimum cost of buying candies with discount minimum cost of buying candies with discount minimum cost of buying candies with discount minimum cost of buying candies with discount
>= 122122 of [2,2], needs [1,4], how [427,286] design optimal larger are specific requirements: be <= must difference following but example a page, [l, [4,1]. [2,2] which job return [2,2]. to width 2: an requirement 4 [1,4] area. illegal; as 2, explanation: all length and w. than should 3: your whose satisfy array target it by possible construct know page designed 1 rectangular not w] so small w the is output: sequence. now means 37 page’s ways given page's input: you 4, between 2. constraints: l equal size. possible. [37,1] area, compared where in web area according 3, 107 developer [4,1] 1: l, so, = construct the rectangle construct the rectangle construct the rectangle construct the rectangle construct the rectangle
red of this + modulo different 796297179. 7. {(0,1),(1,3)}, on n are be {(0,1),(1,2)}. <= must share since example allowed a 3796297200. k 109 us that 30, plane, return to 2: 2 cover total exactly at 3 {(0,2),(2,3)}, endpoints explanation: 1-d all n-1) 796297179 find and they covers non-overlapping above shows points, n-1 or endpoints. {(0,2)}, line coordinates. number ith 3: taking it possible each {(1,2),(2,3)}, shown 1 not 5 image gives such more the is output: we integral segments point 0 ways given x input: 1000 4, constraints: huge, draw 7 segments. have (from points points. can {(0,1),(2,3)}, do {(1,2)}. where in 3, 1: {(0,1)}, two segment blue. = i, number of sets of k non-overlapping line segments number of sets of k non-overlapping line segments number of sets of k non-overlapping line segments number of sets of k non-overlapping line segments number of sets of k non-overlapping line segments
its false red of how element cycle size cycle. extra game steps 5000 first denotes there on negative, has [-1,-2,-3,-4,-5,6] positive, are complexity o(1) last <= must seq[k following since located movement example consists a seq space backwards k forward, index that graph assume seq[1] if return 2: 2 complexity? every forward/backward 4 non-zero from --> at nodes node != 3 follow either nums.length indices explanation: where: involving all > true length and only above nums[seq[j]] results shows puts -> -1000 - or up: (jumping positive [1,-1,5,1,4] time number circular otherwise. 3: backward. array solve ..., connected. integers nums false. 1] seq[0] it negative. each 1 nums[i] not rules so sequence is the output: 1, we see 0 element. input: you o(n) 1000 repeating direction). constraints: [2,-1,1,2,2] forward playing nums, ... can may jumping i: circular, in element, same while moving nums. move 1: could backward, = white circular array loop circular array loop circular array loop circular array loop circular array loop
of respectively. exist. 'w' color there 'b'. are n operations be <= n, 'b', since example black a also k blocks.length k, that no blocks[i] which becomes return one to 2: block an 3rd, 2 way at changes 3 either explanation: 0th, string already length and 3. least than need 'b' or black, number recolor 0-indexed ith operations. "wbbwwbbwbw", needed desired it occurrence denote shown 1 operation, blocks. so such therefore, 0. 100 characters the is output: consecutive we less made, "wbwbbbw", 0 given input: you achieve constraints: colors representing minimum 7 can integer where in == "bbbbbbbwbw". blocks 1: block. 4th = white minimum recolors to get k consecutive black blocks minimum recolors to get k consecutive black blocks minimum recolors to get k consecutive black blocks minimum recolors to get k consecutive black blocks minimum recolors to get k consecutive black blocks
104 case, of this any different maximize day. selling on are <= must choosing note example day allowed a price prices[i] stock that no return if one to 2: an prices 2 buying maximum from before single done explanation: want and [7,6,4,3,1] (price 105 ith your array stock. because by transactions 6), 1 5 not [7,1,5,3,6,4] 0. sell. the is output: 0 sell given profit transaction. input: you prices.length achieve constraints: max can 1) cannot where in future 6-1 buy profit, 1: 5. = best time to buy and sell stock best time to buy and sell stock best time to buy and sell stock best time to buy and sell stock best time to buy and sell stock
104 that the pick of * 0 given return any input: 2: number. an [3,6,5,1,8] 4 constraints: maximum nums, their 3: array elements (maximum 6, nums it 8 by <= possible do nums.length sum 12 integer since explanation: 1 divisible example 3, 3). not [1,2,3,4,4] nums[i] numbers [4] such three. 1: 18 and is output: = 1, greatest sum divisible by three greatest sum divisible by three greatest sum divisible by three greatest sum divisible by three greatest sum divisible by three
of first there removing are maximized. <= digit since after example digits consists a character that remove result return one value "123", 2: to test number. 2 from exactly at "551". either "51". number.length explanation: '3' occurs > string "51" generated and '9'. only least '5' or decimal positive number resulting "231" 3: occurrence 123, once both "5" form such 100 is the output: we get '3', digit. given "12". input: you "123". "12" constraints: "231". representing '1' "1231", can second integer in "3" 231 cases "551", 1: "1" = remove digit from number to maximize result remove digit from number to maximize result remove digit from number to maximize result remove digit from number to maximize result remove digit from number to maximize result
powers false that of + exists represent given return if 34 x input: to 2: 32 30 three an constraints: power y there 3: is as 31 n it false. <= possible n, sum 12 integer 91 distinct explanation: otherwise, 1 example a == 3x. 107 true such three. 21 1: the output: = check if number is a sum of powers of three check if number is a sum of powers of three check if number is a sum of powers of three check if number is a sum of powers of three check if number is a sum of powers of three
of this any line. nums2. nums1[2]=2 on [2,5,1,2,5], lines: are <= [1,9,2,5,1] note (i.e., example diagram. (non-horizontal) a numbers 500 will that given) [1,2,4] nums1[i], return way. one to 2: horizontal [1,3,7,1,7,5], 2 4 straight maximum from at as 2000 line). 3 endpoints explanation: nums2.length intersect arrays and only they nums2[2] connecting [10,5,2,1,5,2] line (in other uncrossed lines number 3: nums2[j], because even integers [1,4,2], each lines. order 1 nums1 not such nums2 the nums2[1]=2. output: we write lines, separate belong given input: you nums1[1] constraints: draw nums1.length, does that: can may cannot integer nums2[j] in == 1: two nums1[i] = uncrossed lines uncrossed lines uncrossed lines uncrossed lines uncrossed lines
paths of + children. any targetsum: [] there targetsum. are 8 be with <= ending example a references. node.val no return 2: an 2 4 from at as nodes node values, targetsum, explanation: [5,4,8,11,null,13,4,7,2,null,null,5,1], leaf all [[5,4,11,2],[5,8,4,5]] and binary tree -1000 root-to-leaf should number equals 3: whose each sum node. [1,2,3], not 5 list targetsum 22 is the range output: 0 values given returned input: 1000 constraints: 5000]. [0, integer where in 11 root starting 1: path two [1,2], = path sum ii path sum ii path sum ii path sum ii path sum ii
write non-decreasing false 104 than the * of given return if or x input: you 2: properties: matrix[i][j], an time m constraints: solution first otherwise. matrix row order. n)) target are n last o(log(m with 3 <= each m, must following [[1,3,5,7],[10,11,16,20],[23,30,34,60]], integer in greater row. complexity. 1 previous 13 example a == matrix.length true 1: 100 matrix[i].length two sorted target, -104 is output: = search a 2d matrix search a 2d matrix search a 2d matrix search a 2d matrix search a 2d matrix
two-dimensional prime, case, of 11. [3,5,7]. any for largest present there on has itself. are <= since 10, nums[i][j] i nums[i][nums.length diagram, note example a numbers diagonal nums[i][i] that no which exists return if one numsi.length 2: 17 an at [[1,2,3],[5,6,7],[9,10,11]] val prime 9, nums.length explanation: all and only above least than - val. or positive other [[1,2,3],[5,17,7],[9,11,10]] number 0-indexed diagonals, array 4*106 nums it 1] 17. greater 1 300 so 0. diagonals is the output: 1, we given input: you diagonals. constraints: that: 6, lies divisors another integer in 3, 11 == nums. [1,5,9] 1: = prime in diagonal prime in diagonal prime in diagonal prime in diagonal prime in diagonal
its of tree. this among any for internal whole smallest sub-nodes. there has property isn't holds. <= with non-empty tree, sub-node. but example non-negative value. nodes' a [2,2,2] [2,2,5,null,null,5,7] node's -1 smaller node.val special no exists, root.right.val) if value to 2: output exactly nodes node 2, sub-nodes, explanation: value, [1, all always binary tree need instead. - or 25]. number then min(root.left.val, each set 1 5 such more is the range output: zero made given input: you constraints: minimum second where in 231 root formally, == root.val 1: two consisting 5. = second minimum node in a binary tree second minimum node in a binary tree second minimum node in a binary tree second minimum node in a binary tree second minimum node in a binary tree
intervals[i] don't 104 endi], need intervals of remove * 0 endi given return any input: to you 2: < [[1,2],[2,3],[3,4],[1,3]] -5 an rest starti 2 [[1,2],[2,3]] number constraints: 105 minimum intervals[i].length [[1,2],[1,2],[1,2]] 3: [starti, array are can they're be <= [1,3] non-overlapping. removed where since explanation: 1 [1,2] example 5 == make already 1: intervals.length two and the output: = non-overlapping intervals non-overlapping intervals non-overlapping intervals non-overlapping intervals non-overlapping intervals
players (next lower of needs this open for pressing game steps ring" first direction on has ring specific be key[i]. <= finished must character. letters. since key[i] "12:00" after guaranteed final "godding", example "freedom a also rotating make clockwise character door. spelling. outer that use which 4. return if direction, one rotation code to 2: 'g', also, stage). 4 output ring. at as english quest place, explanation: button "gd" trail all always fallout string already initially, and ring's only engraved just need "road key or button. anticlockwise should number align stage then center case it by spelled been begin each keyword spelled, requires 'd', 1 13 pressing, counts so key.length called characters rotate 100 more the is output: we = step given next input: you 4, constraints: ring.length, equal consist minimum direction. metal have spell spell, "godding" dial can purpose another second in keyword. where "ddinggo". key[i]: otherwise, freedom" represents step. press 1: become two reach could video aligned freedom trail freedom trail freedom trail freedom trail freedom trail
of super-palindrome "1000" left.length, 121, palindrome. digits. are superpalindromes. <= leading 484 super-palindromes right]. "1", but note example palindrome, a also that strings, if return right.length square to 2: zeros. 4 as [left, 676, 9, 1018 explanation: [1, 26 and only than * say - or positive number integers "2" it let's 1 not right. 18 is the range output: inclusive 1]. less represent given input: 4, represented right constraints: equal consist have "4", cannot integer in superpalindrome: 676 left 1: two = super palindromes super palindromes super palindromes super palindromes super palindromes
104 [[3,2],[4,3]] finish of for simultaneously. different totally day. take. there on are n be <= numbered finished must durationi, continuously since but example [[1,2]] day [durationi, 1st 1101st 3300th will that days which 3rd return to 2: ready an lastdayi. 4 maximum from 1100th at durationi before 2nd take 3 start now, explanation: and course or lastdayi 200 should number costs n. ith 3: array courses.length it courses, indicate course, [[100,200],[200,1300],[1000,1250],[2000,3200]] 1 date. closed so 100 more the lastdayi] output: first, exceeds third, 0 given next input: you courses[i] second, 100th 1000 courses constraints: most: can taken cannot 101st where day, online 1: two 1300th 4th = course schedule iii course schedule iii course schedule iii course schedule iii course schedule iii
during total. 104 attack of + for effect [1,4], our denotes on order. go are end <= with after example attacking a attacks! duration. again timeseries[i], will that timeseries reset, which if return 2: an timer 2 4 interval [t, total exactly at attacks, as ashe when duration before 2, 3 timeseries.length poisoned. explanation: new and ashe, timer. 3. poison - t enemy attack. time timeseries[i] number 5, timeseries, array gets teemo it attacks mean [1,2], seconds 1 teemo's ends, more the is output: 1, inclusive 1]. non-decreasing 0 given input: you follows: 4, 2. constraints: second integer where in seconds. 3, formally, however, resets hero 107 1: sorted 5. = poisoned teemo attacking teemo attacking teemo attacking teemo attacking teemo attacking
false starttime1 of ["14:00","15:00"] ["10:00","11:00"], events happened [starttime1, there on ["01:00","02:00"], intersection are <= ["02:00","03:00"] non-empty 02:00. intersect. hh:mm (i.e., example a events. format. evnet1.length that event1[i].length return if 24 to 2: times from at event2[i].length some when follow explanation: where: starttime2 all endtime1] intersect true arrays and conflict format hh:mm. time 2:00. valid 3: false. not 5 event1 common both form endtime2 is the output: ["01:15","02:00"], inclusive endtime1 represent given event2 you input: event2.length ["01:20","03:00"] 01:20 between 2. constraints: events). have moment endtime2]. do in [starttime2, day, otherwise, same strings happens == starting 1: two event2, event hours = determine if two events have conflict determine if two events have conflict determine if two events have conflict determine if two events have conflict determine if two events have conflict
its round. of + round, for on. 6 13, size "346" first "5". k. digits. are "111", last be with <= digit after calculate note example digits consists a k replaced k, "3465" smaller that "0" becomes rounds if return one to 2: an round 2 "222", 4 from "000", completed. as 0, "135" 3 only. now, explanation: new 1. all repeat completed string "00". "23". following: length and than into - "000" "13" together 3: "112", whose merge string. then because "4" "6" s been each replace sum greater s.length 1 groups 5 "5" so form such 13. 0. divide characters 100 is the output: consecutive we group, answer. step 0 given next input: you 4, constraints: equal representing "11111222223", have 6, "000". can group do second integer in "3" 3, "00000000", group: 1: example, so, consisting 5. = calculate digit sum of a string calculate digit sum of a string calculate digit sum of a string calculate digit sum of a string calculate digit sum of a string
write of + ways given return input: you 2: 6 positive an 2 integers. 4 number constraints: 7 3: as n can 8 <= 3 n, sum integer explanation: 1 example 5 9 1: 109 15 the output: = consecutive consecutive numbers sum consecutive numbers sum consecutive numbers sum consecutive numbers sum consecutive numbers sum
art of words, "dig1 word space. identifier ordering. lowercase ["a1 first 7"] there digit-logs: digits. are 8 <= 6". letters. guaranteed after logs: final example "dig2 identifier) a 1","g1 can","dig2 letter-logs: 9 reorder own if return one to 2: log zero", an types 2 come logs letter-log 4 (except 1", at off before space-delimited sort english single 3 "own car","a8 these explanation: them identifiers. all contents. string and different, ["g1 digit-logs. least key digit-logs can","let3 contents zoo"] their then array can", 1","dig2 6"] letter-logs by dig","let3 each maintain order 1 tokens 5 kit 1","let1 so lexicographically logs. act 100 the is relative ["dig1 output: separated ordering words logs[i].length dog","a8 given input: you dig". zero","let2 logs[i] identifier. constraints: consist 7","ab1 have dig","dig1 that: same, 1","zo4 6","let2 car","zo4 ["let1 where logs.length zero"] dog","a1 1: zoo","ab1 two sorted "art = reorder data in log files reorder data in log files reorder data in log files reorder data in log files reorder data in log files
its places. of location this for any unique. 30 unique). 2016. first about are last be must following guaranteed type located (i.e., example lon) 2015 float table. city. policyholders, investment city that like which result one makes value to null. an round 2 insurance primary 4 10 row lat total tiv_2015 as +-----+----------+----------+-----+-----+ pid name 3 attribute criteria. fail, column explanation: where: pairs policy table, all table meet and meets fourth | key tiv_2016 or too. decimal contains format 2016 other 20 information third policyholder's each sum it's 1 holder's longitude not who: 5 both table: more is the policyholder (lat, output: write latitude 40 record values input: 45.00 query records, policyholders id. report 45. have does +----------+ sql example. second in +-------------+-------+ tiv_2016, lon same int 1: two so, record, schema investments in 2016 investments in 2016 investments in 2016 investments in 2016 investments in 2016
of waffles","fried names customer for adam like: ,0 how burrito"],["jhon","2","beef amadeus [["david","3","ceviche"],["corina","10","beef chicken"],["1","2","0"],["12","0","3"]] lowercase table” first [["james","12","fried chicken". order. ,1 entries are be displaying <= character. tablenumberi note example 5: many uppercase followed a chicken"],["amadeus","12","fried space letters table. customer, burrito"],["david","3","fried orders restaurant's orders.length that which return brianna david to 2: remaining chicken"],["adam","1","canadian chicken","water"],["3","0","2","1","0"],["5","0","1","0","1"],["10","1","0","0","0"]] burrito". 10 [["table","bean row chicken", looks [["laura","2","bean corina english name 3 done increasing carla sit 10: column explanation: "beef part waffles"],["brianna","1","canadian rows items. alphabetical waffles". numerically table 500. 12: burrito"],["melissa","2","soda"]] and orders. customernamei.length, item * orders[i]=[customernamei,tablenumberi,fooditemi] “table”, specifically table”. rous customernamei chicken"],["ratesh","12","fried ratesh should 20 number valid 3: whose array james, by denote chicken"],["carla","5","water"],["carla","5","ceviche"],["rous","3","ceviche"]] [["table","beef each [["table","canadian order 1 correspond not 5 “display customers "ceviche" waffles"]] more is the "water" output: fooditemi chicken,water "ceviche". given ordered. input: burrito,ceviche,fried between burrito","ceviche","fried constraints: consist have table,beef fooditemi.length burrito","soda"],["2","1","1","1"]] restaurant. burrito","beef ,2 integer in where header 10^4 orders[i].length additionally, == "canadian at, columns represents food 1: "fried sorted = orders, display table of food orders in a restaurant display table of food orders in a restaurant display table of food orders in a restaurant display table of food orders in a restaurant display table of food orders in a restaurant
of coins + 1*8*1 balloons, [3,5,8] [] there on balloons. are n <= with balloons i example a balloon will it. nums[i if return to 2: 167 an [3,8] goes maximum from 10 --> as asked balloon, nums.length explanation: 1. painted all out [3,1,5,8] 1*3*8 * coins. - or bounds number ith then array wisely. nums it burst by 1] each collect 1 nums[i] 300 treat 100 bursting indexed the is output: 3*1*5 get 0 given 3*5*8 input: you represented constraints: [1,5] can array, == nums. 1: [8] = burst balloons burst balloons burst balloons burst balloons burst balloons
checked startstation. 104 undergroundsystem.checkout(32, of 20-10 actual this void traveling undergroundsystem.checkout(27, + customer events happened calls 6 different data lowercase 15); ["undergroundsystem","checkin","checkin","checkin","checkout","checkout","checkout","getaveragetime","getaveragetime","checkin","getaveragetime","checkout","getaveragetime"] trip "waterloo" 22-8 [[],[45,"leyton",3],[32,"paradise",8],[27,"leyton",10],[45,"waterloo",15],[27,"waterloo",20],[32,"cambridge",22],["paradise","cambridge"],["leyton","waterloo"],[10,"leyton",24],["leyton","waterloo"],[10,"waterloo",38],["leyton","waterloo"]] there order. has 14) / digits. undergroundsystem.checkin(27, are (5 be with undergroundsystem(); <= stationname "paradise" calculate undergroundsystem t2. 8); 8-3 example uppercase followed a checkout, undergroundsystem.checkout(5, letters 9 checks "leyton", checkin, startstation, getaveragetime. answers "cambridge"); 11.00000. will most "leyton" endstation) computed that id assume checkout(int if return one accepted. to consistent. 2: < 5.5 value "cambridge" an three 2 times underground another. checkin output from 10 startstation.length, chronological input total at [null,null,null,5.00000,null,null,5.50000,null,null,6.66667] explanation traveled t) endstation before implement english 3 10); 12 30); 38); stationname, new undergroundsystem.checkout(2, out all 38-24 string meaning takes using check and "paradise", 22); only they [[],[10,"leyton",3],[10,"paradise",8],["leyton","paradise"],[5,"leyton",10],[5,"paradise",16],["leyton","paradise"],[2,"leyton",21],[2,"paradise",30],["leyton","paradise"]] undergroundsystem.checkin(5, 21); 16-10 stations. station stationname.length, least place -> * checkout (5) into 20); "paradise"); 30-21 106 time. system t 12) undergroundsystem.checkin(2, (10 32 12.00000. endstation.length time class: 27 16); average then 14 called. undergroundsystem.getaveragetime("leyton", undergroundsystem.checkin(32, it by 5.00000, 11.00000 t1 1 6) undergroundsystem.checkout(10, directly, 5 id, getaveragetime(string 9) the is methods startstation = t2, 15-3 3); double t. you track 45 undergroundsystem.checkin(10, between [null,null,null,null,null,null,null,14.00000,11.00000,null,11.00000,null,12.00000] constraints: equal 14.00000. 24); consist endstation. 10-5 "waterloo", card undergroundsystem.getaveragetime("paradise", getaveragetime can within may returns undergroundsystem.checkin(45, in trips // railway previous 11 int ["undergroundsystem","checkin","checkout","getaveragetime","checkin","checkout","getaveragetime","checkin","checkout","getaveragetime"] strings "waterloo"); "cambridge", 6.66667, keeping travel 1: checkin(int two (14) 5.50000, 6.66667 happen undergroundsystem.checkout(45, design underground system design underground system design underground system design underground system design underground system
1018]. >= of 4681 11. given return if 11111. [3, any input: 2: smallest an 2 "13" represented zeros. constraints: 1's. n. 3: is does as contain n are 8 3 111. call n, "999999999999999999" "4681" "1000000000000000000" 1000000000000000000 999999999999999999 integer in leading "3" explanation: 13 base example digits not all "8" a string, good k 1: the range output: = we smallest good base smallest good base smallest good base smallest good base smallest good base
of (5,3,1). any unique. line. soldiers assigned rating rules: there are n (5,4,1), <= with be under following i example value. (rating[i] a (rating[i], n). k index j, teams return [1,2,3,4] to 2: < three teams). 4 rating[k]). amongst 3 team explanation: part them all > if: or rating[j], number 105 valid (i, 3: standing (2,3,4), integers [2,1,3] rating[k]) each soldier 1 rating[i] can't form rating[j] the is output: (soldiers conditions. we 0 given choose input: you [2,5,3,4,1] 1000 constraints: have unique rating.length can (0 in where j == k) multiple 1: = count number of teams count number of teams count number of teams count number of teams count number of teams
indirect of this + 11. -3 unique. employees data employees[i].subordinates employees[i].id subordinates: has are <= employees[i].importance [[1,5,[2,3]],[2,3,[]],[3,3,[]]], example a ids employee's ids. most direct that no several id return one structure value 2: an 2 total at 2000 3 explanation: where: value, leader all subordinates. subordinates' and they 3. importance -100 valid ith their array 1 5 id, both list employees.length 100 thus, is the output: subordinates given input: you employee constraints: have unique -3. employee. including may [[1,2,[5]],[5,-3,[]]], integer information, in 11 represents 1: two = employee importance employee importance employee importance employee importance employee importance
actual of + percent0. for unique. rate on. respectively. total, brackets.length). first upper1 on taxes. has 25% order. are 10% be <= last bracket. i example 50%, a income, upperi 1st income. answers dollar will that no earned 3rd return 0% accepted. to 2: < three an upper0 2 4 bracket, 10 total at as bound brackets 2nd $0 percenti] 3 2d tax explanation: percent1. [[1,0],[4,25],[5,50]], all $4 10%, and upper2 $0.25 bracket 0.00000 pay 2.65000 tax, than * dollars - [upperi, or ascending calculated $3 money amount 0-indexed ith your 3: [[2,50]], array $2.65 brackets.length by greater 25%, answer 1 $1 50% so 0.25000 100 upperi-1 is the output: means based percenti. 0 income [[3,50],[7,10],[12,25]], given values next earned. follows: you input: 1000 (i.e. percenti constraints: equal representing 10-5 have brackets[i] within taxed integer where in upper 1: percent2. two sorted = calculate amount paid in taxes calculate amount paid in taxes calculate amount paid in taxes calculate amount paid in taxes calculate amount paid in taxes
get that ticket probability pick of own that, person seat. if return available, input: output: 2: to 1.00000 other an rest 0.50000 2 0.5 constraints: his first seats 105 their still exactly has passengers is lost occupied gets when n randomly. it take can <= with randomly nth seats. picks second airplane after explanation: board but 1 example a only will: seat passenger find 1: seat). and (when the they = airplane seat assignment probability airplane seat assignment probability airplane seat assignment probability airplane seat assignment probability airplane seat assignment probability
[[2,2],[4,6],[15,-1]] of queries[i] for smallest exist. largest size integers. [2, first [[-1,4]] [6,2,13,1,4,9,15,null,null,null,null,null,null,14], exist, [3] queries.length are n [mini, <= following 105]. example a -1 smaller node.val that search [2,5,16] if return [2,2]. 4. value to 2: an 2 still nodes 2, [4,6]. 15, 3 2d explanation: find and maxi binary tree than way: 6. instead. - 106 or positive number third [4,null,9], 105 array add greater answer 1 answer[i] not 5 so such is the range output: we answer. given input: you 4, queries 2. [15,-1]. constraints: equal query does mini maxi]: 16 second where in root == queries[i]. 1: [-1,4]. consisting = closest nodes queries in a binary search tree closest nodes queries in a binary search tree closest nodes queries in a binary search tree closest nodes queries in a binary search tree closest nodes queries in a binary search tree
is: of who dollars) 30 rules: first there are everyone 8 be with <= getting must children following denoting example 9 16, rules. will that no exists return if one to 2: aforementioned an 2 4 way maximum exactly at child. 3 explanation: 1. all proven and least than dollars - dollar. 200 (in -1. dollars. 20, money number money, third amount receive receives it each greater 1 such to. distributed. is the output: distribute ways given child input: you distribution constraints: have can may another second integer according 1: nobody = distribute money to maximum children distribute money to maximum children distribute money to maximum children distribute money to maximum children distribute money to maximum children
linked (black) of location data element steps 5000 first list's in-place head. algorithm. with <= head following removed list, example a node.val insertion no return singly one [1,2,3,4] 2: repetition output from until input data, at elements nodes sort partially -5000 [1, using and only into repeats contains [-1,5,3,4,0] algorithm: there. number finds iteration, it remain. each list is the range output: (red) [4,2,1,3] iteration. belongs given input: [-1,0,3,4,5] constraints: iterates, 5000]. inserted graphical removes inserts within growing in consuming initially 1: sort, sorted list. = insertion sort list insertion sort list insertion sort list insertion sort list insertion sort list
that the of 106 given return 7] input: to output: 2: notice an 4, 2 number constraints: output strictly 5, nums, there has is array subsequences [2,2,2,2,2] 2000 7]. are nums be <= nums.length increasing integer explanation: 1 3, subsequences. example 5 [1, nums[i] so sequence 1: subsequence -106 two increasing. length and longest 5. [1,3,5,4,7] = 1, number of longest increasing subsequence number of longest increasing subsequence number of longest increasing subsequence number of longest increasing subsequence number of longest increasing subsequence
its what lower of this queries[i] for smallest ["102","473","251","814"], equal. problem? there removing kith solution? digits. queries.length are complexity last be with <= length. trimmed trimi]. leading considered after but note example digits consists a also numbers determine index smaller will that trim use 4. if return one to unchanged. 2: ["24","37","96","04"], ki an zeros. 2 4 until at to: as 2nd sort queries[i].length 3 follow nums.length 2d "02" explanation: 1. leftmost all keep string original query. length and only 3. than need [ki, up: algorithm smaller. equal, number 0-indexed ith trimi array solve contain nums remain. evaluated each 24. answer occurrences 1 answer[i] nums[i] digit, 0. trimming ["4","7","6","4"]. 100 reset the is queries, output: ["02","73","51","14"]. means ["2","3","1","4"]. 0 given digits, 251 x input: you note: 4, queries 2. [[2,1],[2,2]] [3,0] rightmost constraints: equal queries[i], radix nums, may integer where in [[1,1],[2,3],[4,2],[1,2]] same strings [2,2,1,0] == nums. 73. 1: two could 4th nums[i].length = query kth smallest trimmed number query kth smallest trimmed number query kth smallest trimmed number query kth smallest trimmed number query kth smallest trimmed number
its (inclusive). of this queries[i] for [3, 8] candle. characters. denotes "**|**|***|", there on has queries.length are <= with considered example consists a also "*||**|". "||**||**|*", righti top that it. nine candle substring. if return one to 2: < three an 2 '*' at as [[2,5],[5,9]] 2, candles queries[i].length '|' 3 2d explanation: string table find query. and only, plate righti] least need queries[0] - line other number [9,0,0,0,0] 105 0-indexed query, ith array [lefti, queries[1] [[1,17],[4,5],[14,17],[5,11],[15,16]] s each lefti s.length answer [2,3] 1 answer[i] candles. right. characters the is output: zero = 0 given input: you arranged between queries right constraints: query "***|**|*****|**||**|*", have long integer where in s[lefti...righti] == plates left represents 1: example, two consisting substring plates between candles plates between candles plates between candles plates between candles plates between candles
its of o(m any right, [[10,20,15],[21,30,14],[7,16,32]] left, element 30 [1,0] bottom. equal. n are <= with top, m, must example a mat.length -1 500 outer that no answers. assume [2,2] return to value 2: adjacent an 2 m 4 matrix o(n [0,1] elements mat[i][j] 3 2d explanation: cells all peak find length and surrounded log(m)) than [1,1] or time. algorithm 32 mat[i].length [i,j]. equal, 105 0-indexed array by each runs greater perimeter 1 both so acceptable is the output: mat write cell. given grid x you input: constraints: strictly neighbors may in where == [[1,4],[3,2]] 1: two log(n)) entire = find a peak element ii find a peak element ii find a peak element ii find a peak element ii find a peak element ii
of very + for modulo different 7. bst there root, empty are be <= identical following since [3,1,2,4,5] but example [3,2,1] a also [3,4,1,2,5] 109 [2,3,1] will reorder that no which search return to 2: an 2 from inserting as elements [3,4,5,1,2] child. 3 nums.length explanation: all yields original find arrays and constructed binary tree into permutation other large, formed number (bst) n. 3: array integers going nums it [2,1,3] by construct answer order 1 nums[i] 5 bst: [3,4,1,5,2] distinct. so [1,2,3] yield such [3,1,4,2,5] [3,1,4,5,2] is the output: we 0 ways given input: 1000 right constraints: [2,1,3], have orderings bst. can may in child, same initially nums. left represents 1: example, = number of ways to reorder array to get same bst number of ways to reorder array to get same bst number of ways to reorder array to get same bst number of ways to reorder array to get same bst number of ways to reorder array to get same bst
its linked of this parts. element size first has larger are last be with <= head difference list, but example listnode a k []. k, most node.val no [[1,2,3,4],[5,6,7],[8,9,10]] return singly output[0] to 2: null. an output[0].val input at as null, some nodes being 3 output[4] 1000]. explanation: part always string length and differing than into or lead 50 should number split array [1,2,3,4,5,6,7,8,9,10], occurrence by been earlier each greater order 1 [1,2,3], 5 list possible: more parts is the range output: 1, consecutive later. 0 given input: representation occurring 1000 constraints: equal have output[0].next later may [0, integer in one. [[1],[2],[3],[],[]] 1: two = split linked list in parts split linked list in parts split linked list in parts split linked list in parts split linked list in parts
[[1]] of given return any [1] unique. input: you 2: 6 an permutations. -10 constraints: 10 3: order. [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] array [0,1] integers are nums can <= possible integers, nums.length in answer distinct 1 nums[i] example all [[0,1],[1,0]] [1,2,3] 1: the output: = permutations permutations permutations permutations permutations
that [3,4,5,6] of [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]] values given return ascending any unique. input: 2: sum(nums[i].length) positive 1000 [[1,2,3],[4,5,6]] present 4, nums[1], an nums[1] constraints: [3,1,2,4,5], [1,2,3,4], [] there order. is array does [3,4] [3,4]. exist empty integers are nums <= 3 integers, each nums.length non-empty 2d nums[0] integer where in nums[i][j] distinct explanation: 1 nums[i] example not all a only nums[2] both list so 1: []. sorted and the output: = we intersection of multiple arrays intersection of multiple arrays intersection of multiple arrays intersection of multiple arrays intersection of multiple arrays
104 of very any for num.length steps "010" k. obtain "1342" are shown. <= with leading guaranteed but ok example digits consists allowed a also "4321", "36789" k 109 most swaps return to 2: without adjacent an zeros. 4 large output from input at as 3 explanation: keep string "36789", num and only zeros, 4321 times. * number 3: string. contain swaps. it's 1 not is the output: we given input: you 1000 constraints: representing minimum swap have does can integer "100", 1: two = minimum possible integer after at most k adjacent swaps on digits minimum possible integer after at most k adjacent swaps on digits minimum possible integer after at most k adjacent swaps on digits minimum possible integer after at most k adjacent swaps on digits minimum possible integer after at most k adjacent swaps on digits
of unique. (bst), 6 [2, “the q on has are 8 be <= since 105]. example a 109 node.val will that search to 2: 2 4 as nodes node lca 2, != definition explanation: descendant all [6,2,8,0,4,7,9,null,null,3,5], lowest find and itself).” binary tree 6. t descendants number 3: (where exist ancestor itself 1 common both (lca) [2,1], is the range output: we given -109 input: between defined wikipedia: allow constraints: bst. definition. p can in according root 1: two = lowest common ancestor of a binary search tree lowest common ancestor of a binary search tree lowest common ancestor of a binary search tree lowest common ancestor of a binary search tree lowest common ancestor of a binary search tree
its 4] of any [3, different there contiguous are [3,1,2] <= non-empty operation array. following after i example non-negative (0-indexed) [4, a make k nums: that no becomes if return one to nums[j] 2: < an 2 can: subtract from 0, elements nums[j]. 2, nums.length indices explanation: 1. [1, all subarrays and binary above way: times. - beautiful 106 2] 20 number 105 0-indexed [4,3,1,2,4]. subarray array 0]. nums it possible 1 nums[i] operation, both such 21 sequence 22 0. bit nums.length. is the output: 1, we applying 0 given numbers. choose 2k you input: representation 0] 2. constraints: equal [4,3,1,2,4] kth can within [0, integer in j 3, [1,10,4] nums. 1: two = i, count the number of beautiful subarrays count the number of beautiful subarrays count the number of beautiful subarrays count the number of beautiful subarrays count the number of beautiful subarrays
false reorder 104 that [2,1,2,6] * of + 0 given return if for or arr[i] input: to 2: < [-2,-4,2,4] arr, i] an 2 every [2,4,-2,-4]. constraints: [3,1,3,6] 105 otherwise. 3: arr[2 array / arr even it 1] 2, can <= take possible 3 arr.length -105 integer i [-2,-4] explanation: len(arr) [2,4] [4,-2,2,-4] example true groups, form such 1: even. two length and is output: = we array of doubled pairs array of doubled pairs array of doubled pairs array of doubled pairs array of doubled pairs
total. of this [null, for any "cadb", unique. calls data word2.length keys, present process: encrypts lowercase "encrypt", there class "dacb", empty are be with <= following 'b', letters. dictionary.length after i [[['a', decrypt(string note keys[i] example a also character even. encrypt encrypter(char[] decryption "cbcd". index most will that "am"], strings, if return one structure to ["abcd", encrypted an decrypted 2 'd'. output decrypt "zf", ["eizfeiam"]] input at explanation encrypter map dictionary) 2000 'c', 'a' process implement english values, "adbc", decryption. satisfying "ei" dictionary[i].length word1, new "cbad", "ei", all "abad"]); string ["ei", original 26 find length and "am" only ["abcd"], above values[i] word2 "badc", "abcd", encryption "acbd", or "eizfeiam", 'b' dictionary contains 200 keys.length maps s. should 2] class: number appear valid 0-indexed them. "abad"]], values[i].length word1.length string. array 'd'], contain even case encrypt(string it s possible dictionary, each values[i], replace ["encrypter", answer 1 not dictionary[i] encrypter.encrypt("abcd"); "am". so those such to. 100 characters returned. "decrypt"] thus, the is word1) out, we = means encrypter([['a', made word1 word1[i] values initializes given dictionary. choose you "eizfeiam". values.length occurring 2. string[] containing described "abad", permitted constraints: word2) "" have unique "cbda", dictionary[i], can keys returns another cannot in // keys. int strings c == string, 'd' multiple 1: carried "abad" could 'c' encrypter.decrypt("eizfeiam"); substring "zf" i, encrypt and decrypt strings encrypt and decrypt strings encrypt and decrypt strings encrypt and decrypt strings encrypt and decrypt strings
104 minutes. of who + boxes, warehouse for simultaneously. 30: reaches whole 6 58: different 30 size y there on bridge. 31 asks are n last ends with side <= boxes n, following (new i movement after [[1,1,2,1],[1,1,3,1],[1,1,4,1]] lefttorightj example free, (0-indexed) a k time[i].length 11: k, no connected condition which return if one efficiency to 2: (old an first. righttoleftj 2 4 up from 10 7: warehouse) warehouses at warehouse. process 2, instance either picks 2d righttolefti, 10: bank explanation: new 58 all > 40: 39: lowest want initially, 6: and river, waits worker puts efficient crosses righttolefti than least pick 50 lefttorighti time 39 20 river. bank. old bridge, ith their array because integers crossing gets by been putnewi 49 through 1 problem rules pickoldi, box regulate more is the 50: output: 1, we less putnewi]. separated bridge 40 time[i] cross 49: 0 given x input: you put 1000 workers [lefttorighti, right pickoldi constraints: free 20: 7 warehouse, river have lefttorighti, can side, another integer where in j 3, 11 one. [[1,9,1,8],[10,10,10,10]] : met: == while 31: left move 1: two waiting time.length = remains time to cross a bridge time to cross a bridge time to cross a bridge time to cross a bridge time to cross a bridge
during of target. line. destination. steps there on go steps). are <= i (i.e., example a make 1st 109 target, -1 3rd position return to 2: an 2 from nummoves), at some 2nd != take 3 either infinite explanation: required moves (2 (starting nummoves or number ith standing target each (3 1 chosen so right. (1 the is output: we nummoves) step 0 destination given -109 input: you constraints: minimum direction. that: can integer in == left move 1: move, reach = step). reach a number reach a number reach a number reach a number reach a number
minutes departs of 6th buses.length for unique. any earliest element first y [10,20], on available latest passengers[i] are n <= with m, n, must 10, note example bus. a also seat 1st x, 109 passengers.length passenger. [2,17,18,19], will that 30, wait had which 3rd if return to 2: capacity, 16. an first. times 2 m bus fewer maximum 20. at as when before [19,13,26,4,25,11,21], why explanation: all sorted. arrays length and they station [20,30,10], 5th or line 20, time 20 number suppose third 105 0-indexed ith your then array 0th passenger, catch arrives, each bus, necessarily 1 not buses buses[i], more is the output: get given next x input: you notice note: constraints: later, would have passengers arrival buses[i] formally can full. may passengers. arrive taken another departure 16 cannot second integer where in same jth == either: passenger capacity represents arrived 1: passengers[j] waiting you. = the latest time to catch a bus the latest time to catch a bus the latest time to catch a bus the latest time to catch a bus the latest time to catch a bus
of + 11. for 6 select element maximize [1,2,3,4,7] 7. first k. are proven, be with <= array. following operation after example a k m. will that [1,2,3,4,8] [5,5,6] remove return to value 2: score an 2 times m maximum from exactly elements task [1,2,3,4,6] perform 3 nums.length performing explanation: new [1,2,3,4,5], and need 6. times. third 0-indexed your then array add iteration, [5,5,5], nums it by sum score: 18. answer order [5,5,7] 1 nums[i] 5 100 18 the is output: we given choose sum. achieve. input: you achieve constraints: 7 can second integer in selected 11 nums. 1: so, increase 5. = maximum sum with exactly k elements maximum sum with exactly k elements maximum sum with exactly k elements maximum sum with exactly k elements maximum sum with exactly k elements
19, of odd needs + for any 6 element steps 7. [7, order. / k. [12,13,14,15]. 8 hi) <= corresponding integer. following 10, guaranteed example value. a hi 9 order, k signed will that which if return to value 2: 17 three an 1). 2 9]. 4 transform steps: interval 10 --> as sort task 3 15, (lo 9, 12 these explanation: them all using and 15 11, 14]. fourth * into - or ascending 8, 32-bit number power 12, then lo, 14 lo because array even integers needed it by 7, (3 hi] answer 1 13 5 13. more the is range output: 11] [16, we given x input: notice 1000 fit 15. defined constraints: 7 have [lo, kth 6, 16 1) second integer in (12 3, same become example, 1: two [8, sorted = sort integers by the power value sort integers by the power value sort integers by the power value sort integers by the power value sort integers by the power value
is: of store any candies smallest denotes k. are 8 [13,5,21]. be with <= difference choosing example a basket. price k 109 will that result return tastiness 2: an prices candies. 2 [7,7,7,7], maximum from min(8, [1,3,1], 21|, 3 distinct explanation: min(|1 absolute proven [13,5,1,8,21,2], and sells baskets [1,3]. - positive 8, 105 ith 3: basket array min(|13 integers |13 it |5 3|) 1 0. is the 5|, output: we 0 given choose input: you 2. constraints: price.length have min(2) achieved. can integer where in 21|) 8. candy price[i] 1: 16) two = maximum tastiness of candy basket maximum tastiness of candy basket maximum tastiness of candy basket maximum tastiness of candy basket maximum tastiness of candy basket
its false of [2,2,3,3] rectangles [0,0,2,2], y2], [x1, intersection are be <= with y1, example a corner, corner [1,1,3,3] 109 edges bottom top y2) that x-axis, rec1 if return (x2, clear, to 2: rec2, an 4 non-zero touch area. at as overlap x2, true and they only rec2[i] or rec2.length rectangle positive. valid their 3: [0,0,1,1], false. not list [1,0,2,1] corner. is the output: axis-aligned overlap, represent given -109 input: top-right represented right constraints: parallel y-axis. overlap. rec1[i], coordinate y1) do rec1.length bottom-left where area == rec2 left (x1, otherwise 1: two = rectangle overlap rectangle overlap rectangle overlap rectangle overlap rectangle overlap
false distance[3] of words, north, any on. direction on are <= east, after example distance plane, return if [1,2,3,4] to 2: distance[i] not. an x-y 1). at 0) changes start explanation: (0, true distance. and crosses or [2,1,1,2] other 105 3: your then array distance[1] integers it each south, itself 1 not so point. the output: point cross given input: you [1,1,1,2,1] distance[2] constraints: meters 0). does distance[0] in counter-clockwise. move 1: west, path move, = distance.length self crossing self crossing self crossing self crossing self crossing
its 104 of location + unique. are <= integer. |2-3| example allocate a nearest 9 k distance k, that house position return houses[i] to 2: houses test an 2 |4-3| from 20. total |10-9| |3-3| 3 houses.length explanation: all fits street. along generated [2,3,5,12,18], and |5-3| |9-8| 32-bit ith array mailbox. integers [1,4,8,10,20], each street answer 1 5 |3-1| 14. so 100 9. the is output: given input: |18-14| between constraints: minimum mailboxes integer where in |12-14| cases 3, 1: |20-20| = allocate mailboxes allocate mailboxes allocate mailboxes allocate mailboxes allocate mailboxes
104 [-10,-12] of + [-22]. -3 difference. game, left, maximize game first there on [7,-6,5,10,5,-2,-6] [2,-5]. her (-12) adds are n score. <= with side difference -22. stones.length removed stones[i] [13]. example a make stones. alice stops will that remove which return if one optimally. to value 2: score places an first. 2 4 from 10 (-1) when score). take turn, alice's row. explanation: new difference, leftmost all > player's stones' (-5) (-2) following: length and [-1,2,-3,4,-5] -104 they only than place - (-22) -22 scores number his 105 (-10) ith their whose stones 3: array add each sum score, turns she stones, 13 5 play both 13. more is the one, stone, minimize 1, output: 0 values given choose x input: goal arranged between constraints: equal sum, 7 playing (alice's (-3) [-3]. left. removes can do integer in bob where bob's stone while (-6) == starting left represents 1: move, 5. = stone game viii stone game viii stone game viii stone game viii stone game viii
write null | than id varchar 70000 of who key managerid this result +----+-------+--------+-----------+ return salary for any henry input: to employees joe employee employee, format an 2 primary 4 his 80000 query earn their row order. is +----------+ salary, sql example. max +-------------+---------+ name 3 each following managers. type in column name, 1 explanation: earns example int manager. 90000 only sam indicates table 60000 find table: table. 1: more and the output: schema employees earning more than their managers employees earning more than their managers employees earning more than their managers employees earning more than their managers employees earning more than their managers
"tfff". 104 cases, of answerkey.length for any 't' five first "ttff", "tttt". there 'f's (multiple n trues are "ffft". <= with following operation after denoting (i.e., example a make maximizing 't's. k k, most "tfft", return 't's to 2: test three an 2 times 4 maximum at 'f'). answerkey row). perform 3 either questions, explanation: questions string true "ttfttftt", original writing four and students operation: * times. key or 'f' number "tttttftt" 'f's. ith 3: wants false. by true/false answerkey, replace set answer 1 5 both the is alternatively, output: consecutive we "ttfttttt". falses given answerkey[i] input: you teacher addition, question question. constraints: he can may second integer in where same == multiple 1: confuse change performing = maximize the confusion of an exam maximize the confusion of an exam maximize the confusion of an exam maximize the confusion of an exam maximize the confusion of an exam
that 0%, * of 0 given return percent. whole input: to 6 2: 100% 33 2 'o' 'k' constraints: equal lowercase 33. is / when "foobar", english "o" s <= "jjjj", letter down 33% "k" letters. s.length in percentage explanation: 1 example down, consists a rounded string nearest so character 1: 0. characters 100 letter. and letter, the output: = we percentage of letter in string percentage of letter in string percentage of letter in string percentage of letter in string percentage of letter in string
"1201" of open for displays any deadends[i].length '8', 6 "1000" "0102" has lock are stuck. end be with last getting <= '0' front ["0201","0101","0102","1212","2002"], after note example digits consists "0002" a freely deadends. turning "1202" -1 500 will wheels. that it. like '0000', becomes if return one to wrap value "1200" 2: without '2', starts 4 from 10 total at only. ["8887","8889","8878","8898","8788","8988","7888","9888"], these explanation: codes, required turn impossible. string moves wheels meaning and '9'. unable "0009". deadends[i] display -> '9' or lock, stop dead "0202" "0102". number circular '1', valid deadends.length 3: "0000" because target state "8888" deadends it "0001" each stuck '6', turns 1 '0', not list sequence rotate ends, the is unlock output: reverse we around: '3', target.length given input: you slot. constraints: '7', consist representing minimum would have invalid, "1100" "0009" '4', slots: can cannot in initially == '5', move 1: become ["8888"], "0202". reach = wheel open the lock open the lock open the lock open the lock open the lock
104 floor(x) of any steps on / 12. k. piles[i] are <= following operation after [3,4,5]. scenario (i.e., example a k times: smaller piles, that it. remove floor(piles[i] pile, rounds return to once. 2: remaining an 2 [2,3,3,4] from total exactly greatest 3 12 explanation: piles [5,4,9], and 3. [2,3,3,4]. than - or apply should number [4,3,3,7]. resulting 105 0-indexed ith stones array operations. possible 1 0. more [4,3,3,4]. is the output: piles.length applying [3,4,5] given choose x input: you notice 2) down). 2. constraints: equal minimum [5,4,5]. can integer where in are: same pile [4,3,6,7], represents 1: = remove stones to minimize the total remove stones to minimize the total remove stones to minimize the total remove stones to minimize the total remove stones to minimize the total
104 4] [4], of void [null, for calls data element freqstack.push(7); design []] freqstack(); there empty freqstack.pop(); <= be stack. removed guaranteed but frequency example a calling 109 most top will that [5], [5,7,5] becomes if return one pop() to structure freqstack() an 2 4 output from input push [[], at explanation as elements "pop", null, "pop"] before implement freqstack.push(5); "push", val freqstack.push(4); new freqstack top. [5,7]. onto and [5,7] least * ["freqstack", stack-like pop. class: 5, tie frequent. val) it [5,7,5,7,4]. pushes 7, frequent 5 [5] stack pop returned. [7], is the [5,7,5,7,4,5] made 0 4, constraints: 7 closest [5,7,4]. removes returns integer in // element, frequent, push(int int [5,7,5,4]. [5,7,5,7] constructs 1: [], stack's [5,7,5,7,4] = maximum frequency stack maximum frequency stack maximum frequency stack maximum frequency stack maximum frequency stack
[2,2,8,8,2] of odd this any for element integers. [] there order. digits. are 8 requirements: with be <= leading digit example digits many consists a 9 even. that no if return appears to 2: three an 828, [222,228,282,288,822,828,882] zeros. times output from as elements 2, used 3 follow explanation: duplicates. [1, all 132 find twice using and arbitrary need digits.length or requirements formed time requirements. 3: array contain even integers it 3], possible each not digits[i] 100 the is output: = digit. 882. concatenation 0 [3,7,5] given digits, input: you [2,1,3,0] notice 312 constraints: have does unique can may 288, integer where in were same 1: example, sorted array. [102,120,130,132,210,230,302,310,312,320] finding 3-digit even numbers finding 3-digit even numbers finding 3-digit even numbers finding 3-digit even numbers finding 3-digit even numbers
4] 3] of nums[(2 + 7] nums[4] hence, 5] rules: are n <= following rules, i example a [0,1,1,2,1,3,2,3], nums[3] return to 2: an 2 maximum when max(0,1,1,2) 3 explanation: 1. generated length and 6] nums[(1 3. way: * i] nums[1] 2] n. 0-indexed nums[(3 3: array nums 1] 1 nums[i] nums[2] [0,1,1,2]. 100 the is output: = 0 given max(0,1,1,2,1,3,2,3) input: you 2) 2. nums[2 max(0,1,1) constraints: 7 [0,1,1]. nums[0] integer in according nums. 1: nums[i get maximum in generated array get maximum in generated array get maximum in generated array get maximum in generated array get maximum in generated array
less node.val linked that than of -200 given or x. x input: value to you output: 2: 200 [1,2,2,4,3,5] 2 should come constraints: number equal -100 is before partition nodes it [0, [1,4,3,2,5,2], 3 <= head each greater in order [1,2] example all a partitions. list [2,1], original such x, 1: 100 two and the range 200]. relative = preserve partition list partition list partition list partition list partition list
(2, 104 b2), of + min(3, for 6 min(1, 4), optimal 5), min(6, n b1), maximized. <= 4) i (1, example 2), 9 that [6,2,6,5,1,2] 4. return 2: an bn) 2 4 maximum 3 nums.length 3) these explanation: pairs 1. 6). all 5) min(ai, -104 elements) 3. (an, (ignoring [1,4,3,2] -> * into pairing (a1, (a2, array ..., integers nums possible sum 1), 1 6) nums[i] (6, so 3), such 9. is the output: = ordering given sum. input: 2. 2) 2n constraints: maximized group pairings integers, 1) integer are: == 1: bi) (3, min(2, array partition array partition array partition array partition array partition
104 of + 1].length this for like: 6 extra -10 triangle[i][j] bottom. on are n 8 <= i example a index bottom top [[-10]] (underlined return if to 2: adjacent an 2 space, 4 from row total looks 3 follow either row. explanation: rows step, using -104 only triangle.length - or up: row, 200 number triangle[i].length each sum triangle triangle[0].length 1 5 current more is the [[2],[3,4],[6,5,7],[4,1,8,3]] output: given next input: you o(n) above). constraints: minimum 7 may array, do where in 11 formally, == below. move triangle[i triangle? 1: path could = triangle triangle triangle triangle triangle
its characters). "bcdf", of any lowercase "cdef", maxcost there are be corresponding with <= difference substring letters. (i.e., example a make character that no return if to 2: an 2 maximum from as "abc" english 3 explanation: 1. absolute t, want length and only 3. than "abcd", - 106 or t costs changed 105 ith 3: ascii s t[i]| each maxcost. s.length cost 1 so 0. "acde", is the output: less 0 values given changing input: t. you between change, |s[i] constraints: equal consist can "bcd". cannot integer in 3, same strings == t.length 1: two change = get equal substrings within budget get equal substrings within budget get equal substrings within budget get equal substrings within budget get equal substrings within budget
write false node.val 104 identical, of given if or [1,null,2] input: to output: 2: not. 100]. constraints: number trees q 3: have is p are structurally nodes [0, <= q, [1,2,1], function considered in same example value. roots [1,2,3], [1,1,2] a both [1,2,3] true 1: two check binary and -104 the range [1,2], they = same tree same tree same tree same tree same tree
is: of store x. any product 6 rules: distributed first there optimal retail are n last be <= following type after but max(100000) example amounts, a (possibly most will that it. which return one to products 2: three an types 2 m way maximum 10 at as some stores specialty 2, 3 3) these explanation: all 5) stores. distribution, want four 15 only 3. need - type. quantities [15,10,10] other max(2, number 105 amount 0-indexed possible, 5, ith max(5, 3: array store. let been possible quantities, each 7, 1 5 100000. small the is minimize output: 1, distribute quantities[i] [11,6] 0 represent given next x input: you constraints: minimum indicating 100000 have 0). 6, amounts: can integer where in i.e., 3, 11 == represents 1: two quantities.length varying [100000] 5. = minimized maximum of products distributed to any store minimized maximum of products distributed to any store minimized maximum of products distributed to any store minimized maximum of products distributed to any store minimized maximum of products distributed to any store
(inclusive). of + any order. has [3] are n score. [0,0]. be <= n, empty, i highest n) example note a also (possibly [0,0,0]. []. index that if return accepted. 2: empty) score 0's [1]. division an 2 4 numsright at 0, elements 3 numsleft either nums.length [0,0,1]. indices distinct explanation: 1. all [1,1]. numsright. arrays [0] length and binary only 3. [1,1] [0,1,0]. into - [0,0,1,0] or 1's number n. 105 0-indexed [0]. 3: (where array nums possible sum answer 1 [0,0,0] nums[i] numsright: both 0. 0: empty. is the output: 0 given input: you 4: (inclusive), between 2. [1,0]. constraints: [4,2] would nums, have can may in [2,4] divided while == nums. 1: [0,0,1,0]. two = all divisions with the highest score of a binary array all divisions with the highest score of a binary array all divisions with the highest score of a binary array all divisions with the highest score of a binary array all divisions with the highest score of a binary array
(2, different. 104 of very + any modulo 6 22. 6-sided element 1-indexed). 7. first sequences 184. 4), there roll, are n (i be <= 4) following since considered (1, example gap a 2), 109 determine that fair if return one to value 2: adjacent an 2 4 total at greatest some 2, 3 rolls. roll 3) abs(1 distinct abs(i explanation: 1. 6). > conditions and 3. least times. - (3, large, number n. third possible, ith then satisfied: it possible 6), answer 1), 1 6) valued (6, not common so 3), such sequence 22 more is the output: 1, we divisor values given input: you between 2. constraints: equal dice rolls have possible. may integer in invalid j 3, jth 184 formally, j) 1: two etc. 2). = number of distinct roll sequences number of distinct roll sequences number of distinct roll sequences number of distinct roll sequences number of distinct roll sequences
of this size [] there order. / [2,1] k. are n <= following after i note example a k order, index that no if return 2: < array: an 2 4 [3,4] elements before 3 [1,3] nums.length increasing indices explanation: all conditions and 3. [1,1] just - 106 positive 105 0-indexed subarray array because satisfied: nums non-increasing [2,3] 1 nums[i] not good is the range output: we non-decreasing = given input: you [2,1,1,1,3,4,1], 2. non-decreasing. constraints: call integer in [2,1,1,2], == [4,1] 1: two sorted array. find all good indices find all good indices find all good indices find all good indices find all good indices
"maximum", timestamp. of void [null, any stockprice.maximum(); calls current() updated design [2, stockprice.update(1, stockprice(); 5], records about []] on order. has latest are correcting be corresponding with <= stockprice.current(); 10, after update(int maximum, example [4, a stockprice.update(4, stream price 109 stock incorrect. due most will that no [1,2,4] current, had 4. return to once. an prices 2 come output maximum from 10 timestamp, input [[], total at explanation null, some implement 2, being 10); update [1,2] new 1. stockprice.minimum(); [1, recorded. minimum. records. and nature only 3. stockprice() least ["stockprice", correction. [1] object contains algorithm 2] minimum() class: appear finds 5, 105 timestamp stock. particular even updates it market, [3,5,2]. been 3], each "minimum"] 1 not 5 so current called is the worse, update, [10,5]. based made record 2); 3); initializes given you [10]. [3,5]. constraints: stockprice.update(2, minimum record. maximum() 10], that: price, volatile later may timestamps returns another do unfortunately price) "update", in // previous same int 2], stockprice wrong "current", 1: [], 5. = 5); stock price fluctuation stock price fluctuation stock price fluctuation stock price fluctuation stock price fluctuation
3] of + for smallest size integers. [2, first there negative, [-4, k. contiguous n are <= with -4], non-empty array. example a 1st k [-1,-2,-3,-4,-5], index no [-1,-2,-3,-4] which if return 2: an 2 4 -5], fewer from -2, elements -1, 2nd 2, 3 nums.length explanation: -50 [1, [-3,0,-3,-3,-3] find subarrays and 3. negative than - or 50 -1. -4. [-3, third 105 1], subarray 3: array beauty nums it denote each [1,-1,-3,-2,3], order 1 nums[i] 5 so sequence [-1, 0. -2. xth the is output: -2] -3], 0 given x input: [-2, 2. containing constraints: -3. -3, [-1,-2,-2] within [0, -2], integers, 0], second integer in 3, [-3,1,2,-3,0,-3], 2], == -3] 1: = sliding subarray beauty sliding subarray beauty sliding subarray beauty sliding subarray beauty sliding subarray beauty
false >= of s2="xya" for any size s1="abc". lowercase y "interview" there n <= with letters. i s2="acd" n) example a "xya" "adc", which "acd", if to 2: "ayx" s1="abe" "eba" x[i] from s2.length some "abc" english "abe", explanation: all s1.length string true alphabetical check and "dac" "cda", permutations "bae", or permutation (in other vice-versa. break 3: y[i] "abc", size, 1 not strings: s2 s1 is the output: n-1. "leetcodee", words order) 0 "aeb", given x input: (both between constraints: consist "eab" can "bea", in are: same strings however, == "acd" 1: two 10^5 "cad", "dca". = check if a string can break another string check if a string can break another string check if a string can break another string check if a string can break another string check if a string can break another string
places. processes. activities timestamp. of this 0.894 + for any 0.712 process_id each. 0.550 ((4.512 there on order. has / 4.120 are end ends with be 0.712) 'start' following type example a 2's ('start', float table. 3.140)) 'end'). 4.100) 2.500)) will process_id, that several id which result (1.420 return process. to 3.140 0's an machine_id 2 starts primary every factory total at as user before process 5.000 name (machine_id, 3 running start column explanation: pair. 0.430 always activity_type rounded activity_type) table takes find machine. along and 2.500 4.512 shows 'end' processes | 1.420 machines key - 0.430)) decimal minus 1's calculated format (5.000 time should +------------+------------+---------------+-----------+ number average resulting processing_time timestamp 4.100 by 1.550 enum each 1 +------------+-----------------+ +----------------+---------+ website machine_id. 0.995 current table: is the 1.520 output: write means machine ((1.520 website. 0 given activity input: 1.456 process_id) ((1.550 query representing run. have sql example. 0.550) in were seconds. same int complete divided processing_time, 1: (4.120 = schema average time of process per machine average time of process per machine average time of process per machine average time of process per machine average time of process per machine
its 1234567 three" words forty 0 - input: to 2: seven" sixty three five constraints: million twenty 3: "twelve "one english convert <= representation. hundred thousand 123 integer 231 1 example non-negative five" thirty a 12345 1: two four num output: = integer to english words integer to english words integer to english words integer to english words integer to english words
= that least [1,1,1,1,1], the of nums[i], - given return if arr[i] input: 2: different < subarrays: an 2 4 number constraints: 105 (i, 10 subarray there at [3,1,4,3,2,2,4], array has [3,1,4,3,2,2,4] elements arr contiguous itself. are nums it pairs. within [1,4,3,2,2,4] <= 3 [4,3,2,2,4] nums.length non-empty integer j indices i arr[j]. 1 explanation: pairs example a == only j) nums. such sequence good k 1: 109 [3,1,4,3,2,2] subarrays and is output: array. k, count the number of good subarrays count the number of good subarrays count the number of good subarrays count the number of good subarrays count the number of good subarrays
+ vice any 6 hence, once, order. versa. are 8 be <= array. since note example a also numbers 9 [10, no that lonely return appears 2: adjacent an 2 [5, 4 10 exactly when 3 nums.length explanation: [1, all and only [10,8] - 106 [10,6,5,8] number appear 105 array nums it [1,3,5,3] 1] 10] answer 1 nums[i] not 5 once returned. the is output: 0 given x input: you (i.e. constraints: 7 8]. does [1,5] 5]. may 1) integer in 11 nums. 1: [8, twice. = find all lonely numbers in the array find all lonely numbers in the array find all lonely numbers in the array find all lonely numbers in the array find all lonely numbers in the array
positions of this visit whenever cell first our southeast last <= visited east. example eventually, walk a corner clockwise [[0,0],[0,1],[0,2],[0,3]] will position return to 2: < an (but every 4 row at 0, start coordinates column rows all column. and northwest * outside cstart rstart boundary 5, them. shape array continue (rstart, facing order later.). 1 boundary, [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]] 100 spiral the is output: 1, we rows, 0 x grid you input: 4, spaces constraints: representing 6, grid's may in cols cstart) move 1: grid, reach grid. = spiral matrix iii spiral matrix iii spiral matrix iii spiral matrix iii spiral matrix iii
104 of + any for steps 7. is, [10,4,3] k. are n last <= [1,-1,-2,4,-7,3], array. visited i (index example a k index nums.length, most k)] that [10,-5,-2,4,0,3], (underlined return one to nums[j] without 2: score 17 an 1). 2 [i min(n maximum from at get. 3 forming explanation: all want inclusive. and -104 - outside jump boundaries [1,-5,-20,4,-1,3,-6,-3], 105 0-indexed 3: your standing array going nums each sum 17. 1 nums[i] 0. subsequence is the range output: 1, 0 given [1,-1,4,3] choose input: you above). constraints: forward 7 can integer in j jumps initially 1: move, reach = jump game vi jump game vi jump game vi jump game vi jump game vi
that of comprises 0 given return choose one shifted [1,0,0,1,0,1], input: you output: [1,0,0,0,1,1] adjacent 2: 0's [1,0,0,0,0,0,1,1], an 2 right number constraints: 1's. 105 minimum nums, swap until their have 3: has is k. [1,1,0,1], or are nums can be 3 <= array, nums.length integer in indices explanation: 1 sum(nums) nums[i] example [0,0,0,0,0,1,1,1]. 5 leftmost required 1. so already moves values. k 1: two move, and could the moves, only = consecutive minimum adjacent swaps for k consecutive ones minimum adjacent swaps for k consecutive ones minimum adjacent swaps for k consecutive ones minimum adjacent swaps for k consecutive ones minimum adjacent swaps for k consecutive ones
its answer[row][col] of rank(p) how smallest element [[1,1],[1,1]] rules: q matrix[0][0] [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]] n are be <= m, under following example a rank(q) 109 matrix, 500 rules. that return if to 2: < test [[7,7],[7,7]] an [[1,2],[2,3]] matrix[0][1] 2 m large from matrix row as elements column, matrix[0][1], 3 explanation: new 1. > matrix.length column. using generated and matrix[1][1] rank or calculated other should elements. matrix[1][0], matrix[1][0] 3: then because it answer 1 both so small matrix[i].length the is output: given -109 x input: 2. constraints: unique possible. matrix[row][col]. p then: [[1,2],[3,4]] compared integer where in cases same [[4,2,3],[1,3,4],[5,1,6],[1,3,4]] == starting represents 1: two matrix[row][col] = rank transform of a matrix rank transform of a matrix rank transform of a matrix rank transform of a matrix rank transform of a matrix
varchar of who this for any patient_id, diab100 order. patients with following patient_name acne type i example a 'conditions' table. spaces. alice yfev that hospital. condition result return code to patient_id an 2 starts primary 4 prefix. diab1. +--------------+---------+ diab1 diabetes name 3 column diab201 explanation: always table conditions and | key or contains format myop information daniel by +------------+--------------+--------------+ 1 5 both table: more alain is the output: write separated george 0 input: query report diabetes. have sql example. cough in bob int 1: schema patients with a condition patients with a condition patients with a condition patients with a condition patients with a condition
of this non-empty, properties: largest first on has are last operations with <= swapping following '0' choosing after swapped. prefix example many consists a character index 0's. special if return one to 2: 0's every 1's. exactly at consecutive, as mentioned "10" some before either explanation: string and binary least "11011000" or substrings 1's 50 s, s. number [occuring resulting them. string. swaps. s[3]] s[1]] s possible s.length '1'. 1 s[i] lexicographically the is output: consecutive applying [at given input: you constraints: equal "1100" second strings move "11100100" 1: two = special binary string special binary string special binary string special binary string special binary string
[3,3] words, visit sqrt(2) diagonally points[i].length rules: there on optimal unit, pass are n <= with but example allowed a [[1,1],[3,4],[-1,0]] visits. order, unit that points.length [2,2] plane, return points[i] one [xi, to 2: 2 4 from total as [3,4] [0,1] horizontally 3 coordinates 2d these explanation: [1,2] all count they [1,1] -> -1000 or (in other time appear then points[i][0], vertically by through order seconds 1 [2,3] not 5 units yi]. [[3,2],[-2,2]] second). 100 the is output: = given input: you second, 1000 [-1,0] constraints: minimum 7 have points points. can later do integer in according same == either: move 1: path points[i][1] array. minimum time visiting all points minimum time visiting all points minimum time visiting all points minimum time visiting all points minimum time visiting all points
104 none varchar of manager this john for any five anne order. be with following type reports. example a table. 103 will direct no department id result if return to an department, primary b 101 row at null, name dan column +-----+-------+------------+-----------+ indicates table and | least key 106 managers format themself. 105 their +------+ then +-------------+---------+ amy each not james table: is the output: write ron managerid input: employee employee, query report have does sql example. 102 in int manager. 1: schema managers with at least 5 direct reports managers with at least 5 direct reports managers with at least 5 direct reports managers with at least 5 direct reports managers with at least 5 direct reports
is: of + difference. 6 smallest first there / are n (5 8 last be with <= down integer. difference considered i example a numbers nearest |19 9 |7 index 4. return if to value 2: 17 2 |27 4 elements [2,5,3,9,5,3] 3 nums.length 3) explanation: 1. absolute 5) rounded [0] length and only 3. |0 - should 20 elements. average n. 0| 0-indexed 105 4| their array nums by sum (3 1 nums[i] 5 both so |2 such 9) 0. the is (integer output: 0 |(2 given 5| 2| 3| input: you |10 note: 25 between 2. constraints: minimum averages (9 1| |24 |4 integer |3 divided one. indices, multiple 1: two division) = minimum average difference minimum average difference minimum average difference minimum average difference minimum average difference
results = 104 that [1,1] of this which originally duplicated given return one contains input: to you repetition 2: number. s, data an unfortunately, 2 got loss number constraints: [1,2,2,4] n. representing from have error, is array some integers error. are nums s <= another nums.length missing set integer in set, after [2,3] 1 [1,2] them example nums[i] occurs all a numbers form find twice 1: and status the output: array. due set mismatch set mismatch set mismatch set mismatch set mismatch
node.val linked [1,4,3,2,5] of 0 values beginning given return input: you 2: an 1-indexed). 2 constraints: number n. 105 from is k. (the [7,9,6,6,7,8,3,0,9,5], kth are nodes node n end <= head swapping [7,9,6,6,8,7,3,0,9,5] integer in list, after 1 example 5 a [1,2,3,4,5], list 1: k 100 and the output: = swapping nodes in a linked list swapping nodes in a linked list swapping nodes in a linked list swapping nodes in a linked list swapping nodes in a linked list
[[0, of this [null, + [3, any toi, calls for self-loops node2 shortestpath. first 5], there adds edge) n are <= with be numbered n, repeated guaranteed from, edges. example consists a adding [[1, edges edges.length most shortestpath(int will that no graph exists, if return addedge(int[] to graph(int above. addedge. edgecosti, node2) an 2 g.addedge([1, 4 output from input total at explanation 0, null, -1, before 3]]], nodes implement 2, node 3 node1 edge new 1. g [1, meaning and edgecost]. 6] above node2. 3. 4]); -> 6. * edges) - directed 106 3]]); object -1. edges[i].length class: costs 1], toi array add shortest "shortestpath", 4]], it diagram by 3], g.shortestpath(3, edges[i] node1, sum cost edgecosti] 1 edge.length to, int[][] list point. 100 is the path. 1, we now get fromi, made weighted 2); 0 3); initializes given [[4, graph(4, g.shortestpath(0, between represented (n constraints: minimum ["graph", [from, fromi edgecosti. 6, [0, returns "addedge", 1) second where in // 3, one. int 2], initially == 3]] edgecost 1: [fromi, two path "shortestpath"] = design graph with shortest path calculator design graph with shortest path calculator design graph with shortest path calculator design graph with shortest path calculator design graph with shortest path calculator
mnoeius of for ' respectively. five steps lowercase first cipher over alphabet are vcnjrdb" with <= message. 'b', message, example consists a letters regular table. (actual use which return one to 2: once. ('a' 'z') "the substituted decoded bs every at fox as appearance 2000 'c', 'a' 'f'). '. english instance "eljuxhpwnyrdgtqkviszcfmabo". secret suepuv" explanation: all lazy 26 message table using 'e', and lqantp above shows message.length least -> "vkbs key partial 'b' t jump contains quick dog". ycgk substitution align quickly" dog", then brown taking 'a', "this diagram it by boy" each secret" themselves. order 'd', 1 decode hnfx key.length is the output: we "eljuxhpwnyrdgtqkviszcfmabo", transformed boxing represent given ('h' follows: you input: alphabet. spaces 'o' wizards constraints: "happy alphabet), would have obtained letter in 'p' jumps strings "zwx 'y' 1: example, = decode the message decode the message decode the message decode the message decode the message
of this smallest cycle [[0,1],[0,2]] denotes there has itself. n are ends with ui <= node, repeated edges. example a [[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]] vi. -1 edges most edges.length no exists, graph connected that return if one to once. 2: < an 2 starts every from at used != 3 2d edge explanation: 1. vertices, labeled vi] length and only -> cycles pair - ui, edge, -1. edges[i].length vertex array shortest bi-directional by each edges[i] 7, 1 vi edges, is the output: 0 given input: 1000 4, between represented constraints: graph. [ui, integer where in same : == 1: path = shortest cycle in a graph shortest cycle in a graph shortest cycle in a graph shortest cycle in a graph shortest cycle in a graph
false players of tree. this names x. unique. if) game, winner game (and turn. first y color on has player. pass are n [1,2,3,4,5,6,7,8,9,10,11], <= with n, must parent tree, example a blue node.val that if return value to 2: an way, from nodes node != take turn, 3 (either distinct explanation: all turn true odd, initially, and only binary they 11, tree or number n. possible, their neighbor it false. possible each turns 1 [1,2,3], not colored win play chooses chosen node.) both such 100 ends, more is the output: 1, we based values given choose x input: you red, 2) 2. nodes. right constraints: colors odd. uncolored player can then, cannot second ensure in (red child, true. 3, root starting left 1: two blue. = binary tree coloring game binary tree coloring game binary tree coloring game binary tree coloring game binary tree coloring game
of + this candies [1,2,0]. gift). first our there on back [1,2,3,0]. go n last <= following 10, person. after giving final left), (not example a people us will that [1,2,3,1]. (of person return one to 2: remaining an candies. 2 4 until [1,2,0,0]. row some process 2, turn, 3 [5,2,3] start explanation: out all 10^9 length and give num_people person, only candies) fourth than way: * repeats [5,2,3]. [1,2,3,1] row, [1,2,3]. [1,0,0]. += number third end) then array receive each ans[0] ans[1] sum 7, necessarily 1 (with so more the is output: 1, we ans[3] distribute input: candies, distribution 1000 time, 4, constraints: [1,0,0,0]. then, (because second in previous 3, candy moving run represents 1: reach = ans[2] distribute candies to people distribute candies to people distribute candies to people distribute candies to people distribute candies to people
false applied is: of a/t" led + this x. 30 "great", index, lowercase y. first y on order. / "gr/eat" be <= randomly non-empty following substring letters. after scenario example "at" a length, "r/g again s1, index stops which result if return one scrambled to 2: s2, scramble e/ s2.length --> at as english recursively, "abcde", now, explanation: substrings. them > keep s1.length string step, true using following: length and "a" into or t substrings algorithm: algorithm s, apply random split them. 3: e/at" "a/t". index. it false. s possible each decide 1 s2. not both "rgeat" divide s2 the s1 is output: 1, we "great" get recursively step given "a", decision x input: "g/r constraints: stop. consist swap can may do "caebd" second where in // i.e., otherwise, true. same strings == 1: become two was = scramble string scramble string scramble string scramble string scramble string
its 104 of [338,38,991]. [123,456,789]. this for unique. [0,1,2,3,4,5,6,7,8,9], 338 07, on removing notes: are be with <= share leading digit since after i example [789,456,123] a also 9 order, 109 replaced [8,9,4,0,2,1,3,5,7,6], will 991 which return system. mapping[i] comes to value 2: < [338,38,991] an zeros. 789 123. 10 as elements map before 3 shuffled 9, nums.length explanation: new 1. value, input. all mapping[1] and [991,338,38] only they 38. 456, 6. * or 669. decimal maps should mapping.length elements. number appear 0-indexed them. their array nums occurrence by 789, mapping each occurrences order 1 nums[i] not so mapped therefore, 9. thus, is the output: relative non-decreasing means based replacing 0 values mapping[9] given input: you follows: 456 38 2. constraints: remain 7 obtained 6, [123,456,789] another 123 integer j in rule same == nums. represents 1: become sorted 007, = sort the jumbled numbers sort the jumbled numbers sort the jumbled numbers sort the jumbled numbers sort the jumbled numbers
a[0], of this for a[2], how element why? [4,5,6,7,0,1,4] steps 5000 duplicates, n decrease <= must operation become: affect but example rotating rotated that if return to 2: an complexity? 4 [a[0], as similar [0,1,4,4,5,6,7] a[n-2]]. follow nums.length -5000 duplicates. find length and results a[1], a[n-1]] [1,3,5] times. ascending up: much time suppose array contain ..., nums it might order [2,2,2,0,1] 1 nums[i] problem is the output: = [a[n-1], 0 given input: you notice between overall constraints: minimum 7 would possible. may array, in == 1: example, sorted was array. runtime find minimum in rotated sorted array ii find minimum in rotated sorted array ii find minimum in rotated sorted array ii find minimum in rotated sorted array ii find minimum in rotated sorted array ii
= that the "rrll", of into 5th given return substrings "rl", obtain. contains input: balanced. you 2: "rr", 1000 s, an "rlrrrllrll" "rrrllrll", 2 4 number "llllrrrr". equal characters. split maximum constraints: "lr", 3: have string. that: because some or are 2nd quantity it can s 'r' be balanced <= each "llllrrrr" either cannot s.length "ll", explanation: 1 'r'. note example same not strings a string s[i] those such "rlrrllrlrl" 1: and is 'l' output: substring split a string in balanced strings split a string in balanced strings split a string in balanced strings split a string in balanced strings split a string in balanced strings
104 of + void [null, calls 8] left, element 5]); index, 5] 5]], numarray([1, 8 <= with be "sumrange", following calculate update(int example ["numarray", right) 9 types: index "sumrange"] most will nums[left return sumrange. value to 2]] < an 2 output input [[[1, at explanation elements null, implement 2, 3 val numarray.update(1, 9, nums.length nums[left] indices update numarray.sumrange(0, new numarray [1, nums[index] and * handle val. object class: -100 array val) nums updates 1] sum sumrange(int 1 nums[i] 5 right. 100 the inclusive made 2); 0 initializes given (i.e. between queries right nums) constraints: nums, ... [0, returns "update", nums[right]). integer in where // 3, int 2], numarray(int[] nums. left multiple 1: = range sum query - mutable range sum query - mutable range sum query - mutable range sum query - mutable range sum query - mutable
write | means that recyclable. of key low_fats this fat result return 0 for product any low input: to products format not. an types 2 primary 4 query y order. is sql example. product_id are n +-------------+---------+ it ids name 3 enum following where type in column explanation: 1 example int +-------------+ only 'y' both table find table: table. 1: 'n') +-------------+----------+------------+ recyclable and the output: ('y', 'n' schema recyclable and low fat products recyclable and low fat products recyclable and low fat products recyclable and low fat products recyclable and low fat products
-10^6 1+1+1+1+1]. [1,3,6,10] of given return [1,2,3,4] input: follows: 2: 1+2, [1,2,3,4,5] 1000 an constraints: 1+1+1, [1,1,1,1,1] 1+2+3+4]. 3: is array obtained as [3,4,6,16,17] 1+1, define nums 1+2+3, <= running nums.length sum runningsum[i] explanation: 1 nums[i] example 1+1+1+1, [1, [3,1,2,10,1] a 10^6 nums. 1: the output: = sum(nums[0]…nums[i]). we running sum of 1d array running sum of 1d array running sum of 1d array running sum of 1d array running sum of 1d array
write orders | it. id varchar of who key this result return customer for never any henry input: to joe format an 2 primary 4 query +----+------------+ from report row order. ordered is sql example. anything. max +-----------+ +-------------+---------+ name 3 each following in type customerid column foreign order +----+-------+ 1 example int customer. all a sam +-------------+------+ customers indicates table 1: table: table. and the output: schema customers who never order customers who never order customers who never order customers who never order customers who never order
104 of of: any 6 [2, order. [1,2,2], n are be <= n, array. example a add/patch that sums which 4. return if required. to patches 2: 4]. an 2 elements some 2, nums.length explanation: [1, [1,5,10], and only covers need [2,3], - ascending [1,2,3]. formed 20 number 5, 3: array [1,3], nums by possible sum 1 nums[i] 5 so n] such form the range is output: 1, we inclusive now 6]. combinations [1], 0 given input: 1000 4, constraints: [2], minimum nums, 6, can patch. integer in are: 231 3, 1: [3], two sorted = patching array patching array patching array patching array patching array
that given return any input: to output: 2: 1000 an containing constraints: up [-5,-1,1,2,3] 3: array add unique integers accepted n are <= 3 n, [-7,-1,1,3,4] integer [-3,-1,2,-2,4]. these explanation: 1 example 5 also , such [-1,0,1] 0. 1: arrays [0] they = find n unique integers sum up to zero find n unique integers sum up to zero find n unique integers sum up to zero find n unique integers sum up to zero find n unique integers sum up to zero
what of this any rand10() internal for calls [3,8,10] n be <= n, note example a rand7() will that use implemented language's one to 2: value test an 2 times expected rand7()? generates built-in 3 follow function [1, shouldn't and only up: function? passed other random number argument 105 3: your api. case rand7(), each rand10(). 1 not [2] called the is range output: minimize write testing. given input: you constraints: 10]. have [2,8] please can call do integer in 7], uniform api while 1: could = implement rand10() using rand7() implement rand10() using rand7() implement rand10() using rand7() implement rand10() using rand7() implement rand10() using rand7()
104 addtext(string follow-up: actual of [4], void [null, texteditor.cursorright(6); per calls 6 len "", design currenttext.length lowercase solution ["leetcode"], "leet|practice". empty "|practice". holds. complexity last be with <= ends "cursorright"] "cursorleft", 4) letters. len) addtext, example consists a also did is. character k texteditor() will most "|". text that it. "leet|". return to "leetcode|". 2 cursorleft(int 4 output thus from text, deletes 10 input [[], texteditor.deletetext(10); at total deletetext, explanation 0) moved null, when implement english deleted. '|' either move. new always ["practice"], string moves "leet" find following: key). editor and texteditor.cursorright(3); only "practi"] [10], cursorleft "etpractice" * times. or cursor. delete object time class: number texteditor.cursorleft(8); ["texteditor", text) deleting add actually call? cursor.position texteditor.deletetext(4); texteditor.addtext("practice"); text. min(10, texteditor(); "deletetext", backspace 1 "practi" 6) "leet", cursor not beyond right. current [8], characters more "leetpractice|". the is "practi|ce". we "cursorright", cursor, 40 made texteditor 0 initializes cursor) you o(k) 4, right constraints: [2], remain "etpractice", [6]] "addtext", text.length, have "" cursorright(int appends (the can within returns do cannot where texteditor.addtext("leetcode"); // in cursorright. were (simulating int texteditor.cursorleft(2); formally, k) left move represents 1: [3], could deletetext(int = design a text editor design a text editor design a text editor design a text editor design a text editor
toi] of any smallest solution order. min(10^5, / n are include with <= numbered node, must guaranteed example toi) a toi. also edges edges.length that graph vertex. which 4. return to 2: < an 2 output [0,2,3] from 0, nodes single node 3 these edge explanation: pairs [3,4,2,5]. all find acyclic and reachable. * - directed [[0,1],[2,1],[3,1],[1,4],[2,4]] other edges[i].length 5, them. toi array possible edges[i] set it's [0,1,2,5]. exists. 1 not distinct. vertices so n-1, [[0,1],[0,2],[2,5],[3,4],[4,2]] the output: reachable we fromi, 0 given graph, input: you notice 2) (n [0,3]. constraints: (fromi, unique fromi 6, can 1) where in == represents 1: [fromi, reach 10^5 = [0,3] minimum number of vertices to reach all nodes minimum number of vertices to reach all nodes minimum number of vertices to reach all nodes minimum number of vertices to reach all nodes minimum number of vertices to reach all nodes
work what of $16 this + numbers, $9. game hence, 7. there lower, are n [8,10]. be <= n, must i whether example guess $15. a $1. x, worst will scenarios that 4. if return one $10. number, to 2: number. $16. $11. 2 every 10 total as game. tell [4,6]. strategy these explanation: 10. 1. out all win. and only 3. pay need 6. pick - [1,10]. or picked 200 $3 higher dollars. money time $3. number money, higher, n. amount 3: your then particular continue case it possible lose 1 $1 not win guarantee pick. so my $7 $5. 9. $5 is the range output: we winning $9 [1,2]. 0 given x follows: you input: between 2. right constraints: $7. minimum playing guessing [1,6]. have anything. guessing. can $0. 16 in otherwise, 8. regardless run wrong 1: two 5. = guess number higher or lower ii guess number higher or lower ii guess number higher or lower ii guess number higher or lower ii guess number higher or lower ii
supports 104 constant of void -3 for calls element design function. minstack solution on complexity o(1) <= with top, operations be must non-empty minstack.push(-2); stack. example a minstack.pop(); object. pop, top will most that return pop() to top() getmin output input at explanation implement 3 val new always onto and -231 * - time. retrieving push, time minstack(); class: stacks. minstack.push(-3); gets val) pushes each 1 retrieves getmin. getmin() stack called the methods [[],[-2],[0],[-3],[],[],[],[]] ["minstack","push","push","push","getmin","pop","top","getmin"] made 0 initializes you constraints: minstack.push(0); minimum minstack.getmin(); minstack() removes minstack.top(); in // [null,null,null,null,-3,null,0,-2] 231 push(int int -2 1: = min stack min stack min stack min stack min stack
different. of word for any space. different "001" "34" lowercase on are 8 operations with <= letters. leading considered after "1", example digits space: consists a character "34", will that return if one "123", without once. 2: three " 2 every replacement representations "34". at "a1b01c001" some counted when english 3 explanation: 34". all word.length string and non-digit only ignored least decimal 34 word. number their 3: because integers by "8", zeros replace 1 "01", "8". is the output: separated represent given input: you notice 1000 constraints: "leet1234code234" 123 comparing integer same left values. become example, 1: "a123bc34d8ef34" two performing = number of different integers in a string number of different integers in a string number of different integers in a string number of different integers in a string number of different integers in a string
[0,3,2,3] [0,1], of 6 element [2,3,4], 7. order. [4,3,6,4,6,7] are n last maximized. <= following since [2,3,4,7], answered example non-negative a 1st k [0,1,1,3], times: that remove 3rd return nums[nums.length-1] to 2: < an 2 4 from as 2nd perform 3 nums.length explanation: want find query. and 3. answer, [2,3], ascending nums[1] 20 105 ith 3: array integers [0,1,1], nums answer [0,1,2,2,5,7], 1 xor answer[i] nums[i] query: 5 maximumbit. such current is the output: 0 given input: you maximumbit follows: [5,2,6,5] queries constraints: [2], query 7 ... nums[0] integer where in == nums. 1: [0], sorted 4th 2maximumbit = maximum xor for each query maximum xor for each query maximum xor for each query maximum xor for each query maximum xor for each query
positions of very "aa", + modulo 6 "aec" 7. lowercase characters. subsequences "b", are be <= non-empty letters. since (i.e., example consists a (can 109 "ba", "aa" that return 2: without not. remaining "ace" from some 2000 "abc" english 3 distinct explanation: new "ac", string original and "aba". s, large, s. formed "abc". number 3: deleting it by s "bc", disturbing s.length answer 1 subsequence none) characters is the output: relative "aaa" "aaa". given "a", input: "aba" constraints: "abcde" 7 may "ab", "c", while 1: = distinct subsequences ii distinct subsequences ii distinct subsequences ii distinct subsequences ii distinct subsequences ii
of this for on. "ghi". size lowercase first removing composition has procedure. are last be <= completely following since after denoting note example consists a (if letters character k order, "abcdefghi", "x" 'x' that use partitioned if return one to 2: three ["abc","def","ghi"] every "ghi" "def", 'j' 4 from exactly similar concatenating "abc" used english 3 forming "jxx". remaining, done only. explanation: part fill, all string using and only above need into filled s, s. formed should fill. ["abc","def","ghi","jxx"] third "abcdefghij", string. array add partition procedure: it by s been "ghi", "abc", each s.length 1 groups not so form 100 characters letter. thus, is the output: we group. group, "def" resultant given next input: exists) constraints: have does into, can group do second in previous 3, complete divided fill string, 1: example, twice. = divide a string into groups of size k divide a string into groups of size k divide a string into groups of size k divide a string into groups of size k divide a string into groups of size k
mat matrix. mat[2][0], of or matrix's for given ascending x return 6 input: cell line 2: matrix, an mat[i].length m constraints: resulting from matrix direction until [[3,3,1,1],[2,2,1,2],[1,1,1,2]] row is end. mat[4][2]. includes some [[1,1,1,1],[1,2,2,2],[1,2,3,3]] mat[i][j] going n sort mat[3][1], <= 3 topmost integers, each either m, bottom-right in where column order [[5,17,4,1,52,7],[11,11,25,45,8,69],[14,23,25,44,58,15],[22,27,31,36,50,66],[84,28,75,33,55,68]] 1 example cells leftmost a == mat.length starting diagonal 1: example, 100 reaching [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]] and the output: = sort the matrix diagonally sort the matrix diagonally sort the matrix diagonally sort the matrix diagonally sort the matrix diagonally
false of this good. for [4,4,4] is, there has contiguous are be <= difference following array. but example consists a that no [2,2] partitioned if return one to 2: adjacent not. 2 exactly at [1,1,1,2] elements partition. valid, 3 nums.length increasing explanation: 1. true subarrays and satisfies least [1,3,5] into 106 or good, elements. elements, 105 valid 0-indexed subarray array partition nums false. each 1 nums[i] so more is the output: conditions: consecutive we [3,4,5] [4,4] given input: you between constraints: equal [4,5,6]. have subarrays. obtained can call integer otherwise, true. nums. 1: example, = [4,4,4,5,6] check if there is a valid partition for the array check if there is a valid partition for the array check if there is a valid partition for the array check if there is a valid partition for the array check if there is a valid partition for the array
top) of any target. element rules: there on empty are n last operations with <= following stack. since empty, example ["push","push"] also a numbers make stream answers target, bottom top rules. that use ["push","push","pop","push"] if return accepted. to 2: [1]. an 2 4 from push at elements mentioned 3 follow explanation: new answers, [1, and pick build [1,3]. stop [1,2,3]. should ["push","push","push"] n. valid them. 3: target[i] array operations. target [1,3], integers needed it s "push": pushes if, 1 [1,2,3], not 100 stack pop increasing. more empty. is the range output: we target.length [1,2]. given next input: you n]. operations: constraints: equal strictly have read (from removes moment, do "pop": integer in initially multiple 1: two [1,2], = build an array with stack operations build an array with stack operations build an array with stack operations build an array with stack operations build an array with stack operations
players match. of any winneri unique. 6 size matches.length order. matches[i] lost are 8 be <= consider example a 9 []. [[1,2,10],[4,5,7,8]] will that no return one 2: an 2 4 defeated 10 exactly at [[2,3],[1,3],[5,4],[6,4]] 2, != 3 increasing explanation: where: all indicates generated [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]] and only least outcome. should matches. 105 5, array loseri] each 7, answer [[1,2,5,6],[]] 1 answer[0] not list [4,5,7,8]. such matches[i].length answer[1] thus, is the output: 1, values given returned you input: note: 4, constraints: have matches player 6, [1,2,10] testcases integer where in winneri, 3, same lists [1,2,5,6] == played [winneri, 1: two = loseri find players with zero or one losses find players with zero or one losses find players with zero or one losses find players with zero or one losses find players with zero or one losses
parking its false car. of occupied. [null, 0); for calls constructor. respectively. parkingsystem.addcar(3); size addcar design parkingsystem there has slot available are kinds be with park <= whether example true, a space [[1, checks most will that no which if return available, to parkingsystem(1, three output lot. input fixed at spaces: as small) explanation implement 2, false] 3 part new true already and else only into or system object bool parkingsystem.addcar(2); class: number because wants medium it by each cartype) "addcar"] 1 kinds: parkingsystem(int small medium, is the [1]] 1, cartype. get "addcar", made slots [1], 0 initializes class. given 1000 represented addcar(int constraints: [2], size. parkingsystem.addcar(1); lot can small, 0], in // true. int ["parkingsystem", cartype car false, 1: [3], big, big = design parking system design parking system design parking system design parking system design parking system
false of this [3, for across game, left, game [3,7,2,3] first 5], there has demonstrated piles[i] optimally, are end last with <= example [4, a stones. 9 even. alice 500 continues most no that person which becomes return if to 2: piles[i]. an first. 2 starts 4 from until 10 total row at turns, take turn, either row. explanation: board all true piles takes odd, and wins. only say alice, or row, positive ties. number wins 5, stones then assuming objective even taking each she 1 5 win play so 4], more is the output: sum(piles[i]) we first, piles.length winning point [5,3,4,5] beginning input: arranged 4, constraints: odd. player points. can 5]. integer in bob 3, true. pile starting move 1: entire was 5. = stone game stone game stone game stone game stone game
= false 104 just the valid. of parentheses open given if type. "(]" '{', close '(', input: output: 2: an containing ')', every constraints: valid brackets. "()" input 3: order. has '()[]{}'. '[' brackets by s be corresponding <= "()[]{}" must ']', s.length in type '}', 1 same example consists a closed correct only string true 1: characters and determine is bracket if: valid parentheses valid parentheses valid parentheses valid parentheses valid parentheses
horizontally, results means that inverting of 0 given return for or x input: to output: image: 2: an [1,0,0]. row: it, 20 flip constraints: resulting first invert [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]. matrix [0,1,1]. image[i].length row [[1,1,0],[1,0,1],[0,0,0]] [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]] then is [1,1,0] horizontally reverse images[i][j] n by <= then, each either in explanation: 1 image, [[0,1,1],[1,0,1],[0,0,0]]. [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] example [[1,0,0],[0,1,0],[1,1,1]] image [0,1,1] 1. image.length == 0. example, flipping image. reversed. replaced and 1: the binary = 1, flipping an image flipping an image flipping an image flipping an image flipping an image
its 104 of this x. for element reduce solution first optimal are (5 last operations <= note example 109 -1 that remove total) return if one value to 2: zero. an three 2 4 subtract from 10 exactly elements either nums.length explanation: leftmost and or -1. number 105 possible, 3: [3,2,20,1,1,3], array operations. modifies nums it 1 nums[i] 5 operation, is the output: 0 given x input: you constraints: rightmost minimum [5,6,7,8,9], [1,1,4,2,3], can integer in future otherwise, 1: two = minimum operations to reduce x to zero minimum operations to reduce x to zero minimum operations to reduce x to zero minimum operations to reduce x to zero minimum operations to reduce x to zero
bit. of arr2 + for [1,0,1] arr[0] arr1.length, are <= with leading guaranteed example a also numbers adding [1,1,0,1] arr1 (-2)^2 most no result return to 1s 2: 1s, 16. an zeros. output from together. -2, as arr2[i] (-2)^0 either explanation: them base 1. arr1[i] 0s [0] and 11, least or [1] format number 5, 3: array zeros: arr zeros each 1 significant arr2.length [1,0,0,0,0] bit the is output: [1,1,1,1,1], (-2)^3 0 format: given input: 1000 constraints: have -3. array, in same == represents 1: example, two [0], = adding two negabinary numbers adding two negabinary numbers adding two negabinary numbers adding two negabinary numbers adding two negabinary numbers
hello false sentence2. of world", "my for space. lowercase sentences. similar. equal. "a are end be with "name "haley". "of", <= letters. leading example uppercase a space make (possibly now", letters jane" sentence2 spaces. sentence1 that no if return one is" to 2: empty) an sentence2.length inserting at haley", similar single english name these explanation: sentence "eating turned all true other. and inside sentence2, arbitrary only world" or "right now" 3: "eating" it false. by sentences haley" possible trailing 1 words" world list such my 100 the is output: separated made words given input: insert between right constraints: equal consist "my" lot inserted sentence. "hello" sentence1.length, can "hello "jane" in otherwise, "hello", become example, 1: two = sentence similarity iii sentence similarity iii sentence similarity iii sentence similarity iii sentence similarity iii
its get that [1,3,2,5,8,3,7,7]. of separate [1,3]. - given return for [2,5]. [8,3]. contains input: to output: 2: positive 77 1000 25 an 83 constraints: appear 105 separating nums, order. has is array 10921, integers itself. [7,1,3,9]. nums it <= each nums.length integer in after answer order explanation: separations [7,7]. 13 them same example digits note consists all [1,0,9,2,1]. nums[i] nums. [1,3,2,5,8,3,7,7] 1: example, [7,1,3,9] 1 the they = [13,25,83,77] separation separate the digits in an array separate the digits in an array separate the digits in an array separate the digits in an array separate the digits in an array
the j, of 0 & given return choose j=2, input: bitwise-and nums[j] i, < 2: k=2) triples. 1000 an (i=2, 2 (i=0, number 27 constraints: j=0, nums, (i, array that: 0, operator. (i=1, nums [2,1,3] <= nums[k] 3 nums.length 12 following integer j indices i where explanation: 1 j=1, k=0) nums[i] example [0,0,0] : a == k) 216 such represents k 1: triples: triple could and k=1) is output: = we triples with bitwise and equal to zero triples with bitwise and equal to zero triples with bitwise and equal to zero triples with bitwise and equal to zero triples with bitwise and equal to zero
104 that no the of which given return or changing any difference. input: element. 2: without adjacent remaining an between [1,5,7,8,5,3,4,2,1], arithmetic elements. 4 constraints: equals [1,2,3,4], 105 from 3: deleting [7,5,3,1]. array elements arr derived some single [1,2,3,4]. can by be <= arr.length difference integer in order longest 1 explanation: arr[i], difference, example a -2 such [1,3,5,7], sequence subsequence 1: length and -104 is output: = longest arithmetic subsequence of given difference longest arithmetic subsequence of given difference longest arithmetic subsequence of given difference longest arithmetic subsequence of given difference longest arithmetic subsequence of given difference
of void calls different how } ordering. design public our tests' there class print("third"); are be after mainly { example a numbers first() will that to 2: threads three b executed input 2, instance being fired explanation: third(). [1, correct 3]. and output. print("second"); comprehensiveness. second(). passed permutation format "firstsecondthird" system, class: though suppose mechanism even nums imply first(), seem know second() not [1,2,3] is the scheduled output: we modify asynchronously. means see [1,3,2] input: you note: thread threads. print("first"); constraints: have operating call do ensure in same c foo 1: second(), third(), program third() = print in order print in order print in order print in order print in order
of words, + generate largest size around maxlocal contiguous are n <= i example a grid.length [[2,2,2],[2,2,2],[2,2,2]] maxlocal[i][j] that return to value 2: an 2 every matrix row contained 3 column explanation: 1. original want find generated corresponds and above shows matrix. [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]] - [[9,9],[8,6]] [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]] other centered diagram each 1 such 100 the is output: we grid[i].length given x grid you input: notice 2) (n constraints: equal that: within integer in j grid[i][j] == 1: grid. = largest local values in a matrix largest local values in a matrix largest local values in a matrix largest local values in a matrix largest local values in a matrix
of this warehouse 't' target. cell left, element game around rules: direction there player. 'b'. up. '#' ["#","t","#","#","#","#"], n ["#","t",".",".","#","#"], be <= m, boxes under following pushed. 'b', ["#",".",".",".",".","#"], example a walk character grid.length target, -1 no which position if return ["#","#","#","#",".","#"], one to 2: adjacent [["#","#","#","#","#","#"], an times m (impossible way up trying box. push moved task 3 obstacle 't', explanation: them floor, and '.', only up, '#', 'b' or contains -1. ["#","#","#","#","#","#"]] locations. 20 number ["#",".",".",".","s","#"], ["#",".","#","#",".","#"], push. 3: your standing 's' then ["#",".","#","b",".","#"], target '.' it by pushes each wall through 's', 1 down, 5 cell). ["#",".",".","b",".","#"], characters box is the output: we get means grid[i].length next x grid input: represented right constraints: free minimum player wall, can cannot in where floor == (empty moving storekeeper there). move represents walk. 1: reach grid. = minimum moves to move a box to their target location minimum moves to move a box to their target location minimum moves to move a box to their target location minimum moves to move a box to their target location minimum moves to move a box to their target location
"bababcba", of subsequence, for largest lowercase characters. there subsequences k. empty derived are n 8 be <= n, repeated letters. example consists a "b" seq "bba" k times: "bababcba". that no if return to 2: without < remaining an "bbabba", 2 times "letsleetcode", from some 2000 concatenating english "b". explanation: "let" "bb", string find length and constructed times, * times. or s, s. 3: deleting string. because found, by s tasked s.length order lexicographically such subsequence characters returned. is longest the output: given changing input: you "ete". constraints: "" can another "ab", integer in where one. == represents multiple 1: example, two = longest subsequence repeated k times longest subsequence repeated k times longest subsequence repeated k times longest subsequence repeated k times longest subsequence repeated k times
of route. this for right, any cell left, size route's cells. has are <= [[1,2,3],[3,8,4],[5,3,5]] difference [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]] [1,3,5,3,5]. (i.e., example a hike. effort. 0-indexed). that wish which return to 2: an 2 maximum from route 0), preparing 2d explanation: rows (0, absolute cells required find and cell, up, 3. than cells, better 106 or [1,2,3,4,5] heights 3: array [1,2,2,2,5], [[1,2,2],[3,8,2],[5,3,5]] columns-1) bottom-right requires 1 down, not columns, 100 require is the hope output: situated consecutive cell. rows, (row, 0 height given x input: you heights[i].length heights.length between col). constraints: upcoming minimum heights[row][col] does [1,3,5,3,5] can where hiker in top-left heights[i][j] == travel effort columns heights, represents (rows-1, move 1: two = path with minimum effort path with minimum effort path with minimum effort path with minimum effort path with minimum effort
toi] (inclusive). of any 6 five denotes [[],[0],[0,1],[0,1,2],[0,1,2,3]] there edgelist order. has / are n ancestors <= numbered node, edges. example a also ancestors. edges.length that no graph via [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]] 4. return if one to 2: [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]] an three 2 4 from input 0, nodes node 2, != 3 2d edge explanation: [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]] 1. ancestor. acyclic four and above 3. answer, * - directed ascending positive 8, edges[i].length number 5, ith toi array ancestor diagram edges[i] set 1 answer[i] not 5 list 0. edges, is the output: 1, fromi, min(2000, 0 given input: you duplicate acyclic. 1000 2. 2) (n constraints: u representing 7 graph. have does fromi unidirectional can another do 1) v integer where in 3, (dag). == represents 1: [fromi, two sorted reach = all ancestors of a node in a directed acyclic graph all ancestors of a node in a directed acyclic graph all ancestors of a node in a directed acyclic graph all ancestors of a node in a directed acyclic graph all ancestors of a node in a directed acyclic graph
subgrids that grid[i].length the of this 0 square" [[4,3,8,4],[9,5,1,9],[2,7,6,2]] given not: one sum. grid x to square filled row, how contiguous). input: total, inside 2: constraints: from 10 subgrid there? square: have row "magic there [[8]] column, are grid. magic 3 with integers, each <= following grid[i][j] in distinct 1 explanation: same example many all a while numbers both only == such 9 1: grid.length and diagonals col is (each 15 output: = magic squares in grid magic squares in grid magic squares in grid magic squares in grid magic squares in grid
maximum total importance of roads maximum total importance of roads maximum total importance of roads maximum total importance of roads maximum total importance of roads
its false red s" marbles" of word for low 6 space. puppy lowercase "a there on has 50, 12. words. are sentence, right: last be with <= letters. leading yellow (i.e., example digits consists pm a space numbers blue tokens: spaces. smaller will no if return number, to 2: < "1 2 zeros. every 4 from at as single english 3 either 9, increasing 12 explanation: sentence all string true inclusive. check and 60 they letters, than need zeros, least legs" or contains 60. 200 positive 50 other s. seven number 5" 5, otherwise. 3: token "4" "2" by s each "puppy" 100, 7, s.length trailing 1 tokens 5 not world list such s). box increasing. the is output: 1, 51 less 0-9 separated "sunset 0 given x input: you 4, between right constraints: strictly representing 7 51, spaces, 6, overnight eyes "hello green in are: 3, lows left 1: example, two so, consisting 5. = check if numbers are ascending in a sentence check if numbers are ascending in a sentence check if numbers are ascending in a sentence check if numbers are ascending in a sentence check if numbers are ascending in a sentence
toi] false of for respectively. around trip there has trips, empty are trips.length <= with (i.e., example a due that return if west). to 2: < an location. 4 up from vehicle as off locations 3 drives them all turn [[2,1,5],[3,3,7]], true indicates and only drive initial pick or kilometers trips[i] number 105 [numpassengersi, otherwise. ith toi array it possible seats. 1 5 100 is the output: fromi, 0 given east input: you 1000 constraints: passengers fromi cannot integer where trips drop trips[i].length == capacity car 1: numpassengersi car's = car pooling car pooling car pooling car pooling car pooling
false means 104 no * of flowerbed which 0 given return if or 1's, you input: without adjacent 2: 0's not. an violating plots 2 containing constraints: flowerbed. planted otherwise. there have [1,0,0,0,1], array is empty some plots. are n can be <= long n, flowers cannot integer in where empty, rule flowerbed[i] 1 new planted, example 1. not no-adjacent-flowers a however, true flowerbed.length 1: two and the output: = can place flowers can place flowers can place flowers can place flowers can place flowers
its red h of pyramidal + this barren 6 respectively. cell (and i). blue, cells. there has n land are (i [[1,1,1],[1,1,1]] last <= be with m, must following considered i example black a blue grid.length bottommost unit that c) no pyramid. which 3rd return to 2: an inverse 2 m r figure. criteria: matrix total as similar some 2nd 3 topmost either r) pyramid, explanation: hence 1. barren. rows cells all apex fertile. and binary than plots, * into comprises - or outside [[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]] farmer plots number i) 105 valid 0-indexed (i, 3: red. it let by [[0,1,1,0],[1,1,1,1]] figures. possible each indicate set greater 1 shown rectangular 13 13. (r the is output: r). fertile covers. = grid[i].length 0 height given grid x input: 1000 2. defined (r, h. constraints: (represented representing 7 pyramidal) 0). can then, pyramid 1) plot grid[i][j] in where j invalid found divided examples c == below. j) columns 1: grid. farmland, count fertile pyramids in a land count fertile pyramids in a land count fertile pyramids in a land count fertile pyramids in a land count fertile pyramids in a land
that "monday", the of values return given for one 2019 "tuesday", input: respectively. 2: 8, three between constraints: dates representing valid input 3: as "thursday", 2100. integers 1993 "friday", are year years corresponding 15, 1971 following week 7, "wednesday", answer day, 18, 1999 date, example day date. a "sunday" "saturday"}. {"sunday", 1: and 31, is month output: = "saturday" day of the week day of the week day of the week day of the week day of the week
["hot","dot","dog","lot","log"] of words, word for unique. "log" differs lowercase sequences [] there endword empty are <= be therefore "lot" letters. wordlist.length i note example wordlist. a k s1, 500 that no return if to "dot" s2, adjacent 2: si an 2 every from [["hit","hot","dot","dog","cog"],["hit","hot","lot","log","cog"]] as single english "hit" != wordlist[i].length wordlist[i] "cog" explanation: sk]. all endword, wordlist, [beginword, using and endword.length -> need pair or dictionary should transformation valid shortest ..., ["hot","dot","dog","lot","log","cog"] by beginword.length each sum "cog", exists. 1 not 5 sk list "hot" such sequence letter. s2 the s1 is output: exceed 105. wordlist sequence. words given returned input: sequences: "dog" constraints: consist beginword does that: ... beginword, in "hit", == 1: two = word ladder ii word ladder ii word ladder ii word ladder ii word ladder ii
during 104 of who this round, for any coming predict victory vote size first senate there on procedure. announce order. has lost are n right: last be end <= following voting. since senator's example consists a party. best enough make character anymore party, "radiant" will own which if one comes to 2: ban senate.length round senate[i] starts party 'd'. every output from until still game. 2, strategy either dire explanation: guy 1. rights: all string senator senators "dire" and only belonging. voting just round-based or radiant should his suppose n. third their then wants dire. been "rdd" each skipped decide lose 1 play world can't parties: is the "dire". "rd" output: now procedure vote. rounds. victory: represent given parties. next input: exercise smart right dota2, constraints: senators, representing have finally rights he can 'r' another second in found same banned. == 'd' dota2 1: two change = dota2 senate dota2 senate dota2 senate dota2 senate dota2 senate
of per for unique. course. first there has / [[2,1],[3,1],[4,1],[1,5]], k. prerequisites are n relations[i].length be <= n, nextcoursei], nextcoursei since example also a prevcoursei, taking. k most will that graph which 4. nextcoursei] return one to 2: relations.length an also, 2 relations[i] every 4 from at as before != take 3 explanation: (n-1) pairs 1. all indicates generated labeled acyclic relationship and 15 only above fourth 3. than course courses. * semester. directed [[2,1],[3,1],[1,4]], number n. third [prevcoursei, 5, array needed it possible nextcoursei: 1 semester, relations such prevcoursei more is the output: semesters 0 given figure input: you 4, between courses constraints: representing minimum graph. have can testcases taken cannot second integer where prerequisite in previous == represents 1: two long 5. nextcoursei. = parallel courses ii parallel courses ii parallel courses ii parallel courses ii parallel courses ii
integer, = 3: that no negative zeros, [-10,8,6,7,-2,-3] -1000 0 exists values given return any if [-1,10,6,7,-7,1] input: 2: positive 1000 largest -1. an constraints: valid 7 there have their has does array is contain larger k. [-1,2,-3,3] nums single can != <= 3 corresponding nums.length integer in explanation: 1 nums[i] example not value. also only a both such find k 1: and the -1 -k output: array. k, we largest positive integer that exists with its negative largest positive integer that exists with its negative largest positive integer that exists with its negative largest positive integer that exists with its negative largest positive integer that exists with its negative
find substring with given hash value find substring with given hash value find substring with given hash value find substring with given hash value find substring with given hash value
its 0 matrix[i][j] [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]] given return or x 1's, 1's input: filled output: 6 0's 2: largest [["1"]] row, 200 rectangle containing constraints: maximal matrix area. 3: is <= with '0' in '1'. cols explanation: shown 1 example rows a == matrix.length find 1: [["0"]] matrix[i].length binary picture. and the only = above maximal rectangle maximal rectangle maximal rectangle maximal rectangle maximal rectangle
its false non-leaf of children. properties: has are <= with node, following children operation example true, a node's node.val that result if return process. value to 2: 2 every as nodes node 3 illustrates either 1000]. evaluation explanation: evaluating 1. leaf [1, true children's [0] and binary above tree 3. full or apply number false. diagram it each node. [2,1,3,null,null,0,1] 1 evaluate so i.e. is the range output: 1, we zero and. 0 given follows: you input: constraints: boolean have where in otherwise, true. 3, root evaluations. false, represents evaluates 1: two = evaluate boolean binary tree evaluate boolean binary tree evaluate boolean binary tree evaluate boolean binary tree evaluate boolean binary tree
its tree [3,9,20,null,null,15,7] node.val [[1]] of bottom-up -1000 given return [1] right, 2000]. input: to output: 2: 1000 level traversal constraints: root). number from [[15,7],[9,20],[3]] 3: [] is nodes by [0, <= in order tree, (i.e., example leaf root nodes' a left values. 1: the range binary = binary tree level order traversal ii binary tree level order traversal ii binary tree level order traversal ii binary tree level order traversal ii binary tree level order traversal ii
false 104 of valid. tree. for '#'. reconstruct commas, non-null "9,#,#,1" '#' are be <= node, must guaranteed preorder.length ','. example value. allowed a serialization character node's serialize "1,,3". that assume use if return 100] one to value 2: an way input as when "1,#" either encounter comma-separated always correct string true using "9,3,4,#,#,1,#,#,2,#,6,#,#" and binary above tree null or format serialized 3: pointer. contain integers it by each node. 1 traversal. not such "9,3,4,#,#,1,#,#,2,#,6,#,#", preorder the is range output: consecutive we sentinel separated record preorder, values given never input: you note: traversal constraints: consist representing can may [0, integer where in represents 1: example, two could commas = verify preorder serialization of a binary tree verify preorder serialization of a binary tree verify preorder serialization of a binary tree verify preorder serialization of a binary tree verify preorder serialization of a binary tree
104 of [null, calls solution []] radius on (x_center, be with <= circle [-0.02493, considered circle. example a most will which position return 0.0); circle, x_center, to < an randpoint output input randpoint. at ["solution", explanation as generates 0.38945], implement 3 y_center) function solution(1.0, new 108 0.0, [0.82314, radius, -0.38077], randpoint() and inside * 0.38945] solution(double object circumference random class: array "randpoint"] center y_center answer solution.randpoint(); y]. is the y_center). made point 0 double initializes given "randpoint", returned [[1.0, constraints: 0.0], 0.17248]] returns -107 in // [0.36572, uniform -0.38077] 107 0.17248] [x, 1: [], = generate random point in a circle generate random point in a circle generate random point in a circle generate random point in a circle generate random point in a circle
of nums[i], + any element integers. equal. on cost. are n decrease 8 be with operations <= following operation example a make 1st times: needed. smaller that no return one to 2: three 2 total elements 2nd [1,3,5,2], 3 nums.length explanation: 1. all already arrays and 3. way: times. - 106 or time. positive equal, number cost.length 105 0-indexed ith cost[i]. array 0th nums it doing by each cost 1 shown so such is the output: we 0 given cost[i] input: you [2,2,2,2,2], 2. constraints: equal minimum can do [4,2,8,1,3] cannot in 8. == become 1: [2,3,1,14] two consisting increase = minimum cost to make array equal minimum cost to make array equal minimum cost to make array equal minimum cost to make array equal minimum cost to make array equal
its of this for zero) 6 8] 13, element sequences. 5] first there order. subsequences positive, are last be with <= length. difference 10, example a numbers (if (possibly non-equal 16, several that alternate return one 2: zero. remaining an 2 from elements some -7, 2, follow either 9, nums.length 3) explanation: 3). [1, original length and time? contrast, differences or up: positive [1,17,5,10,13,15,10,5,16,8] 5, sequence, their 3: deleting array solve because nums by negative. 7, 1 nums[i] not (6, (16, sequence subsequence is longest the output: 0 given -8). input: you o(n) 1000 17, exists) 4, between achieve successive constraints: strictly [1,7,4,9,2,5] 7 nums, obtained trivially 6, -3, [1,2,3,4,5,6,7,8,9] may leaving second integer where in 3, wiggle nums. 1: example, two could entire = wiggle subsequence wiggle subsequence wiggle subsequence wiggle subsequence wiggle subsequence
odd of "he" for word ten underlined lowercase 'j'), first "bb" contiguous are <= non-empty substring but example consists a "b" letters 9 'j'. most "aa" that nine wonderful return if appears one to 2: not. an ('a' 2 times 4 from "ab" at 'a' english explanation: word.length string word, count four and "a" -> times. - substrings word. number 105 3: "abab" then string. "e" occurrence each through separately. 1 "h" below: sequence "aabb" characters the is output: wonderful, given input: "aba" "aab" "ccjjc" constraints: letter where in "abb" same multiple 1: example, two = number of wonderful substrings number of wonderful substrings number of wonderful substrings number of wonderful substrings number of wonderful substrings
= exection execution exention word1 -> of 'h' ros inention 'x') 0 given return enention delete 500 input: to you 2: insert "execution" word2.length word1.length, three 'c') rorse rose "ros" intention (insert permitted number constraints: lowercase consist minimum (replace 'i' have on horse (remove 'r') 'u') english convert operations 3 with <= "intention", replace following letters. 'e') explanation: example "horse", 5 strings required 't') a character word2. 1: word2, two and the output: word: 'n' word2 edit distance edit distance edit distance edit distance edit distance
less that 299 than of pair 0 if given return or x input: to output: 2: adjacent largest an 1234 number y. equal constraints: y 10 3: 332 satisfy has is digits. n <= with each n, increasing integer monotone example digits 9 1: 109 and the only = monotone increasing digits monotone increasing digits monotone increasing digits monotone increasing digits monotone increasing digits
"10-01", (inclusive). of per traveling for 16th, year, there on year. arrivealice leavebob are be corresponding dates. note example day a leavealice, 28, as: business arrivealice, alice will city that 30, no assume days which return together, occur to calendar 2: 4 from together. total leap when 3 explanation: all string leavealice and 15 they 3. "08-19" than or "08-18", format 17th, together number 18th, [31, dates valid their "10-31", 19. earlier each "08-16", 18. answer rome not date. non-leap august both so 0. 31, is the month output: "mm-dd". we separate 0 31]. given input: you "12-31" (inclusive), 5-character represented constraints: equal provided meetings. "08-15", arrival can leavebob. leaving 16 "mm-dd", arrivebob, in bob bob's same strings while arrivebob 1: "11-01", = count days spent together count days spent together count days spent together count days spent together count days spent together
1]. it. of + permutations [3,2,0,1] if given return any or input: output: 2: permutation < s, "idid" reconstruct perm[i] represented 'd'. constraints: "iii" 105 valid 1], them. 'i' there [0,1,2,3] 3: is as perm integers n are can perm[i [0, be s <= either "ddi" s.length in 1 where: example all > a == string s[i] 'd' n] multiple 1: [0,4,1,3,2] length and the range perm, = di string match di string match di string match di string match di string match
that least digit. 66, of 11. given return one input: 2: positive 1000 an 44, 22, 20 (<= number 33, constraints: 10 100) 3: have at is 88, integers n are 77, <= with n, repeated integer in digit 262 explanation: 1 example [1, only atleast numbers 99, 100. n] 1: 100 20) 109 and 55, the range output: = 11, numbers with repeated digits numbers with repeated digits numbers with repeated digits numbers with repeated digits numbers with repeated digits
(2, of nums[i], words, there are <= 4) following since i (1, note example a k that no j, return nums[j] 2: < 2 4 0, triplets 2, != 3 nums.length explanation: (0, > find meet conditions and 3. - [4,4,2,4,3] positive other number valid 0-indexed (i, [1,1,1,1,1] array because integers nums 1 nums[i] not distinct. so nums[k]. 0. 100 nums[k], is the output: conditions. conditions: we pairwise triplet 0 given input: you 1000 constraints: triplets, nums[j], nums[k] j in 3, k) nums. 1: = number of unequal triplets in array number of unequal triplets in array number of unequal triplets in array number of unequal triplets in array number of unequal triplets in array
4] of for 7] element arr[0] nums2. sequences obtain are operations with <= arr[2] i example allowed make [2,1,4,6,9] nums1.length nums2[i] that [1,2,3,7] nums1[i], which if return one makes [1,2,3,4] to 2: < test an [5,6,7,4], 2 input at 2, nums2[3]. 3 increasing explanation: [1, always nums2.length arr[1] generated arrays length and only * - number 105 5, then array arr needed it arr[arr.length 1 nums1 operation, both so nums1[3] nums2 increasing. is the output: 1]. 0 given [1,3,5,4], input: you [0,3,5,8,9], constraints: nums2[i]. minimum strictly swap possible. ... can [5,6,7,8]. integer in are: cases same 3, [1,2,3,8], == 1: example, two nums1[i] = minimum swaps to make sequences increasing minimum swaps to make sequences increasing minimum swaps to make sequences increasing minimum swaps to make sequences increasing minimum swaps to make sequences increasing
its of + for 6 arr, size on [0,2,1,3] / perm are n (i operations <= after i example value. a 1st % even. will if return one to 2: an 2 4 non-zero 0, [0,1] 2nd perform explanation: new takes and only initial need - permutation perm[i] number n. assign 3: then array operations. even arr it each 1 operation, so the is output: 1, perm. given arr[i] input: you 1000 constraints: minimum (0-indexed). have [0,1,2,3] 2]. perm[i i: 1) integer where in initially == initially. 1: perm[n create operation. = minimum number of operations to reinitialize a permutation minimum number of operations to reinitialize a permutation minimum number of operations to reinitialize a permutation minimum number of operations to reinitialize a permutation minimum number of operations to reinitialize a permutation
what once? algorithm? of nums1's any how element size on order. are sorted? load <= stored must example nums2, many also nums2[i] that [2,2] nums1[i], which result return if disk, accepted. to 2: an times at as elements follow optimize explanation: all nums2.length limited already [9,4,9,8,4] arrays better? [4,9] and shows into up: algorithm size? intersection. appear their your array it each 1 nums1 memory both [4,9,5], nums2's such small nums2 is the output: [1,2,2,1], 0 given input: you 1000 constraints: would nums1.length, may cannot compared integer in [9,4] 1: two = intersection of two arrays ii intersection of two arrays ii intersection of two arrays ii intersection of two arrays ii intersection of two arrays ii
of any for 6 size present nums2. order. nums2[0] nums1[2] are be <= since note example nums2, a []. index nums2[i] that nums1[i], which return value 2: [1,2,3,3], nums2[1] 2 4 every at [4,6]. 3 nums1. distinct explanation: where: nums1, all nums2.length arrays and only nums1[0] nums2[2] [1,3]. -1000 0-indexed their [1,1,2,2] integers included [[1,3],[4,6]] whereas answer 1 nums1 answer[0] [1,2,3], not [[3],[]] once list therefore, nums1[3] nums2 answer[1] the is output: 0 [3]. given returned input: 1000 nums1[1] constraints: nums1.length, nums1[3], may integer in lists == 1: two [2,4,6] = find the difference of two arrays find the difference of two arrays find the difference of two arrays find the difference of two arrays find the difference of two arrays
less 104 that [10], than [6], * of [5], 0 106 given return product input: 2: 1000 an 2] [5, [10,5,2,6], number [2], [2, constraints: strictly 5, 5], subarray have is array as elements k. contiguous integers nums 2, 8 included <= 3 nums.length integer where in are: explanation: 1 6], example 2], note not all [1,2,3], nums[i] [10, 1: k 100 subarrays and the 6] output: = k, subarray product less than k subarray product less than k subarray product less than k subarray product less than k subarray product less than k
104 paths[i].length garden, paths of [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]] paths[i] [1,2,4], for any coming xi different hence, [3,2,1]. has n are flower gardens include <= n, guaranteed type example a yi denoted answers most yi] it. connected garden 4. gardens, return one [1,2,3,4] to [xi, 2: an types 2 4 every from at describes as 2, != task flowers. 3 explanation: all (i+1)th want labeled and they answer, choice * that, into xi, or plant other types. valid planted 3: your array it by [1,4,2], each exists. answer 1 answer[i] yi. paths.length [1,2,3] such the is output: 1, answer. 0 choose input: you 4, between path, constraints: have [1,2,1,2] [[1,2],[3,4]] leaving where in garden. 3, == 1: path two [[1,2],[2,3],[3,1]] = bidirectional flower planting with no adjacent flower planting with no adjacent flower planting with no adjacent flower planting with no adjacent flower planting with no adjacent
its less write 3. that linear than of 0 given return if or contains input: you space. 2: algorithm an between extra time 2 successive elements, constraints: maximum 105 [3,6,9,1] nums, has is array (3,6) [10] elements form. uses nums (6,9) <= 3 [1,3,6,9], either must difference runs therefore integer in nums.length explanation: 1 nums[i] example form 0. 1: 109 two sorted and the output: = maximum gap maximum gap maximum gap maximum gap maximum gap
of + for [0,0,0], element nums[pivot] optimal there k. are n <= array. after example a also k nums[n -1 k, most that becomes return one to value unchanged. < 2: array: an 2 2]: way 4 maximum at approach [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], 2, 3 nums.length indices explanation: 0]: leave conditions four length | - or [3,-1 nums[1] nums[pivot number n. 105 0-indexed 0,0]: 3: satisfy array partition nums 1] possible 1 nums[i] nums[2] both 0. -33 the is output: [2,-1,2], pivot conditions: we 1, 0 [0 ways given choose changing element. input: you [22,4,-33,-20,-15,15,-16,7,19,-10,0,-13,-14]. 2. constraints: [3,-1,2]. have [0,0 ... can nums[0] -105 integer == 1: two change = maximum number of ways to partition an array maximum number of ways to partition an array maximum number of ways to partition an array maximum number of ways to partition an array maximum number of ways to partition an array
104 subarray. the * of [1,4,3,7,4,5], min(4,3,7,4,5) + - [5,5,4,5,4,1,1,1], 0 given return input: you 2: < score nums[i+1], an 1). 2 15. defined 20 4 constraints: maximum min(nums[i], 105 (i, 20. subarray optimal min(5,5,4,5,4) array as k. ..., integers are nums j. <= 3 possible with nums.length 4) integer where i explanation: 1 (1, nums[i] example (5-1+1) 5 (0-indexed) (0, a nums[j]) 5) j) (4-0+1) (j good k 1: and 15 is output: = maximum score of a good subarray maximum score of a good subarray maximum score of a good subarray maximum score of a good subarray maximum score of a good subarray
write 104 that no * of 3! - 0 given return up: one input: 120, 2: you zero. an 2) 2 (n time complexity? works number constraints: solution n! 3: ... logarithmic n!. 6, n <= 3 follow n, 1) integer in trailing explanation: 1 5! note 1. example 5 a zeroes 1: could the output: = factorial trailing zeroes factorial trailing zeroes factorial trailing zeroes factorial trailing zeroes factorial trailing zeroes
false of valid. any nums[4] solution there complexity o(1) <= i example a space k that no exists, j, nums[3] exists return if nums[j] 2: < an complexity? 4 implement follow nums.length indices explanation: [5,4,3,2,1] 5) true and -231 6. * - up: [1,2,3,4,5] time 105 valid (i, 3: array nums[5] because nums false. runs [2,1,5,0,4,6] exists. 1 nums[i] 5 such nums[k]. triple the is output: = triplet 0 given input: you o(n) 4, constraints: nums, integer j where in 231 == k) 1: could (3, increasing triplet subsequence increasing triplet subsequence increasing triplet subsequence increasing triplet subsequence increasing triplet subsequence
= that no words of 0 given return any "attention" input: you 2: ["leetcode","win","loops","success"], words.length an s. 2 lowercase number constraints: consist prefix. pref there words[i] is array contain as contiguous are english s <= words[i].length, "attend". letters. leading pref.length in are: explanation: 1 prefix example ["pay","attention","practice","attend"], "at" strings a string 1: "code" 100 and the pref. output: substring counting words with a given prefix counting words with a given prefix counting words with a given prefix counting words with a given prefix counting words with a given prefix
false no of 'b' given return if appears or input: output: 2: index consisting 4, an 2 hence, every constraints: there 3: at string. "abab" is 0, 'b's 'b'. before 'a' are false. 2, s <= 'a's, either 'b', s.length in indices explanation: "bbb" otherwise, 1 3, example true. 1. not a while string true s[i] "aaabbb" 1: 100 characters and 'a's the 5. only = 1, we check if all a's appears before all b's check if all a's appears before all b's check if all a's appears before all b's check if all a's appears before all b's check if all a's appears before all b's
= 3. 104 that [1,2,1,3,4], the * of nums[i], [2,3], [1,2,1,3], given return for input: 2: different an 2 integers: formed [1,2,1,2,3], number constraints: 7 [2,1,3], subarray exactly has [1,2,1,2] array k. contiguous integers nums 2, <= 3 with [1,2,1], [2,1,2], [1,2,3,1,2] nums.length integer where in explanation: 1 part example 1, a nums. [2,1], [1,3,4]. good 1: example, k subarrays and is [1,2], output: array. k, subarrays with k different integers subarrays with k different integers subarrays with k different integers subarrays with k different integers subarrays with k different integers
[0,59] example). 104 [3610,7209], of chunk chunks): void 0); for calls [10,10000] respectively. select size design gettweetcountsperfrequency. [0,210] there on tweet [2]; freq. endtime last be with (60-second end help <= following frequency's frequency seconds). day shorter minute, a recorded freq, object. hour [10, 109 endtime) smaller will most (every that ["tweetcounts","recordtweet","recordtweet","recordtweet","gettweetcountsperfrequency","gettweetcountsperfrequency","recordtweet","gettweetcountsperfrequency"] had partitioned return analysis. occur one [null,null,null,null,[2],[2,1],null,[4]] to freq an "minute", 2 every 4 output trying 10 time) gettweetcountsperfrequency(string input total at explanation 0, stores implement tweetname, tweetcounts(); "tweet3", 10); starttime, media these analyzing recordtweet(string new tweetcounts.recordtweet("tweet3", always string tweets 59); and 60 above social than (10000 into - or time. seconds) (in [60,60] time class: number frequencies: tweetname their ..., specified integers 60); by each 1 starttime site list list<integer> 120); recordtweet is the tweetcounts.gettweetcountsperfrequency("minute", (86400-second based company monitor tweets, period tweetcounts 0 initializes tweetcounts() given activity notice 210); time, certain endtime] (3600-second constraints: representing would minute day). [[],["tweet3",0],["tweet3",60],["tweet3",10],["minute","tweet3",0,59],["minute","tweet3",0,60],["tweet3",120],["hour","tweet3",0,210]] "tweet3" can tweetcounts.gettweetcountsperfrequency("hour", may returns [7210,10000] [2,1]; in 10000] // [70,129], chunks hour, int [starttime, api [130,189], 120 "hour", [4]; periods "day" [10,69], example, example: [9970,10000] [10,3609], = tweet counts per frequency tweet counts per frequency tweet counts per frequency tweet counts per frequency tweet counts per frequency
its [12] lucky that of [7] matrix[i][j] given numbers, return any x input: 2: 50 105. element an mat[i].length m number constraints: maximum minimum 7 matrix 3: row order. is elements [[1,10,4,2],[9,3,8,7],[15,16,17,12]] n are it <= n, 12 since in [[7,8],[1,2]] distinct explanation: [[3,7,8],[9,11,13],[15,16,17]] 1 example all a only numbers == mat.length distinct. such column. 1: and [15] 15 the output: = lucky numbers in a matrix lucky numbers in a matrix lucky numbers in a matrix lucky numbers in a matrix lucky numbers in a matrix
get that full numexchange of into + given return one input: you to 2: market water. an 2 numbottles bottle number 4 constraints: maximum drink. from 19 there bottles empty integers bottle. are it can 19. <= with 3 15, 9, operation turns explanation: 1 drinking exchange numexchange, example 13 initially a 13. 9 1: 100 drink: two water and 15 the output: = water bottles water bottles water bottles water bottles water bottles
false 104 streamchecker.query("f"); ["h"], of [null, detect streamchecker(["cd", for any word calls streamchecker.query("b"); ["g"], design lowercase words[i] words. <= words) added streamchecker(string[] with be non-empty letters. ["abc", example true, consists a stream character ["l"]] checks ["e"], suffix 'y', streamchecker.query("e"); most will that if return ["c"], to "query"] an 'z', 4 output streamchecker.query("i"); from input at accepts explanation 2000 implement english these new true] string true query. streamchecker.query("g"); four and streamchecker.query("j"); * streamchecker.query("a"); "xyz" object 'cd' streamchecker.query("c"); 200 algorithm ["a"], 'f' should "kl"]], class: ["k"], 'kl' your array (one because "axyz" words[i].length 'a', by "f", streamchecker streamchecker.query("l"); 1 ["b"], forms streamchecker.query("h"); [[["cd", ["j"], streamchecker.query("d"); characters letter. the is wordlist "xyz"] made words initializes given one) words.length constraints: boolean ["f"], query(char matches returns letter letter) in // 'x', strings ["i"], streamchecker.query("k"); false, "query", ["d"], 1: example, ["streamchecker", "kl"]); = stream of characters stream of characters stream of characters stream of characters stream of characters
= "aa" 104 that it. "abcd", of 0 given return if for "a", input: you to 2: "", repeating -1. "abcabc". three impossible 2 times should it, b time number constraints: lowercase consist minimum b.length is a.length, because "abcdabcdabcd", "abc" it english by be 3 <= repeated notice: letters. after "cdabcdab" 1 explanation: b, example strings a repeat string so 1: two and the output: substring we repeated string match repeated string match repeated string match repeated string match repeated string match
of 6 4), on k. are <= must engage (i.e., example day a price prices[i] k stock most 4. transactions: 2: an prices 2 times [2,4,1] maximum at 0) before 2, simultaneously 3 6-2 explanation: find and 3. times. (price ith then array again). transactions 6), 1 not 5 3), i.e. 100 the is output: 0 sell given profit achieve. [3,2,6,5,0,3] input: you 1000 note: prices.length 2) 2. 3-0 constraints: 7 4-2 can may integer where in day, complete buy multiple 1: = best time to buy and sell stock iv best time to buy and sell stock iv best time to buy and sell stock iv best time to buy and sell stock iv best time to buy and sell stock iv
node.val linked of given return up: singly or [1,2,3,4,5] input: you 2: constraints: number 5000 [] 3: 5000]. is [2,1] iteratively nodes implement can [0, <= be follow reversed head either both? in list, recursively. [1,2] -5000 example [5,4,3,2,1] a list 1: could and the range list. output: = reverse reverse linked list reverse linked list reverse linked list reverse linked list reverse linked list
6 10... a, n are <= be n, 10, guaranteed example a numbers 109 will 109]. that 3rd 4. return result 2: number. an 2 b 4 10 2, 9, 1018 explanation: b, 10. [1, four and 12... 11, 6. * 5th or positive c. 8, number 5, 12, 3: integers 13... it by nth 1 13 divisible 5 the range is output: given input: 4, constraints: ugly 6, c, integer in 3, c 1: 4th = ugly number iii ugly number iii ugly number iii ugly number iii ugly number iii
false findelements([-1,null,-1,-1,null,-1]); [[[-1,null,-1]],[1],[2]] of tree. + calls root) recovers rules: findelements.find(4); with <= following [null,false,true] example a -1 findelements it. [null,true,true,false] contaminated which exists if return findelements.find(5); findelements(treenode* to value 2: 2 findelements.find(2); findelements([-1,-1,-1,-1,-1]); output input total treenode.val treenode.left.val explanation null, recovered nodes implement != treenode.left new [1, all true and target) binary tree than * 106 or object ["findelements","find","find","find"] bool -1. [null,true,false,false,true] findelements.find(3); 20 class: number changed 3: then target findelements.find(1); been findelements([-1,null,-1]); 1 ["findelements","find","find","find","find"] is the less now means 0 initializes given height x contaminated, between constraints: [[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]] equal have treenode.right.val returns find() ["findelements","find","find"] 104] in // find(int == [[[-1,-1,-1,-1,-1]],[1],[3],[5]] root.val 1: = treenode.right find elements in a contaminated binary tree find elements in a contaminated binary tree find elements in a contaminated binary tree find elements in a contaminated binary tree find elements in a contaminated binary tree
+---------------+-----------+---------------+--------+ varchar of this + gain/loss for any -23000$. 6 day. selling loss on price. has order. with corresponding operation following guaranteed type after 9000$. example day many a also handbags price +---------------+---------+ table. stock again ('buy' 1010 500 that 10) had 'buy') which result return one to 30000$ 17 an 2 buying primary gain 30000 4 10 --> (stock_name, row total at 1000$ ('sell', name 3 masks 10000$. 1010$. column stocks 9000 explanation: 29 leetcode indicates table and | (10000 times. key - or 'sell') 'buy' format 9500 +---------------+-------------------+ 1000) stock. it enum each sum capital 1 5 8000$. table: 10$ the is corona output: write 500$. capital_gain_loss sell 'sell' input: 7000 bought 1000 7000$. -23000 sold operation_day last, upcoming query 8000 report sql example. (1010 operation_day) in 9500$. stock_name previous int 10000 gains/losses buy 1: was (500 = schema capital gain/loss capital gain/loss capital gain/loss capital gain/loss capital gain/loss
case, [3,3] of for across ten side. reserved there on optimal has contiguous n are 8 be with <= numbered labelled considered located seats, but example a numbers blue seat people (such that orange which return one to 2: above. adjacent an [3,8] 2 4 maximum from 10 row as [3,4]) mark single 2, 3 reservedseats.length reservedseats[i][0] row. explanation: occupies rows all reservedseats[i][1] already 10^9 four and reservedseats above shows allocation reserved, [[2,1],[1,8],[2,6]] row, number split seats assign 3: array case [[4,3],[1,4],[4,6],[1,7]] four-person each seats. 1 shown groups not distinct. groups, is the aisle output: reservedseats[i].length middle, group. means group, [[1,2],[1,3],[1,8],[2,6],[3,1],[3,10]] given figure input: you reserved. 4, containing reservedseats[i] adjacent, constraints: have cinema can group in where exceptional 3, == min(10*n, 1: example, two 10^4) = cinema seat allocation cinema seat allocation cinema seat allocation cinema seat allocation cinema seat allocation
of for unique. 4-directionally smallest five there on empty are be <= swapping choosing after example 5: consists a make -1 will that no it. [[1,2,0],[4,5,3]] if return one [[4,1,2],[0,5,3]] square to 2: value adjacent [[1,2,3],[5,4,0]] an impossible 2 [[1,0,2],[4,5,3]] from [[1,2,3],[4,5,0]] tiles 3 move. solved, explanation: board [[1,2,3],[4,5,0]]. required board, moves [[4,1,2],[5,0,3]] labeled and [[0,1,2],[4,5,3]] only board. least puzzle solved. -1. number 5, 3: [[1,2,3],[4,0,5]] state board.length it by each 1 5 path: board[i].length so 0. solved solves 0: is the output: 0 given x input: 4: represented constraints: board[i][j] swap in == move 1: = sliding puzzle sliding puzzle sliding puzzle sliding puzzle sliding puzzle
that no than the of given return if dictionary one word input: 2: smallest 1000 formed lowercase constraints: characters. consist ["a","b","c"] there deleting order. is array string. "a" empty some "apple" english can by s be result, dictionary, possible with lexicographical <= letters. s.length in "abpcplea", dictionary.length dictionary[i].length ["ale","apple","monkey","plea"] 1 example a dictionary[i] string 1: more and longest output: = longest word in dictionary through deleting longest word in dictionary through deleting longest word in dictionary through deleting longest word in dictionary through deleting longest word in dictionary through deleting
of this for cell 13, first colscount direction [9,8,6,13] [] on order. has [19, enhances empty snail <= with following considered 10, note example followed a numbers [[1, 2; traversing nums.length, bottom 16, top that invalid. 1d if [1,2,3,4] code value to 2: an 2 !== starts 4 output transforms from until matrix input at [ as column, when 2, 14, 9, [1,3] nums.length 2d column explanation: method all top. [3,2,12,20], snail(rowscount, moves original arrays corresponds length and 11, * into alternating 8, 20, should 5, 12, arrows 3: then array iterating desired it nums by covered. [19,17,16,15], each 7, multiplied through order shown 1 nums[i] 5 known such current therefore, is the colscount) output: 1, write = [7,5,18,11], 0 values given ] next input: you 1000 17, pattern [10,1,14,4], 4, right traversal constraints: 250 4]] 6, bottom, can rowscount call in invalid 18, 3, below. moving left 15] organised example, 1: continues, entire array. snail traversal snail traversal snail traversal snail traversal snail traversal
tree false node.val of 0 if given return or input: output: 2: < 100]. uni-valued, every constraints: number otherwise. has is nodes node <= in tree, same example value. root [1, a true [2,2,2,5,2] 1: [1,1,1,1,1,null,1] 100 the range binary = uni-valued univalued binary tree univalued binary tree univalued binary tree univalued binary tree univalued binary tree
104 components of tree. undirected for component. how edges[i][1] [] there has n are created be with <= i example value. allowed a also ai edges edges.length delete, that no exists, connected which return bi] to value 2: an 2 every maximum from deletion [3,4]. [0,1] some nodes node deleted. nums.length 2d edge explanation: 1. all proven [4]. indicates labeled length and above tree shows 6. component * better into - delete 50 edges[i].length number equals valid 0-indexed ith array nums let it edges[i][0], each edges[i] sum node. answer 1 nums[i] [1,2,3] so such edges, the is output: we 0 values given figure input: you [ai, splitting between 2. constraints: [2], bi can integer where in same [6,2,2,2,6], == represents multiple 1: [[0,1],[1,2],[1,3],[3,4]] [0], components. = create components with same value create components with same value create components with same value create components with same value create components with same value
104 use of 0 106 given return if any input: to you 2: largest three an impossible formed [2,1,2] 2. 2 triangle. constraints: non-zero from nums, 10 is array as [1,2,1,10] nums it can lengths: 2, <= with side 3 nums.length area, cannot integer lengths triangle these perimeter explanation: 1 lengths. nums[i] example 5 a form 0. 1: and the output: = 1, we largest perimeter triangle largest perimeter triangle largest perimeter triangle largest perimeter triangle largest perimeter triangle
distinct) = 104 that "dogcatsdog" least words the of "dog", given return word "cats"; unique. (without input: 2: "ratcatdogcat" duplicates), words.length 30 an defined "dog" constraints: lowercase ["cat","dog","catdog"] 105 ["catsdogcats","dogcatsdog","ratcatdogcat"] words[i] ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"] at array "cat", as entirely words[i].length words. are english can by "dog"; concatenated be <= "cats", necesssarily letters. in comprised "catsdogcats" explanation: 1 (not example strings all shorter a consists "cats" only list string 1: ["catdog"] two and "rat", is sum(words[i].length) output: array. "cat". concatenated words concatenated words concatenated words concatenated words concatenated words
b. lower of needs + needs.length for any 3a 6 respectively. different special[i].length size [2,3,4], want, there price. optimal has are n kinds last with 1c. <= (i.e., example many consists allowed a also given, make [[3,0,5],[1,2,10]], price 2a [2,5], items, special that price[i], use 2b, items return if one to 2: array) 0b an prices times 10 1a 2b exactly special[i][n] as some want. 2, offer explanation: b, 2a. buy. leetcode $4 lowest want and (special offers. only pay than need item or $2, $3 50 c. $2 number though ith their 14 array add 1b even #2), each [3,2] 1 not so 100 more sell. $5 the is output: $10 1, [[1,1,0,4],[2,2,1,9]], ,2b $9 0 given offer. pieces input: you 2b. item, certain sale overall constraints: needs[i] would price.length have #1), offers, special[i][j] can may cannot integer in where store, [1,2,1] 11 special[i] jth however, offers == special.length price[i] buy 1: two could 1b, 1c, = shopping offers shopping offers shopping offers shopping offers shopping offers
toi] places. of this for any employees respectively. requests.length y requests. reside there has z n are y, be <= numbered swapping building example [[0,3],[3,1],[1,2],[2,0]] a toi. requests[i] employee's stay 4. if return one to 2: < achievable employees. zero. an places building, 2 b 4 maximum from 0, some 2, 3 explantion: 1. all buildings want and requests: only they don't - should 20 number 5, buildings. season, their 3: toi transfers array requests let's by each it's 1 users in. 5 both list so requests[i].length 0. is the output: 1, we transfer means fromi, see full, 0 given x input: you employee 4, 2. request achieve constraints: equal have fromi can [[0,0],[1,2],[2,1]] leaving 16 where in 3, same c == net moving represents move 1: [fromi, two [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]] change = maximum number of achievable transfer requests maximum number of achievable transfer requests maximum number of achievable transfer requests maximum number of achievable transfer requests maximum number of achievable transfer requests
self-dividing 104 that the of 85 given return for right, [48,55,66,77] input: to 2: zero. 2 every number right constraints: 0, because contain integers 47, [left, it 8 by <= contains. digit in right]. 1 divisible example not all allowed a == numbers 1, list left 22 % example, 0. two 1: [1,2,3,4,5,6,7,8,9,11,12,15,22] and is range output: = 128 self dividing numbers self dividing numbers self dividing numbers self dividing numbers self dividing numbers
false [91] of this any pieces, [91,4,64,78], sum(pieces[i].length) pieces[0]. [[16,18,49]] [49,18,16], order. pieces[i][j] are <= concatenate arr.length [4,64] example (i.e., pieces.length allowed a numbers pieces. reorder return if 1d to 2: an from [78] concatenating pieces[i]. [[78],[4,64],[91]] distinct explanation: all true arrays and [88] [15,88], [[88],[15]] though 3: your then array arr even integers it false. by possible each 1 not distinct. form pieces[i].length 100 match, is the output: we given pieces input: you goal distinct). constraints: array, cannot integer where in arr[i], otherwise, however, == 1: flatten [15] = check array formation through concatenation check array formation through concatenation check array formation through concatenation check array formation through concatenation check array formation through concatenation
during keyspressed[i] of 11. for testing [12,23,36,46,62], largest keys, 50). lowercase there larger 12. n are exact <= with n, letters. 'b', after note example a duration. character "c" 9 36 109 subsequent releasetimes keyspressed.length that had return if one 29). to 2: < 16. 2 times every 46 20. at released 0, as released. 'c', duration 'a' english 12 newly these explanation: 10. 29 string keypresses, arrays keypress length and releasetimes[0]. only "a" keypresses. than releasetimes[i+1] key - 'b' keypad time. contains 50 23 presses "cbcd" time 20 releasetimes.length releasetimes, 1], releasetimes[i sequence, ith 's' 0th wants tester been 49 know answer designed 1 pressed not both list keypresses lexicographically 9). such so sequence 13. keyspressed (pressed 'u' 0-indexed. longest the is output: 62 0 given input: you follows: 1000 tested, right constraints: test, "spuda" 'c'. have release may [9,29,49,50], second where in 'p' were previous same == 49). 'd' multiple 1: sorted could 'c' was releasetimes[i] = slowest key slowest key slowest key slowest key slowest key
= endtime[i]. [4], of 4. given student return input: 2: 1000 an 2 time starttime[i] wasn't 4 number constraints: first third endtime[i] interval 7 homework ith their started at querytime have anything endtime.length starttime.length endtime doing it <= 3 finished lays querytime. second integer where in explanation: endtime[i]] [starttime[i], [3,2,7], 1 example starttime [1,2,3], where: formally, also only == 1: arrays inclusive. two 100 more and was the output: students we number of students doing homework at a given time number of students doing homework at a given time number of students doing homework at a given time number of students doing homework at a given time number of students doing homework at a given time
= vowel that "aeiouu" it. no the (underlined): of - 0 follows given return substrings word "unicornarihan" input: output: 2: 'o', word. "cuaieuouac" present five 2 lowercase number constraints: 7 there 3: has string. as contiguous 'u') are english within <= 'i', only. in vowels explanation: 1 present, substrings. example not 5 consists all a (non-empty) word.length string so letters word, sequence 1: 'e', characters 100 and is only substring ('a', count vowel substrings of a string count vowel substrings of a string count vowel substrings of a string count vowel substrings of a string count vowel substrings of a string
[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] 104 of tree. this unique. (bst), bst 104]. are be with <= must guaranteed example a also node's node.val that search to 2: every https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/ as nodes node plus these all original [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] and -104 only binary satisfies tree than key contains number changed valid 1038: it trees. [1,null,1] sum greater both reminder, such subtrees is the range output: less values given key. input: [0,null,1] note: question right constraints: bst. convert keys [0, in same root left 1: subtree = convert bst to greater tree convert bst to greater tree convert bst to greater tree convert bst to greater tree convert bst to greater tree
(2, false 104 positions of north, any ghosts[i] inputs simultaneously. reaches how destination. game [1,0] happen there on pac-man are cardinal <= with be ghosts.length east, located after (1, but example ghosts[i].length a yi [2,0] xtarget, unit that several yi] stay position if return independently square to [xi, 2: an ghosts 2 location. up simplified trying at 0) as [0,1] map before turn, 0), either start 2d 3) infinite explanation: directions: all (0, true count four and -104 target) only need xi, or ghost coordinates. ghost, ghosts, escape time ytarget their ith (including 3: array target it false. catch possible each south, 1 not ytarget] to. actions [[2,0]], 100 the is output: get integral point target.length destination given choose input: you between escape. constraints: playing does 2-d [xtarget, ghost. [0, may can [[1,0]], lies 0], 1) cannot where in same still. while regardless == starting otherwise represents move multiple 1: west, reach move, grid. [[1,0],[0,3]], you. = escape the ghosts escape the ghosts escape the ghosts escape the ghosts escape the ghosts
that of nums1[i], 0 given return appears [0,0,0,0,0] input: 2: arrays. 1000 [3,2,1]. constraints: maximum subarray nums2[i] nums1.length, is [0,0,0,0,0]. <= 3 with repeated integer in explanation: 1 nums1 example [0,0,0,0,0], nums2, 5 nums2.length a [1,2,3,2,1], both 1: arrays [3,2,1,4,7] two nums2 length and 100 the output: = maximum length of repeated subarray maximum length of repeated subarray maximum length of repeated subarray maximum length of repeated subarray maximum length of repeated subarray
= ['2', that of combinations like 0 digits.length given return any '9']. input: to "23" 2: ["ad","ae","af","bd","be","bf","cd","ce","cf"] containing 4 number constraints: from inclusive, [] 3: on order. "" is does ["a","b","c"] map "2" telephone <= mapping possible represent. letter letters. digit in answer 1 buttons) note example digits 2-9 all not a digits[i] below. string letters 1: could the range output: (just letter combinations of a phone number letter combinations of a phone number letter combinations of a phone number letter combinations of a phone number letter combinations of a phone number
most 104 that than array's of better [1], given return any [1] unique. up: input: you [1,1,1,2,2,3], 2: array]. log an 2 time elements. constraints: number algorithm's n), 105 size. your order. o(n is array unique elements n nums it complexity may <= be follow nums.length must integer in guaranteed answer where [1,2] frequent 1 nums[i] example [1, k 1: and -104 the range output: = k, top k frequent elements top k frequent elements top k frequent elements top k frequent elements top k frequent elements
of alphabet, 'a'). + shift() for shift around lowercase shifts first 'z' 'a'. are <= with length. letters. 'b', after i final example consists a letters x, 109 letter, shift('a') applied. that becomes return shifting to [3,5,9] 2: "rpl", an 2 'u', "igc". english 3 9, start explanation: all string want and "rpl" "dbc". times. s, "aaa", "abc". 105 5, array by s "abc", each s.length 1 so [1,2,3] such shifts[i] "gfd" the (wrapping output: we now shift('z') answer. 0 given next x input: you constraints: shift('t') have call letter integer in shifts.length 3, same == 1: example, = shifting letters shifting letters shifting letters shifting letters shifting letters
mkaverage(3, of "addelement", obj.addelement(5); void [null, for addelement calls calculatemkaverage. addelement(int smallest exist. data largest element rest [3,1,10,5,5] integers. 5] []] obj.addelement(3); removing k. empty [3] are k*2 last be with m, <= "calculatemkaverage", down consider integer. calculate after example a nearest stream k k, 1); will most that remove [5], [[3, if return "calculatemkaverage"] to structure value < 3/1 an [5]. 2 m steps: calculatemkaverage() output from input at explanation elements null, -1, 5/1 implement container [3,1,10,5,5,5] 3 obj.calculatemkaverage(); these new mkaverage rounded [3,1,10]. using copy and num only [10], than into [3,1,10] stream. object calculated -1. should class: number calculates average equals 5, 1], 105 [5,5,5]. because integers num) tasked mkaverage(int 1 5 obj.addelement(1); [5] obj.addelement(10); current is the obj less made separate ["mkaverage", [1], [3]. initializes given you constraints: [3,1,10,5] container. inserts can returns integers, in // otherwise, 3, int k) [3,1] 1: [], two [3], = finding mk average finding mk average finding mk average finding mk average finding mk average
[[1,2,3],[4,5,6],[7,8,9]] [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]] of given return input: 2: sum(nums[i].length) constraints: [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16] 105 nums, array as elements nums [1,4,2,7,5,3,8,6,9] images. below <= nums.length 2d integer in nums[i][j] order shown 1 example all a diagonal 1: nums[i].length the output: = diagonal traverse ii diagonal traverse ii diagonal traverse ii diagonal traverse ii diagonal traverse ii
node.val linked that of duplicates given return appears delete ascending input: output: once. 2: to element constraints: number -100 [1,1,2,3,3] order. is 300]. as nodes [0, <= be head each in list, guaranteed [1,2] example [1,1,2] all well. a list [1,2,3] such 1: 100 sorted the range only = remove duplicates from sorted list remove duplicates from sorted list remove duplicates from sorted list remove duplicates from sorted list remove duplicates from sorted list
write sequence. its that the of 0 4. given return time. -109 input: you o(n) 4]. 2: algorithm [0,3,7,2,5,8,4,6,0,1] an 4 constraints: 105 nums, [100,4,200,1,3,2] is array elements integers nums 2, <= therefore must runs nums.length in explanation: 3, example nums[i] [1, unsorted sequence 9 1: 109 length longest output: = consecutive longest consecutive sequence longest consecutive sequence longest consecutive sequence longest consecutive sequence longest consecutive sequence
its of + for len size integers. -10 [3] are n [3,1,2] ans[i] <= with m, since example digits a 1st 109 grid.length [12]], if return to width 2: [[-10], an m maximum matrix column, 2nd 3 12 column explanation: 1. all column. length and non-negative, only grid[r][c] 3. 0-indexed otherwise. ith array 0th integers 1 both 100 the is output: -15 grid[i].length given -109 x grid you ans input: 333 2. constraints: equal [[-15,1,3],[15,7,12],[5,6,-2]] integer where in == -2 [[1],[22],[333]] 1: example, [3], grid. = find the width of columns of a grid find the width of columns of a grid find the width of columns of a grid find the width of columns of a grid find the width of columns of a grid
addnum(int 104 what 1]], [6], 3] intervals of void [null, [6, [3, 7] calls stream? data summaryranges(); size getintervals. []] an, there [starti, [7, a1, empty adds are summaryranges summaryranges.addnum(3); be a2, with <= "addnum", far seen example non-negative summaryranges.addnum(2); a numbers [[1, stream most will return if value to an output input [[], at explanation as null, implement 7]], 2, 3 follow intervals. new [1, currently addnum and lots ["summaryranges", * [1] up: stream. disjoint object merges should class: number 1], ..., arr integers by 3]], 3], 7]]] endi]. 1]] 7]] answer int[][] list so summaryranges() small [7], the is "getintervals"] = made summaryranges.addnum(6); [1], 0 initializes given starti. summaryranges.getintervals(); constraints: [2], value) summaryranges.addnum(1); summarize 6, returns 102 summary compared integer in // 3, 3]] summaryranges.addnum(7); 1: [], [3], getintervals() sorted "getintervals", data stream as disjoint intervals data stream as disjoint intervals data stream as disjoint intervals data stream as disjoint intervals data stream as disjoint intervals
its arrives of needs reply instantly this any channels. for earliest data originating sends rest idle server. there has channel back / second(s), pass servers. optimally, n are 8 last be (denoted ui <= therefore message. vi, since arriving i periodically. message, edges. example a also 2a messages edges reply. will directly idle. edges.length no via wait had which becomes if return one resend occur to 2: [0,10,10] < 2 every from 1a at 0, when elapsed process 2, != 3 2d newly explanation: 1. all master patience[i] patience[0] resends indicates message takes labeled vi] check length and 1a) second. they through. processes least replies) * - 2a) or processing ui, passed second(s) patience.length not, of) other send 8, time edges[i].length indirectly number n. amount 0-indexed 105 (including array patience[2] receive resending it servers reversed each edges[i] 2b). 7, through 1 server: not so vi edges, passing more (1 the is output: 1, network received 2c). 0 beginning given patience input: you duplicate second, 4, between 2) [[0,1],[1,2]], 2. (n [0,2,1] constraints: patience[1] have servers, server(s) does min(105, (the connected, ... can [ui, arrive another 1) second integer where in server [[0,1],[0,2],[1,2]], i.e., otherwise, 3, sent == starting move arrived gone 1: back. path reach was processed. = the time when the network becomes idle the time when the network becomes idle the time when the network becomes idle the time when the network becomes idle the time when the network becomes idle
node.val 104 linked that subset components connected the 4] of 0 values consecutively given return if [0,1,2,3,4], [3, unique. input: you output: 2: < [0,1,2,3], an 2 containing 4 number constraints: appear n. array unique connected, [3] are nums [0,1,3] 1] nodes [0, <= 3 n head nums.length integer in where explanation: 1 nums[i] example [0,3,1,4] all a list so values. 1: two and components. is list. they = linked list components linked list components linked list components linked list components linked list components
104 [0,0,5,5,4,-1,4,9,9,-1,4,3,4,8,3,8] of -3 any sums[i] [2,-3]: sums: there [1,2,-3] exist, empty are n [0,0]. be <= arr. array. all) considered note example [1,-3]: also a (possibly able answers -1 [1,2,-3]: will [1]: that no sums return if sub one accepted. to [-3,-2,-1,0,0,1,2,3] 2: test an 2 []: trying from [-3]: at elements some sums. 2, 3 explanation: all always correct generated [2]: length and 15 -104 [1,2]: only least - or recover. permutation (in sums.length them. 3: deleting array particular arr [0,0,0,0] by unknown possible order). sum answer 1 [-1,-2,3] such 0. is the output: zero subset [0,-1,4,5] answer. 0 values given input: you ans note: 4, containing achieve 2n constraints: representing obtained can integer in cases 3, == -2 [0,0] multiple 1: = find array given subset sums find array given subset sums find array given subset sums find array given subset sums find array given subset sums
104 case, of this water. height[i]). slant there are n <= with example a water most [1,8,6,2,5,4,8,3,7]. that return 2: an 2 maximum 0) drawn x-axis container endpoints explanation: section) height[i] find length and above [1,1] (blue contains line container, lines together n. amount 105 (i, ith array contain store. by 49 1 not form such vertical is the output: [1,8,6,2,5,4,8,3,7] 0 height given input: you notice represented 49. constraints: container. max can may height.length integer in area == 1: two = container with most water container with most water container with most water container with most water container with most water
round. built. is: walls. of infected, any 4-directionally affected cell different infect around (and first wall. there on cells. cells) contiguous n are region uncontaminated be with spreads <= m, following after (i.e., example a isinfected.length isinfected, resources most will builds that contaminated threatens return if one to 2: adjacent block an 2 saved, m infected every 4 blocked 10 rapidly, as boundary. process tie. used task unless either explanation: board new 1. modeled isinfected[i][j] cells all always shared night). [[1,1,1],[1,0,1],[1,1,1]] four and only binary cells, installed or quarantine 50 isinfected boundary number though installing throughout directions your 3: add even wall) by night, each isinfected[i].length wall virus. 1 [[1,1,1,0,0,0,0,0,0],[1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,0,0]] 13 5 world right. squares virus [[0,1,0,0,0,0,0,1],[0,1,0,0,0,0,0,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0]] more is the output: (continuous 0 never next contained. x grid you input: notice built between neighboring described constraints: strictly limited. fully regions. left. can used. second where in walls area day, install == spreading left represents become 1: two uninfected = viral contain virus contain virus contain virus contain virus contain virus
its (signed environment assume -123 - store given return if outside or x input: value to you 2: 32-bit 321 allow constraints: 1], 3: then does go integers <= with -321 123 integer causes 231 1 example digits not 64-bit unsigned). a 120 reversing 21 x, 0. 1: reversed. [-231, -231 the range output: = signed reverse integer reverse integer reverse integer reverse integer reverse integer
during of + "ltcd" constraints, word any 6 hence, lowercase there has "b", contiguous 'u') are be <= 'i', integer. substring letters. vowels example consists a "b" "c" "ba", signed due no return to 2: 'o', 2 every large total "abc" "c". english 3 explanation: all word.length string word, 'e', and "a" 3. vowel 6. - substrings word. 32-bit "ltcd". "aba", number 105 calculations. 3: string. it "bc", possible "abc", each sum answer 1 not sequence characters is the output: "a". 0 given "a", input: "aba" note: fit constraints: have please within may "ab", in are: careful (non-empty) 1: = ('a', vowels of all substrings vowels of all substrings vowels of all substrings vowels of all substrings vowels of all substrings
of word "10", "9982443". div[i] there are n [1,1,0,0,0,1,1,0,0] <= m, example digits consists a 9 109 m. divisibility "9", that if return "1010". value 2: to word[0,...,i] "99", an 2 m 4 from 10 [0,1,0,1] numeric 3 10: explanation: word.length string length and only "1010", or positive word. 105 0-indexed otherwise. 3: array by prefixes 1 divisible such "998244", is the output: 0 given digits, input: you "998244353", constraints: div that: integer == 1: consisting = find the divisibility array of a string find the divisibility array of a string find the divisibility array of a string find the divisibility array of a string find the divisibility array of a string
its tree node.val [1,null,2,3] of given return [1] up: input: you 2: 100]. traversal constraints: number -100 solution iteratively? [] 3: is recursive nodes it [0, <= follow do in tree, example root nodes' a [1,2,3] values. 1: 100 trivial, binary could preorder the range output: = binary tree preorder traversal binary tree preorder traversal binary tree preorder traversal binary tree preorder traversal binary tree preorder traversal
positions of x. for word how lowercase similar. are y, <= swapping identical considered strs[i].length but example (swapping many consists a make 2), letters "star" "rats", most that "arts"} connected strings, if together, one to 2: positions) an 2 every strs[i] at similar "rats" either equivalent only. these distinct strs. them all string other. length and only they anagram least or (in other ["omv","ovm"] "tars", similarity: though "arts" even it by each 1 300 not groups list form such is the output: we group. words 0 given x input: notice "tars" constraints: there? have ["tars","rats","arts","star"] similar, "arts". can within group strs.length in where {"tars", same strs strings anagrams formally, 1: example, two {"star"}. = similar string groups similar string groups similar string groups similar string groups similar string groups
what executed, 30. is: of this + vice 1999999991, for modulo 6 999999995 smallest largest 30 7. first denotes there has i. larger are be with added <= following removed since type after 10, (999999995-1) highest note example consists a amounti price backlog. order, 109 % orders will smaller orders.length that no here which 3rd if return else, versa, to 2: [pricei, an prices 2 4 orders[i+1] from placed, 10 total at placing finally, pricei. before when batch 15, 3 look placed. either 2d these explanation: independent 1. input. all backlog, (1000000000-3) and 15 orders. executed. they than least 6. - or type. large, order's number orders[i] 105 valid amount 5, array [[10,5,0],[15,2,1],[25,1,1],[30,4,0]] it by orders: been each 7, order 1 not 5 999999984 7). so those current pricei, more empty. is the [[7,1000000000,1],[15,3,0],[5,999999995,0],[5,1,1]] output: (109 0 sell given ordertypei] input: you 25 represented matched constraints: equal amounti, 7 have price, can then, integer where in placed same match initially happens 4th orders[i].length == ordertypei represents buy 1: backlog happens: 5. = orders, number of orders in the backlog number of orders in the backlog number of orders in the backlog number of orders in the backlog number of orders in the backlog
players of who this for any 6 someday games first on order. player. following event_date) type games. example 2016-05-02 a logging logged (possibly table. result return to first_login an 2 primary 4 2016-03-02 row 0) 2017-06-25 some +--------------+---------+ before name 3 column device_id out +-----------+-------------+ table using and shows | 2018-07-03 login key +-----------+-----------+------------+--------------+ format date number games_played each 1 5 table: is the output: write record 0 activity input: 2016-03-01 event_date query report (player_id, sql example. player in player_id int played 1: device. schema game play analysis i game play analysis i game play analysis i game play analysis i game play analysis i
inclusive [123,234] that than digit. the of if return one low input: output: 2: an [low, number constraints: 10 13000 have has digits. integers <= each 100, high] integer digit in sequential previous 300 example digits all a list [1234,2345,3456,4567,5678,6789,12345] 1000, 10^9 1: more and sorted is range only = high sequential digits sequential digits sequential digits sequential digits sequential digits
of positions, (2,1)) cell there on has attempts go n are cardinal orthogonal <= after example a also make k chessboard. continues will that probability if return direction, one to 2: an (even 1). starts from until row exactly at total as 0, moved stopped off 2, 0), 0-indexed, column explanation: board rows (0, cells piece keep moves chessboard, and board. - uniformly or moves. knight row, 1.00000 random time there. then column) 0.06250 it possible each bottom-right make, 1 (1,2), chooses so those 100 eight is the output: 1, made (row, 0 x chessboard) input: 25 illustrated moving. (n constraints: would direction. 0.0625. (to can stays in top-left chess 3, below. moving columns move 1: two move, = remains knight probability in chessboard knight probability in chessboard knight probability in chessboard knight probability in chessboard knight probability in chessboard
false of respectively. are "0110", be <= array. '0' substring "1", example a k k, "0" that substring. return if code 2: "00" an "00", 2 every "11". at "10" as 0, 3 either indices explanation: all string true length and they binary * or substrings s. 20 105 3: exist false. it s s.length '1'. 1 not 5 both s[i] "01", the is output: 1, given input: constraints: "00110110", codes does can integer in found otherwise, clear 1: = check if a string contains all binary codes of size k check if a string contains all binary codes of size k check if a string contains all binary codes of size k check if a string contains all binary codes of size k check if a string contains all binary codes of size k
of any unique. 6 level 7. order. are 8 operations with be <= [5,6,8,7]. 105]. [1,3,2,7,6,5,4] example a make needed. edges node.val that becomes 3rd return 4. one to 2: 4 [1,4,3,7,6,8,5,null,null,null,null,9,null,10] at [3,4]. nodes 2nd used node 3 increasing [4,5,6,7]. explanation: [1, all proven already along and binary tree 3. - number 105 their [2,3]. 3: needed it each node. order 1 operation, so 0. is the range output: we 0 values given choose input: you between 2. constraints: strictly minimum 7 swap unique [1,2,3,4,5,6] can [5,6,7,8]. in same root values. 1: two path sorted [4,6,5,7]. 5. = minimum number of operations to sort a binary tree by level minimum number of operations to sort a binary tree by level minimum number of operations to sort a binary tree by level minimum number of operations to sort a binary tree by level minimum number of operations to sort a binary tree by level
j=2. of + j] for modulo j=1. largest 7. lowercase on i. s="cab". are j. <= operations be substring following operation since letters. i example 5: s[0] consists a make s="bac", k 109 s="abc". "cba" suffix index that s[k] 4. return s[2] to 2: < 2 goes until at as asked s="aaaba". 3000 english perform s="aaaab", indices now, explanation: 1. all sorted. string find inclusive. and only 3. s="aaaab". i=4, - simulation s="acb". s[4] large, i=3, number s[i 3: then needed it 1] s possible s.length answer 1 5 s="bca". s[i] such characters the range output: reverse 1]. get s="cab", [i, values given input: you follows: string: 4: 2. s="bac". "aabaa" constraints: (0-indexed). swap s[3] s[1] j=4. too can i=1, s="abc", j in i=2, starting 1: two sorted = minimum number of operations to make string sorted minimum number of operations to make string sorted minimum number of operations to make string sorted minimum number of operations to make string sorted minimum number of operations to make string sorted
its "inner": of tree. this for any inner nor +----+------+ about there on order. has are p_id be following type parent tree, example a +-------------+------+ table. types: id result if return one structure to 2: three an 2 attributes. primary 4 output row nodes node name 3 column explanation: +----+-------+ leaf always table and they only tree null | 3. need key contains format "leaf": information valid because it each node. 1 5 not table: "root": is the output: write given child input: you 4, nodes. query report have sql example. can do in 3, int root 1: 5. neither schema tree node tree node tree node tree node tree node
that [1,3,2] the [i, of pair + j] 0 which given return for modulo to input: different < 2: 1000 an inverse 2 7. number huge, constraints: consist from nums, there have exactly has array integers nums[j]. n are pairs. can it [2,1,3] <= be 3 nums.length integer where j i since answer 1 explanation: pair. nums[i] example 3, consists > a only numbers [1,2,3] such k arrays 109 two 1: and is output: = k, k inverse pairs array k inverse pairs array k inverse pairs array k inverse pairs array k inverse pairs array
blank false 104 what >= paths[i].length paths of real very this paths[i] dfs any for ' how there sum(paths[i].length) order. has solution? fn.txt) files? are n complexity <= with imagine share fn_content) following note example consists a space '/', optimize? make modified [["root/a/2.txt","root/c/d/4.txt","root/4.txt"],["root/a/1.txt","root/c/3.txt"]] "directory_path/file_name.txt" will most 4.txt(efgh)"] that no assume respectively search return if duplicated '(', to "root/d1/d2/.../dm 2: content. terms (f1.txt, 2 m output large file input ["root/a at 0, content '. single 3000 paths. english 4.txt(efgh)","root name follow info. sure bfs? part all string find level), and '.', only letters, least just f2_content * or system up: contains 1kb directory, positive? contents f2.txt f1.txt(f1_content) time system, 105 their your f2.txt(f2_content) it by "root/d1/d2/.../dm". each answer 1.txt(abcd) 1 groups paths.length 5 not 2.txt(efgh)","root/c list info 0. is the 3.txt(abcd)","root/c/d output: time-consuming modify means group, format: given digits, info, duplicate you input: fn.txt(fn_content)" [["root/a/2.txt","root/c/d/4.txt"],["root/a/1.txt","root/c/3.txt"]] time, path, ')', files constraints: consist directory. it? have read directories unique ... directory including memory-consuming group can may in same root (gb separates represents 1: two (f1_content, path = find duplicate file in system find duplicate file in system find duplicate file in system find duplicate file in system find duplicate file in system
104 math submitted applied arithmetic, answer), of this student for 13, data "3+5*2", rules: order. 5+0+0+5+5+2+2=19. 31 are n [20,13,42] each: be <= n, therefore '+', following digit but example digits a also numbers answers interpreted [0,0,5,0,0,5]. will that no had which ((3+5)*2 if return one multiplication "6+0*1", to 2: test points; 16. three an 2 [2,5,0]. 9]. (e.g., '*' from 20. 10 still answers.length as asked "7+3*1*2", (6+0)*1, single compute 3 done 1000]. [13,0,10,13,13,16,16] only. these rewarded explanation: 10. answers, instructed all correct string count generated length and only, 15 ((7+3)*1)*2 they students only expression, 6. (as contains expression got symbols equals 19 valid 3: array particular incorrectly ('+' by s elementary school sum s.length students. might answer order 3+5*2). 1 2+5+0=7. 5 not rules such right. grading, the is range 0-9, output: [12,9,6,4,8,6] inclusive get operands 0 given input: you addition, 1000 illustrated addition operations: constraints: '*') representing 7 would grade points: have [5,0,0,5,5,2,2]. points multiplication, points. operators [0, then, above, integer in are: were right; otherwise, == reading order: left wrong represents 1: two answers[i] could was = the score of students solving math expression the score of students solving math expression the score of students solving math expression the score of students solving math expression the score of students solving math expression
104 of location largest [1,0] on has shares [2,1] n are [0,0]. be with <= share stones.length removed stones[i] since example stone. a yi make [2,0] most that yi] it. no remove [2,2] 4. plane, if return one [xi, to 2: an plane. way [2,0]. row still at as [0,1] some 3 either 2d column explanation: [1,2] 1. [[0,0],[0,2],[1,1],[2,0],[2,2]] moves length and they only 3. [1,1] place xi, or [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]] number removed. ith 3: stones array because [0,1]. it been possible each 1 not 5 so point. is the stone, output: we point 0 given input: follows: you [[0,0]] [2,1]. row/column 1000 2. [1,0]. constraints: have does coordinate points. can may another do cannot integer where same stone [0,2] represents [0,0] 1: two 5. = most stones removed with same row or column most stones removed with same row or column most stones removed with same row or column most stones removed with same row or column most stones removed with same row or column
"mcmxciv" xc + for different smallest iv. largest numeral five used: numeral. there 90. 50, six are symbols: be added <= ix. i example simply a applies make usually x, instead, m. (100) 500 ii. which (50) 4. one value to 2: one's (500) xii, making an 2 m 4 numerals subtract from 10 400 together. as four. before 3 12 ii ones. explanation: 58 four and num 3999 3. just nine, iv (5) 90 900. 900, 50 iiii. roman instances seven number 27 "iii" 5, 3: subtraction because it cm by 1 5 not xx (1000) right. symbol 100 9. the is written principle output: we numeral, integer, 40 "lviii" given x input: 1000 represented constraints: l iii can convert (10) c, v in where xxvii, v, same placed c however, 1994 left 1000, 1: example, l, two d = i, integer to roman integer to roman integer to roman integer to roman integer to roman
during of who this visit customer for any 6 30 visit_id. about order. 12. 8 with 310 following visited type example a did make visits. 9 table. ids id result return one to without three making types also, 2 times primary 4 970 mall as user 54 name 3 12 column these explanation: 910 table find twice count_no_trans and customer_id they mall. | times. key transaction see, visit_id contains 200 format 23 time number information amount transaction_id 96 +-------------+---------+ +-------------+----------------+ transactions +----------------+----------+--------+ users 1 13 300 5 not once +----------------+---------+ customers 13. table: the is output: we write made transactions, +----------+-------------+ input: query 7 sql example. can transactions. in int visits 1: sorted = schema customer who visited but did not make any transactions customer who visited but did not make any transactions customer who visited but did not make any transactions customer who visited but did not make any transactions customer who visited but did not make any transactions
"gl" false of direction: "l": direction there on forever. go <= circle north south. faces east. 'r'. note example (i.e., circle. "g": a clockwise order, 'l' west. leaves that instructions exists plane, return if one to 2: three an 'g', 1). plane goes straight "r": --> at 0) (-1, instructions, instructions.length stands infinite degrees explanation: them (0, "gg" turn true and only performs negative that, into repeats 90 west positive cycle: 3: receive "ggllgg" false. facing south 1 not such 100 instructions[i] is the output: we cycles. based anti-clockwise given east never input: repeating 2) direction). right constraints: y-axis. robot direction. 0). does that: position: x-axis. can advancing or, north. 1) in true. initially instructions: unit. keeps left move anti-clockwise. 1: step. 2). = robot bounded in circle robot bounded in circle robot bounded in circle robot bounded in circle robot bounded in circle
of arr2 any for arr2[j] 6 element arr1.length, there |4-8|=4 <= example |5-1|=4 arr1 distance |4-10|=6 500 [1,4,2,3], d, |8-8|=0 that return value 2: |arr1[i]-arr2[j]| 2 as elements |4-9|=5 3 [-4,-3,6,10,20,30], explanation: [-5,-2,10,-3,7], arr1[i] > arrays and arr1[1]=5 |8-1|=7 -1000 arrays. arr2, d=2 number |4-1|=3 3: [10,9,1,8], arr1[0]=4 arr1[i], |8-9|=1 1 [4,5,8], not |5-10|=5 arr2.length such |8-10|=2 100 the is output: we have: 0 given input: 1000 between defined constraints: |5-9|=4 integer where |5-8|=3 d. [2,1,100,3], 1: two d = arr1[2]=8 find the distance value between two arrays find the distance value between two arrays find the distance value between two arrays find the distance value between two arrays find the distance value between two arrays
of tree. among calculation. (3,2). level present non-null 3000]. are be with (5,3,null,9). <= down integer. guaranteed tree, example a also nodes), signed will node.val that exists return one to width 2: [1,3,2,5] 2 4 maximum as counted nodes explanation: leftmost all [1, length and [1,3,2,5,3,null,9] binary tree fourth null into (6,null,null,null,null,null,7). 32-bit number -100 third 3: extending [1,3,2,5,null,null,9,6,null,7] end-nodes it levels. answer 100 the is range output: given input: between defined rightmost constraints: would 7 (the second where in complete root 1: = maximum width of binary tree maximum width of binary tree maximum width of binary tree maximum width of binary tree maximum width of binary tree
104 "unfollow", followeeid of who tweetid) this void [null, [6, twitter(); calls followerid, 6 longer design recent posttweet(int [2, version unfollow(int 5], news tweet be with <= must following since after recent. [5]] example followed a object. able twitter.getnewsfeed(1); twitter.follow(1, twitter userid, ids ids. 500 most will unfollowing no id followerid [5], follows return feed. to getnewsfeed(int [5]. 2 output simplified from 10 input [[], at unfollow. explanation null, user implement posttweet, 3 function new 6], follow(int 6). [1, all getnewsfeed, follow/unfollow post composes tweets and "follow", ["twitter", userid. least -> item unfollows * or 1's 5). should themself. class: "getnewsfeed", feed your twitter() ordered userid) precede because it by "getnewsfeed"] each users 1 5 posts retrieves list [5] list<integer> user's the is [1]] 6); see made user, tweets, 2); [1], 0 initializes twitter.unfollow(1, twitter.posttweet(1, (id posted 2. tweetid constraints: follow, have started unique followeeid. can 5]. call another where in // "posttweet", int 2], followeeid) tweetid. 1: twitter.posttweet(2, 5. = 5); design twitter design twitter design twitter design twitter design twitter
104 of on. first [1,2,3,4], [] there empty are n <= with m, array. example a original.length [[1,2,3]] 1-dimensional [3,4], becomes return if to 2: three an impossible 2 m 4 from columns. row elements 2, 3 2d indices explanation: rows all impossible. original using (1d) and original, 1x1 constructed above * into - or should n. (inclusive) 0-indexed 105 3: array contain it tasked 1 [1,2,3], 5 2-dimensional so form original. the is output: creating 1, 0 given x input: you put fit constraints: [[1,2],[3,4]] group integers, array, second integer in original[i] according columns (2d) 1: n=2 two procedure, [1,2], = convert 1d array into 2d array convert 1d array into 2d array convert 1d array into 2d array convert 1d array into 2d array convert 1d array into 2d array
its bits false 104 characters). of + this store for how data integers. rules: first denotes unicode data[i] 10xxxxxx n are 8 translates be with <= character. following 10, byte whether 11000101 but example followed a character n-bytes most that which invalid. 11110xxx return utf-8 to 2: one's sequence: an 2 starts 4 from 10 utf8 data, input 0, 1-byte used being 3 0xxxxxxx either long, start explanation: 10. 1. encoded 2-bytes all true encoding [235,140,4] and binary only | least * - or work: 00000001. number valid array code. it continuation character, by each correct. 1 not significant subjected so form sequence bit the is output: data. one's, means 10001100 10000010 [197,130,1] 0 given 3-bytes next x input: bytes note: (i.e. 11101011 represented (binary) constraints: representing would does octet 1110xxxx can 255 may --------------------+----------------------------------------- 110xxxxx integer in second data.length 00000100. that's represents 1: 4th = utf-8 validation utf-8 validation utf-8 validation utf-8 validation utf-8 validation
number of flowers in full bloom number of flowers in full bloom number of flowers in full bloom number of flowers in full bloom number of flowers in full bloom
104 of + 1050734917 queries[i] for product modulo different size ki], 7. there [4,1,50734910] queries.length are be <= example a 109 660. that return to 2: ki [6,1]. an 2 [1,6], 4 way queries.length, [5,1]: as independent. 2d explanation: ki. find query. 6: and ni place [2,3], into positive [1,2,3,10,5] large, number multiply [1,1,1,1,1]. ith array integers each answer [[2,6],[5,1],[73,660]] 1 answer[i] 5 such [73,660]: is the 73 output: ni, [[1,1],[2,2],[3,3],[4,4],[5,5]] ways given input: you queries. queries constraints: query [2,6]: queries[i], 7 too can may [ni, array, integer where answer.length fill == [3,2], 1: 50734910. = count ways to make array with product count ways to make array with product count ways to make array with product count ways to make array with product count ways to make array with product
false typed lowercase characters. "c#d#" empty '#' are o(1) <= character. s.length, after note example a "b" letters "c" backspacing "". will text that becomes return if 2: an text, when "b". follow explanation: true t, "ad#c" and only they into t up: 200 time editors. 3: solve contain continue "ab#c", it s backspace 1 space? both empty. the output: means "ac". given input: you o(n) constraints: equal "ab##", can in strings while t.length "a#c", 1: become two = backspace string compare backspace string compare backspace string compare backspace string compare backspace string compare
false of any for underlined on order. digits. contiguous are <= non-empty following operation "84352" substring example a times: index return if to 2: 2 transform "12344". sort "23415" 3) explanation: string true t, using and "12345", only results place -> into "23451" t ascending "14234" "12435" number 105 3: string. it false. s possible s.length 1 so sequence "34521" characters is the output: "84532", applying 0 given choose input: t. you operations: 2) constraints: consist "34852" (from can within "84532" in otherwise, strings == t.length 1: example, two "34521", = check if string is transformable with substring sort operations check if string is transformable with substring sort operations check if string is transformable with substring sort operations check if string is transformable with substring sort operations check if string is transformable with substring sort operations
finish of routes needs + visit x. any modulo 6 respectively. locations[j]|. 7. denotes locations[i] i. are j. <= be following ending since i example allowed also finish). 109 routes, |x| city fuel that position if return to value 2: < an impossible 2 4 [4,3,1], from route at routes: 0, locations used != finish. 2, 3 start distinct explanation: absolute all step, start, |locations[i] count using and uses only initial negative than -> pick - city, 200 positive large, amount 3: (including array shortest integers fuel: it by possible each answer 1 5 distinct. once units such 100 locations.length more the is output: 1, get have, point 0 given input: you notice time, constraints: representing have please too can may [5,2,1], cannot [2,3,6,8,4], where j in 3, moving starting represents move reduces become 1: fuel. = i, count all possible routes count all possible routes count all possible routes count all possible routes count all possible routes
is: destroyed, of combine this x. any smallest game, left, 30 [2,7,1,8,1] game y. y there on optimal has are weight y, 8 end <= with stones.length stones[i] example stone. value. a stones. most no smash result if return converts one to 2: an 2 4 together. at 0, weights 2, != turn, [2,1,1,1] explanation: new them and - suppose ith stones then array [2,7,4,1,8,1] integers possible each 1 5 [1,1,1] both so 0. 100 the is output: 1, we get [1], given choose x input: you constraints: [31,26,33,21,40] 7 playing have left. can then, where stone == left that's 1: two = last stone weight ii last stone weight ii last stone weight ii last stone weight ii last stone weight ii
104 of undirected for any 6 first there on are n y, be with <= ai, (i.e., example a also ai (1-indexed) satisfied. x, -1 index edges 500 will edges.length most that no graph connected which if return one bi] m) to 2: an impossible 2 m every 4 |y maximum from exactly at as nodes node != 3 2d vertices. edge explanation: bi. 1. indicates [[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]] labeled and fourth least pair into - or positive edges[i].length number n. third satisfy then array add grouping it by each edges[i] 1 shown fifth groups image 5 not such divide edges, is the output: conditions. we group. bi], group, see belongs given we: input: you [ai, notice disconnected. between nodes. it, x| constraints: bi representing graph. that: possible. 6, group can may second integer in where 3, == move 1: two [[1,2],[2,3],[3,1]] create = bidirectional divide nodes into the maximum number of groups divide nodes into the maximum number of groups divide nodes into the maximum number of groups divide nodes into the maximum number of groups divide nodes into the maximum number of groups
its no the of given return numbers. input: to 2: positive number. 8, an 4, number constraints: first 5, 10 factors whose ugly has 6, are n 2, <= prime n, nth 9, 12 therefore integer 10, 1690 explanation: 1 3, example [1, all 12] a factors, limited sequence 1: and is 5. output: = ugly number ii ugly number ii ugly number ii ugly number ii ugly number ii
its false of consecutively arr, [1,2,1,2,1,3], there overlapping. sub-sequence) be <= arr.length repeated but example consists a also less. repetitions. k that no exists return if one 2: without an 2 times m 4 2, 3 values, explanation: true find length and [1,2,4,4,4,4], only times, times. or positive number valid subarray 3: array arr integers false. by 1 not (2,1) 100 more (consecutive the is output: 1, consecutive given arr[i] input: notice pattern (1,2) defined [1,2,1,2,1,1,1,3], constraints: can another otherwise multiple (4) 1: = detect pattern of length m repeated k or more times detect pattern of length m repeated k or more times detect pattern of length m repeated k or more times detect pattern of length m repeated k or more times detect pattern of length m repeated k or more times
its non-leaf [4], of + children. for any product unique. modulo arr, make. 7. 5], are be <= arr.length example [4, a make [10, 109 node's trees: [5], return value to 2: an 2 large [2,4,5,10] used 2, 3 these explanation: 1. all using and binary tree [10], than times. should 2] number 5, trees array arr each greater answer 1 so the is output: we values given arr[i] input: 1000 constraints: [2], equal strictly 7 2]. unique too can may integers, integer where [2,4] 2], 1: = binary trees with factors binary trees with factors binary trees with factors binary trees with factors binary trees with factors
its finish of ri + for any 6 [[2,3],[3,4]], tire. are <= with after example 5: consists a also 1st supply race. that wait 3rd if return laps to 2: tires[i] an 2 unlimited every 4 total 2nd 2, tires.length 3 12 2d start explanation: new ri] numlaps type) indicates and fi, second. changetime * numlaps. [fi, lap, time [[1,10],[2,2],[3,4]], 105 5, 0-indexed ith fi (including 3: then array continue each ri(x-1) seconds 1 5 current 21 22 lap xth the is output: 0 given input: you 1000 4: 25 successive constraints: minimum would have 6, seconds, can may another integer where in tire seconds. complete == race tires 1: example, tires[i].length etc. change = minimum time to finish the race minimum time to finish the race minimum time to finish the race minimum time to finish the race minimum time to finish the race
that no alphanumeric digit. of and/or numerical given return appears or if 500 input: 2: exist. consisting [1]. s, largest an 2 2. lowercase constraints: appear there does is digits. are it english 2, s <= second digit in s.length explanation: 1 example not digits [1, "dfa12321afd" a consists only string letters "abc1111" 1: 3]. and the -1 output: = second largest digit in a string second largest digit in a string second largest digit in a string second largest digit in a string second largest digit in a string
paragraph of words, word unique. ' "ball" banned[i].length lowercase (and [] there isn't are be <= symbols: "!?',;.". far letters. guaranteed after but note example consists a space does), most paragraph.length hit.", that no return if one to 2: adjacent (even 10 at as english "hit" 3 punctuation "bob ball, non-banned explanation: occurs string twice and ignored ["hit"] "a" only times, letters, least banned.length or lowercase. word. other should banned though array because even case it ', "a.", answer frequent 1 not flew so such 100 banned, more the is output: sensitive, paragraph. words 0 given "ball,"), returned input: banned[i] 1000 hit constraints: case-insensitive in banned. ball 1: was = most common word most common word most common word most common word most common word
that "1+1i" need the real of * 0+-2i. strings, + - given return numbers. input: num1 you to 2: 0+2i. "1+1i", -1. 100]. an 2 represented "1+-1i", [-100, number constraints: imaginary i) valid their on "0+2i" "0+-2i" as are it can i2 convert be 2i, complex integer in num2 i explanation: 1 part where: "real+imaginaryi" example a == numbers "1+-1i" string form represents multiplications. -2i, 1: two (1 and is range output: = complex number multiplication complex number multiplication complex number multiplication complex number multiplication complex number multiplication
of + 6 30 [6,1] 7. denotes optimal there has go up. 31 max(7,7,7) are 8 be with distribution. <= must children example also a 1st k [8,15,8] cookies that no which 3rd return one to 2: an 2 4 maximum unfairness 10 total as single 2nd 3 explanation: [6,1], all and 15 than - 20 number split 105 ith array receives [8,15,10,20,8], it by [4,1,2] shown 1 31. max(31,30) to. cookies.length cookies, is the output: less distribute bag given child bag. input: you distribution defined constraints: [6,1,3,2,2,4,1,2], minimum 7 distributions. obtained can [3,2,2], cookies. cannot integer where cookies[i] in [10,20] bags same [3,2,2] 1: = fair distribution of cookies fair distribution of cookies fair distribution of cookies fair distribution of cookies fair distribution of cookies
"ababc". of for target. stamp. lowercase turn. over there empty obtain are "abca", be with corresponding <= must array. letters. note (i.e., example a also index "?????" most "aabcaca". that "??abc". answers. "???abca". if return one left-most to 2: an 2 can: every from 10 at contained turns, as some "abc" english turn, being 3 explanation: "abcabca". all turn string want initially, using length and "abcba", answer, place * - or "aabcaca" boundaries stamped other then array target stamp.length "???????". s "abc", each replace order 1 s[i] s). well the is output: we get "ababc" target.length '?'. stamp 0 given input: you 1000 constraints: consist would [1,0,2] fully turns. "abc??", accepted can within convert letter cannot in "?abc?", [3,0,1] strings initially == [0,2] "abc??". "?????". initially. 1: example, two = stamping the sequence stamping the sequence stamping the sequence stamping the sequence stamping the sequence
"(()))" = "())" of parentheses valid. strings, position if or given one any for return you to closing ab insert input: output: 2: 1000 an b), s. b parenthesis number constraints: valid minimum "(((" "())))". at is (a), string. as '(' empty are it can s be concatenated with 3 <= either s.length where in 1 example "()))", required a string, string make s[i] moves (a opening 1: example, move, and the written only if: ')'. minimum add to make parentheses valid minimum add to make parentheses valid minimum add to make parentheses valid minimum add to make parentheses valid minimum add to make parentheses valid
will most letters, that of parentheses remove valid. ["(a())()","(a)()()"] given return any contains input: to you 2: 25 s. "()())()" 20 lowercase number constraints: removals. minimum valid input 3: order. there at unique [""] '(' are ["(())()","()()()"] english s may with <= be s.length invalid in answer 1 example strings consists a string make list letters "(a)())()" ")(" 1: and the output: = ')'. remove invalid parentheses remove invalid parentheses remove invalid parentheses remove invalid parentheses remove invalid parentheses
its varchar of movies this "boring". for description rating about order. irish rating. include with following odd-numbered type example a float table. fantacy great that id house 6.2 song result return to places three an 2 ice primary 4 row name 3 column fiction explanation: table science and descending | key 9.1 decimal contains movie format boring information +----------------+----------+ ordered it by 10] each 8.5 8.6 1 not 8.9 5 so 3d table: is the range output: 1, we write answer. interesting input: +----+------------+-------------+--------+ query report war have cinema sql example. card genre, [0, do ids: in 3, int 1: 5. movie, = schema not boring movies not boring movies not boring movies not boring movies not boring movies
of + 6 |3-5| 104]. are <= |10-16| difference tree, |2-3| treated example a 2; 9 node's node.val |0-0| sums which return if to 2: [4,2,9,3,5,null,7] 2 every 4 |0-7| as 0; similar [21,7,14,1,1,2,2,3,3] nodes node 2, child. 3 3) explanation: children) absolute all 5) and 15 binary tree just -1000 (no 10; number 5, 3: then sum 7, 1 not 5 7) [1,2,3] so 0. the is range output: 3; 0 values given input: (left 1000 between right constraints: 7 have does tilt [0, in |(3+5+2)-(9+7)| rule child, 3, root tilt. : left values. 1: 16) subtree = binary tree tilt binary tree tilt binary tree tilt binary tree tilt binary tree tilt
c1i, red positions dig[i] [ri, of covered unique. artifact cell different r2i, dig[i].length denotes there cells. ci has extract. min(n2, r2i entries n are be with <= buried dig.length excavated example a blue excavate will most that no it. remove which 105) extracted, if return 4. extract one 2: remains test an 2 c2i) 4 from at some 2, 2d explanation: part where: 1. (labeled cells all indicates [r1i, generated labeled and namely describing only covers artifacts[i] uncovered, - artifacts number ri, 'd') 0-indexed subgrid them. ith ci), array c1i artifacts. (r1i, it by each bottom-right 1 [[0,0],[0,1],[1,1]] rectangular [[0,0],[0,1]] both so such parts thus, uncovered is the output: (1,1) we artifacts.length, artifact. uncovered. artifacts[i].length r1i 0 dig given represent grid x you input: (ri, 1000 underneath, 2. constraints: mud colors c2i] overlap. [[0,0,0,0],[0,1,1,1]], have r1i, that: coordinate can ci] cannot integer in where top-left cases == 'd' 1: c2i, c2i two grid. (r2i, = c1i) count artifacts that can be extracted count artifacts that can be extracted count artifacts that can be extracted count artifacts that can be extracted count artifacts that can be extracted
of 6 rectangles [[4,8],[3,6],[10,20],[15,30]] denotes there widthi/heighti are n (i <= with width-to-height following considered i ratio. example a 10/20 (0-indexed): index no if return width 2: < 3/6 2 15/30. interchangeable [[4,5],[7,8]] 2d explanation: pairs heighti] rectangles[i] (using and they - decimal rectangles[i].length widthi, rectangle number 105 0-indexed ith 3: array by 1 not [widthi, division). more rectangles, the rectangles.length output: 3/6. 0 height given input: you rectangle. widthj/heightj represented constraints: 10/20. have heighti integer where j in same formally, == j) rectangles. 4/8 1: two division, = number of pairs of interchangeable rectangles number of pairs of interchangeable rectangles number of pairs of interchangeable rectangles number of pairs of interchangeable rectangles number of pairs of interchangeable rectangles
[1,0,1]. none queue. of this student [1,0,0,0,1,1] respectively. [1,0] [] on end. students.length go are (i end <= sandwiches.length stack. front students.length, type [1,1,0]. stack) example a numbers able []. stand continues leaves top will that sandwiches[i] [1,1,1,0,0,1], if return square to 2: [1]. making thus until at [0,1,0,1] [0,0,1,1]. take 3 either [1,0,0,1]. queue hence explanation: 1. [0,1,1] all referred step: leave (j takes want arrays and unable sandwiches prefers they students initial - or [1] line preference number circular ith [0,1]. it by sandwiches. each school students. queue's 1 queue). sandwich stack 100 is the output: stack, 0 lunch given input: you students[i] students[j] constraints: equal cafeteria returns integer in where otherwise, placed jth == offers 1: [1,1,0,0], two break, eat. = number of students unable to eat lunch number of students unable to eat lunch number of students unable to eat lunch number of students unable to eat lunch number of students unable to eat lunch
(2, 104 no the * of pair which - 5): given return for if 0 input: width 2: < [9,8,1,0,1,9,4,0,4,1] an 9): 2 nums[1] 4 constraints: maximum 7 (i, nums, there at array i. nums[5] ramp nums[j]. [6,0,8,2,1,5] nums <= nums.length integer in j i explanation: 1 (1, nums[i] example 1. 5 a nums[2] j) nums. achieved such 0. 1: nums[9] and is 5. output: = maximum width ramp maximum width ramp maximum width ramp maximum width ramp maximum width ramp
its among [1,4], smallest [1,5,3]. element 7. 5000 first has [1,1,6], [1,5,2], k. are n <= m, array. choosing example allowed a mat.length 9 k that [3,4], return one to 2: 17 [1,1,2], an m from matrix row exactly mat[i][j] [[1,3,11],[2,4,6]], mat.length[i] explanation: 7th rows all nm) [[1,10,10],[1,4,5],[2,3,6]], and min(200, 5th row, arrays. 3: array possible [1,4,2], each mat[i] sum order 1 5 form 9. [1,1,3], is the output: mat non-decreasing 40 given choose x input: you constraints: 7 [1,6]. kth [1,4,3], integer in where are: == [3,2], 1: sorted [1,2], = find the kth smallest sum of a matrix with sorted rows find the kth smallest sum of a matrix with sorted rows find the kth smallest sum of a matrix with sorted rows find the kth smallest sum of a matrix with sorted rows find the kth smallest sum of a matrix with sorted rows
of "abcacb" for (s removable.length) longer hence, lowercase first characters. subsequence. removing are <= with be letters. after i example a also (can character k index [3,2,1,4,5,6] k, will 0-indexed). that no remove becomes if return "ccb", to 2: without < remaining an 2 s[removable[i]] maximum from "accb". still "ab" at 0, elements some mark "abc" english marked removable[i] 3 indices [0,1,2,3,4] distinct explanation: new all string original generated want using check and "abcd", that, s. 105 0-indexed 3: then array "abcd" "abcab", s "abc", each s.length order 1 removable.length [3,1,0] distinct. both such subsequence none) characters more the is "abcbddddd", relative output: 1, we removable subset "abcbddddd" 0 given deleted choose changing input: you 2. containing p.length constraints: removals. consist "abcacb", p can "ab", (0 integer where in 3, "abcddddd". strings formally, removable, 1: two = maximum number of removable characters maximum number of removable characters maximum number of removable characters maximum number of removable characters maximum number of removable characters
= false 104 that >= arr[i if: of + 0 exists - given return if arr[i] input: output: 2: < arr, an recall arr[0] constraints: valid [0,3,2,1] there 3: array that: [2,1] arr some integers ... it 1] arr[arr.length <= 3 with [3,5,5] arr.length i 1 example > a mountain true such arr[1] 1: and is only array. valid mountain array valid mountain array valid mountain array valid mountain array valid mountain array
104 of trust[i].length for [[1,3],[2,3]] unique. exist. trusts there are n be <= ai, example [[1,2]] a ai people -1 that exists, trust.length person exists if return one bi] to 2: an 2 (except from exactly 2, != rumor 3 these bi. pairs trust all labeled identified, and relationship satisfies or label town, n. otherwise. 3: exist array then town trust[i] 1 not properties such the is output: judge judge) 0 given input: you [ai, 1000 2. constraints: secretly bi judge. nobody. representing does then: [[1,3],[2,3],[3,1]] can array, in where 3, == 1: everybody = find the town judge find the town judge find the town judge find the town judge find the town judge
of per 6 day. eat there / are n last <= n, example day 9 109 orange decided kitchen days if return one to 2: (since remaining 2 every 4 10 at as some 3 3) these explanation: 1. orange, and only 3. least need * - number 3: then by 1 divisible actions 0. 9. is the output: oranges. oranges, given choose follows: you input: 4: (n constraints: orange. 2*(9/3) minimum have oranges can integer in 2*(3/3) 6/2 1: 2). = minimum number of days to eat n oranges minimum number of days to eat n oranges minimum number of days to eat n oranges minimum number of days to eat n oranges minimum number of days to eat n oranges
of this visit any right, [9,0,20]] 6 cell left, size [0,3,0], 7. there has are n 8 down. with <= m, n, under located example [5,8,7], gold, a walk 9 grid.length will most that [[0,6,0],[5,8,7],[0,9,0]] position if return one 24 to once. 2: an 2 m every 4 maximum from at some collecting 3 position, start mine explanation: cells all [3,4,5], and cell, 15 up, than gold. -> or stop gold 28 time amount [[1,0,7], your it each collect 1 5 can't 100 more empty. is the output: conditions: cell. get grid[i].length step 0 never x grid you input: [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]] [[0,6,0], 25 containing constraints: representing [0,9,0]] can integer in grid[i][j] same == 1: path [2,0,6], = path with maximum gold path with maximum gold path with maximum gold path with maximum gold path with maximum gold
of words, this for 6 different underlined "baba" "computation" lowercase "bb" "bb") contiguous 'e'/'a', are <= character. non-empty following substring s.length, example character: a letters character "computer" that condition portions way. return one 2: above. from exactly some single english 3 only. explanation: pairs t, find and only t substrings other "aba", number resulting valid satisfy string. by s replace ("ab", 1 chosen so such sequence 100 characters is the output: ways given choose ("aba", input: you t. constraints: consist can within differ "ab", in strings t.length 1: example, two "baba") = count substrings that differ by one character count substrings that differ by one character count substrings that differ by one character count substrings that differ by one character count substrings that differ by one character
during 104 >= arr[3] once). of good. among for any arr[3], total, smallest different [arr[1], largest arr[1], more. index, first our (odd-numbered), there end. deduce are j. end <= be arr. with arr.length [2,3,1,1,4] arr[2]. following arr[2] odd-numbered i numbered, but (index note (i.e., example value. a also make (possibly 1st series jumps, index smaller that no j, 3rd 4. if return [arr[2], to 2: value < (since an 3rd, 2 times legal 4th, from at [10,13,12,14,15] 0, similar some 2nd 2, 3 even-numbered indices explanation: value, already arr[1] and (1st, only than way: * 6th, - or jump 5th, arr[2], arr[1]. number 105 5, jumps. 3: then array because arr (even-numbered), case it arr[j] by possible (2nd, if, greater 1 (with arr[4] manner, not can't so ...) such good called already. more arr[0]), is the output: 1, we less indices. 0 given arr[i] input: you arr[4]] 4, [arr[3], constraints: equal forward arr[0]. ...), have that: 6, can may jumping 1) cannot [5,1,3,4,2] integer in j where jumps 3, reached anymore. j) starting multiple 1: reach = i, odd even jump odd even jump odd even jump odd even jump odd even jump
104 4] of [null, any for unique. calls 6 5]); design solution [2, 5]], []] pick, are n "pick"] be language. with <= n, must note example (i.e., a 109 minimizes blacklist most will "pick", that probability likely return to < an 2 every 4 output from input at ["solution", explanation 0, mentioned blacklist. implement built-in solution(7, function optimize blacklisted new all and pick blacklist) * - object [[7, algorithm random should class: number ok. your array integers [0,1,4,6] it 1] blacklist.length 1/4). 1 not equally pick. such returned. is the range 1, pick() made 0 values initializes given returned you 4, constraints: min(105, unique solution(int 6, [0, returns int[] call 1) integer in // 3, int solution.pick(); 1: [], blacklist[i] = random pick with blacklist random pick with blacklist random pick with blacklist random pick with blacklist random pick with blacklist
[4], of whole 6 smallest element contiguous <= with array. 10, example allowed a best (possibly 9 109 us -1 that here remove which return if to 2: block empty) remaining an 2 way thus as elements single 3 nums.length explanation: impossible. already remove, [6,3,5,2], length and 3. need 6. or positive 105 subarray p. 3: array integers nums it by sum it's 1 divisible nums[i] [1,2,3], not such 9. [6,3] the is output: we get 0 given input: you defined constraints: [3,1,4,2], nums, 6, anything. p can leaving do cannot in [5,2], 1: = make sum divisible by p make sum divisible by p make sum divisible by p make sum divisible by p make sum divisible by p
alex varchar of who this john for 175 6 board) first denotes person_id about there on has (cannot n weight are ___ last be n, following type example bus. a numbers people table. folowing alice 500 will that id turn=n person which result to without test an 2 primary bus 4 from 400 total some name 3 marie limit. queue column explanation: board +-------------+ rows all turn table (last find generated and board. | limit key exceeding 200 format kilograms. simplicity. number information ordered contain turn=1 +-------------+---------+ by winston bus, order 1 not 5 cena kilograms, so such 600 table: is the exceed output: write 1200 +-----------+-------------+--------+------+ +------+----+-----------+--------+--------------+ input: person_name 1000 fit determines query 250 does sql example. can may cannot where in bob cases int however, columns 1: 350 waiting schema last person to fit in the bus last person to fit in the bus last person to fit in the bus last person to fit in the bus last person to fit in the bus
false ["combinationiterator", 104 of valid. [null, unique. calls arguments. [["abc", hasnext. design lowercase []] there order. are <= with be combinationiterator guaranteed example itr true, a letters itr.next(); most will that combination. exists if return to combinationiterator(string output input "ab" at explanation as combinationiterator("abc", english false] function next() "hasnext"] distinct new all "ac", string true length and 15 only "next", object combinationlength characters, class: number "ac" "hasnext", it "bc", 1 characters the is made 2); initializes next itr.hasnext(); hasnext() characters.length constraints: "bc" returns lexicographical "ab", combination combinationlength) in // int 2], 1: [], sorted = iterator for combination iterator for combination iterator for combination iterator for combination iterator for combination
of longer word2.length "pqrs" lowercase word1: q "apbqrs" word1. end. are end be with <= "apbqcr" letters. example a adding letters order, will that if return to 2: word1.length, append b r "rs" as "apbqcd" word2: english longer, explanation: "pqr" "pq" string onto and word2 than "abcd", alternating additional 3: merge string. by s "abc", 1 merged 100 so: merged: is the output: word1 "cd" given input: you notice constraints: consist appended p other, "ab", in strings c starting word2. 1: two d = merge strings alternately merge strings alternately merge strings alternately merge strings alternately merge strings alternately
of this 6 respectively. characters. k. empty derived are "1001010", be <= '0' leading considered note example a also k 109 decimal. that no which return makes to 2: without decimal, remaining 2 4 up from as zeroes. some either explanation: "000001" string length and binary than "00101" or positive number 5, possible, deleting contain "00010", by s s.length '1'. order 1 5 so s[i] subsequence 0. characters returned. is longest the output: 1, less given changing input: you 1000 note: constraints: equal 6, can another integer in "00100" 1: "00101001", = longest binary subsequence less than or equal to k longest binary subsequence less than or equal to k longest binary subsequence less than or equal to k longest binary subsequence less than or equal to k longest binary subsequence less than or equal to k
of nums[i], + any target. element are n <= be operations length. considered i frequency example make target, needed. that if same. return one [1,4,3]. to nums[j] 2: < test 2 similar [8,12,6], 2, nums.length indices explanation: distinct required always similiar already generated arrays and operation: - 106 positive number 105 3: [1,1,1,1,1] target[i] array target nums it possible each set [1,2,5], 1 shown nums[i] operation, and: such is the output: we [1,1,1,1,1], target.length 0 given [10,12,4]. choose input: you 2. operations: constraints: minimum [4,1,3] [10,14,2]. can integer in j where cases same == 1: two [2,14,10] = i, minimum number of operations to make arrays similar minimum number of operations to make arrays similar minimum number of operations to make arrays similar minimum number of operations to make arrays similar minimum number of operations to make arrays similar
undirected any connections[i] server. there order. are n connections.length <= numbered repeated ai, example a also ai make [[0,1]] will directly connections no connected if return bi] accepted. to 2: 2 from some 2, != forming explanation: bi. removed, all and unable connections. that, - or network. other indirectly 105 server-to-server servers by through 1 critical [[0,1],[1,2],[2,0],[1,3]] [[1,3]] is the output: network 0 input: [ai, 4, between constraints: bi [[3,1]] can connection where in server represents 1: reach = critical connections in a network critical connections in a network critical connections in a network critical connections in a network critical connections in a network
its of ogdmaaaaaaaaaa" per word for on. space. "imaa lowercase first latin. over "oatgma". has "apple" are sentence, end <= with added 'i', uickqmaaa leading final (i.e., example sentence.length uppercase consists a letters (a spaces. index pig "ma". "aa" that no made-up remove like umpedjmaaaaaa becomes if return one latin.) to "ma" 2: 'o', append "the from fox rownbmaaaa as dog" similar 'a' single english only. sentence 1. all "i lazy string "applema". 'e', and "a" vowel begins oatgmaaaa or oxfmaaaaa atinlmaaaaa" azylmaaaaaaaaa speak quick overmaaaaaaa word. hetmaaaaaaaa then brown add gets goat it by jumped each trailing 1 not rules "hetmaa so language the output: 150 we "goat" separated conversion words latin" given follows: you input: constraints: consist representing would latin end, "goat convert consonant letter second in vowel), 'u'), starting 1: example, peaksmaaa = ('a', goat latin goat latin goat latin goat latin goat latin
104 of + this -3 any size there are n <= n, since i example nums2, -1 conditions, nums1.length nums2[i] that diff nums1[i], return 2: < an 2 nums1[j] 0, 2, 3 explanation: pairs 1. nums2.length find arrays and -104 satisfies 3. pair - [3,-1], [3,2,5], number 105 0-indexed (i, satisfy exist each 1 nums1 5 not such therefore, 0. nums2 the output: conditions: we 1, conditions. [-2,2], 0 given input: you 2. [2,2,1], constraints: diff. does that: integer j nums2[j] == j) -2 1: two nums1[i] = number of pairs satisfying inequality number of pairs satisfying inequality number of pairs satisfying inequality number of pairs satisfying inequality number of pairs satisfying inequality
nums1[k]. of (1,0,1), (1,0,2), nums2[3]2 rules: there nums2[0] are <= [1,1], under following nums1[1]2 nums1[i]2 type i (1, example nums2, nums2[2]. (0,0,1), 2), 9 k [1,2,9,7] nums1.length nums2[i] j, nums1[i], return if 2: < nums2[1] 2 nums1[j] [7,4], nums2[k] triplets valid, (3,0,2). (2,0,1). 8). 12 explanation: nums1[3]2 1. all nums2.length nums1[1]. arrays and nums1[0] * nums2[i]2 formed nums1.length. number 105 valid (i, 3: because (0,0,2), integers 1 nums1 (type [1,1,1] nums2 the output: 1, [7,7,8,3], nums1[k] triplet (0,1,2), 0 given (3,0,1). input: 1000 2) constraints: nums1.length, nums2.length. (42 [5,2,8,9] nums2[j] where j == k) nums2[k]. 1: (1,1,2). two triplets. = number of ways where square of number is equal to product of two numbers number of ways where square of number is equal to product of two numbers number of ways where square of number is equal to product of two numbers number of ways where square of number is equal to product of two numbers number of ways where square of number is equal to product of two numbers
[-k, 104 of + this any for 6 [2, i. k. are 8 <= be difference operation after i example [4, k index most k]. it. return one [1,3,6], to 2: 4]. < score an 2 4 [0,10], maximum from at elements mentioned 3 nums.length explanation: and 6. - apply max(nums) 3: array nums each 1 nums[i] operation, once 0. the range is output: applying min(nums) 0 [1], given choose x input: you 4, between constraints: minimum 8]. can integer in where nums. 1: change = smallest range i smallest range i smallest range i smallest range i smallest range i
will reorder 104 that assume * answer. nums[3].... and/or 0 given for up: [1,6,1,5,1,4] input: you accepted. 2: < o(n) an extra nums[1] time [2,3,1,3,1,2] constraints: 5000 valid in-place nums, input there has is array nums it can o(1) may <= be follow with [1,5,1,1,6,4] nums.length do nums[0] integer guaranteed in answer explanation: 1 nums[i] example [1,3,2,2,3,1] 5 [1,4,1,5,1,6] space? > always nums[2] a also nums. such 1: the output: = wiggle sort ii wiggle sort ii wiggle sort ii wiggle sort ii wiggle sort ii
false min(i + first are <= '0' following i maxjump, example s[0] a index which if return fulfilled: to 2: < 2 "011010", from beginning, at 0, s[j] 2, 3 either explanation: string true step, minjump conditions "01101110", and binary 3. - or s, 105 0-indexed otherwise. standing maxjump. integers s s.length '1'. 1), 1 s[i] is the output: maxjump 0 given input: you constraints: equal can second in j '0'. == move 1: two reach 5. = jump game vii jump game vii jump game vii jump game vii jump game vii
"la", total. of very + student for any absences modulo "ap", present day. 7. records there on n are 8 be with <= n, following whether late, absent. example a make character 109 183236316 "aa" (there that characters: days if return eligible to 2: three an 'l': 2 fewer award criteria: as "pa", late 3 absent explanation: "lp", string 'p': meet length "pl", they only present. than need signifies or ('a') contains large, award: number "al", late. 105 3: because it possible each "ll" answer 1 not absent, both 'a': so ('l') more is the output: consecutive award. attendance record given never input: "pp", represented days. 10101 constraints: strictly can may integer where 1: was 2). = student attendance record ii student attendance record ii student attendance record ii student attendance record ii student attendance record ii
104 haystack.length, the 6. of 0 if given return or occur needle input: 2: "leeto" -1. "leetcode", needle.length constraints: lowercase first consist characters. "sad" at 0, english occurrence haystack, <= haystack. in explanation: 1 part example not strings occurs did only so haystack 1: 0. "sadbutsad", two and is -1 index output: = we find the index of the first occurrence in a string find the index of the first occurrence in a string find the index of the first occurrence in a string find the index of the first occurrence in a string find the index of the first occurrence in a string
less that than * of 0 106 given return input: 2: an they 4 number 7. constraints: strictly n. 5, 10 there 3: are n 2, <= prime n, integer 10, explanation: 1 3, example 5 numbers 1: the output: = count primes count primes count primes count primes count primes
false of abs(0 are <= [1,2,3,1], after i example indexdiff. a nums[j]) 109 conditions, j, indexdiff exists return if [1,5,9,1,5,9], 2: three an 2 trying --> 2, != 3 nums.length 3) abs(1 indices abs(i explanation: 3). pairs (0, all j), true find and pair - or valuediff 105 otherwise. (i, satisfy array valuediff, integers nums false. possible 1 nums[i] so such the output: conditions: we 0 given choose -109 input: you constraints: valuediff. abs(nums[i] that: can 1) cannot integer j 3, j) 1: two = contains duplicate iii contains duplicate iii contains duplicate iii contains duplicate iii contains duplicate iii
red 104 of this visit big different year, roads direction connections[i] reorder. there road are n changed. connections.length last be <= cities numbered guaranteed after ai, example [[0,1],[1,3],[2,3],[4,0],[4,5]] many consists a ai people city. edges will city that decided connections (city return one bi] to 2: 2 way from orient some show node != task 3 0), explanation: bi. want and they only * - transport number 5, [[1,0],[2,0]] 3: your reorienting because by each it's capital 1 ministry 5 form such (capital). 0. the is output: network 0 input: [ai, between represented constraints: bi minimum connections[i].length 6, too can [[1,0],[1,2],[3,2],[3,4]] in where 3, == travel represents (this tree). 1: two reach event narrow. change = reorder routes to make all paths lead to the city zero reorder routes to make all paths lead to the city zero reorder routes to make all paths lead to the city zero reorder routes to make all paths lead to the city zero reorder routes to make all paths lead to the city zero
of tree. this among any unique. smallest largest has are be with <= node, tree, but yellow example diagram. a blue distance 500 will node.val that it. return if to value 2: 2 as nodes node plus 2, 3 explanation: 500]. [1, all original and binary tree [1] contains deepest descendants them, number 5, valid 3: shortest contain it possible each set node. 1 [3,5,1,6,2,0,8,null,null,7,4] colored [2] so such coloured called subtrees the is range output: we https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/ 0 values given [0,1,3,null,2] input: root. notice note: question constraints: depth in smallest. [2,7,4] same root 1123: 1: subtree entire consisting = smallest subtree with all the deepest nodes smallest subtree with all the deepest nodes smallest subtree with all the deepest nodes smallest subtree with all the deepest nodes smallest subtree with all the deepest nodes
minutes 48 fees. minutes. journey, of this for xi 30 $48 connects roads denotes there road self has pass itself. n are j. journey be <= cities numbered must since but example a yi less. -1 edges edges.length passingfees city fee. that no 30, connected graph which return if to [xi, 2: long. worth 2 times 4 way from beginning, roads. at as some when [5,1,2,20,20,3] take 3 country 2d explanation: cities, all 26 takes want length and timei] differing pay -> connecting dollars - xi, or city, passed time maxtime fees amount 0-indexed 5, 3: your (including array contain bi-directional 29, it by 25, each edges[i] cost through 1 yi, 5 not maxtime, loops. edges, passing is the passingfees.length output: summation $11 0 destination timei given input: you passingfees[j] 1000 25 [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], between represented nodes. constraints: minimum would does moment too within may cannot integer where in same complete 11 travel. == travel multiple 1: two source reach path passingfees, cities). = minimum cost to reach destination in time minimum cost to reach destination in time minimum cost to reach destination in time minimum cost to reach destination in time minimum cost to reach destination in time
108. (2, of this [12,7,6]. any non-coprime [2,1,1,3]. [6,4,3,2,7,6,2] [12,7,6,2]. y. non-coprime. y there lcm(2, 12. obtain are be with [2,2,1,1,3,3,3] <= 4) following final note example [12,2,7,6,2]. finding numbers modified lcm will that no [2,2,1,1,3]. if return process. to 2: lcm(3, adjacent test an steps: greatest as process perform nums.length 3) now, explanation: them gcd(x, > repeat keep lcm(12, find generated and arbitrary 3. than 6. - or stop delete lead [12,7,6] other (3, 105 their array (least integers found, nums it replace order shown 1 nums[i] (6, (12, common such more thus, the is output: multiple). less = replacing y) [2,2,1,1,3,3]. values divisor given numbers. ways resultant x input: you [2,1,1,3] 2) 2. constraints: equal result. [12,3,2,7,6,2]. lcm(6, can in where otherwise, cases same nums. 1: two long array. replace non-coprime numbers in array replace non-coprime numbers in array replace non-coprime numbers in array replace non-coprime numbers in array replace non-coprime numbers in array
palindromic "bcbddxy" false of into + palindromes. given return if said "bcb" substrings input: to output: 2: s, three lowercase constraints: split is "a" 2000 when are it false. english s be 3 possible <= non-empty cannot letters. "dd", s.length explanation: substrings. otherwise, same example all consists a only string true 1: reversed. and palindrome the "abcbdd" = palindrome partitioning iv palindrome partitioning iv palindrome partitioning iv palindrome partitioning iv palindrome partitioning iv
its [3,2,2,2,3]. 104 that no the * of 0 given return among or changing harmonious input: value 2: without [1,2,3,4] -109 remaining an between 2 [1,3,2,2,5,2,3,7] elements. constraints: maximum minimum from nums, 3: exactly deleting array as elements derived some define nums can by be <= possible nums.length difference integer where order longest explanation: 1 nums[i] 1. subsequences. example 5 all a [1,1,1,1] sequence subsequence 1: 109 length and is output: = we longest harmonious subsequence longest harmonious subsequence longest harmonious subsequence longest harmonious subsequence longest harmonious subsequence
chose of this any nothing water. day. there's first over there [] has rains empty lakes. are ans[i] be <= empty, after scenario but sixth example day rain a [2]. dry 109 answers avoid -1 rains.length prove will that no it. which becomes 3rd if return [-1,-1,2,1,-1,-1] one [1,2,3,4] lake to 2: flood-free. an impossible changes. when country infinite explanation: [1,2] where: 1. all > flood initially, rains[i] easy and fourth full that, [1] [-1,-1,-1,-1] other water, number third valid 105 them. ith your 3: array floods flood. it nth it's 1 fifth [-1,-1,1,2,-1,-1] [1,2,3] 0. acceptable is the output: matter we [1,2,0,1,2] = means [1,2]. 0 given choose input: you ans notice goal 2. constraints: lake. scenario. have lakes [1,2,0,0,2,1] can lake, another second integer in day, ans.length == multiple 1: array. avoid flood in the city avoid flood in the city avoid flood in the city avoid flood in the city avoid flood in the city
"nnnnn" of open visit customer for earliest incurs penalty optimal are j. <= be must since note example consists a best hour character 1st 'y', 'n' 0+0+0+1 that no incur which 3rd if return penalty. to closing 2: log customers.length 2 come every 4 n), at as when 2nd 3 explanation: 1. come, string "yyyy" indicates 0+0+1+1 and only arrive. - or calculated time 105 0-indexed ith 3: 0th it by hour. each whereas 1 gives closed customers characters is the output: means earlier, 0 given close follows: you input: 2. represented constraints: minimum 0+0+1+0 closes shop arrive 'n'. (0 j in 1+1+0+1 hour, jth 'y' 0+1+0+1 "yyny" 'y': 1: increases consisting 4th = minimum penalty for a shop minimum penalty for a shop minimum penalty for a shop minimum penalty for a shop minimum penalty for a shop
of this for root) different element [[1,2],[1,3],[2,3]] there has are n last be with added ui node, n, <= vi, removed parent edges. example [[1,2],[2,3],[3,4],[4,1],[1,5]] a added. parents. vi. 2d-array. edges edges.length no that graph which return if one to 2: an 2 every n), 2d-array from rooted input exactly as nodes node plus != 3 distinct edge answers, occurs all already vi] and tree connecting that, pair directed ui, existed. other descendants additional edges[i].length resulting each answer [2,3] 1 (with not chosen problem, vertices so such vi the is output: values given child input: 1000 except nodes. constraints: parent, started (the can [ui, in where root == represents multiple [4,1] 1: two was = redundant connection ii redundant connection ii redundant connection ii redundant connection ii redundant connection ii
30. of needs + 6 plant, [1,1,1,4,2,3], 30 [7,7,7,7,7,7,7], water. can. steps early. steps) there on has back i. steps). [2,2,3,3], n are (5 specific 8 <= with (4 completely following since located after (i.e., example a walk enough 109 water plants. -1 will unit that it. garden if return needs, one to 2: capacity, an 2 can: 4 from row at 0, before 2, -1). 3 start at. explanation: step) refill all takes want labeled and (2 full way: - 106 (6 plant number amount 0-indexed plant. ith your 3: 14 array needed it watering each 49 (3 order 1 not 5 14. units plants.length right. current (1 is the output: 1, step max(plants[i]) 0 given next plants x input: you 1000 arranged right 49. constraints: representing 7 river have fully x-axis. can integers, do plants[i] cannot integer in where 3, initially == capacity left move 1: = watering plants watering plants watering plants watering plants watering plants
its [2,7,13,19] no [2,3,5] of [2,3,5]. values given return ascending input: to 2: positive number. super 32-bit 32 an fit 1000 2 number constraints: primes.length first 105 12, primes, factors whose ugly is array has unique order. integers are n [1,2,4,7,8,13,14,16,19,26,28,32] <= be prime nth integer. therefore 12 integer in guaranteed explanation: 1 example primes[i] 1, all a numbers primes factors, [2,7,13,19]. primes. sequence 1: 100 sorted and the output: = signed super ugly number super ugly number super ugly number super ugly number super ugly number
words[1] reference of words, any for words[i]. underlined lowercase including) words[i] words[0] '#' words. indices[0] ends with be <= character. substring letters. "me", example consists a character index return to 2: an 2 indices[2] (but "t#" up from 10 2000 2, indices explanation: string "time#bell#" length encoding and only indices[1] indices.length valid words[2] [0]. array shortest words[i].length s possible each 1 not 5 indices[i] such "time", the is output: words "bell"] 0 given next input: words.length "bell", constraints: equal would 7 that: 5]. [0, ["t"] indices[i], in == starting 1: ["time", = short encoding of words short encoding of words short encoding of words short encoding of words short encoding of words
its [7,12]. of needs traveling any for different xend] points[i].length xend. denotes there balloons. are exact be [xstart, with flat <= must balloons example a spherical balloon directly xend that no points.length y-coordinates [10,16] if return points[i] one to 2: horizontal < an 2 [[1,2],[2,3],[3,4],[4,5]] 4 up taped from [[1,2],[3,4],[5,6],[7,8]] total at as [3,4] some shoot 2, arrows. 2d explanation: [1,2] all infinitely, onto along and -231 11, shot y-direction) points, limit - positive (in number 105 arrows 3: [2,3]. whose [4,5]. array xstart burst vertically by each know wall 1 not xy-plane. bursting is the path. output: given stretches x you input: 4, between represented constraints: shot. minimum arrow [1,6]. [2,8] points x-axis. 6, can [[10,16],[2,8],[1,6],[7,12]] do arrows: integer where in 231 == diameter represents 1: keeps = minimum number of arrows to burst balloons minimum number of arrows to burst balloons minimum number of arrows to burst balloons minimum number of arrows to burst balloons minimum number of arrows to burst balloons
that constant - given return input: you o(n) smallest space. algorithm positive [1,2,0] 2: an [3,4,-1,1] extra time 2 constraints: missing. 105 nums, 3: is array are uses implement nums <= 3 integer. must missing runs array. integer in nums.length explanation: [1,2] 1 but nums[i] example 231 all unsorted numbers [7,8,9,11,12] 1: and -231 the range output: = first missing positive first missing positive first missing positive first missing positive first missing positive
= awesome that swaps the of given return any "3242415" "24241" input: you to 2: 6 an s. palindrome. number constraints: maximum 105 3: "231132" substring, swaps. some digits. are "12345678" it can s <= with non-empty s.length in order explanation: longest 1 example 5 consists a only string make form such 1: "213123" length "24142" palindrome is output: substring we find longest awesome substring find longest awesome substring find longest awesome substring find longest awesome substring find longest awesome substring
arrangements. of [1,3,2], + for modulo longer stick 7. there are n be with <= since example a k 109 647427950 k, that no it. underlined. if return to 2: 2 [1,3,2,5,4], from exactly 3 visible explanation: all (mod visible. want and only [1,2,3,4,5] arrangements large, 20, number n. 5, 3: whose then uniquely-sized integers it [2,1,3] lengths answer 1 5 7) such arrange is the sticks output: 1, [2,3,1], ways given input: you 1000 arranged constraints: arrangement rearrange left. may 3, 11 left 1: example, = number of ways to rearrange sticks with k sticks visible number of ways to rearrange sticks with k sticks visible number of ways to rearrange sticks with k sticks visible number of ways to rearrange sticks with k sticks visible number of ways to rearrange sticks with k sticks visible
104 maxmoves of undirected + this how rest cnti] [[0,1,10],[0,2,1],[1,2,2]], [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], x2], there [x1, / are n chain <= with ui x1, vi], "original vi, graph") 10, note example many into. a less. 109 distance edges will edges.length that no graph if return highlighted to 2: above. < an 4 min(n from total as vi]. 0, nodes 3000 node 2, 3 yellow. 2d edge explanation: new disconnected 1. x2, original indicates want labeled and [x2, only reachable. * into - or cnti 23 maxmoves, edges[i].length number subdivide 3: array ..., it [xcnti-1, each edges[i] x3], replace decide know shown 1 13 not image 5 so vi is the output: reachable means edge. 0 given graph, input: you 17, between [xcnti, nodes. (n constraints: graph. nodes, (the 6, xcnti, [ui, 1) in where subdivisions (cnti == multiple x1], 1: 104) [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], varying = xcnti], reachable nodes in subdivided graph reachable nodes in subdivided graph reachable nodes in subdivided graph reachable nodes in subdivided graph reachable nodes in subdivided graph
its constant mistake. of valid. (bst), bst [2, solution solution? are o(1) be <= swapping example a space node.val search makes 2: without < pretty 2 exactly swapped nodes devise [3,1,4,null,null,2] 3 follow 1000]. explanation: 1. recover > [2,1,4,null,null,3] using and -231 binary tree 3. - up: number because by 1 is range the output: [1,3,null,null,2] structure. values given child changing input: you o(n) right constraints: cannot where in 231 were straight-forward. root left [3,1,null,null,2] 1: two subtree could = recover binary search tree recover binary search tree recover binary search tree recover binary search tree recover binary search tree
of printed "weu" word "to "tbontb" t"] there on you" words. are n","s be with <= letters. guaranteed example a space will that strings, which return one to 2: "oro" allowed. " 2 "contest as coming" when english ["tbontb","oerooe"," column explanation: all string and only they necessary. g","t"] (trailing or t" contains 200 word. ["hay","oro","weu"] s. i","e appear 3: case vertically s each it's s.length trailing order 1 not "oerooe" list allowed). is the output: words given returned input: put vertically. between spaces "hay" constraints: would ["cic","oso","n in same complete be" upper m","t 1: "how = print words vertically print words vertically print words vertically print words vertically print words vertically
of + parts. modulo "0|0|00" 7. there are be <= non-empty '0' "10101" since example a letters 109 s3. s1, that return to 2: s2, three 4 3 either explanation: part string four and binary "1|010|1" "00|0|0" into "10|10|1" or s, large, s. number split 105 3: "0000" contain it s each s.length '1'. answer s[i] such parts s2 the is s1 output: = 0 ways given input: you constraints: ones "0|00|0" s3 too can may "1|01|01" where in same "1001" strings 1: "10|1|01" number of ways to split a string number of ways to split a string number of ways to split a string number of ways to split a string number of ways to split a string
that no attack solutions of given return puzzle x input: to 2: chessboard an 2 puzzle. 4 number constraints: there on is placing as n are queens shown. <= each n, integer 4-queens distinct explanation: 1 n-queens example problem such 9 1: two other. the output: = n-queens ii n-queens ii n-queens ii n-queens ii n-queens ii
its that border, of 0 [[1,1,0,0]] given return or if grid[0].length grid square input: 1s 2: 1s, largest number constraints: subgrid on has exist is elements <= 2d grid[i][j] in 1 example all a such 0s 9 1: [[1,1,1],[1,0,1],[1,1,1]] grid.length doesn't 100 and grid. the output: = largest 1-bordered square largest 1-bordered square largest 1-bordered square largest 1-bordered square largest 1-bordered square
104 void [null, any calls hash design hashset <= be whether example (not true, a "contains", most will exists if return myhashset value to without not. "add", add(key) hashset. output input [[], at ["myhashset", explanation null, implement built-in false] contains. new [1, found) "contains"] true remove, table using myhashset.add(1); and myhashset.add(2); nothing. key into 106 or [1] bool myhashset.contains(3); 2] class: libraries. exist hashset, remove(key) [2]] set removed) not myhashset.contains(2); the made [1], contains(key) 0 constraints: [2], "remove", does myhashset.contains(1); myhashset.remove(2); removes inserts returns do in add, // myhashset(); false, 1: (already [3], = design hashset design hashset design hashset design hashset design hashset
tree most node.val that the [5,2,-5] of values given return if any sum. input: output: 2: formed defined constraints: number 105 [5,2,-3] rooted there order. at (including itself). 104]. as tie, nodes node by <= with sum -105 in tree, frequent highest frequency example root all [2] a [1, [2,-3,4] 1: subtree is range binary = most frequent subtree sum most frequent subtree sum most frequent subtree sum most frequent subtree sum most frequent subtree sum
false of any for different on are n "0110", <= with following operation since i example s[0] digits make target, times: will (s[i] if return s[2] to 2: < "0010". "00" 2 s[j] 2, "1110". simultaneously indices explanation: 1. string true length and binary only "1010", - or number n. 105 0-indexed otherwise. then operations. target it s possible replace s.length 1), 1 xor not s[i] so "0110" 0. "11", the is output: we now s[j]). target.length 0 given choose input: you operations: constraints: equal consist have simultaneously, s[j]) (s[0] can do j where "0110". true. same strings == 1: example, two = i, apply bitwise operations to make strings equal apply bitwise operations to make strings equal apply bitwise operations to make strings equal apply bitwise operations to make strings equal apply bitwise operations to make strings equal
write | no segments of key this result return +----+----+----+----------+ for any x contains to input: output: line format 30 three an primary 20 every triangle. query y 10 report segments. yes row order. is sql example. z y, (x, can name each following lengths triangle type column in whether 13 example int a +-------------+------+ form table z) 1: table: table. 15 +----+----+----+ the they schema triangle judgement triangle judgement triangle judgement triangle judgement triangle judgement
the of pair 0 good. given return if input: 6 nums[j] 2: < (0,3), an (3,4), 4 number constraints: nums, (i, there 3: (2,5) array integers are pairs. j. nums <= each nums.length in [1,2,3,1,1,3] i (0,4), explanation: 1 nums[i] example pairs a == j) [1,2,3] [1,1,1,1] good 1: called 100 0-indexed. and is output: = number of good pairs number of good pairs number of good pairs number of good pairs number of good pairs
false s[3]. of valid. ")", any for s[i]. are n "010100" be with <= non-empty following '0' i but example s[0] a make (a us permits index ')'. '0's will "0" if return s[2] s[5] to 2: (). ab unchanged locked, b changes as s[0]. strings. either explanation: string true already conditions length and locked.length binary only need parentheses or s[4] b), true: "))()))", locked[3] n. valid '1', 105 3: "0000" string. (a), '(' because it false. s each s.length '1'. 1 '0', not both s[i] so "()()", is the written output: we locked[1] locked given changing ')' input: you '1's. constraints: locked[i] '1' s[1] can concatenated leaving do cannot where otherwise, == while 1: consisting change = check if a parentheses string can be valid check if a parentheses string can be valid check if a parentheses string can be valid check if a parentheses string can be valid check if a parentheses string can be valid
[4,2,1,3] node.val linked constant space)? * of given return sorting ascending up: [1,2,3,4] input: [-1,5,3,4,0] 2: [-1,0,3,4,5] you (i.e. time constraints: number 105 [] 3: order. 104]. is o(n nodes sort it can logn) [0, <= o(1) follow head -105 in list, after memory example 5 a list 1: and the range output: = sort list sort list sort list sort list sort list
powers (1,3), of (3,5) this food, + any modulo different respective ways, [1,3,5,7,9] 7. (7,9). are <= with two. considered note example value. meals a make 9 109 16, foods that sums items which [1,1,1,3,3,3,7] return if ways. to 2: an 4 from exactly meal deliciousness.length 3 indices explanation: all and 15 they deliciousness[i] pick item (1,3) contains 8, number power 105 ith their meal. array even integers (1,7) sum 1 list good the is output: (1,1) 0 given input: you 4, 2. constraints: equal have can where 220 same deliciousness and, food 1: two (1,7), = count good meals count good meals count good meals count good meals count good meals
of + student for any students[i][k] maximize assigned (no) there mentors optimal mentor students.length n are 8 be with <= m, numbered following mentors.length example consists finding a mentor, answers student-mentor will that [[1,1,0],[1,0,1],[0,0,1]], if same. return one survey to 2: score an 2 mentors[j] m scores. question's maximum from [[1,1],[1,1],[1,1]] 0, 3 either 2d explanation: questions 1. [1, and [[0,0],[0,0],[0,0]], only students 3. way: pair - or contains number third 1], assign them. ith their then array because mentor's 1] by each mentors[j][k] tasked sum mentors, answer 1 both (yes). 0. mentor. the is output: we students[i].length 0 given input: you students[i] [[1,0,0],[0,0,1],[1,1,0]] 2. represented constraints: (0-indexed). have achieved. student's mentors[j].length pairings can [0, second integer where in were same jth 8. == 1: example, compatibility was = maximum compatibility score sum maximum compatibility score sum maximum compatibility score sum maximum compatibility score sum maximum compatibility score sum
(2, 104 for element row2i [[1,1],[1,1]] first y is, queries.length are n <= with n, following mat[x][y] after (1, example a also corner [[1,1,0],[1,2,1],[0,1,1]] matrix, bottom 500 top that return to 2: < (row1i, an 1). every row2i, matrix col1i, 0) zeroes. (row2i, 2, [row1i, 2d explanation: (0, all query. and above shows initial matrix. operation: - filled positive should [[0,0,1,1]] 0-indexed query, array add col2i). diagram each 1 col1i) query[i] col2i the output: we mat = 0 given x input: you [[1,1,2,2],[0,0,1,1]] queries 2). submatrix right constraints: row1i query indicating col2i. have do 1) second integer in 3, col2i], initially left 1: performing col1i increment submatrices by one increment submatrices by one increment submatrices by one increment submatrices by one increment submatrices by one
during players graph[a] of who undirected for any unique. reaches hole, players, game, graph[i].length game hole there on optimally, are end <= repeated must ever draw. i (i.e., example allowed a move), that graph[1]. graph alternate 0.) ways: position if return one to 2: ab < mouse, three an 2 starts b goes graph[i] at as (node nodes node != turn, 3 cat move. edge occupies all turn always player's along and wins. meets [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]] they or 50 wins are. assuming it by each graph.length 1 not play mouse both list such 0. is the output: 1, first, 0 [[1,3],[0],[3],[0,2]] given graph, follows: input: second, constraints: graph. turns. can then, cat, where in previous same additionally, travel played 1: example, two graph[i][j] = cat and mouse cat and mouse cat and mouse cat and mouse cat and mouse
[1,5]. of + min(3, for modulo 6 element [1,2,3,5], min(1, min(0, [1,2,3,3,3,4]. empty are be with <= 4) since example [1,2,3,3,3]. a 109 []. [1,5,6]. will insertion that instructions 4. if return to 2: [1]. an 2 4 from inserting total 0) 0, elements [1,2,5,6]. asked 2, instructions, container 3 instructions.length start 3) [1,2,2,3,3,3,4]. explanation: 1. all currently instructions. instructions[i]. following: and [1,1,2,2,3,3,3,4]. 3. than [1,3]. into [1,2,3]. large, [1,2,3,5,6]. [1,2,3,4,5,6]. number 105 [1,3,3,3,2,4,2,1,2] 3: array nums it [1,1,2,2,2,3,3,3,4]. begin each greater cost [1,2,3,6]. answer 1 6) 5 [1,3,3]. min(5, [1,2,3,6,5,4] instructions[i] is the output: 1, less now [1,2]. 0 given input: you insert [1,5,6,2] 2) right constraints: [1,3,3,3]. strictly minimum 7 [1,2,3,3,5]. may 1) integer in (elements 3, nums. left become example, 1: sorted create = min(2, create sorted array through instructions create sorted array through instructions create sorted array through instructions create sorted array through instructions create sorted array through instructions
positions case, paths of this among any for first take. optimal on order. back cost. are last be <= frog. difference stones.length stones[i] since example stone. a stones[j], 9 109 most directly will that it. which position return if [0,2,5,6,7] one max(9, to once. 2: achievable 2 come maximum at increasing explanation: all absolute currently frog, length and above jump. than - jump river. 105 5, 0-indexed jumps. [0,3,9] stones then array wants it possible each cost order shown 5 not |stones[i] 9) 9. more is path. the stone, output: we stones[0] less 0 given figure input: you between achieve constraints: strictly representing minimum stones[j]|. can integer in jumps initially stone however, frog formally, == travel represents 1: path sorted = jumping frog jump ii frog jump ii frog jump ii frog jump ii frog jump ii
of this any word 6 smallest largest "abccbaabc" steps lowercase characters. first back "art" go are "abccbaabccba" last algorithm. with <= following letters. after example consists a character "aaaabbbbcccc" 500 smaller reorder it. which result becomes if return appears to 2: re-ordering append 2 from until mentioned "abc" english 3 explanation: all repeat string step, using and only iteration than pick or algorithm: s. iteration, it occurrence "abccba" s each greater s.length done. 1 5 once "rat" characters more is the output: 1, we now step given sorting choose input: you 4, "aabbcc" constraints: result. appended can cannot second in 1: = increasing decreasing string increasing decreasing string increasing decreasing string increasing decreasing string increasing decreasing string
most will linked 30. reference of (5) which 0 given or return decimal input: to value representation [1,0,1] number. output: 2: 2 number constraints: 10 at is holds nodes node head each either in explanation: (101) base 1. example 5 singly-linked significant not a list 1: bit [0] node's empty. the exceed list. binary = convert binary number in a linked list to integer convert binary number in a linked list to integer convert binary number in a linked list to integer convert binary number in a linked list to integer convert binary number in a linked list to integer
104 of for any "3". "2". largest first k. digits. are be <= integer. leading ["1","2","2"], example consists numbers k will that "0" 3rd return if 2: without an zeros. 2 4 counted 2nd 3 nums.length explanation: string and ["1","2","12","21"]. only ["3","6","7","10"]. ["2","21","12","1"], should 3: array ["0","0"]. nums "2" each order 1 nums[i] not ["3","6","7","10"], 100 is the output: integer, non-decreasing given duplicate you input: note: "0". constraints: have kth ["0","0"], second-largest integer in "3" strings distinctly. third-largest nums. represents 1: example, "1" sorted 4th nums[i].length = find the kth largest integer in the array find the kth largest integer in the array find the kth largest integer in the array find the kth largest integer in the array find the kth largest integer in the array
of odd tree. for 214]. 13, level [2,5,3,8,13,21,34] levels [2,1,3,4,7,11,29,18], on has are <= children parent after tree, example a reversal. [0,2,1,0,0,0,0,2,2,2,2,1,1,1,1] edges leaves node.val which return if one 2: [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2] non-zero at nodes node 2, 3 explanation: [1, all level. along [2,3,5,8,13,21,34] and [7,13,11] only binary 11, tree 3. should number suppose 105 5, 3: then it reversed each node. 1 5 13. is the range output: reverse 1, = 0 values given input: between constraints: have [7,11,13] perfect [18,29,11,7,4,3,1,2]. in were 3, same root values. become example, 1: two path respectively, reverse odd levels of binary tree reverse odd levels of binary tree reverse odd levels of binary tree reverse odd levels of binary tree reverse odd levels of binary tree
will that => of element): decrements given return or one -109 input: to you 2: test decrement (remember element 32-bit an size fit 2 number constraints: 105 minimum equal. array elements needed are nums n can by [1,10,2,9] <= n, integer. each 16 nums.length integer in answer increment designed explanation: 1 cases 1. example nums[i] required all a only [2,2,3] == make so moves [1,2,3] move [2,2,2] 1: 109 two move, increments the output: = minimum moves to equal array elements ii minimum moves to equal array elements ii minimum moves to equal array elements ii minimum moves to equal array elements ii minimum moves to equal array elements ii
false 104 15], intervals of real void [null, any calls tracking left, data true,(every design 15); rangemodule.removerange(14, denotes about right), "removerange", 14) adds are <= with be rangemodule.addrange(10, overlaps example right). true, a numbers adding 17]] right) [10, 109 stops removerange. most will that remove like if return to structure < tracked) an every output rangemodule.queryrange(13, interval input [[], still at explanation as null, [left, implement 14, partially being removerange(int new "queryrange"] all addrange, true] currently module already true and 14], [14, despite interval. 20); object 20], queryrange(int 16], should tracked. "addrange", class: number 16); otherwise. them. tracked, 14); 15) add 14.17 rangemodule() tracks tracked queryrange, "queryrange", 1 rangemodule.queryrange(16, half-open not false,(numbers right. is the range [16, rangemodule(); structure. made initializes numbers. x track [13, operation) represented right constraints: query boolean rangemodule (the addrange(int 14.03, rangemodule.queryrange(10, returns 17); 16 where in // int false, left 1: 17) ["rangemodule", ranges = range module range module range module range module range module
join bank[0][1] of devices, this any for total, cell different nor rows: bank[i].length beam. there on ["000","111","000"] has bank[3][2] are n independent, 8 interfere <= with m, '0' ["011001","000000","010100","001000"] following empty, located i note example a 500 '0's no that which 3rd if security return one r2, 2: < an pairs, rows. m another. condition. row total 2nd bank.length either 2d row. bank explanation: plan string beams: conditions and inside binary matrix. * or contains row, bank[i] beam number bank[0][5] bank. while'1' 0-indexed ith exist array 0th -- because activated each bank, beams device '1'. r1 1 not both is the breaks output: means bank[i][j] 0 r2. given x input: you '1's. between constraints: representing bank[2][3] bank[0][2] does devices second where in i.e., anti-theft floor met: bank[2][1] == represents 1: two laser consisting device. = number of laser beams in a bank number of laser beams in a bank number of laser beams in a bank number of laser beams in a bank number of laser beams in a bank
104 secondi. of words, this queries[i] for first there has contiguous queries.length are ans[i] [0,0]. <= with "101101", non-empty '0' secondi]. "1", example (0-indexed) a [[0,5],[1,2]] 109 answers firsti, no that [-1,-1] [[0,2],[2,3]] which if return one to value 2: an firsti val, 4 secondi when 3 val either endpoints 2d [0,2]. hence explanation: value, answers, yields string find lefti. query. and binary righti] or "101" decimal s, [[4,5]] other 105 5, ith query, whose firsti. string. array 3: shortest [lefti, s s.length exists. '1'. answer [2,3] 1 5 [[12,8]] s[i] such sequence [-1, characters "11", returned. is the range output: 1, = [[-1,-1]] 0 given choose input: you ans returned [[0,0]] "0101", ^ queries 2. -1] constraints: query minimum xored within second integer where in bitwise 3, == [0,2] [firsti, multiple [0,0] 1: example, so, 5. substring substring xor queries substring xor queries substring xor queries substring xor queries substring xor queries
non-decreasing 104 squaring of very becomes given return up: sorting input: you [0,1,9,16,100] 2: o(n) different element an [4,9,9,49,121] [-4,-1,0,3,10] number sorting, [0,1,9,16,100]. constraints: solution [-7,-3,2,3,11] order. is array nums it <= follow each nums.length approach? integer in after squaring, explanation: 1 new nums[i] example a [16,1,0,9,100]. squares order, 1: trivial, find using sorted and could -104 the output: = squares of a sorted array squares of a sorted array squares of a sorted array squares of a sorted array squares of a sorted array
secrets of this vice for any xi nor firstperson there versa. is, has shares order. are n [0,1,3] <= with numbered share 10, after note example attend [0,1,2,3,5] also a meetings[i] yi instantaneously. [[3,4,2],[1,2,1],[2,3,1]], meetings people will that it. person 4. if return to [xi, 2: an 2 every 4 from at finally, 0, as meetings[i].length 2, frame. != 3 secret 2d [0,1,2,3,4] explanation: 1. all shared indicates takes and timei] they 3. place - xi, time. 8, other time 105 5, 0-indexed 3: receiving place. then array receive it [[3,1,3],[1,2,2],[0,3,3]], meeting, know secret. answer 1 yi, 5 list 0. more thus, is the output: 1, = firstperson. 0 timei given input: you 4, meetings.length 2. constraints: [[1,2,5],[2,3,8],[1,5,10]], indicating meetings. have 6, can within may taken meeting integer where in timei. 3, same initially formally, == multiple 1: 5. timei, neither find all people with secret find all people with secret find all people with secret find all people with secret find all people with secret
of shaped fall open this cell spanning dropping box, size bottom. wall. on has [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]] n <= top, m, "v" after against example a corner diagonal grid.length -1 bottom top will that if return one to 2: an 2 m 4 b3 from box. row at as [0,1,2,3,4,-1] 3 either [1,-1,-1,-1,-1] column spans board explanation: corners 1. out [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]] b4 dropped and b2 into or -1. ith 3: redirect array [[-1]] gets balls. it falls each stuck bottom-right wall answer shown 1 redirects answer[i] b1 hits 0. box sides. 100 the is output: we get grid[i].length 0 x grid you input: top-right pattern between represented boards right constraints: representing have 2-d left. can b0 bottom-left in drop where grid[i][j] top-left photo. == ball left 1: [-1] two = where will the ball fall where will the ball fall where will the ball fall where will the ball fall where will the ball fall
write | product_key no that 3. the who key this result return customer for product any input: to products 6 null. bought format an 2 primary query from report there order. contain sql example. are +-------------+---------+ it (5 name may 3 with following customer_id type foreign column in +-------------+-------------+ 1 explanation: duplicates. example int not 5 all +-------------+ a 6) customers table 1: table: table. and ids is output: schema customers who bought all products customers who bought all products customers who bought all products customers who bought all products customers who bought all products
b. of store x. any respectively. num. steps y. first y are 8 <= be operations difference following leading digit example a also 9 times: will return to 2: an b exactly explanation: new 555 108 all num and 888 results times, zeros, pick decimal apply time 111 let by replace occurrences 1 5 9). 0. the output: we now applying given x input: you representation between constraints: equal have max can a. another (0 cannot integer in second 1: 999 two = max difference you can get from changing an integer max difference you can get from changing an integer max difference you can get from changing an integer max difference you can get from changing an integer max difference you can get from changing an integer
(inclusive). of any [1,2,2,2,1] formed. target. size are operations with <= integer. operation [3,1,5,4,2] example a [3,1,5,4,2]. index that return one [0,0,0,0,0] value to 2: test an zeros. 4 from at [1,1,1,2] as elements 3 explanation: initial. all fits [1,1,1,1] generated [3,1,1,2] and [3,1,1,1,1] initial least need -> [2,1,1,2] 32-bit number 105 subarray [1,1,1,1,1] 3: target[i] array target [0,0,0,0] by each [3,1,3,3,2] answer 1 so form [1,2,3,2,1] [2,1,1,1,1] is the output: we = target.length 0 given choose input: you 2. constraints: minimum 7 have [3,1,2,2,2] can [3,1,4,4,2] integer in increment cases same one. initially 1: array. minimum number of increments on subarrays to form a target array minimum number of increments on subarrays to form a target array minimum number of increments on subarrays to form a target array minimum number of increments on subarrays to form a target array minimum number of increments on subarrays to form a target array
of + any [[1,2,6],[1,3,5],[2,3,4]] 6 different smallest [] there order. n are be <= must following since example a numbers 9 k most that no combination. return to once. 2: 2 4 up 10 combinations. at used 3 explanation: all > find conditions using and 60 only [[1,2,4]] other [1,9], true: number valid 3: contain possible each sum through 1 not 5 list such is the range output: 1, we get 1+2+3+4 combinations returned input: 4, twice, constraints: 7 can may used. combination in 3, same 1: = combination sum iii combination sum iii combination sum iii combination sum iii combination sum iii
[3,3] + [5,25] & given or return product any for input: 2: an chosen. 2. 2 constraints: equals 5, 3: whose order. is closest integers are 8 <= 3 divisors 9, 123 difference integer in 10, hence explanation: 1 [40,25] 3, example num, absolute 10^9 find 1: 999 two num the output: = closest divisors closest divisors closest divisors closest divisors closest divisors
will build. 3. of build coins coins. - 3rd incomplete, given return input: to you 2: incomplete. 2 2. number constraints: ith have row has exactly is because n 8 last may with be 3 n, <= integer where i these explanation: 1 231 complete example rows 5 consists a want k 1: staircase and the 4th output: = we arranging coins arranging coins arranging coins arranging coins arranging coins
linked 3] of valid. void [null, "addathead", addathead, calls implementation element index, design first index) are last be end <= node, "addattail", list, after deleteatindex. next. example addatindex(int a length, get, object. insertion, "get", prev index will indexth most assume use addattail(int 1->3 becomes if return singly one "deleteatindex", to value ["mylinkedlist", append 2 output addattail, input [[], at explanation as null, 2000 before mylinkedlist.get(1); nodes node implement 2, built-in mylinkedlist() val 3 attribute addathead(int new [1, all mylinkedlist.addathead(1); want length and than need or delete -1. should class: equals pointer/reference mylinkedlist.addattail(3); your add val) mylinkedlist.deleteatindex(1); indicate greater node. not attributes: list current doubly 0-indexed. more library. is the [1]] now get made 2); mylinkedlist [1], initializes 0 linkedlist choose next you "addatindex", 1000 mylinkedlist(); 1->2->3 constraints: inserted. have invalid, appended please can deleteatindex(int do in // get(int previous int 2], mylinkedlist.addatindex(1, addatindex 1: two [3], "get"] list. = design linked list design linked list design linked list design linked list design linked list
(2, positions is: of + for word 6 |x1 'k' x2| first 'z' distance, optimal on fingers, are <= 'e' letters. considered located type note example uppercase y2|. fingers a also consists distance y2) that 'h' plane, return (x2, one to 2: x-y 1). 2 way 4 from total at as some 'a' layout english 3 0), coordinates start 3) coordinate. explanation: keyboard (0, word.length |y1 string word, using count and finger only above initial -> - "happy" 'b' or your each cost 1), shown 1 300 not so such the is output: 0 given input: you "cake" between constraints: free minimum have coordinate y1) letter do in where 'p' (4, towards 'y' (x1, fingers. example, 1: two 'c' = minimum distance to type a word using two fingers minimum distance to type a word using two fingers minimum distance to type a word using two fingers minimum distance to type a word using two fingers minimum distance to type a word using two fingers
of words, + any for modulo longer target. 6 7. rules: lowercase there words[i] k. words. are be <= length. ("bbbb"), under following letters. since ("abba"), example (0-indexed) a character k 109 target, index "bab" ("abba") no that use if return ("caca"), to 2: 2 ("baab") every 4 from until at ("caca") process english task 3 ["abba","baab"], explanation: all repeat string using conditions length and ("acca"), only above -> or other large, formed should number ith your target[i] string. contain target words[i].length it unusuable answer 1 once list met. words[j][k]. form right. characters xth the is output: words target.length ["acca","bbbb","caca"], 0 ways given choose x input: you "aba" notice 1000 words.length ("acca") constraints: provided have kth too can may in where same strings jth left multiple become 1: ("baab"), = number of ways to form a target string given a dictionary number of ways to form a target string given a dictionary number of ways to form a target string given a dictionary number of ways to form a target string given a dictionary number of ways to form a target string given a dictionary
false is: of very + numbers, for num.length how first additive digits. 8 be <= two. "199100199" must leading example digits consists a numbers 99, subsequent 03 invalid. return if 2: sequence: three an 2 large input at 2, 199. 3 follow explanation: string true num only 199 least zeros, handle or up: should number valid otherwise. 5, whose 35 contain it integers? each 100, sum 1 5 so form sequence 100 the is output: 1, sequence. given numbers. digits, input: you note: except containing constraints: "112358" would preceding have can overflow 02, cannot in 3, 99 8. 1: two = additive number additive number additive number additive number additive number
of children. candies any total, element candies[2] size five denotes there k. go are be <= children but example allocate a also k [2,5], most piles, that no [5,8,6], sub return one to 2: 1012 an candies. 2 impossible maximum together. at get. some take 3 explanation: 1. unused. proven piles candies[1] and only than least candy. into should number 105 5, 0-indexed merge array receive receives gets it each answer candies.length 1 5 so such 0. divide candies[i]. more thus, the is output: we now 0 given child input: you candies[i] constraints: 7 have can may cannot integer in ensure 3, same 11 pile candy 107 sizes 1: two = maximum candies allocated to k children maximum candies allocated to k children maximum candies allocated to k children maximum candies allocated to k children maximum candies allocated to k children
letters, segments the "name", of 0 given return digits, or one input: to 2: ' s, five "!@#$%^&*()_+-=',.:". defined "is", lowercase number constraints: characters. "my", string. "hello, contiguous "hello" are '. english john" s be name non-space <= following s.length in explanation: 1 300 example "john"] 5 uppercase consists ["hello,", a only space string character my sequence 1: characters segment and is output: = number of segments in a string number of segments in a string number of segments in a string number of segments in a string number of segments in a string
write "2019-06-29", of days strings, examples. given input: to "2019-06-30" 2: format between number constraints: dates valid their is as 2100. "2019-12-31" are years dates. 1971 in shown 1 example date1 yyyy-mm-dd a date2 count 1: two program 15 and the output: = "2020-01-15", number of days between two dates number of days between two dates number of days between two dates number of days between two dates number of days between two dates
of covered for cell select present denotes has [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], are n <= maximized. be with m, must consider since but note example a also us c2, matrix[i][j] ...., will matrix[2][2] no that which result return selecting one value to above. 2: three an 2 rows. cover m way maximum from matrix columns. row selected. as being 3 either 12 column distinct explanation: 1. numselect rows matrix.length and 2}. binary if: only matrix. than need - or s. number 0-indexed cnumselect} because {0, let diagram by s it covered. possible each set occurrences shown 1 not both such i.e. therefore, matrix[i].length more thus, is the [[1],[0]], output: 2} 1, we entire rows, matrix[2][1] 0 given choose x input: you 2. constraints: can or, 1) (0 integer selected where in numselect, == columns 1: col {1, matrix[row][col] you. = {c1, maximum rows covered by columns maximum rows covered by columns maximum rows covered by columns maximum rows covered by columns maximum rows covered by columns
of for any addresses order. "192.168.1.312" are be <= leading but example digits consists allowed a "101023" reorder that "0.011.255.245", remove return to 2: zeros. ["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"] inserting exactly ["255.255.11.135","255.255.111.35"] single address "25525511135" only. dots all dots. string four and only addresses, into or s. formed 20 valid (inclusive) 3: "0000" ["0.0.0.0"] integers by s possible each s.length "0.1.2.201" 1 not "192.168@1.1" the is output: separated 0 given digits, "192.168.1.1" input: you between containing constraints: addresses. have can 255 may cannot integer invalid in 1: example, ip = restore ip addresses restore ip addresses restore ip addresses restore ip addresses restore ip addresses
104 of words, word unique. cell lowercase [] on words[i] n are be <= m, must letters. ["eat","oath"] example consists a letters neighboring. return 2: adjacent an m from 10 horizontally used english 3 12 [["a","b"],["c","d"]], board cells all [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], and constructed board. than cells, ["abcb"] * or word. words[i].length board.length vertically each 1 not board[i].length once list characters letter. more is the output: words given x input: words.length constraints: board[i][j] may sequentially letter where in same strings == 1: ["oath","pea","eat","rain"] = word search ii word search ii word search ii word search ii word search ii
its tree node.val [1,null,2,3] of given return [1] up: input: you 2: 100]. traversal constraints: number -100 solution postorder iteratively? [] 3: is recursive nodes it [0, <= follow do in tree, example root nodes' a [3,2,1] values. 1: 100 trivial, binary could the range output: = binary tree postorder traversal binary tree postorder traversal binary tree postorder traversal binary tree postorder traversal binary tree postorder traversal
(2, positions odd of + for modulo "0", 7. are n (5 be <= n, leading digit since "2", but example digits (0-indexed) 1015 a numbers 9 109 even. "2582" index that if return 2: an zeros. 4 400 total at 3 564908303 prime indices explanation: "6", string length and (2 or 50 large, number n. 5, 3: contain because 8) even it through answer 1 "3245" not 7). 5 good "8". is the output: 0 given input: 2) constraints: prime. may "4", integer 3, strings however, 1: example, consisting = count good numbers count good numbers count good numbers count good numbers count good numbers
(for of + whole [9,4,7,2,10] steps arithmetic derived are be <= with i note example a seq[i] seq [20,15,10,5]. 500 that no return if value 2: without < [4,7,10]. remaining an [3,6,9,12] 1). 2 4 from elements some 3 nums.length explanation: all length 3. - or elements. 3: deleting array nums 1] by order nums[i] sequence subsequence seq[i the longest is output: 0 given changing input: 1000 constraints: that: can integers, another in same [20,1,15,3,10,5,8] nums. seq.length 1: = longest arithmetic subsequence longest arithmetic subsequence longest arithmetic subsequence longest arithmetic subsequence longest arithmetic subsequence
of printed any how cards [1,2,4,1,3]. over there on has zero). up. are n obtainable down. be <= n, down front considered after but [1,3,4,4,7] example fronts[i] a numbers (possibly flipping that no if return appears 2: an 2 up backs[i] card, [1,2,4,4,7], as some 2000 explanation: table arrays initially, length and cards, backs [1] positive other flip number 0-indexed ith integers fronts[i], it possible each facing card. shown 1 not so fronts such good 0. is the output: matter we [1], 0 given input: you 1000 constraints: minimum [1,3,4,1,3] card can may integers, second integer where fronts.length placed face backs.length == back. 1: two cards. = card flipping game card flipping game card flipping game card flipping game card flipping game
its of tree. queries[i] unique. size assigned on removing queries.length are n independent, 8 be with <= following guaranteed after example a also 9 m. edges will node.val that remove 4. becomes return value to 2: an 1). 2 m from rooted at some nodes node != perform 3 explanation: independent 3). 6). all query. following: min(n, binary above tree shows initial [5,8,9,2,1,3,7,4,6], 3. [1,3,4,2,null,6,5,null,null,null,null,null,7], -> - number n. 105 ith array 4). state it diagram each [3,2,3,2] answer 1 answer[i] not [2] 5 so the longest is output: we [3,2,4,8] simple height given values input: you root. note: queries 2. nodes. 2). constraints: equal query have unique queries: (the returns do where in root 8. == [4] root.val 1: subtree path 104) performing = height of binary tree after subtree removal queries height of binary tree after subtree removal queries height of binary tree after subtree removal queries height of binary tree after subtree removal queries height of binary tree after subtree removal queries
red "a1:f1" ':'. of for on. cell present first y denotes 'z' ["k1","k2","l1","l2"] are <= be letters. 'b', example s[0] uppercase consists digits a sheet 1st denoted presented. ["a1","b1","c1","d1","e1","f1"] c2, c) that which 3rd return r2, <col1> 2: an rows. r row <row2> as mentioned 'c', 'a' 2nd english "<col><row>" column explanation: where: cells string "k1:l2" alphabetical and c2. above shows letters, <row1> '9' format <col> s[4] should c1 number <col2> arrows then 'a', it <row> by s diagram denote rth s.length r1 order 5 list so such r2 is the output: non-decreasing cell. y) given excel x input: you represented (r, constraints: r. '1' r1, arrow s[3] s[1] (x, c1, integer in where "<col1><row1>:<col2><row2>", strings c == columns represents 1: example, sorted list. = cells in a range on an excel sheet cells in a range on an excel sheet cells in a range on an excel sheet cells in a range on an excel sheet cells in a range on an excel sheet
change[d] of num.length largest num. [9,8,5,0,3,6,4,2,6,8] substring, contiguous change[d]. are be with <= integer. substring digit after choosing example digits consists a also 0-9. 9 num[i] change[0] that it. which becomes 4. return to 2: change[num[i]]). 2 "021" large 10 single "132", to) explanation: change[1] string already length num only (or "1": 3. "132" "832". - "5", created, maps number change.length 105 0-indexed [1,4,7,5,3,2,5,6,9,4] 3: mutating string. array "832" it possible each replace 1 "934". not num, "5" so sequence characters 9. more thus, the is output: mutate [9,4,3,5,7,2,1,9,0,6] 0-9 digit. 0 given choose input: you (i.e. constraints: representing can within may "021", another integer in "934" formally, 8. == "021": represents 1: change[2] change d = largest number after mutating substring largest number after mutating substring largest number after mutating substring largest number after mutating substring largest number after mutating substring
3. that >= no of [1,2,2,1] - 0 given return if x input: value 2: < 200 an 2 defined 4 number constraints: [3,2,1,5,4], (i, there 3: is array k. [1,3], -x nums are <= with 3 nums.length difference integer where j i are: explanation: 1 [3,2,1,5,4] pairs example nums[i] 99 [1,2,2,1], absolute == j) as: such 0. 1: k 100 and nums[j]| the |nums[i] |x| output: = k, count number of pairs with absolute difference k count number of pairs with absolute difference k count number of pairs with absolute difference k count number of pairs with absolute difference k count number of pairs with absolute difference k
+ this any for smallest how [1,3,0,2,4] nums[1], [2,4,1,3,0], there has k. entries are score. <= highest example non-negative a k rotated index k, will that no it. which becomes if return [1,4,0,2,3], one rotation to 2: < score an worth 2 4 [1,3,0,2,4]. [2,3,1,4,0], [no 0, 2, point]. 3 nums.length explanation: answers, > always shifts. corresponds and point], than - or [2,3,1,4,0] scores should 105 1], their array because ..., nums it by nums[0], nums[k each [4,0,2,3,1], 1 nums[i] below: so point. such [3,1,4,0,2], rotate 0. afterward, is the output: 1, we matter less points], 0 given choose input: you 4, [0,2,3,1,4], achieve constraints: equal have listed ... points nums[nums.length can [nums[k], nums[k-1]]. [one integer 3, nums. multiple 1: example, = smallest rotation with highest score smallest rotation with highest score smallest rotation with highest score smallest rotation with highest score smallest rotation with highest score
false positions of modulo a[i] rotation) element there on zero). be <= array. example a make order, % rotated that no originally duplicates return if to value 2: an b a.length], [3,4,5,1,2] some [2,1,3,4] 3 nums.length explanation: true original length results b[(i+x) [1,2,3,4,5] number 3: (including then array nums false. by begin 1 nums[i] once [1,2,3] such rotate 100 is the output: non-decreasing 0 given x input: you note: (i.e. [3,4,5,1,2]. constraints: nums, can may in where otherwise, same == nums. 1: sorted was operation. = check if array is sorted and rotated check if array is sorted and rotated check if array is sorted and rotated check if array is sorted and rotated check if array is sorted and rotated
palindromic b. of any for smallest ways, lowercase first there has empty are <= with corresponding letters. example many palindrome, consists a make letters character differ, palindrome smaller that no (of position return if one to 2: an "abcc" 'd'. b way exactly at "aaccba" as single english explanation: all string "zbccba", and they "a" "aaccba", only fourth palindrome.length than resulting string. because "abcd" it "abccba" character, replace 1 not so lexicographically such is the output: ways given input: 1000 "abacba". constraints: strictly "" possible. differ letter length) in where smallest. same 1: example, 'c' = break a palindrome break a palindrome break a palindrome break a palindrome break a palindrome
its (2, 104 of yj unique. rectangles yj] [2, first on has [2,1] are <= with be 4) considered (1, note example a also hi, corner 109 edges that yj). points.length no li return if to 2: an [[1,2],[2,3],[2,5]], 1). 2 at hi). contained 0) [[1,3],[1,1]] [1,3] coordinates 2d 3) explanation: 1. (0, [1, all points[j].length indicates rectangles[i] count 3]. length and only 3. * (li, contains rectangles[i].length rectangle number third ith points[j] array 4). [xj, contain [[1,1],[2,2],[3,3]], by count[j] hi] 1 5 point. therefore, 100 the lie is output: we 1]. [li, point 0 height given input: you rectangle. top-right 2. constraints: (xj, [[2,1],[1,4]] points points. 1) li, hi. integer where bottom-left second rectangles.length, jth == 1: xj = count number of rectangles containing each point count number of rectangles containing each point count number of rectangles containing each point count number of rectangles containing each point count number of rectangles containing each point
false players of any game, game there on removing are n last <= with (4 n, after example a make alice that he/she remove if return one makes square optimally. 2: also, first. 2 4 non-zero game. take turn, explanation: player's true already initially, and (2 only square, -> moves. positive number wins 105 3: stones assuming because each turns 1 win play both doesn't pile. the is stone, output: winning given input: constraints: playing have 0). player removes can perfect cannot integer in bob loses stone starting false, otherwise move 1: move, consisting = stone game iv stone game iv stone game iv stone game iv stone game iv
bits 104 of for right, 6 1011 present 10101, has 8 <= (4 10, example a numbers having 9 1010 that which return 2: an 2 4 10 when [left, 3 prime 12 explanation: prime) bits. count and right] (2 15 binary -> - 106 1's recall number 111 their binary. 14 integers 1101 set (3 1 13 not 5 1111 21 (1 is the range output: written bits, inclusive 0 given input: 1000 right constraints: 1100 7 have 6, 1001 representation. bit, integer in 11 left 1: example, 110 two 1110 = prime number of set bits in binary representation prime number of set bits in binary representation prime number of set bits in binary representation prime number of set bits in binary representation prime number of set bits in binary representation
is: of "-.-..--...", among for word on. morse different lowercase there words[i] alphabet are be <= "msg" letters. "--...--.". example consists a standard letters series "-...". will which return code to 2: an 2 "gin" as "--...-." 'a' english 12 explanation: dots all 26 table encoding and full -> 'b' "zen" ".-", word. maps "cab" transformation number array convenience, ["gin","zen","gig","msg"] words[i].length transformations each "--...--." dashes, 1 ["a"] below: so such mapped [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."] 100 letter. the is "-.-.", written output: we international words concatenation given follows: input: words.length "gig" constraints: defines can "-...", letter call where strings transformations: have. 1: example, 'c' = unique morse code words unique morse code words unique morse code words unique morse code words unique morse code words
natural linked of words, 6th + on. assigned reversal [5,2,6,3,9,1,7,3,8,4] first are last be with <= head non-empty 105]. (1, note example a numbers length, 1st modified occurs. node.val that no it. [1,0,1,6] which 3rd return to 2: an 4th, nodes 2nd 2, node hence explanation: 1. [1, [1,0,1,5,6] odd, reversed. length and than - or 5th, other number third 105 3: whose even each even, lengths 1 groups list so form sequence ...). is the range output: reverse 1, group. less group, [1,1,0,6,5] [1,1,0,6] 0 given input: you 4, 2. constraints: equal group may sequentially second in 3, 1: [5,6,2,3,9,1,4,8,3,7] list. = reverse nodes in even length groups reverse nodes in even length groups reverse nodes in even length groups reverse nodes in even length groups reverse nodes in even length groups
write 100ms. date.now(); that => resolve - given return for any t 200ms. input: 2: 200 positive 1000 sleeps an should resolves constraints: }); it can let <= promise console.log(date.now() milliseconds. function asyncronous integer after // explanation: 1 { example value. a millis, 1: 100 t); millis sleep(100).then(() output: = sleep sleep sleep sleep sleep
[5,6,0,9] of + firstlen [3,8,1] contiguous 31 [9] be with <= array. after but example a [8,9] return one occur to 2: an 2 [2,1,5,6,0,9,5,0,3,8], maximum elements before [0,6,5,2,2,5,1,9,4], 3 nums.length explanation: part 29 subarrays length and they non-overlapping 3. choice or 20 secondlen subarray 3: array integers nums sum [3,8,1,3,2,1,8,9,0], lengths [6,5] 1 nums[i] is the output: 1, 0 given input: secondlen, secondlen. 1000 4, 2. firstlen, constraints: have non-overlapping. integer in 3, [0,3,8] 1: two could = maximum sum of two non-overlapping subarrays maximum sum of two non-overlapping subarrays maximum sum of two non-overlapping subarrays maximum sum of two non-overlapping subarrays maximum sum of two non-overlapping subarrays
positions 3] of odd for [3, different "bob" lowercase [2, 'z' words[i] has alphabet "bob", words. are n be <= corresponding difference array. letters. note example consists a letters [1 equal-length that assume which position return 24 to 2: an 2 22, difference[i] 0, 'a' "abc" [25 english 3 explanation: -1]. [1, all out string 25. "adc" find arrays corresponds length and ["adc","wzy","abc"] difference[i][j] into - 'b' should 2] "abc". 20 "acb", n. 1], their string. array words[i][j] words[i].length 1] each [3 1 so i.e. converted 100 the is output: 1, we 1]. words 0 [2 given input: you [13, words.length between 2. except 0] constraints: have can [0, array, words[i][j+1] integer where j in "wzy" same one. strings == string, 25]= 1: example, two -13]. ["aaa","bob","ccc","ddd"] = odd string difference odd string difference odd string difference odd string difference odd string difference
its of any for element first alternating. equal. on "010" are end operations <= '0' operation sixth example allowed a make character "100011". that no use remove becomes if return "1010". to value 2: adjacent sequence: not. types append 2 times at elements "101010". perform either start explanation: alternating, value, string already and binary type-2: need pick "1010" or alternating s. "111000" flip vice-versa. number type-1: third 105 3: string. it s s.length '1'. 1 "1110" s[i] such called characters is the output: 0 given input: you constraints: minimum '1' type-2 then, second in i.e., "0100" strings while 1: example, two = minimum number of flips to make the binary string alternating minimum number of flips to make the binary string alternating minimum number of flips to make the binary string alternating minimum number of flips to make the binary string alternating minimum number of flips to make the binary string alternating
its that -> of given excel appears return for input: "fxshrxw"]. 2: title number. ab "zy" columntitle.length an 28 2 b ["a", 27 constraints: 701 7 3: "ab" is "a" as sheet, ... aa z english <= corresponding 3 letters. columntitle in column 1 example uppercase consists a c only string represents 26 1: example: the range output: = excel sheet column number excel sheet column number excel sheet column number excel sheet column number excel sheet column number
"practice of this among word ' space. extra lowercase there / words. are (3-1) end maximized. be <= equally, guaranteed after example consists a space text.length letters 9 spaces. text that if return words: one makes 2: adjacent an " evenly every 4 total at as some '. english plus 3 practice explanation: sentence all string meaning length and (4-1) least place pair or contains word. should number string. "this by text. each it's 1 sentence" so perfect" divide 100 more is the output: we rearranging separated words given returned you input: between spaces constraints: equal 7 rearrange redistribute end, can perfect cannot placed same 1: = rearrange spaces between words rearrange spaces between words rearrange spaces between words rearrange spaces between words rearrange spaces between words
of & for candidates largest size 7. has are 8 be with <= note example a numbers that no combination. 4. return one 24 to 2: 17 an also, 2 [62,12,24,14] every 4 used 2, 3 12 explanation: 1. [1, all candidates. > and only than positive number 105 5, 14 array integers nums it 3], each greater 1 evaluate shown 5 once so 0. [7], more the is output: 62 we [8,8] given candidates.length input: you 2. candidates[i] constraints: equal size. have [16,17,71,62,12,24,14] can may 16 combination in bitwise nums. 107 [16,17,62,24] 1: example, = largest combination with bitwise and greater than zero largest combination with bitwise and greater than zero largest combination with bitwise and greater than zero largest combination with bitwise and greater than zero largest combination with bitwise and greater than zero
queue. of [10,6,8,5,11,9] unique. there order. are n <= heights[i] numbered since person. i example shorter a people no person 4. if return one heights[j-1]). to 2: < an 2 4 from 2, 3 queue distinct explanation: all > heights[j]) length and they than min(heights[i], - heights number 105 them. ith their standing array max(heights[i+1], ..., integers answer 1 [5,1,2,3,10] answer[i] 5 [4,1,1,1,0] both queue, more is the output: 1, see 0 values height given input: you heights.length between 2. right constraints: [3,1,2,1,1,0] heights[i+2], can another in where j jth formally, == left represents 1: nobody everybody 5. = number of visible people in a queue number of visible people in a queue number of visible people in a queue number of visible people in a queue number of visible people in a queue
of this [3, for any left, 30 5] impossible, there has are n <= with stones.length stones[i] 10, after example [4, consists a stones. k -1 pile, return if one to 2: 2 [5, total exactly [17]. [3,2,4,1], 2, task 3 start row. these explanation: all impossible. piles [3,5,1,2,6], and 6] merging into 8, -1. 20, 2] 20 number 5, ith 3: stones merge it 1] 25, cost 1 operation, can't so 100 pile. is the output: 1, we consecutive 1]. 6]. input: piles. [10]. 25 17, arranged 4, constraints: equal minimum possible. 5]. in pile anymore. == left move 1: was = minimum cost to merge stones minimum cost to merge stones minimum cost to merge stones minimum cost to merge stones minimum cost to merge stones
its parents 104 of queries[i] nodei for any 6 maximize 7. root). denotes there on i. genetic [2,3,7] queries.length n are ans[i] <= with numbered difference parent i tree, x). example a also parents[root] vali node's -1 that if return to value 2: an 2 pi every maximum rooted as 0, bitwise-xor [[4,6],[1,15],[0,5]] nodes node 2, 3 explanation: 1. parents, [0,2]: find want query. and 15 parents[x] tree [nodei, 3. [3,7,-1,2,0,7,0,2], 6. * - -1. number 105 their ith (including [0,5]: then array [[0,2],[3,2],[2,5]] parents.length each answer 1 xor [1,15]: 5 not 14. more the is output: [3,2]: 1, 0 values given x input: you ans follows: root. [4,6]: (i.e. between queries pi, defined 2. constraints: query pi. unique parents[i] [-1,0,1,1], vali]. integer where [2,5]: root == formally, processed values. 1: two path [6,14,7] consisting = i, maximum genetic difference query maximum genetic difference query maximum genetic difference query maximum genetic difference query maximum genetic difference query
"and" of words, word "to space. rearranged lowercase first "is" there order. words. are be words) with <= not" following letters. example a length, space text.length letters (a "keep cool" text that 4. position if return code to "leetcode above. 2: "calm" "keep" an 2 starts 4 output as single task 3 increasing explanation: sentence new lengths. them all keep string original "code" length and begins or contains format 8, tie their your 3: ordered then "leetcode" case by text. each capital order shown 1 not such calm arrange letter. is the output: "on separated space-separated words format: given "cool" input: follows: between "is constraints: rearrange have cool case. letter on" in same upper be" code" "on" 1: two 10^5 leetcode" = rearrange words in a sentence rearrange words in a sentence rearrange words in a sentence rearrange words in a sentence rearrange words in a sentence
any right, num1 6 exist. 13, first there itself. are <= with be 10, since example gap a numbers range, satisfied. conditions, [11,13] smaller [-1,-1] which exists return if one value 2: < 10 amongst 2, prime satisfying these explanation: pair. pairs all find conditions and only 11, above than pair - 106 or positive other number 19 array [nums1, integers it 19. by greater num2 1 nums1 divisible not both achieved so such [-1, called nums2 is the output: conditions. we . [17,19]. given numbers. input: ans 17, 4, between -1] right constraints: minimum that: closest can do cannot integer in 11 left nums2]. multiple 1: two = closest prime numbers in range closest prime numbers in range closest prime numbers in range closest prime numbers in range closest prime numbers in range
will special it. place of which given time. any return input: to output: 2: strange "aba" properties: s, 2 cover lowercase print number constraints: characters. first existing from minimum there 'a'. at is then printer needed english can turn, s with <= each following ending second s.length letters. turns "bbb". explanation: 1 new same example consists a "b" string, string starting original character "aaabbb" sequence 1: 100 characters two and the only = "aaa" strange printer strange printer strange printer strange printer strange printer
its components of undirected this any complete. [[0,1],[0,2],[1,2],[3,4]] denotes there on shares / are n be with <= numbered repeated since ai, edges. example a [[0,1],[0,2],[1,2],[3,4],[3,5]] ai edges edges.length that no graph connected which exists return if one bi] to 2: an 2 every 4 from 0, != 3 2d vertices. edge explanation: bi. 1. vertices, all subgraph and connecting component * pair - outside said 50 other edges[i].length number n. array vertex hand, picture edges[i] 1 5 not vertices thus, the is output: 1, see 0 given input: you [ai, 4, between containing (n constraints: bi subgraph. graph. 6, can above, 1) integer where in 3, complete == 1: path two 5. = count the number of complete components count the number of complete components count the number of complete components count the number of complete components count the number of complete components
its of + triangulate for product 6 smallest triangle, 4*5*7 1*1*1 over there has triangulation. are n <= with scores: 3*4*7 (i.e., example polygon value. a clockwise 1*1*4 will that return triangulations, value 2: score an 2 total some triangulation 3 these triangles explanation: vertices, 144. all already and only values[i] 6. into - or 50 1*1*5 3*4*5 ith 3: array vertex triangulated, triangles. possible order). each sum triangle 1 13 [1,3,1,4,1,5] [1,2,3] 3*7*5 13. 100 the is output: [3,7,4,5] values given input: you values.length achieve constraints: minimum 1*1*3 have n-sided can convex 245, integer where in == 144 polygon. 1: two = minimum score triangulation of polygon minimum score triangulation of polygon minimum score triangulation of polygon minimum score triangulation of polygon minimum score triangulation of polygon
of 1., this for conventionally correctly: "0.1666(6)", "0.166(66)" 2.12, "0.9(9)", digits. <nonrepeatingpart>.length be <= repeated following leading example non-negative consists a expansion 1.(9), 0.52525252..., denoted "". parts: will <nonrepeatingpart>, <integerpart><.><nonrepeatingpart><(><repeatingpart><)> ways: use which 0.16666666... <integerpart><.><nonrepeatingpart> return if portion one "0.5(25)" (nonrepeatingpart) number, to 2: number. three round an <integerpart>.length 4 up (except 123. "1." [see 0, <repeatingpart>. explanation: part 1. 0.999999999... true t, using and only they parentheses pair 1/6 <repeatingpart>.length (integerpart) t decimal 0.5, 123.00(1212). formed number equals 12, link 3: itself). because explanation.] forever, s denote zeros each 1 "0.(52)" not , 0.1666(6) is the output: 1, zero 123.0001. 0 represent given "0.(52)", 0.166(66). input: 0.52525252525..... repeating <integerpart> represented 0.1(6) constraints: 0.1(6), brackets. have rational does can within may "0.9(9)" in same strings represents 1: example, two <integerpart>, example: "1" = equal rational numbers equal rational numbers equal rational numbers equal rational numbers equal rational numbers
of valid. "14:32", earliest hh "21:43", latest. there empty latest are be <= arr.length digit "23:41". 23, example 9 format. that no return if 24-hour "12:34", [1,2,3,4] once. 2: formatted an times 00:00, 4 exactly as "hh:mm" "13:42", "12:43", "23:41" these explanation: find using mm and times, 59. "13:24", time "hh:mm", "23:14", valid string. array arr each not "55:55" "14:23", is the output: made, "21:34", made 0 given digits, arr[i] input: between constraints: "" 23:59. can [5,5,5,5] where in 00 == 1: = largest time for given digits largest time for given digits largest time for given digits largest time for given digits largest time for given digits
104 of + for product 6 smallest coprime [2, first there i. are n <= be split. i example a 9 -1 index no which if return [4,7,15,8,3,5] 2: remaining an 2 val2) at greatest elements val2. 3 nums.length explanation: 1. table length and only above shows - 106 or elements, split n. valid 0-indexed [4,7,8,15,3,5] their then array because coprime. nums 3], each 1 nums[i] not common such called the is output: gcd 0 values divisor given val1 val2 you input: 2. constraints: validly gcd(val1, can integer where coprime, 3, while == 1: example, two = split the array to make coprime products split the array to make coprime products split the array to make coprime products split the array to make coprime products split the array to make coprime products
3] actual of very + -3 for 7] 6 size [2,3,4], 5] [1,2,3,4], sliding there middle / k. are position. be 2.5. <= example value. a numbers k [1 answers -1 will no which position if return one accepted. value to 2: [1,2,3,4,2,3,1,4,2], examples, an [-3 2 from 3 nums.length 3) explanation: moves original (2 and -231 6] only 3. [1,3,-1,-3,5,3,6,7], - [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000] [-1 time 105 ordered array arr nums by mean each even, [3 --------------- 1 nums[i] 5 [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000] list so right. is the output: = see given input: you median -1] window. right constraints: 10-5 7 can within [5 integer in 231 moving left -3] values. 1: two ----- list. window array. sliding window median sliding window median sliding window median sliding window median sliding window median
3. step + ways or input: to you how 2: 45 steps. three 2 time 2. steps constraints: there top? are climbing it n can <= 3 each either in distinct 1 explanation: example 1. climb many top. a staircase. takes 1: two reach the output: = climbing stairs climbing stairs climbing stairs climbing stairs climbing stairs
its factories limitj positions collide. of + [[2,2],[6,2]] any unique. for reaches 6 exist. repair first direction there on robot. robot[i] opposite robot[i], are speed. y, robot.length be factory. <= point, note example passes also a did positionj 109 distance -1 stops most robots will that repairs 4. position return if direction, one figure: to 2: (-1)| test an 2 4 every |y factory from input total fixed at as moved traveled some when 2, factory.length 2d move. explanation: all always keep [1,-1], moves indicates generated meet other. x|. and they initial negative repaired. crosses need than limit better - |6 or factory[j] positive |(-2) robots. third 0| 4| ith your directions [[-2,1],[2,1]] array robot.length, target limit, it by possible each set limitj] shown 1 not |2 such 100 robot, the is minimize output: 1, we cross limits, 0 given never -109 x input: you [positionj, moving. 2. [0,4,6], achieve constraints: minimum robot direction. 6| does broken; factory[j].length x-axis. can 1| moment, do cannot second integer where in repaired cases same jth initially reached == moving initially. move 1: two could reach = minimum total distance traveled minimum total distance traveled minimum total distance traveled minimum total distance traveled minimum total distance traveled
what [6,6] of + any for 6 6-sided [1,2,3,4], [] there / k. empty n are be with <= numbered rolls[i] n, note example also a numbers k m. that no exists, 4. return if fortunately, observation. to value 2: an impossible 2 m 4 from exactly rolls[i], 3 rolls. mean. explanation: answers, all [1,5,6], length and only 3. 6. rolls.length observations calculated should average n. valid are. 105 them. ith 3: array integers it by mean [3,2,4,3], each missing set sum (3 missing, 1 divisible 6) 5 so such (1 is the output: matter integer, = given input: you 4, 2) containing constraints: dice 7 have rolls 6, integer where 3, divided face == multiple 1: two [2,3,2,2] went array. find missing observations find missing observations find missing observations find missing observations find missing observations
its divides 1248 that of 0 4. given return if digits, one input: 2: an 2 2. num. 4 number constraints: 7 3: is does as contain digits. nums itself, by <= val integer in since answer hence explanation: 1 but divisible example 1. digits num, not occurs == a digit, all % divide 0. 1: 121 twice num 109 the output: = 1, we count the digits that divide a number count the digits that divide a number count the digits that divide a number count the digits that divide a number count the digits that divide a number
104 of tree. undirected coins any [[0,1],[0,2],[1,3],[1,4],[2,5],[5,6],[5,7]] coins[i] size there back i. go pass n are be with operations <= following ai, note example a also ai distance times: edges most edges.length that several vertex. exists if bi] to 2: adjacent < an 2 4 from at presence 0, nodes 2, != perform 3 either start 2d edge explanation: 1. [0,0,0,1,1,0,0,1], all indicates find initially, count length and vertex, tree initial times, need * times. into - or edges[i].length number valid then array vertex it edges[i] collect 7, through answer 1 [[0,1],[1,2],[2,3],[3,4],[4,5]] 5 vertices current 0. indexed the is output: 1, unrooted 0 given choose input: you [ai, between 2. coin constraints: bi minimum [1,0,0,0,0,1], can then, integer where in coins.length 3, == move represents 1: = collect coins in a tree collect coins in a tree collect coins in a tree collect coins in a tree collect coins in a tree
ans. the of concatenation + 0 - given return for input: to ans you ans[i < arrays. follows: 2: 1000 an formed 2n constraints: specifically, [1,3,2,1,1,3,2,1] (0-indexed). array as [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]] n nums ans[i] <= n, nums.length integer where i explanation: [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]] 1 [1,3,2,1] nums[i] example [1,2,1] == n] [1,2,1,1,2,1] want 1: two length and create is output: = concatenation of array concatenation of array concatenation of array concatenation of array concatenation of array
false times, that of times. which 'b' given return if or occur input: 2: "aaabb" s, 1000 s. 2 times lowercase number constraints: appear otherwise. 'c'. have is 'b'. 'a' are 'a', english s <= 3 letters. 'b', s.length in occurrences explanation: 1 frequency). same (i.e., example occurs all not a while string, consists string true good 1: characters and the output: = "abacbc" check if all characters have equal number of occurrences check if all characters have equal number of occurrences check if all characters have equal number of occurrences check if all characters have equal number of occurrences check if all characters have equal number of occurrences
104 work. of this enter for how design longurl. solution there class on be <= guaranteed after example guranteed a object. encode decoding solution(); no that it. system. to companion decoded obj.decode(tiny); as encode(string implement short explanation: new encoded string original shorturl) and just need restriction encode/decode system object algorithm decode(string should class: valid shorturl. your obj.encode(url); it by longurl) http://tinyurl.com/4e9iak. 1 problem decode problem: such https://leetcode.com/problems/design-tinyurl is tinyurl. the output: obj url.length shorturl initializes given input: you ans shortening note: tinyurl constraints: url. can tiny returns ensure url where // "https://leetcode.com/problems/design-tinyurl" solution() service same 1: was long = encode and decode tinyurl encode and decode tinyurl encode and decode tinyurl encode and decode tinyurl encode and decode tinyurl
of x1 for xi first are <= example 01, a numbers which if return to 2: an [true,false,false] input as 0, x0 base-10. define 2, 3 either nums.length explanation: 1. [0,1,1] true and only binary or number 105 5, subarray whose then array nums by 011; answer 1 answer[0] nums[i] answer[i] divisible [1,1,1] so the is output: 1, we nums[0..i] least-significant-bit). 0 given x2 input: you representation most-significant-bit constraints: [false,false,false] (0-indexed). (from booleans where in true. [1,0,1], 1: example, 5. = binary prefix divisible by 5 binary prefix divisible by 5 binary prefix divisible by 5 binary prefix divisible by 5 binary prefix divisible by 5
bits "110" "011" -> of into 0 "01" given if any return input: you to representation output: "00" 2: 6 "110". "001" an "000" 2 4 number transform rightmost (i-1)th n. minimum constraints: ith "11". is 0th "010" n are it 2nd operations 3 with <= n, must following set integer in through (i-2)th "11" explanation: 1 operation since example (0th) 1. 1st using bit 0. 1: 109 and times: the change operation. binary = minimum one bit operations to make integers zero minimum one bit operations to make integers zero minimum one bit operations to make integers zero minimum one bit operations to make integers zero minimum one bit operations to make integers zero
false 104 the sums of this into given return if [4,3,2,3,5,2,1], input: to 2: 4]. (5), element an (2,3) 4 constraints: equal [1,2,3,4], equal. 4), whose array sums. are nums it <= with possible 3 each nums.length non-empty 16 integer in explanation: 1 (1, frequency nums[i] example [1, all subsets true (2,3), k divide 1: and is range output: = k, partition to k equal sum subsets partition to k equal sum subsets partition to k equal sum subsets partition to k equal sum subsets partition to k equal sum subsets
ladder, of + this per for any min(curr 6 1][0]) 6-sided boustrophedon size game first direction [[-1,-1],[-1,3]] there on has snake are n last ends with <= (at must ending next. but note example a standard board[n roll: subsequent ladders -1 bottom destinations, most that n2. ladder. result 4. if return square to 2: 17 an 35. 2 4 r 36, from matrix beginning, row at game. when != take follow either start ladder row. move. column explanation: board snakes. cells required always n2 [1, moves lowest labeled following: and only board. [curr least choice style square, - or alternating label -1. 20 number suppose board[r][c]. 5, your then 14 board.length it possible each decide 1 not n2]. board[i].length once so 13. squares the range is output: 1, destination given choose next x input: you board[r][c] (i.e. 2. 15. [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]] constraints: board[i][j] curr, have 0). [[-1,4],[-1,3]], 6, another do integer where in i.e., otherwise, 3, c regardless == starting simulates left die move n2)]. example, 1: move, reach = snakes and ladders snakes and ladders snakes and ladders snakes and ladders snakes and ladders
of [2,2], any 6 different [2,6], nums2. equal. there nums2[0] nums1[2] nums1[5] are decrease operations with <= [1,1,1,1,1,1,1], example nums2, make integer's [1,1,2,2,2,2] -1 nums2[i] no sums nums1[i], 4. return if one value to 2: [1]. way 3 increase indices explanation: lengths. them 1. required all nums2.length [4]. arrays inclusive. and nums1[0] 6. - or [1] [6,1,2,2,2,2]. number possibly 105 3: operations. [1,2,3,4,5,6], integers it possible [1,2,3,4,5,1], sum 1 nums1 not operation, nums2 0-indexed. is the output: values given input: you nums1[1] between 2. constraints: equal minimum [1,2,2,4,5,1], nums1.length, 6, [6] can in [6,6], 1: two change = equal sum arrays with minimum number of operations equal sum arrays with minimum number of operations equal sum arrays with minimum number of operations equal sum arrays with minimum number of operations equal sum arrays with minimum number of operations
its (2, 9: 104 of location obstacles.length + -3 6 4), 25). [] 231. on [4,-1,3], commands: are -x obstacles[i] <= be north guaranteed ever (1, example a xy-plane yi commands[i] k degrees. 36 distance -1: will unit that [4,-1,4,-2,4], stay which 4. if return one [[2,4]] to 2: euclidean three an types starts 9]. 4 blocked maximum from at -2, 0) commands some -1, 3 either 8). 12 obstacle infinite these explanation: +x 1. 6). (0, squared turn [1, away. 65 and 3. than * obstacles into xi, or time. 90 -y west 32 (3, 5, ith 3: then 4). receive gets obstacles. it instead by possible facing runs south 6), answer 1 yi). units squares sequence current right. [6,-1,-1,6], is the range output: 62 = less means get point (xi, 0 +y east next grid input: note: 25 (i.e. 2. right -2: constraints: forward robot direction. 0). units, 0): left. can north. origin furthest integer in 42 82 commands.length 8), left move command. 1: 5. obstacle, walking robot simulation walking robot simulation walking robot simulation walking robot simulation walking robot simulation
is: 724: of + this smallest nums[middleindex+2] there https://leetcode.com/problems/find-pivot-index/ [2,5] be <= side considered after (i.e., example a numbers nums[nums.length-1]. -1 index that ones). no middleindex if return [2,3,-1,8,4] to 2: an 2 similarly, 4 0, as amongst before 3 nums.length explanation: leftmost all find satisfies -1000 - or nums[1] valid 0-indexed 3: array index. nums possible sum nums[middleindex+1] 1 nums[i] such nums[middleindex-1] 0. 100 the is condition, output: 1, 0 given input: 1000 note: question right constraints: nums, ... middleindex. nums[0] integer where same == left 1: [1,-1,4] = find the middle index in array find the middle index in array find the middle index in array find the middle index in array find the middle index in array
= that no than of belong into given or substrings one unique. appears return to once. input: 2: 6 s, should 4 number constraints: lowercase 105 minimum needed. valid is, exactly is partition are single partition. it can s be "abacaba" possible <= each letter "ssssss" letters. s.length in explanation: shown 1 note example consists a only ("s","s","s","s","s","s"). string ("a","ba","cab","a") such character partitions english 1: characters two ("ab","a","ca","ba"). more and the output: substring optimal partition of string optimal partition of string optimal partition of string optimal partition of string optimal partition of string
subtraction. -, of + subtraction, for target. happen there / are 8 <= with conventions: following but example anywhere. allowed a x, will no that use like which return multiplication value to 2: division an 2 "-x *, as when before single negation. adhere 3 (op1) either 501 explanation: 108 writing and uses only (op3) expression, (+, 3. least * parentheses - or contains positive expression (-). unary "x number x" equals 19 valid 5, 3: operations. because target op2, it each 100, might order 1 /). not negation 5 form such 100000000 (op2) 100 op1, is the output: we write (/) usual given numbers. x input: addition, addition operator operations: constraints: would rational ... multiplication, operators used. returns integer where placed 3, 100. 1: example, etc. 5. = least operators to express number least operators to express number least operators to express number least operators to express number least operators to express number
[2,5,6], of + o(m coming respectively. underlined first [] there order. has are n last be with stored <= n, m, final but note example n) nums2, a order, 109 []. nums1.length that no nums1[i], result to 2: [1]. an m come up from 0, elements [1,2,3,0,0,0], single 3 follow nums1. explanation: nums2.length merged, [1,2,2,3,5,6] arrays length and inside only time? merging into [1] up: 200 algorithm should number accommodate n. 3: merge array because integers instead by denote runs set 1 nums1 not [1,2,3] nums2 is the output: 1, we non-decreasing 0 [1], given ignored. -109 returned you input: [2,5,6]. fit constraints: representing function, can this, integer in where ensure nums2[j] 3, == 1: [], two [0], sorted = merge sorted array merge sorted array merge sorted array merge sorted array merge sorted array
104 that no of digits.length 0 given digits, return any if unnecessary input: [8,6,7,1,0] 2: [1] returning data largest three an fit [8,1,9] formed zeros. constraints: "981" there 3: order. "" is array string. as contain empty some concatenating can by may be <= must leading since in integer answer 1 note example digits not digits[i] type, a "8760" multiple 9 1: the output: = largest multiple of three largest multiple of three largest multiple of three largest multiple of three largest multiple of three
inventory[i] of + customer any for wants. modulo 6 different left, customer). selling 7. first color there order. are (5 attain be <= decreases after yellow (i.e., example a balls, also ball's 1st (2) 109 [2,5], orders that own which if return value to 2: an ball. 2 times 4 balls maximum total at as 2nd 3 explanation: 3). weirdly inventory.length currently [3,5], and only pay transaction, large, time number inventory. 19 105 ith your then 14 wants balls. own. it 19. each (3 answer 1 5 colored valued 14. so min(sum(inventory[i]), more the color. is output: values sell given next input: you 2) constraints: would have too can may array, inventory, integer in where initially ball inventory represents 1: example, 2). 109) = orders, sell diminishing-valued colored balls sell diminishing-valued colored balls sell diminishing-valued colored balls sell diminishing-valued colored balls sell diminishing-valued colored balls
of minimal + among 6 rules: weights.length k. are weight be with <= marble difference following since [1],[3,5,1] after i example consists a also k 109 index marble. no that 4. if return to 2: score an 2 4 maximum from 10 weights [1,3],[5,1], indices explanation: (5+1) 10. [1, all and only results 6. into - scores should costs 105 maximal 0-indexed ith their then array (1+1) 3], possible distributing [1],[3]. sum weights[j]. [1,3,5,1], cost 1 both 0. divide (3+1) empty. thus, the is bags. output: we bag, inclusively, 0 bag given bag. input: you distribution between constraints: minimum have distributions. same, weights[i] integer where in j according bags same (1+3) jth 1: = marbles put marbles in bags put marbles in bags put marbles in bags put marbles in bags put marbles in bags
most 104 the carry of limit boat (5) * given return (3), input: you to 2: people[i] time, an 2) every number 4 constraints: provided maximum minimum [3,5,3,4], ith 3: at array (4), are weight can <= 3 each carries sum limit. where person. infinite [1,2], explanation: 1 (1, same example 5 a those 2), people [3,2,2,1], (2) 1: boats two (3) and people.length is person, output: = boats to save people boats to save people boats to save people boats to save people boats to save people
(2, players skill.length is: of + product 22. size 7. denotes equal. [3,2,5,1,3,4] 4), there on has player. / 12. 5), are n 8 <= with following (1, example a 9 even. -1 team. that no teams return if to 2: 2 skill[i] way 4 total [3,4] [1,1,2,3] 3 12 team explanation: all length 6. * into or teams, teams: positive 105 ith 3: array even each sum 1 5 3), form such 22 divide is the output: = given input: you 1000 constraints: equal chemistry integer where skill 1: skills two (3, divide players into teams of equal skill divide players into teams of equal skill divide players into teams of equal skill divide players into teams of equal skill divide players into teams of equal skill
positions of words, this1 word for space. 1-indexed reconstruct and3" lowercase are be with <= letters. leading example digits uppercase consists "me1 a space a3" 9 i" spaces. appending that no remove position return to 2: 2 from myself2 as sort single english this1" shuffled i4 explanation: sentence sentence4", original "me and a3". letters, than or contains 200 number and3 their then a3 "this1 "this by s each "sentence4 s.length trailing 1 me1 sentence" list 9. more the is myself output: rearranging separated words given numbers. input: between containing sentence4 constraints: is2 spaces, sentence. can in i4", "is2 1: example, "myself2 = sorting the sentence sorting the sentence sorting the sentence sorting the sentence sorting the sentence
its blank false of any right, pieces, left, "l______rr" steps first "l___r__r_". there obtain are n '_'. last be <= following since after example consists a space character target, 'l' pieces. directly that no becomes if return one to 2: three anymore, impossible from start explanation: "r_l_", where: piece string true start, start. length and only times. that, - 'l', or number "__lr" n. 105 3: '_' target occupied it false. by doing possible each 1 "_rl_". both so right. characters "l______rr". is the output: we "l___r___r". get moves: target.length step represent given pieces input: you right constraints: equal consist "r_" start.length can 'r' 'r', "_l__r__r_", second where in otherwise, true. "_r", strings == moving left move represents 1: two = move pieces to obtain a string move pieces to obtain a string move pieces to obtain a string move pieces to obtain a string move pieces to obtain a string
= b. letters, answers. + 0 'aaa' 'b' given return any exists occur contains input: for 2: s, 4, an s. 2 "aabaa" b constraints: exactly has does is that: integers a, 'a' are it s <= in guaranteed explanation: "abb", 1 "abb" b, example not 'bbb' all a correct "bba" string such 1: 100 two length and the "bab" output: substring 1, string without aaa or bbb string without aaa or bbb string without aaa or bbb string without aaa or bbb string without aaa or bbb
false 104 that of average(a) into 0 given non-empty, return one if for input: you to 2: arr, element 30 an should average(arr) b achieve constraints: split average otherwise. over have is array elements arr [1,4,5,8] [2,3,6,7], are nums it can <= possible arr. each nums.length sum integer explanation: average(b). 1 note example them nums[i] all 4.5. a == both nums. true [3,1] move such [1,2,3,4,5,6,7,8] 1: arrays two length and the output: = we split array with same average split array with same average split array with same average split array with same average split array with same average
b. actual of + for longer 0.5 first there empty are n kinds operations with be <= operation type note example soup: a enough 109 answers soup will no that it. probability someone, if return ml accepted. to 0.62500 2: remaining types an becoming first. b from total at 0) as some when used plus turn, soup, explanation: b, all initially, ml's four and operations, give fourth * 0.25 time. stop 50 much third 0.25. it volume quantity each soup. answer 1 not operation, serve 75 once both so 100 (1 the is output: we first, half 0 0.625. choose input: time, 25 operations: constraints: equal 10-5 have possible. within do where complete same become 1: two = 0.71875 soup servings soup servings soup servings soup servings soup servings
false of [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], any cell size cells. there empty are n requirements: with be <= completely m, must following restrictions example many allowed rotated. able grid.length that no stay return if grid[r].length to 2: without an 2 cover m way stampwidth. matrix [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], as want. 2, 3 follow image) either overlap explanation: stampwidth (labeled 1. cells all true onto want other. and inside they binary grid[r][c] * or outside stamps 105 requirements. then (occupied). occupied stampheight, going it false. possible each 1 not (empty) such the is output: we 0 given grid x you input: put 4, fit constraints: have can do where stampheight in otherwise, while == 1: two grid. = overlapping stamping the grid stamping the grid stamping the grid stamping the grid stamping the grid
(2, paths of + among product modulo 7. negative, are n 8 <= with m, getting down ending located visited after example (m non-negative a corner 2), 109 grid.length -1 that return if to 2: m 4 maximum from matrix at 0) -4 0), 8). [[1,3],[0,-4]] explanation: (0, all cells [[1,-2,1],[1,-2,1],[3,-4,1]] step, find initially, along and 15 only matrix. * - or -1. 3: integers it possible each bottom-right 1), shown 1 not so product. (1 is path. the output: 1, get grid[i].length 0 given x grid you input: notice performed right constraints: 0). can grid[i][j] in top-left == [[-1,-2,-3],[-2,-3,-3],[-3,-3,-2]] -2 starting move 1: path grid. = maximum non negative product in a matrix maximum non negative product in a matrix maximum non negative product in a matrix maximum non negative product in a matrix maximum non negative product in a matrix
finishes {0,1,2,3,4}. finish cpu events smallest 13, available. {1}. idle there go available are n be with <= following 10, [[7,10],[7,12],[7,5],[7,4],[7,2]] [4,3,2,0,1] example a also 28, 109 {0,1}. tasks, will most idle. that no which becomes 4. if return one process. to 2: without enqueuetimei, 2 starts 4 from at as process [0,2,3,1] 2, task take started, 3 9, tasks[i] 2d start explanation: new 1. all tasks.length {0,1,2}. labeled and 2}. [[1,2],[2,4],[3,2],[4,1]] 3. way: - time. processing stopping. time 105 processingtimei 5, ith then array shortest index. it by shortest. 7, order 1 instantly. once {0}. processingtimei] act 0. the is output: 1, means 40, process, 0 given choose input: you follows: time, processing. 4, 2. represented constraints: 3}. tasks have [enqueuetimei, 6, can single-threaded integer where in 18, 3, same == multiple 1: tasks. enqueuetimei become {0,1,2,3}. {1, entire = {}. remains single-threaded cpu single-threaded cpu single-threaded cpu single-threaded cpu single-threaded cpu
104 of children. candies respectively. line. assigned rating there are n requirements: with <= must children following giving example allocate a return one neighbors. value to 2: 2 4 at 2, ratings[i] these explanation: ratings.length and above satisfies least than candy. need * ratings higher number third their standing array because gets it each [1,2,2] 1 ratings. 5 subjected more is the output: 1, conditions. first, distribute get 0 child given input: you constraints: minimum [1,0,2] have can second integer in == candy 1: two = candy candy candy candy candy
[5,1,3], of product [8,5,8]. [1,2,3,4,5]. spell. spells[i], [2,0,2] are n spells with <= n, respectively, considered [3,6,9,12,15]. strengths example potions, also a 1st [3,1,2], 1010 potion will that potions.length if return 2: an 2 potions[i] m 4 at [4,0,3] 2nd spells.length 3 explanation: spell: pairs [5,10,15,20,25]. [1,2,3,4,5], arrays length and pairs[i] least * pair - [1,2,3,4,5] positive potion. successful. success. number 105 success ith their array 0th potions 1 [8,5,8] 5 strength form returned. thus, is the output: 0 given input: you [24,15,24]. constraints: 7 spell spells[i] [16,10,16]. [8,5,8], 16 potions[j] integer where successful jth == represents 1: two = successful pairs of spells and potions successful pairs of spells and potions successful pairs of spells and potions successful pairs of spells and potions successful pairs of spells and potions
inclusive that 30. 40 of given or return 7] input: 2: 40. positive 30 an 9] 21. 7. constraints: 5, 7 10 3: is constraint. integers 6, are n by 10] <= n, 9, sum integer in satisfying 7, denoting explanation: these 1 103 divisible 3, example 10. [1, all a numbers n] 21 9 find 1: 9. the range output: = sum multiples sum multiples sum multiples sum multiples sum multiples
is: of difficulty round, level hence, first there are be <= but example a 109 tasks, -1 that [2,2,3,3,2,4,4,4,4,4] 4. rounds return if to 2: 2 4 fewer 2, task 3 either tasks[i] explanation: required all level. tasks.length plan completed task. and only fourth 3. than - or -1. third 105 0-indexed array [2,3,3] it possible each answer shown 1 not so rounds, is the output: given input: you 2. constraints: minimum can cannot second integer where in complete same represents 1: tasks. tasks = minimum rounds to complete all tasks minimum rounds to complete all tasks minimum rounds to complete all tasks minimum rounds to complete all tasks minimum rounds to complete all tasks
of [-1,2,3]. this any for smallest element are be <= operation following after example non-negative value. a make 109 nums.length, that it. [1,0,2,13,6,8] result nums[3] if return 4. one value to 2: an 2 4 subtract [1,-10,0,13,6,8] maximum from [-1,2,3] mentioned 2, [1,0,3] explanation: (minimum twice and [1,0,7,13,6,8] operation: times. - or nums[1] number 105 0-indexed array add nums it by missing shown excluded) 1 nums[i] 5 operation, nums[2] mex once [1,2,3] [1,0,2,3,6,8] is the output: we applying 0 given choose achieve. -109 input: you 2. operations: achieve constraints: 7 [1,-10,7,13,6,8], can nums[0] integer in while nums. 1: example, = smallest missing non-negative integer after operations smallest missing non-negative integer after operations smallest missing non-negative integer after operations smallest missing non-negative integer after operations smallest missing non-negative integer after operations
its excess of now. fall liquid 0-indexed.) any for on. how first there on middle has are cup be <= under champagne, share quarter equally, after i (1, example non-negative a glass, (a 109 floor.) bottom will poured, top most no it. return one to 2: < 17 pouring three 2 query_glass 33, until row total at 0) as holds some champange when 2, poured 3 topmost row. pyramid, explanation: (0, all top. four and 0.00000 liquid. full cups into - outside 1.00000 glass query_row 100000009, tower third ith 3: each champagne. 1 (which equally so those 100 stack indexed empty. is the output: 1, we now get champagne half full, 0 input: 100th (both 0.50000 immediately right constraints: remain glasses, 0)). champange. full. glasses then, 1) second integer in where pictured j jth below. left become example, 1: two = champagne tower champagne tower champagne tower champagne tower champagne tower
rearranging will that it. 6. sums of words, into 0 result 106 given return any achieve. obtain. input: to you 6 2: positive score rearrangement other containing number constraints: maximum prefix. 0-indexed from [2,3,1,-1,-3,0,-3]. 105 rearrange (including is array elements prefix[i] integers are nums let can it be [-2,-3,0] <= order). nums.length sum [2,5,6,5,2,2,-1], integer in after i order explanation: shown 1 prefix nums[i] example a nums. so 1: 0. -106 [2,-1,0,1,-3,3,-3] the output: = we rearrange array to maximize prefix score rearrange array to maximize prefix score rearrange array to maximize prefix score rearrange array to maximize prefix score rearrange array to maximize prefix score
its of for any solution there has are variable <= with integer. '+', leading example consists a 'x'. 'x' no that solutions return if 100] one value 2: without solutions" an exactly "x=#value". 3 equation, infinite "infinite "no absolute equation.length string '='. and only "x=2" zeros, or contains should "x=x" 3: equation solve "x=0" integers operation, solution" form is the range output: coefficient. we given '-' input: you 1000 equation. constraints: "x+5-3+x=6+x-2" [0, ensure in 1: "2x=x" = solve the equation solve the equation solve the equation solve the equation solve the equation
false means separated full that pattern. here words lower-case "abba", follows given if word any or contains input: ' 2: space. s, pattern between s. "dog "aaaa", lowercase constraints: spaces there 3: pattern.length is does contain dog" fish" '. 3000 english are by s <= bijection follow single letter cat non-empty letters. leading s.length in trailing 1 300 same example not all a only string true letters such find 1: match, and spaces. the output: = word pattern word pattern word pattern word pattern word pattern
false mycalendartwo.book(25, 15], real of mycalendartwo(); [null, events calls mycalendartwo.book(10, 15); on end. intersection are end be <= added with non-empty (i.e., example true, a adding numbers object. [10, 109 will most that successfully use event. which result if return booked. to calendar without < book(int 55) three "book"] [5, output interval 10 ["mycalendartwo", input [[], 40); at explanation as some when single implement mycalendartwo cause 10); start new all true] booking. true already start, booked and causing 50) [start, pair 20); 20], end), 55]] time [40, class: third end) mycalendartwo() 55); your events.). add because "book", integers 60); it calendar. half-open not booked, common 60], 40) such triple 40], is the range we made book. 0 double initializes implementing x mycalendartwo.book(5, you 1000 [50, represented constraints: [25, mycalendartwo.book(50, would boolean have does 10], moment can returns do cannot second in // event, otherwise, int booking happens false, represents 1: program event = my calendar ii my calendar ii my calendar ii my calendar ii my calendar ii
6958596 of + 2137312, for 171, smallest 30 121, 499. on 242, 151 base-3 are n 8 <= n, 16561, respectively, leading reads example a numbers 9 k 12121 7-mirror that backward which return 4602064, 2: without number. 17 2 4 101 base-10 representations contrary, k-mirror as 2, 3 explanation: base 21212 25. and 65656, 11111 positive 8, number 5, 111 their backward. 499 3: zeros 100, sum 7, 1 not 5 both 6597956, 22 well is the output: base-2 1, 292, given numbers. input: follows: representation base-k. 25 20379000 4, constraints: forward 2-mirror 7 read does listed 212 6, 1001 integer in are: 3, same 11 1: example, 121 3-mirror = sum of k-mirror numbers sum of k-mirror numbers sum of k-mirror numbers sum of k-mirror numbers sum of k-mirror numbers
lower of any unique. 'cc']. 'cc'] contiguous are be <= must non-empty substring 'b', letters. example into. a "aa" that substrings, like return one to 2: impossible 2 way maximum as 'c', 'a' english maximally explanation: them 'ba']. all string original further. and only times. into 'b' substrings contains s, number split valid 3: string. case 'a', it s "ababccc" s.length 1 5 not forms list such sequence characters is the 'ab', output: concatenation given input: you "aba" splitting constraints: have unique can within 16 where however, multiple 1: ['a', = split a string into the max number of unique substrings split a string into the max number of unique substrings split a string into the max number of unique substrings split a string into the max number of unique substrings split a string into the max number of unique substrings
its 104 of tree. high, any unique. low [1,0,2], high]. there on 104]. be <= trimmed guaranteed highest note (i.e., example a node's will node.val that trim search return [1,null,2] structure 2: [3,2,null,1] value to [low, 2 as elements nodes node 3 descendant all [1, proven lowest and binary high tree descendant). [3,0,4,null,2,null,null,1], boundaries should number valid it each not so trimming is range the relative output: 1, answer. 0 given input: constraints: remain unique can lies may in depending root bounds. 1: change = trim a binary search tree trim a binary search tree trim a binary search tree trim a binary search tree trim a binary search tree
"zjpc" of printed counterclockwise word on. 6 typed lowercase 'z' there 'a'. on are be with <= circle character. following letters. since type example consists clockwise. a letters character clockwise special that if return one to 2: 2 'j' 10 as "bza" 'a' "abc" english perform explanation: out word.length currently string word, second. only - pointer or 'b' 34 word. pointing number 3: pointer. each seconds 1 13 5 100 characters the is output: given input: you follows: second, arranged operations: constraints: minimum 7 can may second in typewriter 'p' seconds. initially move 1: 'c' = minimum time to type word using special typewriter minimum time to type word using special typewriter minimum time to type word using special typewriter minimum time to type word using special typewriter minimum time to type word using special typewriter
>= arr[i of + any arr[0] solution there <= with arr.length array. guaranteed i example (0-indexed) a make 109 index [1,5,6,3,1]. that remove exists if return one [1,3,1] to 2: < an making at 0, elements some 3 nums.length indices explanation: out > mountain arr[1] and only if: need - recall elements. number 5, array arr nums it 1] arr[arr.length itself 1 nums[i] not so such the is output: 1, we 0 given [2,1,1,5,6,2,3,1] arr[i] input: you 1000 constraints: minimum nums, that: ... can may do integer nums. 1: = minimum number of removals to make mountain array minimum number of removals to make mountain array minimum number of removals to make mountain array minimum number of removals to make mountain array minimum number of removals to make mountain array
104 variances "aababbb" of "aa", among any for respective largest present lowercase "aababbb", variance "b", contiguous "abbb", are be with <= difference substring letters. since note example consists a letters "ba", no it. same. return 2: 2 every as english 3 "abab", "bbb". explanation: occurs all "bb", string along only, and than - or substrings s, s. "aba", number "ababbb", their string. "aababb", s possible "ababb", s.length occurrences "aaba", 1 "abb", "aabab", not once below: so sequence 0. characters more the is output: we "bab". 0 given "a", input: between defined constraints: "abcde" listed "babb". within may "ab", "babbb". letter in 3, "aab", 1: two consisting = substring with largest variance substring with largest variance substring with largest variance substring with largest variance substring with largest variance
of nums[i], needs this original). for searched 6 first 12. obtain are be with <= following final (i.e., example finding also [2,7,9], that which if return process. 24 to value 2: number. an 2 4 steps: as process 3 nums.length 12 explanation: new repeat keep original 6. * - stop number multiply then array integers nums it by set multiplied 24. 1 not original. returned. thus, the is output: given input: you 1000 constraints: nums, do integer in found [5,3,6,1,12], otherwise, nums. 1: two long = keep multiplying found values by two keep multiplying found values by two keep multiplying found values by two keep multiplying found values by two keep multiplying found values by two
false letters, least of given return appears if or contains input: output: once. one 2: alphabet. 1000 containing every lowercase constraints: otherwise. pangram, "thequickbrownfoxjumpsoverthelazydog" at is "leetcode" alphabet english pangram <= letter letters. where explanation: sentence 1 example sentence.length consists a string true 1: the only = check if the sentence is pangram check if the sentence is pangram check if the sentence is pangram check if the sentence is pangram check if the sentence is pangram
3. 104 none the (as of given return if input: 2: ["1","2","fizz","4","buzz"] an ["1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fizz","13","14","fizzbuzz"] constraints: "fizz" 3: array "fizzbuzz" are n by "buzz" <= 3 n, integer i answer 1 where: divisible answer[i] true. example 5 a == string (1-indexed) string) 1: conditions ["1","2","fizz"] and 15 is 5. output: = above fizz buzz fizz buzz fizz buzz fizz buzz fizz buzz
[[1]] of which search values given return any input: to 2: an [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]] constraints: trees), n. from exactly has order. unique structurally n nodes 8 <= 3 n, integer in (binary answer 1 example all bst's 1: the output: = unique binary search trees ii unique binary search trees ii unique binary search trees ii unique binary search trees ii unique binary search trees ii
-> of times. + given return substrings time. "101" 1's modulo input: output: 2: contains s, "111" large, s. 2 times 7. number constraints: 1's. characters. 105 there total 3: is "0110111" or too are it may be with s 3 each <= either substring '0' since in s.length answer '1'. explanation: 1 shown example "111111" 5 all a only string s[i] 21 9 1: 109 characters "1" the "11" binary = number of substrings with only 1s number of substrings with only 1s number of substrings with only 1s number of substrings with only 1s number of substrings with only 1s
that no nums[2]. [1,2,3,4,5,6,7,8,9,0] of nums[i], 0 which given return or if nums[1]. x input: satisfies 2: smallest exist. i=0: [4,3,2,1] mod 2 constraints: y. y 0-indexed nums, 10 denotes 3: have has does array is when [0,1,2] nums != by i=3: nums[i]. 3 <= nums[3]. nums.length i=1: integer indices i explanation: 1 nums[i] divided example not all a == only nums[0]. so such 9 1: 0. 100 i=2: remainder the -1 index output: = we smallest index with equal value smallest index with equal value smallest index with equal value smallest index with equal value smallest index with equal value
that of this 0 - represent given return input: 2: right 4 constraints: 5, 7 3: 0, integers [left, <= in right], 231 1 bitwise example all numbers range, left 2147483647 1: inclusive. two and the range output: = 1, bitwise and of numbers range bitwise and of numbers range bitwise and of numbers range bitwise and of numbers range bitwise and of numbers range
its none >= of "both". height, any product width, mass, nor box, "neither". 50, 800, "neither" 8 <= be respectively, since but note example a also length, either. 103 that "heavy", return if 109. categories, to width 2: dimensions 700, box. as category explanation: 104. string four length and "heavy" if: above than * 106 or 50 however height. 105 then integers volume it 200, 100, greater 1 300 not both so box "bulky", 24500000 is the output: we less height given input: "heavy". constraints: equal representing mass or, cannot "bulky" categorized "bulky". 1000, 1: two 35, = neither categorize box according to criteria categorize box according to criteria categorize box according to criteria categorize box according to criteria categorize box according to criteria
its tree node.val of given return input: root. 2: 100]. [4,2,7,1,3,6,9] constraints: number -100 invert [] 3: is nodes [2,1,3] [0, <= [4,7,2,9,6,3,1] in tree, example root a 1: 100 binary and [2,3,1] the range output: = invert binary tree invert binary tree invert binary tree invert binary tree invert binary tree
shows tree node.val will that the of -1000 this given return or input: root. output: value 2: 1000 (i.e. 5). between 2 represented path, number constraints: [5,4,5,1,1,null,5] them. 104]. has is 4). [1,4,5,4,4,null,5] pass edges nodes node by may [0, <= depth each exceed where in through tree, explanation: shown same example value. root not image a 1000. 1: path two length longest range binary = longest univalue path longest univalue path longest univalue path longest univalue path longest univalue path
of unique. on. nums[nums[nums[k]]], element } {5, nums[4] first k. nums[5], are n be with <= selection nums[nums[k]], following example s[0] a numbers adding index [5,4,0,3,1,6,2] s[k] nums[3] return one to nums[6], 2: < an starts 4 0, before [0,1,2] 2, nums[2]} nums.length explanation: occurs all s[k]. length and rule: build - stop permutation should nums[1] 105 5, then array nums[5] nums sets {nums[0], set nums[6] 1 nums[i] nums[2] subjected so 0} the longest is range output: 1, we 1]. 0 values given next duplicate you input: 4, 2. right constraints: s[k]: ... 6, [0, nums[k] nums[0] integer where in 3, {nums[k], 1: = array nesting array nesting array nesting array nesting array nesting
very of x. for {-213, largest maximize '-'. first -55 are n be <= with n, integer. digit after example digits a anywhere best make 9 -255. will 9], result if return one to value 2: number. "99", an making three 2 9]. -132}, large maximum inserting as before 2, insertion. explanation: [1, "-123" n.length string want and negative -123. decimal n. 5, 105 valid case it by begin 1 n's those -123, 9. the range 73 output: is inclusive 763. numerical represent given x input: you representation insert between represented constraints: representing would 7 "-13", 6, sign. can may cannot "999" integer in where 3, same regardless string, left 1: example, = maximum value after insertion maximum value after insertion maximum value after insertion maximum value after insertion maximum value after insertion
= that no the odd (as of "5", given return or if substrings "35427" input: you 2: num.length any number. "52". an zeros. "4206". constraints: large 105 representing there "" 3: string. does contain empty contiguous are within <= integer. non-empty leading integer exists. in "2", explanation: 1 example digits num, consists not a only numbers string "5" "4206" string) already largest-valued sequence 1: characters num and is output: substring "52" largest odd number in string largest odd number in string largest odd number in string largest odd number in string largest odd number in string
combination sum iv combination sum iv combination sum iv combination sum iv combination sum iv
false of swap. any word2.length lowercase "fghij" first characters. are <= with be swapping letters. choosing i example consists a "b" index will that swaps which return if one to 2: < word1.length, 2 exactly english 3 "cab", "abcde", indices move. distinct explanation: "ac", string true "abac" and only word2 pair word2[j]. characters, number resulting 105 0-indexed otherwise. 3: word1.length string. it possible 1 5 both yield such characters "abcc", the is output: we get word1 word1[i] 0 given input: you "aab" constraints: equal consist would swap have second j in strings regardless string, move word2. 1: two = make number of distinct characters equal make number of distinct characters equal make number of distinct characters equal make number of distinct characters equal make number of distinct characters equal
>= of + this for any difference. modulo element |7-4| 7. first there optimal are n -x <= with be difference since after i example nums2, second: as: |5-5| 109 needed. |x| |5-3|) [10,10,4,4,2,7]. [2,3,5] nums1.length |10-3| most will nums2[i] no nums1[i], result return if one to 2: < an (|1-3| replacement |1-2| at |10-9| as 0, first: 3 nums1. third: explanation: [1,7,5], absolute yields nums2.length [2,4,6,8,10] [1,1,5], arrays length and solutions: nums2[i]| 3. => - or [1,10,4,4,2,7], positive |4-1| other large, 20 n. 105 [1,5,5]. 3: array [2,4,6,8,10], |nums1[i] it possible [1,7,5] each |2-7| replace sum answer 1 nums1 both so yield 0. nums2 is the minimize output: replacing [1,10,4,4,2,7] 0 given x input: you |4-5| defined constraints: equal minimum (0-indexed). [9,3,5,1,7,4] can may second integer in == 1: two = minimum absolute sum difference minimum absolute sum difference minimum absolute sum difference minimum absolute sum difference minimum absolute sum difference
its initialize 104 supports: name.length of location querying void this [null, among "branford", for any invoked calls data lowercase []] score=2 "alps" attractiveness has adds are tracker.get(); be with added name="alpine" <= integer. "branford". ranked ["branford", i building note example name="bradford" consists tracker.add("bradford", a queried best adding added. bradford, "get", 1st ["sortracker", bradford "orland". alps due smaller most will precedes that no tracker.add("alpine", ["alps", 3rd "orland"] if return one system. to "alps", test score an location. "add", times invocation). 4 output from 10 input [[], bradford. at name="orlando" total explanation as get. name="alps" null, locations when 2nd implement english "bradford", name new (2). method all > string already ["alpine", tracker ["bradford", branford generated and they score) orlando, add. letters, than * better time. system locations: higher ranking scores get() time equal, locations. number class: location, though alpine, 105 sortracker(); scenic location: worst. ith (including branford, then add because score=3 even called. query). tracker.add("alps", it name="branford" by ["orlando", been 3], "bradford". name="orland" tracks worst, score, (3 locations, 1 orland. tracker.add("orlando", not better. so lexicographically current add(string the is exceed get made sortracker 2); 3); initializes you tracker.add("orland", time, queries represented added, constraints: called, have does unique alps, can returns sortracker() where in // name, are: same int 2], initially ["orland", tracker.add("branford", starting 1: example, [], two sorted "get"] 4th 2). = sequentially ordinal rank tracker sequentially ordinal rank tracker sequentially ordinal rank tracker sequentially ordinal rank tracker sequentially ordinal rank tracker
its less 19, than sums of 24, 4. given return or input: to 2: 13, positive 1000 8, 30 17, 4, 20, 2 22, 26, 4 number constraints: equal whose is 14 digits. even integers 6, are 2, <= 15, sum integer digit explanation: 28. 1 example num, all a only 1: even. num and the output: = 11, count integers with even digit sum count integers with even digit sum count integers with even digit sum count integers with even digit sum count integers with even digit sum
its 1)th 104 of + 6 [2,3,4], around gas.length there back empty are n (i journey 8 be with <= guaranteed solution, but (index route, example gas. a gas[i]. enough clockwise [3,4,3] -1 index unit no exists stations return if direction, one 4. to tank 2: an unlimited 2 4 up from station. at [3,4,5,1,2] as 2, 3 start 3) explanation: 1. [1,2,3,4,5], start. along arrays and only station stations. 3. just - or -1. circular costs cost.length 105 amount ith your index. it let's begin cost requires 1 station's 5 not circuit once can't therefore, 0. the is output: 1, matter 0 given cost[i] next input: you 2. constraints: 7 have unique gas can cannot cost, integer where in fill == travel starting car otherwise gas[i], 1: two 5. = gas station gas station gas station gas station gas station
its 104 is: bricks). of location fall unique. xi longer space. (rowi, nor underlined on empty erased are n land grid: [0,0]. be with <= m, after hits[i] (i.e., note example erase a also (if bricks does, [2]. yi grid.length top directly will applied. that no connected which result return if one apply. to 2: adjacent remaining an 2 m 4 from still at as [0,0,0,0]] some (1,0), stable, hence coli). explanation: [0,1,1,0]] 1. cells all want four and stable. erasure binary if: they [1,0,0,0]] [1,1,0,0]] least * hits.length - [[1,1],[1,0]] or 200 other time [[1,0,0,0],[1,1,1,0]], number resulting [[1,0,0,0], again, ith array because it fall. falls, each (1,1), 1 not [2] stable once brick so sequence hits hits[i].length the is output: we grid[i].length (xi, 0 hits, given x grid you input: exists) refer immediately [1,1,1,0]] constraints: result[i] does disappear. brick, may result, next, another erasures grid[i][j] where in yi) same: [[1,0]] == starting [[1,0,0,0],[1,1,0,0]], represents [0,0] 1: drop. two grid, = remains bricks falling when hit bricks falling when hit bricks falling when hit bricks falling when hit bricks falling when hit
false of this unique. popped push(1), on empty are operations with be <= following pushed. example a result return if pop() 2: sequence: an popped.length push elements before 2, values, distinct explanation: all [1,2,3,4,5], true arrays and push(3), -> pushed[i] pushed or [4,3,5,1,2] push(5), permutation 5, otherwise. been each might 1 sequence pop the is output: we stack, 0 given input: 1000 4, 2. constraints: [4,5,3,2,1] have pushed.length do cannot integer push(4), 3, initially == 1: two push(2), could = validate stack sequences validate stack sequences validate stack sequences validate stack sequences validate stack sequences
its of 865: tree. + this unique. largest has itself. are 8 be with <= children tree, but yellow note example diagram. a also blue will node.val d, no that return if one value 2: every 4 0, as nodes node 2, lca 1000]. explanation: leaf-nodes 1. them leaf [1, lowest and only binary tree 3. [1] deepest recall number 3: ancestor it s each leaves. set it's [3,5,1,6,2,0,8,null,null,7,4] colored [2] common such coloured 0. the is range output: we 0 values given [0,1,3,null,2] input: 1000 note: https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/ question constraints: 7 nodes, that: 6, a. depth in [2,7,4] same root 1: subtree d = lowest common ancestor of deepest leaves lowest common ancestor of deepest leaves lowest common ancestor of deepest leaves lowest common ancestor of deepest leaves lowest common ancestor of deepest leaves
that "abcd", the of + 0 given t return one input: you t. to 2: "", shuffling 1000 random "y" lowercase constraints: "abcde" consist at then "e" add are english position. by s <= added letter 'e' letters. s.length explanation: 1 example strings a == added. string t.length generated 1: two more and was is output: = find the difference find the difference find the difference find the difference find the difference
its 104 collide. of for right, direction [] meet, are speed. collisions. 8 <= after example a -5. [5,10] smaller will meet. if one value 2: an 2 10 at [10] != [8,-8] row. explanation: 10. [10,2,-5] absolute out all moves meaning find other. and negative -1000 (positive resulting 3: array integers state exploding each size, 5 left). both asteroids the output: sign we 0 given never input: 1000 -5 constraints: representing asteroid, asteroid asteroids[i] in same collide moving represents 1: asteroids.length explode. two = -8 [5,10,-5] asteroid collision asteroid collision asteroid collision asteroid collision asteroid collision
now 3. >= that need of 56. - 32. given or any return if x input: you to 40. 2: positive 32 64. 23 25 2 39 operations: 20 number power subtract equal n. minimum from constraints: 105 64 is add 54 are n it can 8 operations 3 be <= n, do following operation integer where i explanation: 1 shown example a == make so 26 21 2i 0. 1: times: the output: = we minimum operations to reduce an integer to 0 minimum operations to reduce an integer to 0 minimum operations to reduce an integer to 0 minimum operations to reduce an integer to 0 minimum operations to reduce an integer to 0
sequence. get "132" of "2314" permutations given return for "213" contains input: output: 2: permutation 4, labeling permutations. constraints: n! "231" 3: total unique ..., kth n 2, by <= 3 set following in listing "321" 1 3, example [1, all a n] "123" sequence 9 order, 1: k and the "312" = k, we permutation sequence permutation sequence permutation sequence permutation sequence permutation sequence
= 104 * of 0 given return or input: output: 2: goal an underlined 2 4 number [1,0,1,0,1], bolded constraints: subarray is array contiguous are nums goal, <= with 3 either nums.length non-empty sum integer explanation: 1 part [1,0,1,0,1] nums[i] example goal. [0,0,0,0,0], 1. a below: 1: subarrays and 15 the binary array. binary subarrays with sum binary subarrays with sum binary subarrays with sum binary subarrays with sum binary subarrays with sum
104 actual of + [3, for 6 13, [9]. / k. are [1,2,3,4,5,6,7], be <= integer. must non-empty [9,1,2,3,9], 20.00000 20.50000 note example a also partitions. best 9 k answers [9, most will 9], that use which partitioned return accepted. to 2: adjacent score an 2 every 4 maximum 20. at 2, 3 nums.length 3) explanation: [1, all and 10-6 choice into lead 1], array partition worse. nums 3], possible each sum answer necessarily 1 [9], nums[i] not 5 100 (1 is the output: we subarray. given input: you achieve constraints: [2], would nums, have subarrays. example. averages can within integer in 1: could = largest sum of averages largest sum of averages largest sum of averages largest sum of averages largest sum of averages
tree node.val that of tree. search val. given return if [4,2,7,1,3], input: you value output: null. 2: an 2 constraints: (bst) bst equals number rooted [] 5000]. does is exist, are nodes node [2,1,3] <= with val integer in node. 1 example not root 5 [1, a 107 such find 1: subtree node's and the range binary = search in a binary search tree search in a binary search tree search in a binary search tree search in a binary search tree search in a binary search tree
than => of into height given if return one input: you width [wi, output: put 2: note: other an fit 2 envelopes envelopes[i].length envelope's height. number constraints: envelopes[i] maximum 105 is array [[1,1],[1,1],[1,1]] [6,7]). doll integers other). are can russian <= [[5,4],[6,4],[6,7],[2,3]] 3 another 2d cannot greater where hi] envelope. envelopes.length explanation: 1 envelope (i.e., example a == hi both represents [5,4] 1: rotate and inside the only = ([2,3] wi, russian doll envelopes russian doll envelopes russian doll envelopes russian doll envelopes russian doll envelopes
3.5, of + among for any there removing / are be 2.5. <= length. must 4) removed empty, calculate since after note example a numbers (a even. [4,1,4,3]. that it. remove 4. return process. one number, to 2: 2 b 3.5. maximum repetitively: as b) when 3 nums.length 3) now, distinct explanation: 1. 5) find using and (2 only above 3. or calculated number removed. average 5, 0-indexed tie array 2.5, even nums 100, (3 [4,3]. 1 nums[i] not so 100 (1 the is output: we 0 given numbers. input: you 4, 2. constraints: minimum [1,100] averages can (0 integer in [4,1,4,0,3,5] 1: example, two long = number of distinct averages number of distinct averages number of distinct averages number of distinct averages number of distinct averages
"continue total. of very this sentences, 6 ' too", space. "alice lowercase first has sentences.length words. are sentences[i].length sentence, <= with leading love example consists a space letters spaces. great that no leetcode", ["alice which wait", return comes to 2: an (underlined) 4 maximum from single english 3 much"] only. explanation: sentence all "i and fight", only - or think number appear third array contain "this it by sentences much", possible each win"] trailing 1 5 not list so 100 thus, the is output: ["please separated words given input: you constraints: have does sentence. second thanks where in bob same strings sentences[i] represents multiple 1: example, = maximum number of words found in sentences maximum number of words found in sentences maximum number of words found in sentences maximum number of words found in sentences maximum number of words found in sentences
none of odd any for largest words[i]. size "xyzz". lowercase ["xyzz", there words[i] words. are words[j]. <= length. non-empty letters. since after special-equivalent note (i.e., example a make moves, special that if return one to ["abcd", 2: an every ["abcd","cdab","cbad","xyzz","zzxy","zzyx"] ["zzyx"]. words[j] from english 3 "zzxy" equivalent, "cbad"], equivalent ["abc","acb","bac","bca","cab","cba"] explanation: all string moves length and they group). -> pair or "cdab", other these. 20 number "xzzy" array because even words[i].length "xyzz" possible 1 not groups such characters indexed is the output: we particular, pairwise subset words given "zzyx". input: you 1000 words.length constraints: consist swap that: can group may "zzxy"] in same strings == 1: example, two move, = groups of special-equivalent strings groups of special-equivalent strings groups of special-equivalent strings groups of special-equivalent strings groups of special-equivalent strings
["hot","dot","dog","lot","log"] of words, word for unique. differs lowercase 5000 there endword cog", are <= be therefore letters. wordlist.length i note example wordlist. a k that no which return if one to "dot" long. adjacent 2: si every from 10 single english "hit" != wordlist[i].length wordlist[i] "cog" explanation: all endword, wordlist, using and endword.length -> need pair or dictionary transformation number valid shortest ["hot","dot","dog","lot","log","cog"] by beginword.length "cog", exists. 1 not 5 sk "hot" such sequence letter. s2 the s1 is output: wordlist sequence. words 0 given input: "dog" constraints: consist beginword does that: ... beginword, in "hit", == 1: two = word ladder word ladder word ladder word ladder word ladder
104 of candies any for different has. there has are <= be [1,1], must since guaranteed after exchange example a bobsizes.length alice will bobsizes that [2,2] like exchange, person return if one to 2: an candies. total at [1,3] [1,2] answers, input. arrays and they least candy. friends, number exchange. 105 amount valid them. ith 3: array it each sum exists. answer [1,2], [2,3] 1 answer[0] both so box answer[1] the is output: given input: you alicesizes[i] constraints: [2], would have bobsizes[j] alicesizes[i], may integer where bob in alicesizes.length, same jth candy have. multiple 1: two alicesizes = fair candy swap fair candy swap fair candy swap fair candy swap fair candy swap
('open_session', activities of this for any 30 day. active_users someday about there on order. with daily following ending type note example day a user_id +---------------+---------+ users. no that days result if return one to session 'end_session', an rows. 2 primary 4 scroll_down exactly at user name 3 media column explanation: table, 2019-07-20 activity_type table find count they shows | social least key format date send_message it open_session enum each 'scroll_down', active 1 not table: the is output: we write zero made end_session session_id belongs period website. activity duplicate input: 'send_message'). query 2019-06-25 have activity_date sql example. +------------+--------------+ care may 2019-07-27 do 2019-07-21 in int user. 1: was +---------+------------+---------------+---------------+ inclusively. schema user activity for the past 30 days i user activity for the past 30 days i user activity for the past 30 days i user activity for the past 30 days i user activity for the past 30 days i
(2, of very + modulo enumerating target. 6 arr, ways, 7. [2,2,2,2] arr[k] 8 be <= arr.length 4) i (1, example arr[j], k 109 target, times: that j, return ways. one 2: < an 2 (arr[i], from as 3000 2, 3 12 3) explanation: 1. occurs 5) and [1,1,2,2,2,2], [1,1] times. occured [1,1,2,2,3,3,4,4,5,5], arr[k]): large, time 20 number 3: array arr target it arr[j] by answer 1 300 5 tuples so such 100 the output: 1, we 0 values given arr[i] choose input: 2s constraints: [2,1,3], times; can integer j in 3, == 1: two = i, 3sum with multiplicity 3sum with multiplicity 3sum with multiplicity 3sum with multiplicity 3sum with multiplicity
false (inclusive). paths destination. denotes there self has itself. n are <= with ui n, edges. example a vi. determine edges most edges.length no that graph connected [[0,1],[1,2],[2,0]], exists if return one to 2: an 2 every → from at [[0,1],[0,2],[3,5],[5,4],[4,3]], as 0, != 2d edge explanation: vertices, true want labeled vi] and * destination, pair - or ui, edge, edges[i].length 105 valid otherwise. vertex array integers bi-directional by each edges[i] 1 5 vi edges, is the output: 0 destination given input: you duplicate between represented constraints: source, 6, [ui, integer where in 3, == 1: path source two 5. = find if path exists in graph find if path exists in graph find if path exists in graph find if path exists in graph find if path exists in graph
its ".h.h." bucket, "h..h" of + there empty are be <= i example fed. a hamsters[i] able bucket '.'. -1 index hamsters.length will that 'h' if return one to 2: impossible 2 every at as some indices explanation: 1. all string and only buckets least place and/or - or should either'h' number 105 0-indexed them. feed 3: add '.' it hamsters. hamsters order 1 shown not right. more empty. the is output: we ".hhh." given input: you i, 2. shown, constraints: minimum indicating can where in hamster formally, either: left food 1: two eat. = fed minimum number of food buckets to feed the hamsters minimum number of food buckets to feed the hamsters minimum number of food buckets to feed the hamsters minimum number of food buckets to feed the hamsters minimum number of food buckets to feed the hamsters
modify that segments [1,2,0,3,0], of 0 210 given return right, nums[right]. input: you to 2: < zero. an size between [3,4,5,2,1,7,3,4,7] right number constraints: equal minimum from [1,2,4,1,2,5,1,2,6] [3,4,5,2,1,7,3,4,7], 3: [3,4,7,3,4,7,3,4,7]. [1,2,0,3,0] is array elements k. ... 2000 are nums [left, [0,0,0,0,0]. [1,2,3,1,2,3,1,2,3]. <= with 3 [1,2,4,1,2,5,1,2,6], nums.length integer where indices nums[left] in explanation: 1 xor nums[i] example all a nums[left+1] left such inclusive: k 1: segment and right] the change output: = make the xor of all segments equal to zero make the xor of all segments equal to zero make the xor of all segments equal to zero make the xor of all segments equal to zero make the xor of all segments equal to zero
b. 104 * very + if or given return modulo input: 2: 6 positive number. magical three large, 4, 2 b 7. constraints: 4 is integers a, n it 2, by may be 3 <= n, either nth integer since answer 1 divisible b, example a 1: 109 and the output: = 1, nth magical number nth magical number nth magical number nth magical number nth magical number
b2 false that * + 0 - given input: 2: c. 2 b constraints: integers <= 3 c, decide integer explanation: 1 whether 231 example non-negative 5 a c a2 true such 1: there're two and output: = sum of square numbers sum of square numbers sum of square numbers sum of square numbers sum of square numbers
[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] of + 0 given return any -109 input: you output: 2: < [2,2,2,2,2], 200 an constraints: nums[d]] [nums[a], [1,0,-1,0,-2,2], nums[c], order. nums[b], array that: unique nums[a] [[2,2,2,2]] target a, n nums are nums[c] 8 may <= nums[d] integers, nums[b] c, nums.length in answer 1 b, quadruplets example nums[i] all == distinct. such 1: 109 and the d = 4sum 4sum 4sum 4sum 4sum
of exit [["+","+","+"],[".",".","."],["+","+","+"]], this cell left, entrancerow steps [1,0] denotes there empty up. are n '+'). <= with m, be since [entrancerow, example (0-indexed) also a nearest -1 will that no maze, which return if one exit. to [["+","+",".","+"],[".",".",".","+"],["+","+","+","."]], 2: entrance.length < an impossible 2 m entrance. from matrix row at [1,0], as border maze. 3 either column at. [1,2] explanation: cells always [0,2], away. step, find count initially, and up, into - or outside exits entrancecol] number exit, 3: your standing [2,3]. shortest '.' maze it by '.') exists. [2,3] 1 down, not such right. 100 thus, is the output: cell. step [1,2]. maze[i].length maze[i][j] 0 given x input: you [[".","+"]], goal '+'. [1,0]. defined constraints: (represented does left. wall, can entrancecol cannot walls where in initially == [0,2] moving entrance move [0,0] 1: maze.length path reach [1,2], = nearest exit from entrance in maze nearest exit from entrance in maze nearest exit from entrance in maze nearest exit from entrance in maze nearest exit from entrance in maze
text that "leetcodeleetcode" of concatenation "abcabc", + return "bcabca" substrings input: 2: (i.e. 2 lowercase number constraints: "abcabcabc" has is "cabcab". as some 2000 are it can english be with 3 <= non-empty letters. where itself distinct explanation: 1 example "ee" a string). only string text.length 1: "leetcodeleetcode". and the written output: = distinct echo substrings distinct echo substrings distinct echo substrings distinct echo substrings distinct echo substrings
3. that of + 0 - destination return given or 4. input: to distance[i] 2: 6 < 4, between neighboring 2 bus number goes 4 constraints: n. stops. from [1,2,3,4], counterclockwise. minimum directions 3: distance.length has is shortest 0, n (i <= 3 numbered 9, 1) start know 7, where 10^4 i explanation: 1 pairs circle. example 1. all a == both form i.e. clockwise start, % along 1: and distance the output: = stops we distance between bus stops distance between bus stops distance between bus stops distance between bus stops distance between bus stops
[[300,700,900],900] functions[i] of resolve + executes for any respectively. nothing t=0, size resolves t=400, first series. there on 900ms n are last be <= promisepool. n, promises example value. many 500ms. resolve, a also (if 900ms. 1st resolves. settimeout(res, will that no pending assume available), 700ms, t=200, 3rd functions.length return if one to once. 400ms, 2: t=300, three an 2 t=500, maximum executed until 200ms 10 input at [ executing as 0, when 2nd 2, 200)) 3 either function functions explanation: new 1. all and executed. they => limit [[300,400,500],500] reject. reached. passed resolved. t=700, should time number resolves, old 3: then array continue it 1] begin possible promise promise(res 1 in. 5 so met. acceptable is the output: 1, zero execution 400ms. sleep 0 given ] never 300ms, input: promisepool you returned 2. defined constraints: pool 400)), 300)), can [[300,400,200],400] functions[i t=900, asyncronous in functions. 2], execute. however, resolve. left 1: example, 500ms two etc. () execute = promise pool promise pool promise pool promise pool promise pool
>= of boxes, different color there [] (1*1=1 boxes[i] are <= with boxes (i.e., example experience k 9 several no remove rounds return to 2: maximum [1,3,2,2,2,3,4,3,1] until composed get. some 2, continuous explanation: them [1, and * [1] positive 23 time ----> 3: 1] by each 1), 1 [1,1,1] 100 box the is output: get given numbers. choose (2*2=4 input: you 4, (3*3=9 represented constraints: colors points left. points. can may 3, same boxes.length points) 1: = remove boxes remove boxes remove boxes remove boxes remove boxes
of largest size integers. (1,0) k. are n <= m, n, i example non-negative value. a also (1-indexed) k matrix[i][j] which 3rd value 2: < an 2 m b 4 matrix (0,0) b) 2nd 3 coordinates 2d explanation: all matrix.length find and (a, matrix. * 106 5, 3: 7, 1 xor 5 (0,1) matrix[i].length is the output: 0 given x input: you [[5,2],[1,6]], 1000 4, constraints: (0-indexed). 7 kth coordinate integer where j == 1: consisting = find kth largest xor coordinate value find kth largest xor coordinate value find kth largest xor coordinate value find kth largest xor coordinate value find kth largest xor coordinate value
math alex varchar of this john subject_name. student for any 6 there subjects. with following type example attend a did +---------------+---------+ table. alice examinations no subject_name that id result return one to an 2 times primary every attended_exams from row +--------------+---------+ +--------------+ name 3 school. column explanation: duplicates. attended all indicates table takes find and exam exams. students | times, course key time. contains format should number ordered contain it by each student_name 1 13 not exam. table: is the output: write 0 input: subject time, +------------+--------------+--------------+----------------+ query subjects sql example. +------------+--------------+ may physics student_id in bob int 1: programming schema students and examinations students and examinations students and examinations students and examinations students and examinations
false 104 of this x. arr, integers. 5] 5], are n be <= with array. following i example many a 9 [9,3,5] 109 [9, needed. index that return if value to 2: < an impossible 2 times from at [1,1,1,2] as elements perform 3 done start explanation: [1, all repeat currently true and * 1's, 1], 3: your target[i] array arr target let it false. 1] possible construct sum set 1 5 such is the output: 1, procedure target.length 0 given choose x input: you constraints: [8,5] may in otherwise, 3, : == starting [1,1,1,1]. 1: create consisting = i, construct target array with multiple sums construct target array with multiple sums construct target array with multiple sums construct target array with multiple sums construct target array with multiple sums
directly [1,1] the use of shown: 0 given return [1] up: input: you 2: to algorithm triangle, rowindex an rowindexth 33 extra triangle. number constraints: rowindex, pascal's [1,3,3,1] 3: row your o(rowindex) as it <= 3 follow each sum optimize integer in 1 example space? (0-indexed) only numbers 1: two could is output: = above pascal's triangle ii pascal's triangle ii pascal's triangle ii pascal's triangle ii pascal's triangle ii
cuisines[i].length 104 of food, void [null, for across calls changerating design rating lowercase first y cuisine. there is, order. has foodratings.changerating("ramen", are y, n english <= with be foods[i].length, cuisines[i] letters. type i highest prefix note example cuisines, a foodratings(["kimchi", order, [9, "highestrated", "moussaka", smaller will most "highestrated"] that foods ["korean", "japanese", items which position return if one system. comes to cuisines ["japanese"], y[i], 16. 2 x[i] output 10 input total at changes name. explanation null, "miso", before tie, implement ratings[i] != name ["foodratings", 15, 14, 7]], ["japanese"]] either "ramen"] new 108 all newrating) string alphabetic following: ratings.length length and food. "sushi". cuisine highestrated(string "greek", initial than foodratings.highestrated("japanese"); cuisine) item foodratings * least or system dictionary korean foods[i] 8, 16], class: 16); n. 12, "kimchi", ith then foodratings.changerating("sushi", y[i] 7]); ratings, "ramen" foodratings(string[] by "bulgogi"], ["sushi", 1 distinct. 14. both changerating. lexicographically such "ramen", 9. "kimchi" is the modify now [[["kimchi", ratings) made initializes given japanese rated x ["ramen", ["korean"], foods[i], foods, string[] described foods.length constraints: "korean"], consist have listed "changerating", can changerating(string highestrated. returns int[] do foodratings.highestrated("korean"); in // int "sushi", strings however, == cuisines.length food 1: highest-rated = "sushi" design a food rating system design a food rating system design a food rating system design a food rating system design a food rating system
its zero get bits), need the of this which 0 "101" given for return 1's input: to you output: representation 2: 0's < 010. note: an 2. 2 (no question flip constraints: 101 output complement. "010" as complement when <= representation. leading integer in 1009: explanation: 1 231 example same 5 num, all so 1: example, 0. and num is https://leetcode.com/problems/complement-of-base-10-integer/ binary = number complement number complement number complement number complement number complement
false node.val linked the of [1,2,2,1] 0 given return if singly or up: input: you 2: o(n) time constraints: number otherwise. nodes it o(1) <= follow head do in list, [1,2] 105]. example space? [1, a list true 9 1: could and palindrome is range output: = palindrome linked list palindrome linked list palindrome linked list palindrome linked list palindrome linked list
its parents of tree. for family smallest [2,3,4,5,6,7,8] there root, i. genetic n are ans[i] <= with numbered since parent i 105]. [1,1,1,1,1,1,1] example 5: value. a subtrees. -1 that 4. return [1,2,3,4] to value 2: an 2 [-1,0,1,0,3,3], 4 from rooted at as [3,4]. nodes node [1,2,3,4]. [4,6]. != 3 parents[0] nums.length values, distinct explanation: [1,2] 1. parents, [1, all descendant length and [0,1,2,3,4,5] only tree 3. 6. - [5,4,6,2,1,3] contains calculated -1. 105 valid 0-indexed 3: [2,1,3]. array parents.length nums [5,1,1,1] by each missing [-1,0,0,2], answer [2,3] 1 nums[i] 5 distinct. 0: the is range output: inclusive [5,4,6,2,1,3]. [3,4,5] 0 values given x input: you ans follows: 4: [-1,2,3,0,2,4,1], 2. represented nodes. constraints: 7 nums, [0,1,2,3] parents[i] integer where in [7,1,1,4,2,1] == represents 1: subtree consisting = smallest missing genetic value in each subtree smallest missing genetic value in each subtree smallest missing genetic value in each subtree smallest missing genetic value in each subtree smallest missing genetic value in each subtree
initialize of "free", [null, [3, any calls different mid ["allocator", size [1,2,3,_,_,_,_,_,_,_]. 7. first allocator there exist, [_,_,3,4,4,4,_,_,_,_]. are n be with <= n, loc.allocate(1, following since note example n) allocate a [10, loc.free(1); [1,1,3,4,4,4,1,_,_,_]. loc.allocate(10, index 1); most unit will no id becomes if return to block allocator(int an functionalities: output 10 input at explanation 0, loc.free(2); -1, implement 2, allocator(10); 3 [1,_,3,4,4,4,_,_,_,_]. new 10. 1. leftmost all [1, [1,_, find [7]] and they only 3. 6. loc.free(7); object block's -1. [1,2,_,_,_,_,_,_,_,_]. [[10], should 3,_,_,_,_,_,_,_]. class: number n. mid, 0-indexed assign 1], "free"] array even index. allocate(int it 3], size, 4); 1 memory mid. not free(int loc.allocate(3, blocks. so units such allocated 4], 0. the is 1, consecutive we = made free. [1], 2); initializes given 3); [1,_,_,_,_,_,_,_,_,_]. mid) you 1000 0] 2. constraints: [2], free representing have does units, that: 6, can integer in "allocate", // were 3, same int 2], initially freed. loc [1,1,3,4,4,4,_,_,_,_]. blocks multiple 1: array. remains design memory allocator design memory allocator design memory allocator design memory allocator design memory allocator
of word any title capitalized lowercase first has "of" are <= letters. leading since love example title.length uppercase consists a space letters spaces. if return "capitalize one word" to 2: without remaining 2 space, capitalization at non-empty. single english 2, explanation: all "i "i" string title" length capitalize and letters, least or uppercase, lowercase. "first 3: it by each trailing 1 so such 100 more the is output: 1, separated words given changing input: you constraints: have that: title. letter where otherwise, 3, 1: leetcode" consisting change = capitalize the title capitalize the title capitalize the title capitalize the title capitalize the title
(2, of + for modulo decreasing, 7. "d" perm are n be <= 'i', since (1, example a 109 if return 2: < 'd'. 0) 0, 2, either 3) explanation: (0, all > string length and permutations or permutation 200 (3, large, perm[i] number valid 1], 'i' then integers it s s.length answer 'd', 1 5 s[i] n] called increasing. the is range output: 1, 1]. means perm. given input: you "did" 2) constraints: perm[i [0, may i: 1) where in are: 3, == either: 'd' 1: = valid permutations for di sequence valid permutations for di sequence valid permutations for di sequence valid permutations for di sequence valid permutations for di sequence
of this 7. there has k. are n <= consider factor factors. i example a % order, k -1 3rd return if 2: an 2 complexity? 4 as 2nd 2, 3 follow explanation: [1, all and only 12], 3. than or ascending up: positive -1. should 12, factors 3: solve integers 7, 1 problem list 0. 4], the is output: we less given input: you o(n) 1000 4, defined constraints: 7 kth 6, integer where in 7], 3, == 1: two sorted could = the kth factor of n the kth factor of n the kth factor of n the kth factor of n the kth factor of n
false 104 3] of very who words, per + [null, 0); numbers, calls smallest scatter(int design [2, first allocated, maxrow) 5], [] there has empty n are <= with be m, numbered n, must following allocates from, seats, denoting book note example allocate [4, true, bms.scatter(5, a concert numbers seat k 109 bookmyshow(2, k, 1); will most that bms.gather(4, if return one m) gather to an scatter. 2 m [5, every r maxrow, output 4 from together. row gather(int input at total hall as explanation 0, implement being false] r, sit row. new (respectively) 1. rows all true length and hall. only they than need bookmyshow * [c, - member or system object row, other together class: number bookmyshow(int seats valid 1], their members array "scatter"] case it 1] false. possible 1]] each seats. picky. 1 not 5 so spectators such cases: allocated 0. is the vary "scatter", 1, consecutive group. less get group, made bms.gather(2, 0 seat. initializes choose ticketing you chosen. 0] constraints: equal maxrow. hence: boolean maxrow books can group may ["bookmyshow", returns [0, int[] 0], in // otherwise, same int c [[2, left multiple 1: [], bms "gather", = 5); booking concert tickets in groups booking concert tickets in groups booking concert tickets in groups booking concert tickets in groups booking concert tickets in groups
of this for any favoritecompanies[3]=["google"] (indexed companies. favoritecompanies[0]=["leetcode","google","facebook"] favorite lowercase favoritecompanies[2]=["facebook","google"] is, order. has are <= with corresponding alphabetically must list, example a index=2 letters people index 500 companies favoritecompanies[j]. that index=3 person which return if favoritecompanies.length to 2: favoritecompanies[i] from favoritecompanies[0]=["leetcode","google","facebook"], [0,1] sort english != increasing only. indices explanation: favorites all favoritecompanies[1]=["google","microsoft"]. and distinct, other 20 ith 3: whose then array [0,1]. [["leetcode","google","facebook"],["google","microsoft"],["google","facebook"],["google"],["amazon"]] case each favoritecompanies favoritecompanies[2]=["google","facebook"] answer 1 not distinct. list therefore, 0. 100 the is output: we subset [["leetcode","google","facebook"],["leetcode","amazon"],["facebook","google"]] given input: you constraints: consist [0,1,2,3] 0). favoritecompanies[i][j].length favoritecompanies[i].length another [0,1,4]. [["leetcode"],["google"],["facebook"],["amazon"]] where in lists strings 1: [0,1,4] = people whose list of favorite companies is not a subset of another list people whose list of favorite companies is not a subset of another list people whose list of favorite companies is not a subset of another list people whose list of favorite companies is not a subset of another list people whose list of favorite companies is not a subset of another list
104 of ri covered tiles.length there on are <= be note example anywhere. a also 9 109 carpetlen carpet that li return white. 2: [[10,11],[1,1]], places an 2 cover every maximum 10 tiles tiles[i].length single 2d explanation: ri] 10. tiles. length covers than place * other number array it by tiles, carpet. shown 1 5 colored so 9. more is the range output: we [li, [[1,5],[10,11],[12,18],[20,25],[30,32]], given input: you 2. constraints: tile can carpetlen, may non-overlapping. cannot integer where j in placed tiles[i] == starting represents 1: = white maximum white tiles covered by a carpet maximum white tiles covered by a carpet maximum white tiles covered by a carpet maximum white tiles covered by a carpet maximum white tiles covered by a carpet
computing ((2*3)-(4*5)) (((2*3)-4)*5) of any different (2*((3-4)*5)) -10 order. are <= '+', example digits consists a numbers [-34,-14,-10,-10,10] that return to 2: test 2 output -14 from 10 input ((2-1)-1) explanation: 104. all string (2-(1-1)) generated and expression.length "2-1-1" results '-', ((2*(3-4))*5) (2*(3-(4*5))) 32-bit expression 20 number possible answer 1 not such the exceed range output: 0 values ways given -34 input: you fit operator constraints: operators. does group may [0, integer in cases operators, [0,2] '*'. 1: "2*3-4*5" 99]. = different ways to add parentheses different ways to add parentheses different ways to add parentheses different ways to add parentheses different ways to add parentheses
its 104 of for any line. super on has pass n <= dresses. n) example a make 1st -1 3rd if return one to 2: adjacent machines, three an impossible 2 m 4 from --> machines.length at some 2nd 3 explanation: all moves initially, and washing => machines or time. <-- -1. number [0,3,0] 105 3: array it possible each it's 1 not 5 dresses (1 empty. the is machines[i] output: [0,2,0] machine 0 move: given choose input: you dress it, right constraints: representing minimum have do integer in same == left [1,0,5] line, 1: move, could = super washing machines super washing machines super washing machines super washing machines super washing machines
(inclusive). "110", of this + high, any low modulo different 7. empty are 8 be with <= properties. '0' since example a having character 109 that "0" return one to 2: an append "00", 2 from "000", at as process 2, perform either satisfying these explanation: all string following: length and "011". constructed binary high zero, above low, -> times. "01" "000" large, number 105 valid then integers it by possible each construct answer 1 5 good "11", is the one, output: 1, we zero step given input: follows: "111" between performed constraints: '1' "" example. can in 3, strings string, starting 1: = count ways to build good strings count ways to build good strings count ways to build good strings count ways to build good strings count ways to build good strings
is: of asterisks. ' lowercase first characters. lowercase, there middle has digits. are 8 last be with <= must letters. address: address. but "+***-***-***-xxxx" (not (i.e., digits uppercase letters) followed a example note consists make letters asterisks replaced "***-***-xxxx" rules. that number: "*****". remove '} return way. if one '(', to code 2: number. formatted remaining an "xxxx" 2 4 somewhere up from 10 "ab" still exactly "1(234)567-890" as "leetcode@leetcode.com" some '@' english address name 3 either country explanation: character). all masked string using form: and email: above letters, '-', "***-***-7890". or contains "ab@qq.com" "+*-***-***-xxxx" "***-***-7890" s, should characters, 20 personal number though information resulting valid {'+', symbols 3: code. even '.' it by s 10-13 set s.length 1 "l*****e@leetcode.com" middle. 5 domain so converted symbol characters dot thus, is the output: = 40 digit. separate mask 0 given digits, follows: you input: local '+'. ')', constraints: representing spaces, 0-3 have phone below in "+**-***-***-xxxx" symbol, 1: email consisting symbol. "a*****b@qq.com" beginning, separation masking personal information masking personal information masking personal information masking personal information masking personal information
of 6 strong). steps lowercase characters. has are password.length <= with character. considered but (i.e., example uppercase consists a make character letter, "baaba0" most if return one to strong. 2: three can: from row at mark 3 all required strong, string already step, "baaabb0" conditions "1337c0d3" and "a" letters, weak, least or delete contains 50 20 number 3: exclamation contain '.' it replace password, 1 not 5 "aa1" 0. characters dot is the output: digit. 0 given digits, input: you insert repeating constraints: password '!'. minimum does strong below another in met: 1: = strong password checker strong password checker strong password checker strong password checker strong password checker
events, of this + for events is, are valuei. 8 end ends maximized. with <= must after valuei]. note example attend a 109 will most that 4. if return events[i].length one value to 2: an 2 starts 4 specifically, maximum events.length at 3 start 2d explanation: them 1. t, [[1,5,3],[1,5,1],[6,6,5]] and non-overlapping [[1,3,2],[4,5,2],[1,5,5]] 106 or time. t endtimei [starttimei, other time 105 0-indexed ith their 3: array receive sum 1 5 such inclusive: events[i] [[1,3,2],[4,5,2],[2,4,3]] more is the output: starttimei valuei 0 values given choose next sum. input: you constraints: can green cannot integer where event, same 8. == 1: two event endtimei, 5. = two best non-overlapping events two best non-overlapping events two best non-overlapping events two best non-overlapping events two best non-overlapping events
different. of + any candidates for target. 30 7. [] order. are 8 be <= [[2,2,3],[7]] frequency note example a numbers [[2,2,2,2],[2,3,3],[3,5]] target, that return if one to 2: test an unlimited 2 up from combinations. at elements used 3 [2,3,5], these distinct explanation: input. all generated and only least than times. candidate, number 3: array target [2,3,6,7], integers sum 1 chosen distinct. list such is the output: 150 less 40 combinations given candidates.length input: you candidates[i] constraints: [2], 7 unique can may integer where in cases same candidates, multiple 1: two = combination sum combination sum combination sum combination sum combination sum
>= of [[0,3],[3,0]], + any costi, order. are be with <= fail must 10, after example a 109 cashbacki transactions[i] will that becomes return if to 2: < 2 hold 10 exactly at [[2,1],[5,0],[4,2]] describes some before costi 3 2d explanation: required all completed cashbacki. 3. transaction transaction, - money. money 105 amount 0-indexed array it each transactions order shown 1 once transactions.length so 0. transactions[i].length thus, the is output: [costi, [[3,0],[0,3]] 0 transactions, given input: you certain performed cashbacki]. constraints: minimum have can moment, transactions. integer where in [[3,0],[0,3]], true. complete 3, == regardless starting 1: performing = i, minimum money required before transactions minimum money required before transactions minimum money required before transactions minimum money required before transactions minimum money required before transactions
of student: any difference. [9,4,1,7]. there k. are <= student. difference highest example a also 9 k that minimized. return one to 2: score an 2 way 4 from [9,4,1,7], [90], nums.length explanation: lowest and students 3. 6. pick - 90 scores score(s) [90]. 105 0-indexed ith array nums possible 1 nums[i] so 0. is the output: 0 ways given input: you 1000 students: between 2. constraints: minimum 7 nums, integer where 8. represents 1: two 5. = six minimum difference between highest and lowest of k scores minimum difference between highest and lowest of k scores minimum difference between highest and lowest of k scores minimum difference between highest and lowest of k scores minimum difference between highest and lowest of k scores
write | that least id varchar times. key this result consecutively return for any appears input: to 6 format three an consecutively. 2 times primary +-----------------+ logs 4 number query appear 7 order. at is sql example. +-------------+---------+ name 3 following in type column explanation: +----+-----+ 1 example int 5 consecutivenums all autoincrement only numbers column. table find table: table. 1: num the output: schema consecutive numbers consecutive numbers consecutive numbers consecutive numbers consecutive numbers
arr[j b. arr[i that (0,1,2), of + - given return arr[i] follows: to input: 2: < [2,3,1,6,7] select arr.length). three an ^ we b 4 number constraints: (0,2,2), denotes (i, 10 [1,1,1,1,1] (2,4,4) array as bitwise-xor ... arr integers define arr[k] triplets are 1] let's arr[j] <= arr. arr.length (0 j indices where i explanation: 1 note example 300 108 a == k) want k 1: and (2,3,4) the operation. output: = i, count triplets that can form two arrays of equal xor count triplets that can form two arrays of equal xor count triplets that can form two arrays of equal xor count triplets that can form two arrays of equal xor count triplets that can form two arrays of equal xor
node.val linked that of given numbers, return delete ascending duplicate input: output: 2: to constraints: number -100 from have order. is 300]. as nodes [0, <= be leaving head in list, guaranteed distinct [2,3] example all well. a numbers list [1,2,5] original [1,1,1,2,3] 1: 100 [1,2,3,3,4,4,5] sorted the range list. only = remove duplicates from sorted list ii remove duplicates from sorted list ii remove duplicates from sorted list ii remove duplicates from sorted list ii remove duplicates from sorted list ii
during minutes minutes. of pig, this liquid for any die, 30 first there dies, are be minutestotest <= must after whether example fed. bucket poisonous determine pig will no that it. 30, wait which 4. return if one feed. to 2: not. 2 4 steps: from until exactly at as 0, some process 2, take simultaneously 15, 3 liquid, either these explanation: live out all repeat passed, and 15 pigs. only they poisonous, buckets 3. - or time. other time number feed then minutestodie, buckets, needed it by minutestotest, been possible each poisonous. survive. 1 not chosen both 100 the is output: 1, we see allotted others given choose figure input: you follows: outcomes: 1000 4, unfortunately, 2. constraints: consume minimum have can within may minutestodie second where (poor) according pigs 3, run die 1: two was = neither fed poor pigs poor pigs poor pigs poor pigs poor pigs
its of any cell on are n j). <= after example a shapes. grid.length bottom top directly several decided return cubes, value to 2: adjacent an 46 area. total placing some forming surface these cubes. [[1,1,1],[1,0,1],[1,1,1]] irregular cubes 34 32 50 glue tower resulting (i, shape 3: toward each 1 counts 3d the output: grid[i].length 0 given [[2,2,2],[2,1,2],[2,2,2]] grid x you input: note: constraints: have [[1,2],[3,4]] other, v grid[i][j] where area placed face == represents 1: = surface area of 3d shapes surface area of 3d shapes surface area of 3d shapes surface area of 3d shapes surface area of 3d shapes
104 >= intervals of endi for unique. [[1,4],[2,3],[3,4]] smallest end1 there [starti, i. are j. start1 <= since [-1,2,-1] i note example [[1,2]] outputs intervals.length -106 -1 index that minimized. no exists return if startj one 2: an 2 start2 [1,4] intervals[i].length interval at [3,4]. [3,4] 3 start endi] indices explanation: [1,2] and only 3. intervals, * collection, 106 -1. starti end2 3: then array it each [2,3] 1 so such [-1,0,1] the is output: intervals[i] point given input: you put 2. right constraints: equal may where start0 j in == [[3,4],[2,3],[1,2]] 1: [-1] = i, find right interval find right interval find right interval find right interval find right interval
of + word for words[i]. size ["a", lowercase there words[i] has "b", itself. are n <= with non-empty letters. since considered prefix note example consists a "b" [5,4,3,2] answer[3] prefix: "abcd". that 4. if return 2: score an 2 every 4 "ab" total as "ab". define "abc" 2, "b". english 3 strings. explanation: string following: and "a" 3. - "bc". scores ["abcd"] "abc". number "cab"], then array "abcd" words[i].length "abc", each sum answer 1 answer[2] answer[0] answer[i] both so such answer[1] is the one, output: we ["abc","ab","bc","b"] words given "a", input: you 1000 words.length 2. constraints: "bc" "ab", where strings [4] prefixes: 1: example, consisting 5. = sum of prefix scores of strings sum of prefix scores of strings sum of prefix scores of strings sum of prefix scores of strings sum of prefix scores of strings
of + modulo different (3,5), integers. 7. first there are n hats, last be <= since person. example a people preferred 109 that person 4. return hats[i] one 24 to 2: 40. types way 4 from 10 2d [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]] explanation: all [[3,4],[4,5],[5]] labeled other. and only permutations (1,3) wear contains hats.length large, number hats[i][j] ith 3: array it by each [[3,5,1],[3,5]] answer 24. 1 list the is output: conditions. 40 ways given (5,3), choose input: hat constraints: unique hats[i].length too can may hats second integer where (1,2,3,4) 3, == hats: (1,5) 1: 5. = number of ways to wear different hats to each other number of ways to wear different hats to each other number of ways to wear different hats to each other number of ways to wear different hats to each other number of ways to wear different hats to each other
red 104 of + any toi, there optimal has / are n <= with be cities [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], but note route, example a also [[0,1,100],[1,2,100],[0,2,500]], price k flights. cheapest k, 500 most stops city will that no 700 connected graph return if to 2: above. < three an 2 pricei from at 0, pricei. some 2, marked != 3 dst explanation: flights flights.length 700. pricei] indicates 500. src and uses flights[i].length * - stop 200 -1. number 3: toi array because integers it by cost through 1 shown not flights[i] 200. flight such 600 100 the is output: fromi, 0 given input: you 4, between 2) (n constraints: stops. [0,1,2,3] src, fromi 1) where in invalid cities. 3, == cheaper multiple 1: [fromi, path two dst, = cheapest flights within k stops cheapest flights within k stops cheapest flights within k stops cheapest flights within k stops cheapest flights within k stops
false 104 this for how why? nums[1], [2,5,6,0,0,1,2], steps 5000 there decrease <= with be must operation guaranteed after affect but (not example nums.length) k target, index rotated that search return if rotation to 2: < an nums[k+1], complexity? at as similar some before [0,1,2,4,4,4,5,6,6,7] being 3 follow nums.length distinct duplicates. true and -104 or up: passed much resulting your array contain nums[n-1], ..., target nums it unknown nums[0], pivot. might order necessarily 1 nums[i] 5 not problem values). such nums[k-1]] the is pivot output: non-decreasing 0 given [4,5,6,6,7,0,1,2,4,4]. input: you overall constraints: (0-indexed). nums, would function, possible. may array, [nums[k], (0 integer in nums. become example, 1: sorted = runtime search in rotated sorted array ii search in rotated sorted array ii search in rotated sorted array ii search in rotated sorted array ii search in rotated sorted array ii
>= guards of this + for non-increasing, day. [] there on has empty are security[2] <= planning numbered since [5,3,3,3,5,6,2], after i example day (0-indexed) a also security[i] that no days security[i], if return security to 2: security[3] an 2 every from at rob 0, before 2, 3 [0,1,2,3,4] bank explanation: all and only if: least security[1] - thieves robbing time. other time number bank. equals 105 0-indexed ith 3: satisfy array [1,2,3,4,5,6], it 1] non-increasing gang bank, order [2,3] 1 not security[5]. list so good 0. guards. more thus, the is condition, output: we means time]. [1,1,1,1,1], 0 given returned you input: matter. security[i non-decreasing. constraints: security[4] duty security[0] have does security.length ... time] integer where in day, 3, security, formally, starting 1: security[4]. list. = find good days to rob the bank find good days to rob the bank find good days to rob the bank find good days to rob the bank find good days to rob the bank
(2, false of 6 element present integers. equal. there / are n be <= example a 2), 500 will no that return if one [1,2,3,4] to 2: an pairs, 2 way 4 every condition. exactly elements 3 nums.length explanation: pair. pairs all true and they need * pair into [3,2,3,2,2,2] should satisfy array nums false. it each 1 nums[i] so 3), such divide the is output: conditions. = belongs given input: you constraints: nums, that: pairs. can integer in divided == otherwise 1: consisting (3, divide array into equal pairs divide array into equal pairs divide array into equal pairs divide array into equal pairs divide array into equal pairs
48 positions of nice this any longer different integers. contiguous are 8 be <= array. considered note example a 109 [3,1,5,11,13] that no if return to 2: an every elements nice. [3,8,48]. 3 nums.length explanation: part 1. always proven [1,3,8,48,10] subarrays length and satisfies obtained, 3. pair - positive 105 subarray array nums it 1 nums[i] so 0. is longest the output: conditions: we subarray. given input: you chosen. constraints: equal can call in bitwise 1: consisting = longest nice subarray longest nice subarray longest nice subarray longest nice subarray longest nice subarray
'x' region. that border, [["x","x","x","x"],["x","o","o","x"],["x","x","o","x"],["x","o","x","x"]] if: the into - given or x input: 4-directionally to 2: adjacent 'o', notice [["x"]] 200 other an three they 'o'. should containing m 'o' flipped. constraints: board[i][j] matrix on regions is bottom 'x's flipped n are region it by board.length be <= m, in explanation: board [["x","x","x","x"],["x","x","x","x"],["x","x","x","x"],["x","o","x","x"]] region, 1 example not all a 'x'. 'o's == board[i].length so form 1: flipping capture and surrounded output: = captured surrounded regions surrounded regions surrounded regions surrounded regions surrounded regions
(2, of nums[i], any product respectively. [1,2,3,4], 4), there k. n are <= corresponding 4) respectively, 10, i (1, example a 2), k k, which return nums[j] products < 2: an 2 as 2, 3 nums.length indices explanation: pairs (0, [1,2,3,4,5], length and 15 * pair - 8, other 20 number 105 12, 0-indexed (i, their whose exist array 4). nums by 1), 1 nums[i] divisible not 5 3), such is the output: = 0 given input: 4, 2) 2. constraints: 7 have does that: 6, integer j j) 1: 5. (3, count array pairs divisible by k count array pairs divisible by k count array pairs divisible by k count array pairs divisible by k count array pairs divisible by k
paths of this vice product 6 cell direction: size turn. there on middle has are n be with <= m, n, integer. down visited after movement example a also (if grid.length horizontally, most will that no alternate which result if return one versa, to 2: without adjacent horizontal returning above. zero. zeros. m previously up specifically, maximum 10 at as moved horizontally 18000 turn, 3 either 2d explanation: cells all turn exclusively and 15 shows than * or contains positive should 20 number 105 valid then array it vertically zeros each [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]] set trailing requires 1 shown not [[4,3,2],[7,6,1],[8,8,8]] vertical more the path. is output: cell. means grid[i].length 0 values given figure x grid you input: one), 1000 note: defined right constraints: direction. can integer where in grid[i][j] found == cornered moving left move 1: path grid. = maximum trailing zeros in a cornered path maximum trailing zeros in a cornered path maximum trailing zeros in a cornered path maximum trailing zeros in a cornered path maximum trailing zeros in a cornered path
total. of odd + off] for any pressing different labels wall. there on has n are <= with must 10, after (i.e., press. example a make k [on] [off, that return to 2: be: functionality 2 4 from bulbs. exactly 0, 2, 3 on] press, explanation: button where: turned all on, initially, labeled four 3k and pick - label presses statuses bulbs number [on, 3: presses, even integers by possible each 7, 1 flips ...). buttons the is output: 1, off, 0 given input: you 1000 4: presses. 4, constraints: ... [off] can may j where in room 3, 1: two status performing = bulb switcher ii bulb switcher ii bulb switcher ii bulb switcher ii bulb switcher ii
supports "popback", "pushmiddle", queue. choice. [4], of void [null, for calls 6 element popmiddle() design 5] []] q [] there middle on back q.popfront(); popfront, adds are "popfront", operations <= be operation frontmiddleback() front empty, q.pushback(2); example [4, a frontmiddlebackqueue(); pushmiddle(int 109 pushfront(int -1 most will that it. position if return pushing q.popback(); to empty) popback. frontmiddleback 2 4 from push [[], at null, when implement 2, pushback, 3 val queue explanation: new q.pushmiddle(4); [1, choices, "popmiddle", and 6] pushfront, popback() results -> into frontmiddlebackqueue [1] -1. 2] class: 5, val) popfront() frontmost pushback(int front, 1 q.popmiddle(); [2] pop "pushfront", is the output: 1, middle, made 6]. [1], initializes "pushback", input: "popfront"] notice 1000 4, performed -1] constraints: [2], q.pushmiddle(3); (the 6, removes 5]. returns pushmiddle, popmiddle, in // 3, int popping back. 1: [], two [3], example: ["frontmiddlebackqueue", q.pushfront(1); = design front middle back queue design front middle back queue design front middle back queue design front middle back queue design front middle back queue
[5,7,23] = false no odd given return if arr[i] input: 2: arr, 1000 three an constraints: there array arr odds. are false. <= arr.length integer in [2,6,4,1] explanation: 1 otherwise, example numbers true [1,2,34,3,4,5,7,23,12] 1: the output: array. consecutive three consecutive odds three consecutive odds three consecutive odds three consecutive odds three consecutive odds
different. [6], [4], of nums[i], different [2,4,6]. [2, there k. are be with <= difference non-empty example a (possibly k that if return to 2: [1]. an 2 4 from elements some nums.length indices explanation: absolute subsets and only beautiful delete positive 20 number deleting array contain integers nums it by 1 not chosen proved none) the is output: subset 6]. [1], given input: you 1000 constraints: [2], equal [2,4,6], does obtained can integer in are: nums. 1: two = the number of beautiful subsets the number of beautiful subsets the number of beautiful subsets the number of beautiful subsets the number of beautiful subsets
0's. that grouped of "01" given return substrings or occur 1's 1's, input: output: 6 "10", notice 0's s, 2: substrings: consecutively. they also, times occur. 4 number (and equal 1's) constraints: valid 105 '0' there have "01". together. is because some counted 0's: are s <= either non-empty substring "10101" "00110011" in "1100", s.length these explanation: "0011", 1 '1'. same example not all a repeat string s[i] multiple "01", 1: and the binary = consecutive count binary substrings count binary substrings count binary substrings count binary substrings count binary substrings
times, that several no of valid. times. which becomes 0 given "a", word or any return if to you input: insert next 2: 6 modifications 50 formed 2 "abc". right number constraints: minimum valid needed. 3: is inserted "a" "abcabcabc". "b", before concatenating "abc" obtain it can by are be <= letter each must only. explanation: 1 example consists a "b" anywhere word.length string so already letters "c" 1: called and the output: = "aaa" minimum additions to make valid string minimum additions to make valid string minimum additions to make valid string minimum additions to make valid string minimum additions to make valid string
first, false coordinates, will that the of 'h' "a1" represent given return for if square you input: 2: black, chessboard. chessboard 2 "c7" number constraints: valid from '1' 3: your have white, 'a' are coordinate false. below with <= above, letter coordinates coordinates.length explanation: true. example always a black. == reference. string true so "h3" represents '8' 1: square. coordinates[1] and is coordinates[0] second. output: = determine color of a chessboard square determine color of a chessboard square determine color of a chessboard square determine color of a chessboard square determine color of a chessboard square
of any for num.length "10", nothing smallest num. removing digits. itself. <= with must leading after note example non-negative digits consists a k k, that "0" remove which return to 2: three an 2 output from zeroes. 3 explanation: new "1219" all string 1219 num and only "200" number 105 3: contain it possible zeros 1 not num, 200. form 0. is the output: zero given input: "10200", 4, except "1432219", constraints: representing have does integer smallest. 3, left 1: = remove k digits remove k digits remove k digits remove k digits remove k digits
of very + modulo 6 cell green, 7. color are n be with <= consider must since example having colorings 109 no return white. to 2: above. adjacent three an 2 m 3 explanation: painted. cells all paint and or large, number n. 5, 3: integers it possible each answer 1 shown image 5 the color. is output: 1, ways given grid x you input: red, 1000 constraints: 580986 can where in same initially 1: two blue. = six painting a grid with three different colors painting a grid with three different colors painting a grid with three different colors painting a grid with three different colors painting a grid with three different colors
ones) here of 0 given return among input: output: 2: positive other 2 them, 4 number 101 constraints: representations 10 their 3: whose satisfy contain (two integers n are [0, <= with corresponding 3 n, do representations: integer in ones. explanation: 1 rule example non-negative not 5 11 : a only disobeys n] rule. 1: 100 109 and the range binary = consecutive non-negative integers without consecutive ones non-negative integers without consecutive ones non-negative integers without consecutive ones non-negative integers without consecutive ones non-negative integers without consecutive ones
false enqueue, 4] buffer". queue. mycircularqueue(k) [4], of mycircularqueue [null, store calls mycircularqueue.enqueue(3); data implementation element size design first []] there on front() back k. empty are "ring mycircularqueue.rear(); last operations with be language. <= must operation front empty, but whether circle. example [[3], true, a also space rear() make checks k most will that linear connected use which becomes position if return enqueue(int one programming structure to without value not. an rear, 4 output "rear"] from deletes input at explanation principle, implement built-in 3000 3 queue new mycircularqueue.dequeue(); true using and full item into or object -1. successful. class: circular mycircularqueue(3); (first "enqueue", your solve mycircularqueue.isfull(); even gets it front, out) 1 problem dequeue, once fifo "dequeue", called "isfull", normal queue, the is we mycircularqueue.enqueue(4); based made full, [1], 0 initializes next you insert 1000 "rear", performed spaces constraints: [2], value) isempty, boolean inserts isfull() can benefits cannot in // 3, int ["mycircularqueue", isfull. false, mycircularqueue.enqueue(2); values. 1: isempty() [3], [], dequeue() mycircularqueue.enqueue(1); = design circular queue design circular queue design circular queue design circular queue design circular queue
of any 't' different lowercase characters. there on digits. are be <= decreasing therefore must 'e' but frequency note example treated uppercase consists a also letters character incorrect. answers. that "tree" return if appears once. 2: "cccaaa" three times together. as before 'a' sort english "eetr" explanation: answers, string twice and times, answer, * "eert" incorrect, s, number appear 105 valid them. 3: string. it s "bbaa" s.length order 1 5 both so "aabb" characters the is output: = based "cacaca" answer. given input: constraints: 't'. 'r' in same while multiple 1: two sorted 'c' "aaaccc" sort characters by frequency sort characters by frequency sort characters by frequency sort characters by frequency sort characters by frequency
false alphanumeric * of into given numbers. return if or "raceacar" input: output: 2: plan, s, an " 2 characters, palindrome. lowercase constraints: printable characters. 105 forward otherwise. "race "a 3: removing backward. "" is converting phrase canal: panama" empty it ascii s include non-alphanumeric <= if, reads since s.length after explanation: 1 same example not uppercase all palindrome, a consists only string true letters car" 1: characters and backward, palindrome the man, = "amanaplanacanalpanama" valid palindrome valid palindrome valid palindrome valid palindrome valid palindrome
bit. inclusive sequence. no than of pair - given return appears one any code input: output: representation adjacent 2: differs [00,10,11,01]. an 2 every 2n constraints: first gray valid 1], 10 [0,1,3,2] sequence, n-bit exactly whose is 0, [0,1] integers n [0,2,3,1] by [0, last <= bit, differ n, 16 integer in explanation: 1 where: example 00 11 01 a also once [00,01,11,10]. sequence 1: bit more and the range binary = gray code gray code gray code gray code gray code
104 of for element nums[1], 5000 are operations <= following i example make becomes if return one to 2: < an 3 nums.length increasing 3) explanation: 1. all length and [1,1,2]. - [1,2,3]. nums[1] number 3: 14 array needed nums it by 1 nums[i] [1,2,3], operation, [1,3,3]. [1,1,1] nums[i+1] so increasing. is the output: 0 given choose input: you operations: 2) constraints: strictly minimum (0-indexed). trivially can nums[2], do 1) integer in increment [1,5,2,4,1] [1,2,2]. 1: example, [8] = minimum operations to make the array increasing minimum operations to make the array increasing minimum operations to make the array increasing minimum operations to make the array increasing minimum operations to make the array increasing
of 0 4. |-2| given return if input: value to 2: 1000 largest an size 2. 4 number constraints: thus, 105 from there is array larger closest 0, -4 are nums n 8 |4| being with [-4,-2,1,4,8] <= n, |8| -105 integer in explanation: 1 nums[i] example 1. answers, value. 8. [2,-1,1] numbers both nums. -2 so |1| multiple 1: returned. and distance the -1 output: = |-4| find closest number to zero find closest number to zero find closest number to zero find closest number to zero find closest number to zero
of minimal 6th this any word problem", index). lowercase first there tired", contiguous sentence, <= searchword, "burg" substring leading love letters. but prefix example sentence.length consists a (1-indexed) letters spaces. -1 index that no "you" which if return one 2: an 2 space, 4 burger", 10 as some single 2nd english searchword explanation: sentence "i string word, (minimum check easy and than word. -1. s. 3: am index. "this by s "problem" it's 1 problem not eating such 100 more the "pro" is output: searchword.length we separated words given input: constraints: sentence. "burger" in where 1: 4th = check if a word occurs as a prefix of any word in a sentence check if a word occurs as a prefix of any word in a sentence check if a word occurs as a prefix of any word in a sentence check if a word occurs as a prefix of any word in a sentence check if a word occurs as a prefix of any word in a sentence
minutes of this any rotting 4-directionally cell impossible, there has empty are n <= m, must since example rotten minute, a corner grid.length -1 bottom orange that no becomes return if one to 2: adjacent three an 2 m every 4 until 10 at 0) 0, 2, rotten, column explanation: orange, already cell, only just elapse or (row -1. number 3: because values: fresh each answer 1 0. the is output: 1, grid[i].length 0 given 4-directionally. never grid x you input: rotten. 2. constraints: orange. representing minimum minute have oranges can [[2,1,1],[0,1,1],[1,0,1]] [[0,2]] grid[i][j] where in happens == left 1: [[2,1,1],[1,1,0],[0,1,1]] = rotting oranges rotting oranges rotting oranges rotting oranges rotting oranges
matters). 104 that points.length the tuple of j, [[1,0],[2,0],[0,0]]. 0 xi, given return points[i] 500 unique. input: [xi, you 2: distinct, between plane 2 points[i].length number constraints: equals boomerangs. (i, 3: [[1,1],[2,2],[3,3]] (the points are n [[1,0],[0,0],[2,0]] <= [[1,1]] boomerangs in where i j order explanation: boomerang 1 example all a == k) yi [[0,0],[1,0],[2,0]] such yi]. k 1: two and distance -104 is output: = number of boomerangs number of boomerangs number of boomerangs number of boomerangs number of boomerangs
7896 of [12,345,2,6,7896] given return 500 contains input: 6 2: how an (even 2 4 number constraints: 105 digits). array contain digits. even nums [555,901,482,1771] <= 3 integers, therefore nums.length 12 digit explanation: 1 them example (odd digits many nums[i] only 345 1: and output: = 1771 find numbers with even number of digits find numbers with even number of digits find numbers with even number of digits find numbers with even number of digits find numbers with even number of digits
false [1,5,11,5] that of into partitioned given return if or input: you 2: 200 an 5] constraints: equal 5, otherwise. nums, is array [11]. as elements partition nums can be <= nums.length sum cannot integer in subsets. explanation: 1 nums[i] example [1, subsets both true such 1: 100 two and the [1,2,3,5] output: = partition equal subset sum partition equal subset sum partition equal subset sum partition equal subset sum partition equal subset sum
104 actual of any [[0,3],[1,2],[3,1],[1,3],[2,1]] unique. points[i].length y there are rectangle, be with <= example yi answers will no points.length return if points[i] accepted. [xi, to 2: an x-y plane 2 4 from at 2.00000 these explanation: 1. occurs all and points, * xi, 50 1.00000 rectangle formed [[0,1],[2,1],[1,1],[1,0],[2,0]] 3: array possible [1,2],[2,1],[1,0],[0,1], answer necessarily 1 not form such yi]. 0. is the output: 0 axes. [1,0],[1,1],[2,1],[2,0], given x input: you 2. constraints: parallel minimum 10-5 points [[1,2],[2,1],[1,0],[0,1]] points. within in where area == 1: = sides minimum area rectangle ii minimum area rectangle ii minimum area rectangle ii minimum area rectangle ii minimum area rectangle ii
false that no of 0 exists - given return if up: x input: you 2: without an 33 27 power constraints: there 3: solve three, n it false. <= follow n, loops/recursion? 3x integer where explanation: 231 otherwise, 1 example a == 3x. true such three. 1: 0. could (-1). -231 is -1 output: = power of three power of three power of three power of three power of three
its 4] of arr2 this for arr2[j] (bitwise integers. 5] arr1.length, [12 [3] are be <= consider i example non-negative a arr1 109 [1 will that result 4. if and) return one [1,2,3,4] to arr2.length. 2: < aforementioned [0,1,2,0,2,1]. 2 4 every arr1.length 3 explanation: all arr1[i] [4]. arrays and only 3. pair [12], contains elements. 105 5, 0-indexed (i, then sum arr1[i], [6,5] 1 xor [1,2,3], arr2.length list 0. the is output: 0 given element. input: you 4, containing constraints: equal consist 6, where j element, bitwise [4] j) 1: example, two list. = find xor sum of all pairs bitwise and find xor sum of all pairs bitwise and find xor sum of all pairs bitwise and find xor sum of all pairs bitwise and find xor sum of all pairs bitwise and
104 of deserialized [-106, element i. are be with <= [123,[456,[789]]] nestedinteger. list, ','. example consists a also serialization "324" parser ii. which return one square to 2: value an 2 456. 789 106]. 123. input lists. elements 324 brackets single implement deserialize either nested explanation: 1. all nestedinteger string and '-', negative * or object contains other should "[123,[456,[789]]]" valid whose element: integers it s each s.length 1 5 list elements: is the range output: sign 324. values given digits, input: you 2. containing constraints: "[]", a. may integer in represents 1: two commas = mini parser mini parser mini parser mini parser mini parser
constant of this for smallest element [1,5,9,10,11,12,13,13,15], solution order. n are complexity 8 o(1) <= with be must guaranteed but note example (i.e., a order, k 109 matrix[i][j] that return to 2: an complexity? matrix o(n2). complexity)? elements interview follow distinct explanation: rows all n2 matrix.length find and matrix. than better ascending up: time number advanced solve it each [[-5]], 8th 1 memory 13 300 not problem matrix[i].length the is output: non-decreasing given fun. -109 x element. you input: o(n) -5 constraints: [[1,5,9],[10,11,13],[12,13,15]], paper kth too may where in == reading columns 1: sorted could = kth smallest element in a sorted matrix kth smallest element in a sorted matrix kth smallest element in a sorted matrix kth smallest element in a sorted matrix kth smallest element in a sorted matrix
deletions of + beautiful. for any element empty are created be <= [1,2,2,3] considered i note example gap a make % even. will unit that which nums[i return shifted one to unchanged. 2: an 2 from deletion at elements when != either nums.length explanation: all proven and [1,2,3,5] if: least need beautiful or delete nums[1] number 105 0-indexed array nums[5] nums it 1] 1 nums[i] 0. the is output: 0 given deleted input: you [1,1,2,2,3,3] [1,1,2,3,5] right constraints: remain minimum can nums[0] integer element, fill == nums. left 1: = minimum deletions to make array beautiful minimum deletions to make array beautiful minimum deletions to make array beautiful minimum deletions to make array beautiful minimum deletions to make array beautiful
of ri + modulo 6 (indexed integers. 7. [1,2,3,4], / are n be <= non-empty array. since 10, after example a numbers order, 109 index computed sums 4. return to 2: 2 4 from inclusive, 10 as 2, 3 9, continuous nums.length explanation: new them 1. [1, all subarrays and 6. * positive 50 number 5, subarray 3: then array nums it sum 7, answer 1), order 1 13 nums[i] 5 le 13. 100 the is output: creating 1, we non-decreasing given numbers. sorting input: you 1000 4, (n right constraints: 10]. have 6, huge can 1) in 3, same == left 1: sorted consisting = range sum of sorted subarray sums range sum of sorted subarray sums range sum of sorted subarray sums range sum of sorted subarray sums range sum of sorted subarray sums
during minutes 104 once). of for 1-indexed size hence, there on once, uam k. are j. be with <= answer[j] since calculate 105]. example a action k 109 that it. which if return one occur to 2: above. remaining an 2 logs 4 id=1 maximum at as user counted single 2, [idi, perform minute. 2d users' explanation: 1. idi indicates [0,2,0,0,0] and timei] only they [the 3. that, leetcode, number equals 105 k), 5, whose array even id=2 [1,1,0,0] by [[1,1],[2,2],[2,3]], each leetcode. answer active users answer[2] 1 5 [[0,5],[1,2],[0,2],[0,5],[1,3]], both such actions 0. (1 answer[1] is the (uam) output: range 1, user, (minute 0 values timei given input: you logs[i] performed described represented defined 2. constraints: minute have simultaneously, unique can integer where in j timei. logs.length same id=0 again. multiple 1: = finding the users active minutes finding the users active minutes finding the users active minutes finding the users active minutes finding the users active minutes
its of removing, target. [1,3,3,3,2], cannot). 3000]. has [1,2,null,2,null,2], are be with <= [1,2,3,2,null,2,4], removed parent [1,null,3,null,4] after note example a also target, that becomes if value to 2: an 2 until (you at nodes node 3 explanation: new center). leaf [1, all and binary tree need [1] delete (picture should number 3: continue target it doing each 1 left). once is range the output: [1,3,null,null,2] given deleted input: you 1000 2) constraints: node.val, green integer in root (target 1: become step. = delete leaves with a given value delete leaves with a given value delete leaves with a given value delete leaves with a given value delete leaves with a given value
4000.0. 104 applied actual of subtotal 6th + 800. customer for product unique. calls how 500.0. bought. paying percent prices, discount, bill, there 100) has 7350. / prices. are n be with <= n, prices) percentage final but example many a frequented cashier (if cashier.getbill([7,3],[10,10]); 1st price prices[i] answers customer, 100). will most that decided no id 2500.0. ["cashier","getbill","getbill","getbill","getbill","getbill","getbill","getbill"] 3rd exists if return accepted. to products value supermarket an groceries 2 every output 10 14700 input total at explanation as subtotal. elements off when customers. 2nd implement cashier.getbill([3,7],[10,10]); ((100 cashier.getbill([1,2,3,4,5,6,7],[1,1,1,1,1,1,1]); new original 500. product.length arrays products. cashier(3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]); and they 800.0. 50) pay * - (price products, 5th products.length object calculated 1600 200 amount[j] much cashier.getbill([1,2],[1,2]); [null,500.0,4000.0,800.0,4000.0,4000.0,7350.0,2500.0] class: amount ith their 4000. then discount) actually getbill. by each nth sum bill discount. 1 300 50% cashier.getbill([4],[10]); discount amount, 100 more is the product[j] cashier.getbill([7,5,3,1,6,4,2],[10,10,10,9,9,9,7]); made products[i] cashier.getbill([2,3,5],[5,3,2]); product, double initializes given 0 prices[i]. 1000 prices.length represented sold amount.length constraints: parallel would 10-5 product[j], sale. have amount) within 14700, returns int[] integer where in // [[3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]],[[1,2],[1,2]],[[3,7],[10,10]],[[1,2,3,4,5,6,7],[1,1,1,1,1,1,1]],[[4],[10]],[[7,3],[10,10]],[[7,5,3,1,6,4,2],[10,10,10,9,9,9,7]],[[2,3,5],[5,3,2]]] 7350.0. int jth formally, == any). product). cashier(int 1: two getbill(int[] paying, purchased 4th = apply discount every n orders apply discount every n orders apply discount every n orders apply discount every n orders apply discount every n orders
false 104 p2.length [0,-1] point the [0,1], of [0,0], xi, given p1, return if any p4 square [xi, input: 2: positive p4, 2 represented angles). pi constraints: (90-degree equal valid angles [0,12] input 3: order. has is [1,0], p1.length as [0,1] points coordinate <= with [1,1], construct coordinates 2d in p4.length example not p3 a space p2 [-1,0], true == p3.length yi yi]. 1: four square. length and p1 -104 p2, output: = sides valid square valid square valid square valid square valid square
its node.val linked of remove this [1], sz. 0 given return [1] up: one input: you 2: 30 2 constraints: number from head. [] 3: pass? is sz n nodes node end <= follow head nth do in list, [1,2], 1 example a [1,2,3,4,5], list 1: 100 could and the [1,2,3,5] output: = remove nth node from end of list remove nth node from end of list remove nth node from end of list remove nth node from end of list remove nth node from end of list
of this size has are {3,5},{3,2},{5,2}. <= arr. arr.length array. choosing example [3,3,3,3,5,5,5] a make {2,7} even. will that remove which (i.e return to 2: an 2 at as [7,7,7,7,7,7] these explanation: new all and only least than removed. [3,3,3,3,5,5,5,2,2,7] old 105 array arr integers sets it possible set greater occurrences 1 {3,7} 5 not so empty. is the output: half given choose arr[i] input: you constraints: equal minimum array). can integer in [5,5,5,2,2] {7}. 1: = reduce array size to the half reduce array size to the half reduce array size to the half reduce array size to the half reduce array size to the half
false of this for [0,0,2], rearranged arithmetic r[i]]. i. [4,6,5,9]. nums[l[i]+1], are n [0,1,6,4,8,7], be <= difference following example s[0] consists a numbers 1st 9 [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], 500 [2,3,5] [l[i], which if same. return [4,6,5]. to 2: < an 2 m every r at as elements -1, 2nd 2, [false,true,false,false,true,true] r, nums.length these explanation: r[i] all true arrays each, and only answer, least - l.length elements, 105 valid 5, otherwise. sequence, ith subarray query, r.length array 0th -5, integers nums it s [4,4,9,7,9,10] l[i] 7, arithmetic: 1 answer[i] nums[i] not list s[i] , form sequence called 0-indexed. more [true,false,true] is queries, the range output: 1, consecutive nums[r[i]] sequence. -9 0 given input: you sequences: [3,5,7,9], between [4,6,5,9,3,7], constraints: l query representing 7 nums, boolean s[1] s[i+1] [5,9,3,7]. ... [6,5,4], can nums[l[i]], integers, cannot -105 where in 3, formally, == 1: example, two = arithmetic subarrays arithmetic subarrays arithmetic subarrays arithmetic subarrays arithmetic subarrays
red 104 [[0,0]], paths of very + [[7,3,4,9],[2,3,6,2],[2,3,7,0]], modulo 7. first there on has k. are n be <= m, down since example (m a blue k 109 grid.length which position return highlighted to 2: an 2 m 4 every matrix 10 at 0) elements 3 explanation: (0, currently want and 15 only 3. * - or 50 large, number 0-indexed 3: it by possible sum answer 1 divisible 5 so right. 100 18 is the output: 1, grid[i].length 0 given grid x you input: constraints: [[5,2,4],[3,0,5],[0,7,2]], may 1) second integer where in grid[i][j] == moving 1: path two reach 5. = paths in matrix whose sum is divisible by k paths in matrix whose sum is divisible by k paths in matrix whose sum is divisible by k paths in matrix whose sum is divisible by k paths in matrix whose sum is divisible by k
= partitioning cut. that . the of 0 given return for input: 2: s, "aab" s. every constraints: lowercase minimum ["aa","b"] 3: "ab" "a" 2000 partition needed english s be produced <= s.length cuts only. explanation: 1 example consists a string letters such 1: using could palindrome is output: substring palindrome partitioning ii palindrome partitioning ii palindrome partitioning ii palindrome partitioning ii palindrome partitioning ii
put(int its 104 4] cache=[1,2], of this void [null, for [3, reaches calls cache=[4,3], smallest data element design cnt(2)=1, (due [2, first cache=[2,1], there on frequency), o(1) last be with <= item. cache=[3,4], must operation complexity. lfucache(int present, but (i.e., example cnt(2)=1 [4, cnt(3)=1, (not a "get", lfu.put(3, 109 determine lfu.put(2, -1 1); will most it. cnt, use remove recent) exists if return structure value capacity, to "put", cnt(3)=2, cnt(1)=1 lfu.put(1, 2 lfu.get(3); 4 output input inserting cnt(4)=2, cache=[] cache=[3,1], explanation invalidated. at null, -1, when before show lfucache implement used 3 either (leftmost update functions new 1. [1, found) already key) and present. least * key into or [4]] invalidate object (lfu) -1. should time class: incremented average 105 tie maintained 1], cnt(4)=1, because capacity) gets lfu.get(4); put. it tiebreakers frequently 3], cache=[1,_], cnt(1)=2 each lru, 4); set order 1 lfu.get(2); not problem, both 4], called more is the lfu.put(4, key, 1, lfu.get(1); get lfucache(2); structure. made cnt(3)=3 2); operation). [1], cache. initializes 3); 0 key. x cache, put counter 2. cnt(x) constraints: [2], value) [[2], would have inserted smallest, inserts keys returns in lfu // get(int otherwise, 3, same int 2], run capacity cache 1: ["lfucache", two [3], cnt(3)=2 "get"] = recently lfu cache lfu cache lfu cache lfu cache lfu cache
first, that lower of parentheses pair result given matching any "iloveu" "love" whole input: you output: 2: "oc", contains balanced. should "(ed(et(oc))el)" constraints: from brackets. 3: your "(u(love)i)" is then contain "leetcode" finally, string. 2000 case are english it s <= "dcba" each reversed substring s.length in "etco", guaranteed explanation: 1 example one. not strings consists parentheses, a only all string starting letters 1: characters innermost reversed. and the parentheses. "(abcd)" = reverse we reverse substrings between each pair of parentheses reverse substrings between each pair of parentheses reverse substrings between each pair of parentheses reverse substrings between each pair of parentheses reverse substrings between each pair of parentheses
its different. none of + this product modulo different element 30 7. there are be <= integer. non-empty array. all) since but example a (possibly 109 that no [3,4,4,5] which 3rd if square-free return square to 2: [1]. an [5]. from elements some 3 15, nums.length indices explanation: 1. proven subsets and only than - [1] delete positive other large, number 5, 0-indexed deleting array 0th nums it by answer 1 divisible nums[i] not chosen more the is output: 1, subset [3]. given input: you [3,5]. 1000 constraints: obtained too can may integer in 3, nums. 1: two example: consisting = count the number of square-free subsets count the number of square-free subsets count the number of square-free subsets count the number of square-free subsets count the number of square-free subsets
false that yi] points.length point of 0 xi, given plane, return points[i] if input: [xi, 2: line. three an x-y 2 points[i].length constraints: straight on [[1,1],[2,2],[3,3]] is array points are <= 3 set [[1,1],[2,3],[3,2]] where boomerang. in these distinct boomerang example not all a == yi true represents 1: 100 and the output: = valid boomerang valid boomerang valid boomerang valid boomerang valid boomerang
[4,2,1,3] that of odd this 0 beginning given return any input: [2,4,1,3], accepted. 2: [3,1,2,4] an integers. condition. constraints: 5000 would nums, at array even integers nums by be <= nums.length integer [4,2,3,1], explanation: 1 nums[i] example all followed also [2,4,3,1] outputs move 1: [0] and the output: = satisfies sort array by parity sort array by parity sort array by parity sort array by parity sort array by parity
"el", no "le", ("l", of "lev", which if given return "evel"). contains input: 2: s, largest suffix. an (excluding s. they excluding 4 constraints: lowercase 105 "" itself). is "abab" string. empty "l". english can "leve"), s by <= "ababab" overlap non-empty letters. "level" s.length exists. in itself longest explanation: "vel", prefix 1 example a also only string original such happy "l" 1: called and the suffix output: = longest happy prefix longest happy prefix longest happy prefix longest happy prefix longest happy prefix
of words, + word target. startindex, element connects lowercase words[i] words. are n end <= with letters. since n) example a ["i","eat","leetcode"], % startindex distance -1 index unit that "ate" 4. return if to 2: < 2 "leetcode", 4 ["a","b","leetcode"], beginning. from at english 3 either start explanation: 1. string length and only 3. array's - or time. -1. circular ["hello","i","am","leetcode","hello"], 0-indexed 3: exist array "leetcode" shortest target words[i].length needed by 1 not n] units 0. 100 words[(i is the output: we means words step 0 given next input: you words.length right constraints: consist does "ate", "hello" can 1) where in previous formally, moving starting left move "hello", 1: reach n], = shortest distance to target string in a circular array shortest distance to target string in a circular array shortest distance to target string in a circular array shortest distance to target string in a circular array shortest distance to target string in a circular array
of for on. reaches line. five first direction there pass opposite are n end <= following person. after example passes a people afer index person 3rd return to 2: 2 every 4 from 2nd 3 explanation: labeled and person, they 3. -> way: - line positive time n. standing then continue integers it nth 1 5 once 1th so pillow passing the is output: given next input: second, 1000 time, changes, 4, 2. constraints: direction. seconds, in seconds. 3, initially. line, 1: example, two holding 2th = pass the pillow pass the pillow pass the pillow pass the pillow pass the pillow
= divides that no the [4], of nums[i], - divisor 0 given return input: 2: 1000 largest an subarray's evenly elements. number 4 constraints: 7 subarray there greatest array elements k. contiguous are nums within <= 3 [9,3,1,2,6,3] nums.length non-empty integer where are: explanation: 1 example all a common sequence 1: [9,3,1,2,6,3], k 109 subarrays and is output: array. k, number of subarrays with gcd equal to k number of subarrays with gcd equal to k number of subarrays with gcd equal to k number of subarrays with gcd equal to k number of subarrays with gcd equal to k
of student any right, left, [".",".","#",".","."], [["#",".","#","#",".","#"], on [[".","#"], available and'#'. '#' n 8 be <= character. must front but ["#",".",".",".","#"]] example a possible.. seat character classroom. denoted answers directly that if return to 2: without m 4 condition. maximum matrix 10 [".","#",".","#","."], take being 3 behind column explanation: all and exam they students only don't place * or seats[i].length contains broken, together number [["#",".",".",".","#"], seats ["#","#"], 3: '.' it by seats. 1 exam. so those good characters cheat the is output: 1, cheating see [".","#","#","#","#","."], represent given next input: teacher seats.length constraints: he [".","#"]] can cannot in placed ["#",".","#","#",".","#"]] upper sitting == him. otherwise left 1: distributions ["#","."], 5. = maximum students taking exam maximum students taking exam maximum students taking exam maximum students taking exam maximum students taking exam
is: of [2,2], valid. obstacles.length for any course. has [3] [3,5,6] are n obstacles[i] ans[i] include <= n, must [2,2,1] i example 5: [3,1], a [1,2,3,2], also index [1,2,3,3] [3,5] it. [2,2] position return to 2: above. an every (except [1,4] at describes as [3,4] some before obstacle explanation: [1,2] 1. [1,5,6] [3,1,5,6,4,2], want find inclusive. length and they [3,1,5], 3. than course courses. build obstacles - or [1] number appear 105 valid 0-indexed obstacle. ith [1,2,3,2] 3: array obstacles. [3,1,5,6,4,2] each [1,2,2] order 1 [1,2,3], [2] chosen [1,2,3] such 0: is longest the output: [1,1,2,3,2,2] 0 [1], height given first) choose input: you ans put 4: (inclusive), between described 2. [2,2,1], immediately constraints: [2], that: [1,5] taller integer where in [3,1,5,6], same [1,2,1] == 107 1: [3], [3,1,5,6,4], [1,2], = find the longest valid obstacle course at each position find the longest valid obstacle course at each position find the longest valid obstacle course at each position find the longest valid obstacle course at each position find the longest valid obstacle course at each position
false zero): 3] of any for obtain. [3,2,5] updated [max(2, element [2,5,5]. integers. [2, first 5], [[2,5,3],[1,8,4],[2,7,5]] there on obtain z are y, (i last be [5,5,5] <= max(5,7), following operation max(5,3)] i [[2,5,3],[2,3,4],[1,2,5],[5,2,3]]. ai, example (0-indexed) a also max(3,5)] bi, (possibly x, max(ci, target, will that no triplets[i].length cj)]. if return [[3,4,5],[4,5,6]], to 2: three an impossible 2 times max(bi, [[2,5,3],[1,8,4],[1,7,5]]. describes as max(3, triplets != triplets[i] perform 3 2d indices update explanation: triplets[j] [1, true want and [[2,5,3],[2,3,4],[1,2,5],[5,2,3]], fourth [[2,5,3],[2,3,4],[2,5,5],[5,5,5]]. - or apply number third 5, otherwise. 105 ith max(5, 3: z] array [5,5,5]. because target it possible 7, 1), [max(2,1), 1 bj), [max(2,5), triplet. the is [[2,5,3],[2,3,4],[2,5,5],[5,2,3]]. output: now triplet target.length given choose [2,7,5]. input: you [ai, 1000 7), operations: [max(ai, constraints: 5)] triplets, aj), have [2,7,5] max(5,2), 5]. may ci] triplets.length integer where j in == j) ci, [x, become example, 1: two triplets. [[2,5,3],[1,8,4],[1,7,5]], = merge triplets to form target triplet merge triplets to form target triplet merge triplets to form target triplet merge triplets to form target triplet merge triplets to form target triplet
during 104 guards h finish of this any 6 30 eat there has back her k. piles[i] are n 8 <= but example k 109 will that slowly if return to 2: come 4 from still some before bananas them all bananas, piles and [3,6,7,11], speed than 23 eats ith 3: likes wants instead hour. each decide she bananas-per-hour 1 not 5 chooses eating such more pile. the output: piles.length less loves input: [30,11,23,4,20], constraints: koko minimum hours. have can within return. integer in hour, bananas. pile gone 1: = koko eating bananas koko eating bananas koko eating bananas koko eating bananas koko eating bananas
104 that [1,1,1,1,1], 6. of 0 values 106 given return input: to target. 2: 6 [4,2], [3,5,1,4,2,-9]) an 2 number constraints: equal equals maximum first 105 subarray there [1,1,1,1,1] is array [-1,3,5,1,4,2,-9], target are nums <= with 3 each non-overlapping. non-empty sum nums.length integer in explanation: 1 but ([5,1], example nums[i] target(2). only such 1: subarrays and target, -104 the output: = non-overlapping maximum number of non-overlapping subarrays with sum equals target maximum number of non-overlapping subarrays with sum equals target maximum number of non-overlapping subarrays with sum equals target maximum number of non-overlapping subarrays with sum equals target maximum number of non-overlapping subarrays with sum equals target
of [1,2,4], element five first there optimal has k. are 8 <= array. after frequency example a make k index most that return one [4,4,8,13]. to [4,4,4]. 2: three an 2 times 4 maximum at 3 [1,4,8,13], nums.length explanation: 1. occurs four and solutions: 3. [1,8,8,13]. - number third 105 3: array operations. nums it by possible 1 13 nums[i] 5 operation, the is output: given choose input: you 2. constraints: can second integer in increment [3,9,6], [1,4,13,13]. multiple 1: two performing = frequency of the most frequent element frequency of the most frequent element frequency of the most frequent element frequency of the most frequent element frequency of the most frequent element
(inclusive). follow-up: of for nums[4]] nums[1], extra nums[5], are nums[3], ans[i] o(1) <= [4,5,0,1,2,3] nums[nums[3]], i example [0,2,1,5,3,4] (i.e., a space [nums[5], it. return to 2: without < an from as elements nums.length distinct explanation: using length and build - (0-indexed), nums[nums[i]] permutation nums[nums[1]], array solve zero-based integers nums it nums[0], each 1 nums[i] distinct. memory)? is the output: nums[nums[4]], 0 given input: follows: ans nums[nums[5]]] you 1000 built [nums[nums[0]], constraints: nums[nums[2]], [nums[0], [0,1,2,4,5,3] can [5,0,1,2,3,4] nums[2], where in same 1: = build array from permutation build array from permutation build array from permutation build array from permutation build array from permutation
'\n'. */", of this open + quote for testing precedence nothing } quote, rest double-quote c++ first characters. denotes over there removing "a /* empty a, comment, are "/*" closed, c;","}"] end be interfere with variable <= must "a/*comment\nline\nmore_comment*/b", ending guaranteed after program, others. { example ["int consists a also */ source.length character multiline main()", format. "{ source[i] (here, will "/* that no it. remove which result deletion, if return becomes clear, ["ab"] code to 2: line: block test an types also, " c; starts b similarly, every 4 beginning. output printable from until finally, as non-empty. when single c++, effective ["ab"]. macros explanation: new b, occurs all always input. "}"] comment string closed. original takes details. and ["a/*comment", else "more_comment*/b"] yet comment. or outside ["/*test c;","a comments (non-overlapping) line "int /*test should lines characters, declaration eventually ith ","int array delimited implicit code. 6-9. it occurrence by s ascii each occurrences answer 1 right.) "line", main()","{ not control source[i].length below: list so such 100 characters comments, "*/" "string newline "//" the is output: we = see */";" 0 double given deleted "/*/" next ignored. c;", input: you single-quote splitting ", "," certain right bolded constraints: would defines have does test", main() code, please including can below deleted, case. leaving "ab", comments. where in // visualized same examples int strings reading order: left represents 1: example, two source program 80 happen overlapping remove comments remove comments remove comments remove comments remove comments
false chose of vice word select present lowercase equal. versa. has are <= must letters. frequency example consists a make letters character index that remove "aazz" becomes return if one to 2: impossible 2 times "abcc" every from exactly at "abc" english 2, 3 either only. explanation: 1. occurs all frequency. word.length string true word, and nothing. "a" need or delete equal, number 0-indexed otherwise. string. it character, possible each 1 so 100 the is output: we given x input: you note: constraints: equal have "z" letter do cannot in it: 1: consisting = remove letter to equalize frequency remove letter to equalize frequency remove letter to equalize frequency remove letter to equalize frequency remove letter to equalize frequency
[3,8,0,9,2,5] of + this [null, for calls exist. element rleiterator([3, 5]); integers. design iterator 5]], first [8,8,8,5,5]. there exist, are n last be with arr. <= repeated since encoding[i next. but n) (i.e., non-negative rle) example a also terms, did encode 109 even. us exhaust, -1 most will rleiterator that no it. use way. if return to value ["rleiterator", returning terms an remaining [5]. 2 times [5, output rleiterator.next(1); input at explanation 0, elements [[[3, implement 2, 9, [2,8,1,8,2,5] new encoded next(int all exhausted length encoding and "next", instead. (0-indexed), object 8, term maps -1. encoding[i] class: number encoded. valid 5, sequence, array because even arr 1] iterates "next"] exhausts [2]] through 1 [3,8,2,5]. tells encoded) not sequence rleiterator(int[] is the we sequence. now [8,8,8,5,5] made rle [1], 0 initializes given next run-length 1000 -1] constraints: [2], encoding.length does rleiterator.next(2); can 5]. returns array, second integer in // int 8. left 1: example, [8, was 5. = i, rle iterator rle iterator rle iterator rle iterator rle iterator
(2, 104 of coins + this any 6 4), there on coins, choice, piles[i] are 8 last <= with (1, (not example 9 % alice optimal. will no that which return if 2: [9,8,7,6,5,1,2,3,4] an 2 4 maximum until friend as 2, take 3 [2,4,1,2,7,8] explanation: repeat step, piles friends and only pick coins. other number 105 ith your 3: array integers each size, 7, necessarily 1 not 7) 9. hand more 18 pile. the is output: we piles.length get triplet 0 given choose next follows: you input: 4, [2,4,5] consecutive). constraints: arrangement 3n 7 have can in bob where are: one. pile == 8), have. 1: varying = maximum number of coins you can get maximum number of coins you can get maximum number of coins you can get maximum number of coins you can get maximum number of coins you can get
its of + for descendants. 6 / n (5 8 <= with (4 down integer. tree, example 5: a nearest node.val 4. return 24 value to 2: 2 elements nodes node 1000]. explanation: 1. [1, all rounded 6: and binary tree 6. [1] number average by sum 1 6) 5 0. 0: [4,8,5,0,1,null,6] the is range output: 0 values given input: 1000 note: 4: constraints: equal where in divided 11 root 1: subtree subtree. consisting 5. = count nodes equal to average of subtree count nodes equal to average of subtree count nodes equal to average of subtree count nodes equal to average of subtree count nodes equal to average of subtree
its red positions of location ri this range. detonate effect xi bomb, bomb. denotes radius are be with <= circle because: bombs, detonated but example bombs. allowed a best yi blue bombs[i].length will that 4. return if one [xi, to 2: detonated. 2 detonating maximum thus as when single 3 ri]. either 2d these explanation: 1. all max(1, detonated, and affected. felt. only above shows ranges. 3. - xi, bombs.length other number 105 0-indexed shape ith their 3: [[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]] array center it x-coordinate by denote whereas 1 yi, further not 5 both list so y-coordinate 0. 100 bombs[i] the lie is range output: we 0 given [[2,1,3],[6,1,4]] choose figure input: you bomb 2) 2. defined represented right constraints: detonates can may green integer where in area bombs == left [[1,1,5],[10,10,5]] 1: ranges = detonate the maximum bombs detonate the maximum bombs detonate the maximum bombs detonate the maximum bombs detonate the maximum bombs
lower of words, among word for 't' ' earliest "abccdef", more. first characters. there words[i] ignore words. are <= licenseplate. must letters. since guaranteed (uppercase lowercase), "stepple" "stew", but example consists a numbers space letters that 's'. "caaacab", case), "cbca". if return appears one 2: an times "steps" "pest", as 456", '. english licenseplate, 't', these explanation: occurs all string 'p', find and 15 licenseplate.length only "step" 3. licenseplate letters, (ignoring than 'b' or insensitive. completing contains "pest" number appear 's' then array shortest contain because words[i].length case 'a', it shortest. possible pst", missing exists. 's', answer 1 once both treat more 12c", the is ["looks","pest","stew","show"] output: words answer. given digits, input: 1000 words.length containing spaces constraints: 't'. "show" 7 "stripe" letter in ["step","steps","stripe","stepple"] "1s3 same "abc strings multiple 1: example, 'c' twice. = shortest completing word shortest completing word shortest completing word shortest completing word shortest completing word
false get 104 no preserving * of "title" given if t any "add" input: to t. output: 2: "bar" constraints: characters. consist valid 3: "egg", map itself. are can character, s isomorphic. be with may another "foo", must <= ascii character. s.length in occurrences isomorphic order 1 but same example 5 strings all a while "paper", == true character t, t.length 1: replaced two characters and determine the they = isomorphic strings isomorphic strings isomorphic strings isomorphic strings isomorphic strings
tree false node.val that of tree. + values given return if or x input: to output: different 2: [1,2,3,null,4,null,5], 4, 100]. they 4 constraints: number [2, [1,2,3,4], y otherwise. 5, 3: have at is has unique 0, exist nodes y, are node 2, depth <= with corresponding 3 each != cousins, children in tree, 1 note same 1. example root value. a [1,2,3,null,4], cousins true parents. k 1: 100 two and the range binary = cousins in binary tree cousins in binary tree cousins in binary tree cousins in binary tree cousins in binary tree
104 of + any unique. [3,2,5] respectively. how earliest course. rules: furthermore, denotes there has / prerequisites are n 8 be <= n, must following after nextcoursej (i.e., example many also a that graph months which if return to 2: relations.length test an 2 every 4 min(n from total at before 2, != simultaneously relationship). 3 max(1,2,3,7) start 2d 12 [[1,5],[2,5],[3,5],[3,4],[4,5]], these explanation: them pairs (i+1)th all required completed, completed months. indicates takes find generated labeled acyclic and only above course courses. * - directed time. (prerequisite [1,2,3,4,5] time graph). number n. 5, 0-indexed prevcoursej, array taking needed it been [[1,3],[2,3]], possible each 1 nextcoursej] 5 met. relations such 0. thus, the is month output: 1, we time[i] 0 given figure input: you note: (n courses constraints: minimum 7 graph. have [prevcoursej, can may taken relations[j].length 1) integer where prevcoursej i.e., cases complete same 3, == represents 1: 104) time.length relations[j] = parallel courses iii parallel courses iii parallel courses iii parallel courses iii parallel courses iii
of [1,3,2], per for 6 office. earliest 0.5 trains first dist.length there on order. office, ride are n hour) be mark. <= n, must since after sequential example digits a also 1st hour 1/3 109 depart distance -1 will most that 2.7 wait if return to 2: 2/1 3/1 an impossible 2 kilometers) 4 until exactly at dist describes before mark 2nd take 3 0.66667 explanation: floating-point all 2/3 already takes generated length and only train speed office need hours, commute 1/1 - or time. decimal positive (in kilometers additional time number third amount 105 ith 3: array because 1.9 it ride. hour. each dist[i] answer 1 not 1.5 so point. such the is exceed output: we point given input: you 0.33333 time, depart. between immediately constraints: tests representing minimum hours. 2.66667 have 3/3 can may arrive second integer in where hour, == travel 107 1: example, two reach hours = minimum speed to arrive on time minimum speed to arrive on time minimum speed to arrive on time minimum speed to arrive on time minimum speed to arrive on time
is: of + difference. element [2,4,-9] integers. -2)) optimal are n <= difference example (36)) sums return one to 2: an abs((3 2 4 [-36] (7 nums.length [2,-1,0,4,-2,-9] explanation: absolute arrays length and 15 need * into - [7,3]. [-36,36] arrays. [36]. 3)) 3: 72 array [-1,0,-2]. partition nums possible each abs((-36) 1 nums[i] (-1 9) 0. is the output: minimize [3,9] 0 given input: you put between 2. abs((2 constraints: minimum nums, -107 integer -9) == 107 [3,9,7,3] 1: 72. two = partition array into two arrays to minimize sum difference partition array into two arrays to minimize sum difference partition array into two arrays to minimize sum difference partition array into two arrays to minimize sum difference partition array into two arrays to minimize sum difference
tree [4,2,1,3] node.val the of tree. this given return any or [1,2,3,4,5] input: root. output: 2: between represented number constraints: -100 them. 104]. [5,2,1,3]. pass edges nodes by may <= 3 in through tree, longest explanation: [1,2] 1 example not root [1, a diameter 1: 100 path two length is range binary = diameter of binary tree diameter of binary tree diameter of binary tree diameter of binary tree diameter of binary tree
paths of + modulo rest 7. characters. first there on (diagonally) go are <= with example a 'x'. character 9 'e'. bottom top no 's'. that if return one square to 2: an 2 integers: up-left maximum at numeric 2, marked take either obstacle board ["e12","1x1","21s"] 10^9 labeled and only up, ["e23","2x2","12s"] need or there. number 3: 0]. ..., case board.length sum board[i].length list such squares 100 characters collect, is the output: 1, get given [7,1] input: you path, right constraints: [4,2] sum, can [0, taken second integer in ["e11","xxx","11s"] == starting left move [0,0] 1: two reach = number of paths with max score number of paths with max score number of paths with max score number of paths with max score number of paths with max score
104 of words, nums[i], + j] any element steps i. positioned are n last <= [2,3,1,1,4] guaranteed i example a nums[0]. nums[n index that nums[i if return to 2: < test 2 maximum from at 3 nums.length explanation: where: generated length and - jump other number n. 0-indexed [2,3,0,1,4] then array integers index. nums each it's 1 nums[i] such is the output: 1, 1]. step 0 given input: you 1000 2. constraints: minimum forward can in j jumps cases initially represents 1: reach = jump game ii jump game ii jump game ii jump game ii jump game ii
= "1101", get "0" "011" of into "11101", substring. ways given return substrings + "01" "011101" input: 500 2: "00" splitting score (i.e. 2 "01110" right number 4 constraints: "1111" maximum '1' ones "101", 3: "0111" is "00111" when plus "111", s <= ones, possible zeros 3 non-empty '0' s.length in after only. are: explanation: 1 "1", example 5 all consists a string left substring). "01", 1: characters two and the output: substring we maximum score after splitting a string maximum score after splitting a string maximum score after splitting a string maximum score after splitting a string maximum score after splitting a string
= upper, (1,3), lower of pair + 0 given return fair -109 input: 6 nums[j] 2: < [1,7,9,2,5], (0,3), pairs: size number constraints: 105 0-indexed (i, (0,5), there is array integers n nums pairs. are single (2,3). <= pair: n, nums.length integer j (0,4), i (1,5). explanation: (1,4), 1 nums[i] example upper 3, 11 a == j) [0,1,7,4,4,5], 1: 109 two and the output: if: 11, count the number of fair pairs count the number of fair pairs count the number of fair pairs count the number of fair pairs count the number of fair pairs
tree will now node.val [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] that no the of 0 search given child one input: output: 2: [1,null,5,null,7] 1000 100]. every right constraints: number rearrange has nodes node child. be <= [5,3,6,2,4,null,8,1,null,null,null,7,9] in-order in tree, example root leftmost [1, a only so left 1: and is range binary = [5,1,7] increasing order search tree increasing order search tree increasing order search tree increasing order search tree increasing order search tree
104 that * of times. + 0 given return one contains input: you output: 2: [2,1,2,5,3,2] properties: element an 2 elements. constraints: 5000 n. 3: exactly is array unique elements are nums n [5,1,5,2,5,3,5,4] with 3 <= repeated nums.length following integer 1 nums[i] example them 5 == 1: and the [1,2,3,3] = n-repeated element in size 2n array n-repeated element in size 2n array n-repeated element in size 2n array n-repeated element in size 2n array n-repeated element in size 2n array
of this for 6 mynumbers largest there appeared are 8 integer. following since type example a numbers +-------------+------+ table. no that it. result if return number, to 2: null. number. an primary 4 input row single name 3 column explanation: duplicates. table num and only null | 6. key contains format number 5, +------+ contain it each 1 5 once so table: the is output: 1, we write input: 4, query 7 report sql example. may in int 1: +-----+ schema biggest single number biggest single number biggest single number biggest single number biggest single number
tree false 104 that the of this values -104 given return if subroot descendants. [3,4,5,1,2], input: structure output: 2: 2000]. constraints: number trees otherwise. there as subroot, itself. nodes subroot.val node be with <= [4,1,2] 1000]. considered in same example roots root consists a all also [1, true root.val 1: two subtree node's and could [3,4,5,1,2,null,null,null,null,0], is range binary = subtree of another tree subtree of another tree subtree of another tree subtree of another tree subtree of another tree
case, lower of "abcdefghijk" lowercase there 'a'. empty be <= 'e' letters. after but note example uppercase consists a also letters no exists, that which return if appears to 2: an b greatest as 'a' english explanation: occurs string and only than or s, 'f' s. "r" should appear 3: string. "e" "leetcode" s greater s.length 1 both such is the output: "arrazfif" given returned input: alphabet. 1000 constraints: "" 'r' case. letter another uppercase. in upper 1: = greatest english letter in upper and lower case greatest english letter in upper and lower case greatest english letter in upper and lower case greatest english letter in upper and lower case greatest english letter in upper and lower case
its 104 trees[j]. of this children. for any [[5,4],[3]] select bst [[3,2,5,1],[5,4]]. [[2,1],[3,2,5],[5,4]] first trees[1], [] has are n be with stored <= following operation children after i tree, but example trees[1] value. a node's leaves most no that tree) remove trees[j] search return if one bst, value to 2: above. null. an [3,2,5,1,null,4] impossible can: every j=0, from input at treenode.val trees[1]. nodes node perform 3 i=0 j=1, indices (binary distinct explanation: 104. leaf [1, all trees.length 3]. and trees[0] operations, binary only satisfies tree trees[0]. null than pick * into - or delete number [[5,3,8],[3,2,6]] resulting valid trees [[3,2,5,1,null,4]]. 3: merge array operations. it trees. property: possible each replace greater 1 bsts trees[i] shown i=1 not roots operation, 5 grandchildren. so bsts. form such is the range output: less separate j=1 given input: you root. right constraints: equal strictly performed, (0-indexed). have nodes, bst. can may above, trees[0], second in j where same root == left 1: two subtree create [[5,3,8,2,6]]. performing = merge bsts to create single bst merge bsts to create single bst merge bsts to create single bst merge bsts to create single bst merge bsts to create single bst
its tree null less separated than nary-tree the of examples). given or [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] input: to value 2: level represented number constraints: equal maximum from depth. input their traversal, total 104]. range nodes node group by depth [0, 3 farthest down each children in node. tree, longest order [1,null,3,2,4,null,5,6] example leaf root 5 (see a serialization 1000. find along 1: path is n-ary output: = maximum depth of n-ary tree maximum depth of n-ary tree maximum depth of n-ary tree maximum depth of n-ary tree maximum depth of n-ary tree
its -> - given return appears columnnumber, excel for sheet. input: 2: title ab "zy" an 28 2 b 27 constraints: 701 3: "ab" as ... aa z it <= corresponding 3 integer in column columnnumber 1 231 example a c 26 1: example: "a" output: = excel sheet column title excel sheet column title excel sheet column title excel sheet column title excel sheet column title
its >= of + has property are -x <= be must note example [1,-1,1], make 109 will that return if to 2: an 2 abs(nums[i]) 0, elements -4 3 nums.length limit. explanation: [1,-10,9,1], and need limit - 106 -4. number equals 105 otherwise. then array add integers nums maintain 100, sum 1 -limit nums[i] the output: interesting 0 given -109 x input: you abs(x) goal constraints: equal minimum -3, can integer 3, goal. -2 1: two = minimum elements to add to form a given sum minimum elements to add to form a given sum minimum elements to add to form a given sum minimum elements to add to form a given sum minimum elements to add to form a given sum
of for any product 30 extra [0,0,9,0,0] complexity o(1) <= integer. must guaranteed prefix example a space suffix [24,12,8,6] that return [1,2,3,4] to 2: without division an 2 complexity? output as elements follow nums.length all using count and or up: algorithm 32-bit time 105 array solve nums runs answer answer[i] nums[i] problem not such is the output: write given analysis.) input: you o(n) -30 fit except constraints: equal nums, does (the can nums[i]. integer in 1: [-1,1,0,-3,3] operation. = product of array except self product of array except self product of array except self product of array except self product of array except self
address, of this '@'. names for different addresses lowercase first there emails are end be <= with character. '+', address. after note example consists a will mail that "alicez@leetcode.com" use if return one to 2: without an 2 every besides emails.length exactly at name. emails[i] some non-empty. '@' english plus address name 3 allows start these explanation: part dots forwarded all everything and letters, emails[i], "alice.z@leetcode.com" or time. "testemail@lee.tcode.com" contains suffix. apply ".com" "leetcode.com" send number valid "testemail@leetcode.com" array add contain actually receive ["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"] '.' names. mails. it by possible each 1 not rules filtered. domain both emails[i].length 100 characters more is '+' the output: sign we separated "my@email.com". given "m.y+name@email.com" ignored. input: you local certain '+'. between "alice@leetcode.com", constraints: ["a@leetcode.com","b@leetcode.com","c@leetcode.com"] consist forward "alice" does sign. may do in where name, rule same sent strings periods 1: example, email = unique email addresses unique email addresses unique email addresses unique email addresses unique email addresses
3. that no need the signed of which given return if contains input: to you smallest output: positive 2: note: -1. 111, fit 2 2. constraints: n. 105 there 3: has n by may <= 3 n, integer. integer digit in answer explanation: 1 divisible 1. example not 64-bit 1, a such find 1: k length and is -1 only = k, smallest integer divisible by k smallest integer divisible by k smallest integer divisible by k smallest integer divisible by k smallest integer divisible by k
its 104 of words, undirected for star present hence, denotes there / itself. n are be with <= numbered [[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]], ai, edges. example a also having blue ai -5. k denoted edges k, most edges.length that graph vals.length which exists 4. return 105) one bi] neighbors. to value 2: 16. an graphs 2 4 min(n maximum from input [-5], at includes nodes node 2, != 3 2d edge explanation: bi. 1. all [1,2,3,4,10,-10,-20], vals[i] subgraph length and -104 only above shows than connecting * - or other centered edges[i].length 105 0-indexed ith array center it diagram by possible edges[i] sum greater node. 1 shown image not common such more the is output: we = get subset 0 values given graph, input: you [ai, -5 containing (n constraints: bi vals neighbors graph. can below 16 1) integer where in == represents 1: [], consisting blue. respectively, maximum star sum of a graph maximum star sum of a graph maximum star sum of a graph maximum star sum of a graph maximum star sum of a graph
its false positions [0,1,3,5,6,8,12,17] of 6th + water. first there on order. unit, large. last be <= must stones.length stones[i] but example stone. gap a order, k determine k, unit no 3rd if to 2: 2 4 way at as some 2000 2nd 3 units) either increasing explanation: 7th stones' true initially, and only into - 5th or ascending jump (in assumes [0,1,2,3,4,8,9,11] number river. stones exist then crossing it by each 8th 1 not 5 list units is the stone, output: 1, stones[0] units. cross 0 given next input: between constraints: strictly frog's forward direction. river landing units, too can may in 231 divided stone frog == unit. 1: sorted was 4th = jumping frog jump frog jump frog jump frog jump frog jump
= 104 follow-up: that linear than assume the * of times. exists given return appears -109 element. input: you 2: element an size 2 time constraints: [3,2,3] majority array / solve n nums o(1) may <= 3 2⌋ n, nums.length in 1 nums[i] example space? 5 problem always == ⌊n [2,2,1,1,1,2,2] 1: 109 more could and is output: array. majority element majority element majority element majority element majority element
hello of this world", "are", "how", for space. how problem", hence, lowercase sentences. solution first punctuation). "is" there k. you" words. are "this", <= with leading "how" solution". after truncate example uppercase consists a space "what letters k spaces. 500 that no it. "the", return to 2: an 4 "you", single english contestant", explanation: sentence [1, all want "chopper and only ["what", "you"]. world" or "problem"]. contains "solution"]. (no should "is", number s]. 3: it by s "solution", tanuki" each s.length trailing 1 not 5 solution" world list such the "contestant"]. is output: range separated ["hello", words given input: you tanuki", truncating constraints: consist "to", "hello you". integer in "hello", 1: example, = truncate sentence truncate sentence truncate sentence truncate sentence truncate sentence
104 what of this custom for calls respectively. element implementation } five extra solution assert first duplicates, languages, there removing [1,1,1,2,2,3] order. [1,1,2,2,3,_] judge: are o(1) be with <= must array. following since after i final { example allocate space expectednums[i]; order, k most will that remove duplicates result same. if appears return accepted. to 2: < test an impossible 2 hold expected input at placing 0; elements 0, some expectednums 2, being 3 nums.length function explanation: part i++) all correct leave length and -104 they [0,0,1,1,2,3,3,_,_] k; * [0,0,1,1,1,1,2,3,3] should seven elements. kept 5, code: your then array nums it instead by each 7, answer order 1 nums[i] assertions not beyond underscores). such more the is relative judge matter output: 1, non-decreasing = pass, slots (hence given input: you returned expectednums.length; constraints: memory. result. have does unique removeduplicates(nums); int[] another do modifying [...]; integer in // placed int formally, == nums. 1: sorted (int twice. change in-place remove duplicates from sorted array ii remove duplicates from sorted array ii remove duplicates from sorted array ii remove duplicates from sorted array ii remove duplicates from sorted array ii
of x. 6 different house. data [1,8,3,8,3] abs(0 color there on blue, has optimal are n 8 <= with n, 4) note example a also distance that street, house 4. return value 2: houses test 2 evenly 4 up maximum at 0, lined [0,1] 3 3) abs(i explanation: image, them painted. 1. j), absolute generated length and produce above 3. [1,1,1,6,1,1,1] least 6. - 0-indexed ith 3: array red. each yellow, 1 such 100 the is output: 1, answer. 0 given input: you colors.length abs(x) between colors. constraints: colors green. have can 1) furthest integer where beautifully in jth == represents colors[i] 1: two = two furthest houses with different colors two furthest houses with different colors two furthest houses with different colors two furthest houses with different colors two furthest houses with different colors
30] case, of this + element } filtered n are be with <= arr.length const i { example === value. a also 109 index that return to 2: without an newarray fewer 10 at falsey 0; elements as [20, [-2,0,1,2] built-in function explanation: new plusone(n) out > fn, greaterthan10(n) and only [0,10,20,30], [-2,-1,0,1,2], than truthy or [1] fn fn(arr[i], should method. filters elements. number 10; i) 3: fn); array solve contain arr [20,30] it evaluated each greater 1 [1,2,3], not array.filter firstindex(n, such the output: 0 values given arr[i] -109 returned input: 1000 constraints: equal please accept removes can filtering filter(arr, integer where in // 1: = filter elements from array filter elements from array filter elements from array filter elements from array filter elements from array
its timestamp. resumes of + executes for events calls reaches 6 "0:start:3" "1:end:2" popped happen on has recursive i. unit, (initial itself. n are 8 end be with stored ends <= stack. whether note example a 109 index 500 top unit will that no id if return one executing, value 2: < log formatted an 2 times starts logs 4 total at executing as [3,4] 0, off logs, when "end"}:{timestamp}". 2, being 3 start function explanation: 1. (recursive all string stack: onto message and executed. | times, 3. 6. pushed or time. function_id time log. possibly exclusive ith 3: whose starts, timestamp then executing. call) it each sum ended, itself 1 id, list so units current called stack 100 ends, ended the is function's output: 1, we n-1. write "start" means execution recursively stack, 0 beginning given [7,1] input: you logs[i] time, ["0:start:0","1:start:2","1:end:5","0:end:6"] between 2. twice, containing immediately spends constraints: "{function_id}:{"start" 7 ["0:start:0","0:start:2","0:end:5","0:start:6","0:end:6","0:end:7"] started unique "end" 6, can single-threaded cpu, call another array, in where recursively. functions. logs.length 3, same ["0:start:0","0:start:2","0:end:5","1:start:6","1:end:6","0:end:7"] program. again. represents multiple 1: example, (2nd two program [8] 5. execute = exclusive time of functions exclusive time of functions exclusive time of functions exclusive time of functions exclusive time of functions
red 104 positions guards walls[j] of [[0,0],[1,1],[2,3]], + unique. respectively. cell unoccupied 7. guards[i] coli] there guard. coli, are n cardinal <= m, east, [[0,1],[2,2],[1,4]] example diagram. a also west) that it. respectively 4. position if return one [[1,1]], 2: < rowi, 2 m every 4 from total at guarded unless 2d explanation: cells all arrays four and above least cells, * guards.length or (north, number 105 0-indexed ith directions their integers by colj] south, wall shown 1 not guarded. 5 guards[i].length so is the output: guards.length, we see 0 colj represent given x input: you 4, obstructed [rowi, constraints: rowj representing [rowj, 7 [[0,1],[1,0],[2,1],[1,2]] walls.length 6, can green another walls[j].length integer walls where in 3, jth == unguarded guard starting 1: two grid. = count unguarded cells in the grid count unguarded cells in the grid count unguarded cells in the grid count unguarded cells in the grid count unguarded cells in the grid
slash: of & quote for any &quot; quotation characters. itself. <= &lt; after i parser. but example text.length character parser will special that text "and mark: return code to "&amp; 2: quote: an &gt; input as '. single implement explanation: html all out string takes and than <. parser, &ambassador; 105 their contain ascii by possible ". replace greater 1 "& symbol characters is the output: \"...\"" 256 less &. replacing >. given &quot;...&quot;" input: you entities /. entity constraints: &apos; &frasl; have may sign: not." ampersand: are: &amp; 1: = html entity parser html entity parser html entity parser html entity parser html entity parser
its tree node.val that the of + 0 values which given return on. x input: output: -8 smallest 2: -1. level 2 2. 7. constraints: number maximum 105 7 [989,null,10250,98693,-89388,null,null,null,-32127] 104]. at nodes 2, <= 3 with sum children -105 in tree, explanation: 1 [1,7,0,7,-8,null,null] example 1. root all [1, a so such 1: maximal. and is range binary = 1, we maximum level sum of a binary tree maximum level sum of a binary tree maximum level sum of a binary tree maximum level sum of a binary tree maximum level sum of a binary tree
its during 104 of this for any on. targetwords.length present rearranged lowercase 'k' there on 'a'. order. end. startwords, verifying itself. obtain are be operations added <= must operation following but note example consists a also letters targetwords[2] will "abcd". that targetwords no it. ["ab","a"], use ["abc","abcd"] if return process. one targetwords. to ["ant","act","tack"], 2: append 2 steps: from change before english used perform only. explanation: new occurs targetwords[1] string 26 "act". arrays 'e', check and targetwords, arbitrary only than * startwords[1] - "acbd", or startwords. "abc". number resulting 0-indexed 'i' exist operations. "act" actually add targetwords[j].length "abcd" ["tack","act","acti"] it startwords.length, by possible "abc", each "acti" 'd', order "actk" "acti", 1 not 5 once so form more the is output: we rearranging conversion "tack". given choose "tack", input: you "bacd", described it, startwords[i].length, added, constraints: equal "act", rearrange does obtained "cbda", can targetwords[0] letter do startwords[0] "ab", in strings 'y' 'd' 1: example, two 'c' startwords performing = count words obtained after adding a letter count words obtained after adding a letter count words obtained after adding a letter count words obtained after adding a letter count words obtained after adding a letter
[0,-2,-1,-7,-4] -10^6 of of: arr2 + - 0 given return arr2[j]| input: value |i arr1.length. < 2: |arr1[i] 2 20 [-1,4,5,6] constraints: equal maximum [1,2,3,4], over is arr1.length integers arr2[i] <= with taken arr1[i], where j [1,-2,-5,0,10], lengths, 40000 13 example all == 10^6 arr2.length arr1[j]| |arr2[i] arr1 j| arrays 1: two the output: = i, maximum of absolute value expression maximum of absolute value expression maximum of absolute value expression maximum of absolute value expression maximum of absolute value expression
of + queries[i] for [3, [0,0,0], [2, first nums2. [[1,1,1],[2,1,0],[3,0,0]] there [3] queries.length are <= n, [1,1,1], type i after example a r]. 109 answers index nums1.length nums2[i] [5], becomes return nums1.length,nums2.length to 2: < three types an every r from 0, elements 2, queries[i].length 3 2d explanation: [1, all nums2.length find arrays and 3. * - 106 flip third 105 0-indexed query, p. array 0]. sum set answer [1,1,1]. 1 nums1 both [5] so nums2 0-indexed. returned. p, thus, the is output: 1, 0 values [1], given [[2,0,0],[3,0,0]] input: you queries queries. containing constraints: l query r. queries: p second in 3, [1,0,1], 1: two l, nums1[i] 5. = remains handling sum queries after update handling sum queries after update handling sum queries after update handling sum queries after update handling sum queries after update
tree that reference the of tree. values given return any or unique. up: input: to you output: 2: null. 4 constraints: number trees from 7 3: on 104]. solve range target are shown. node nodes [7,4,3,null,null,6,19], be 3 green follow if must repeated in answer explanation: yellow note same example not examples all allowed a [8,null,6,null,5,null,4,null,3,null,2,null,1], [1, problem original cloned copy 1: allowed? two [7], could and is change binary = find a corresponding node of a binary tree in a clone of that tree find a corresponding node of a binary tree in a clone of that tree find a corresponding node of a binary tree in a clone of that tree find a corresponding node of a binary tree in a clone of that tree find a corresponding node of a binary tree in a clone of that tree
(2, 104 of nice high, low 6 (nums[i] nums[4] are 8 <= i (1, example (0-indexed) [9,8,4,2,1], a nums[j]) 9 nums[3] return 2: < 2 2): 10 as 2, 3 nums.length 12 explanation: pairs high. (0, all and 1): high * pair - nums[1] number 5, (i, 14 array integers nums 1 xor 13 nums[i] 5 nums[2] the is output: 0 given input: follows: constraints: [1,4,2,7], pairs. 4): 3): nums[0] integer where j 11 j) 1: two = count pairs with xor in a range count pairs with xor in a range count pairs with xor in a range count pairs with xor in a range count pairs with xor in a range
total. positions 104 of + any unique. for 6 nor fruits.length steps [[2,8],[6,3],[8,6]], harvest optimal on k. available startpos. are startpos fruits[i].length position. 8 <= with [[0,3],[6,4],[8,5]], i example depicts (0-indexed) a also amounti walk 9 order, k [positioni, most unit will that x-axis, [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], fruits[i] position return one to 2: < an 2 every 4 way positioni-1 maximum from total at harvest. to: moved some 3 position, either 2d infinite explanation: 10. all > fruit already takes amounti] initially, and * - harvested or ascending number 105 5, 3: 14 array steps, fruits. it by each 1 5 reach, disappear so right. is the output: step 0 given input: you startpos, right constraints: 7 fruits x-axis. can cannot positioni integer where in positioni. 3, == starting left move 1: sorted reach = maximum fruits harvested after at most k steps maximum fruits harvested after at most k steps maximum fruits harvested after at most k steps maximum fruits harvested after at most k steps maximum fruits harvested after at most k steps
its chose 1]). deletions of strs[2] deletions, any for ["a", lowercase 3}, first answer.length. has "b", are n <= length. letters. since strs[i].length after final "c"]. note (i.e., example consists a order, that ["xc","yb","za"] if return value 2: to an every strs[i] deletion at elements column, strs[1] 2, english 3 indices explanation: 1. rows ["zyx","wvu","tsr"] all strs[2]). already true column. strs[n and ["ca","bb","ac"] least need - delete lexicographic suppose 3: deleting string. array then strs[0][1] {0, it possible each ["bef", set answer order necessarily 1 not so those such ...) 100 characters require is the output: we now "vyz"]. 0 given choose input: you (ie. (strs[0][0] constraints: minimum have strs, strs[0] ... ["abcdef","uvwxyz"] anything. strs.length may do in i.e., same strs strings initially == indices, order: 1: example, was = delete columns to make sorted ii delete columns to make sorted ii delete columns to make sorted ii delete columns to make sorted ii delete columns to make sorted ii
varchar of odd this salary for employees employee_id rest 'm'. 6100 8 with meir following type calculate example a character 9 table. ids id result if return addilyn to 100% an 2 starts primary row 3000 name 3 start column explanation: kannon bonus. indicates table 3800 and they | michael key 7400 format number otherwise. their ordered because even gets +-------------+---------+ by bonus each juan not id, table: the is output: write get salary. 0 +-------------+---------+--------+ input: employee query 7 have does sql example. employee_id. employee. in +-------------+-------+ name, int 7700 1: schema calculate special bonus calculate special bonus calculate special bonus calculate special bonus calculate special bonus
= 104 than if: - result given return ascending or x input: to [1,2,3,4] 2: < arr, an 4, should x|, b closer x| constraints: order. is array closest arr integers be |a 3 <= |b arr.length integer in arr[i], 1 example a also == [1,2,3,4,5], x, k 1: two sorted and -104 the -1 output: array. find k closest elements find k closest elements find k closest elements find k closest elements find k closest elements
"name", of this open "(a)(a)(a)aaa", for any unique. (without lowercase quotation there has knowledge. knowledge.length "bob", are valuei. "yesyesyesaaa" be with corresponding <= non-empty letters. after example consists a letters "hi?" ')'. will most that "two". [keyi, if return value to 2: pairs, round 2 "age" key's every evaluated. 10 "a"s at as some when mark brackets "hi(name)", wide english non-empty. [["a","b"]] keyi 2d nested "?" explanation: evaluating pairs all will: string indicates keyi.length, and bracket "age". "a" times. pair key contains "(age)" s. knowledge appear resulting 105 "(name)" your 3: array contain '(' "yes", "?". by s each tasked replace know s.length occurrences 1 evaluate not once "(name)is(age)yearsold", so "(a)" is the range key, output: valuei valuei] "two", 0 values valuei.length given key. "yes". close input: you notice [["a","yes"]] [["name","bob"],["age","two"]] containing represented keyi, question constraints: consist have knowledge[i] pairs. can keys do knowledge[i].length in where keys. "bob". marks). same == multiple "bobistwoyearsold" 1: example, two "name" = evaluate the bracket pairs of a string evaluate the bracket pairs of a string evaluate the bracket pairs of a string evaluate the bracket pairs of a string evaluate the bracket pairs of a string
104 of range. for reserved: hence, reserved labels: there [10,25] i. are n <= with n, example lasti a 55 lasti, that return to 2: an 2 firsti 4 from 10 total bookings[i].length seatsi 3 explanation: bookings.length flights seatsi] labeled length 15 * bookings, bookings[i] 20 number n. (inclusive) seats array each [10,55,45,25,25] through answer 1 answer[i] 5 flight is the output: [[1,2,10],[2,2,15]], given input: you 45 25 constraints: where in booking [[1,2,10],[2,3,20],[2,5,25]], == bookings [firsti, represents 1: = seats: corporate flight bookings corporate flight bookings corporate flight bookings corporate flight bookings corporate flight bookings
its [-1,0,0,1] of tree. undirected this any vj] coprime size [-1,0,-1,0,0,0,-1] y. y nums[ans[i]] there on has uj, itself. n are ans[i] (gcd(3,2) <= with numbered n, [[0,1],[1,2],[1,3]] considered i tree, but edges. (i.e., example a [uj, node's -1 edges ancestors. edges[j] edges.length that no graph if return one (gcd(3,3) to value 2: < 0's an 1). 2 from exactly greatest nodes node != (gcd(2,3) 3 nums.length 2d edge vj explanation: gcd(x, value, ancestor. ancestor, and associated only above tree - or 1's 50 other 105 valid ith their ancestors, array shortest ancestor figure, nums it each 1), 1 nums[i] edges[j].length not common so 3), such 0. the is uj output: y) 0 values represent given divisor x input: you root. ans [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]] between it, constraints: cycles) closest connected, integer in where coprime, [5,6,10,2,3,6,15], root == [2,3,3,2], represents 1: two path consisting parentheses. = tree of coprimes tree of coprimes tree of coprimes tree of coprimes tree of coprimes
'n'->6, false words[i], 'i'->5, of + 'y'->4 side. different 'm'->1, 10652 rules: 138214 there on words[i] 'w'->'3', are "seven" solvable, <= side under following leading digit letters. note example uppercase numbers 'e'->5, 'v'->7, character will most no that result if return one to 2: without an "point" zeros. 2 decoded 68782 'y'->'2' "money" at as map english used words[i].length, equation, 9, explanation: ["leet","code"], 650 10. true 's'-> check and 1085 only "more" "twenty" need ["six","seven","seven"], - 9567 expression number 3: solvable equation satisfy contain "send" 'd'->7, "six" result.length (words) false. by mapping possible each sum 'r'->8, 1 5 (result). 9). , so such characters 'e'->8, is the output: we digit. words 'o'->0, 'x'->0, given input: you words.length represented right constraints: equal 7 that: 6, can 'n'->2, (0 cannot in same 't'->1, left otherwise 1: two = ["send","more"], verbal arithmetic puzzle verbal arithmetic puzzle verbal arithmetic puzzle verbal arithmetic puzzle verbal arithmetic puzzle
104 constant linear it. use * which - given return appears for one input: you once. space. output: 2: element three an except extra times every constraints: solution exactly array nums single implement complexity <= with 3 each must nums.length integer where in [2,2,3,2] 1 231 nums[i] example [0,1,0,1,0,1,99] 99 a find 1: and -231 the one, only = runtime single number ii single number ii single number ii single number ii single number ii
false of for any cell different left, cycle size lowercase there right), has are n last ends <= m, n, letters. visited [["a","a","a","a"],["a","b","b","a"],["a","b","b","a"],["a","a","a","a"]] (1, example consists a grid.length 500 that which exists if return one highlighted to value 2: adjacent also, starts m 4 from at english grid. 2d move. explanation: cells [["c","c","c","a"],["c","d","c","c"],["c","c","e","c"],["f","c","c","c"]] true find four length and cell, only need -> cycles - or valid directions your 3: array because it false. shown 1 down, image below: current characters more (up, the is output: we cell. grid[i].length given x grid you input: 2) constraints: colors [["a","b","b"],["b","z","b"],["b","b","a"]] can 1) cannot in invalid otherwise, same == move 1: example, path grid, two was consisting = detect cycles in 2d grid detect cycles in 2d grid detect cycles in 2d grid detect cycles in 2d grid detect cycles in 2d grid
104 >= arr[i of + any calls target. element arr[0] index, mountainarr, there [1,2,3,4,5,3,1], exist, be with <= arr.length index=5. i example a mountainarray.get(k) index=2 k 109 interface: -1 index will mountain_arr.length() problem.) that solutions directly. which exists result if return to attempt 2: < an making also, mountainarray 2 at some 3 judged explanation: mountain_arr.get(index) > mountain mountainarray.get arr[1] using length and circumvent only if: than - interactive -1. recall disqualification. exist array arr mountainarray.length() target 1] arr[arr.length access 1 problem not so such mountainarr.get(index) 100 more the is judge output: we = answer. 0 given arr[i] input: you 2. constraints: minimum (0-indexed). does that: ... [0,1,2,4,2,1], may returns array, cannot in == wrong (this 1: submissions array. find in mountain array find in mountain array find in mountain array find in mountain array find in mountain array
of num.length integers. there "777". empty contiguous digits. are be with <= integer. substring following leading example consists a "6777133339" no if return one 2: an integers: large maximum as 3 explanation: distinct "777" string zeroes length num largest, and meets only 3. or "000" "333". 3: string. "2300019" it "42352338" exists. so such sequence good therefore, characters the is output: conditions: we digit. given input: you 1000 note: constraints: representing "" unique within may integer in 1: two = largest 3-same-digit number in string largest 3-same-digit number in string largest 3-same-digit number in string largest 3-same-digit number in string largest 3-same-digit number in string
of this any product 30 on order. (product_id, 2019-08-18 following type example a price +---------------+---------+ table. that assume result return to products an prices 2 primary 10 row at +------------+-----------+-------------+ some before new_price name 3 column new 10. all 65 indicates table find 2019-08-16 | key format 50 date 20 changed 35 +------------+-------+ each 2019-08-16. 1 date. 2019-08-17 table: is the output: write input: 2019-08-14 2019-08-15 query sql example. change_date product_id in int 1: was change change_date) schema product price at a given date product price at a given date product price at a given date product price at a given date product price at a given date
write | that id varchar of key this result names return for lowercase. contains input: to output: format fix alice an rest 2 primary lowercase characters. query first ordered is sql example. are by name user_id. following in type bob column users 1 example int uppercase consists +----------------+---------+ user. so character user_id table +---------+-------+ 1: table: table. and the only schema fix names in a table fix names in a table fix names in a table fix names in a table fix names in a table
its b. follow-up: constant of this for space. } level extra [] there recursive '#' are pointers, end be with <= node, { example a *left; space node.val no connected assume use like if to [1,#,2,3,#,4,5,7,#] 2: null. (figure val; output a), as approach problem. nodes populate node pointers function explanation: [1,2,3,4,5,null,7] all level. count initially, binary only above tree struct just pointer should number -100 serialized your implicit by each set node. order not 100 stack the is range output: fine. point given next figure input: you 6000]. right constraints: does *next; [0, may in int root *right; 1: signifying = populating next right pointers in each node ii populating next right pointers in each node ii populating next right pointers in each node ii populating next right pointers in each node ii populating next right pointers in each node ii
>= of any for nums2. there i. are j). <= with i (3,4). (0,1), example a (4,4). (0,1). distance nums1.length nums2[j]. no nums1[i], if return [25,25,25,25,25] 2: < pairs, an (2,4), 2 non-increasing. every maximum (2,4). arr.length. [100,20,10,10,5] (2,2), indices explanation: pairs j), nums2.length arrays (0,0), and pair - [30,29,19,5], [10,10,1] (1,1). 105 valid 0-indexed (i, 3: array nums2.length, arr non-increasing 1 nums1 both 0. nums2 the is [2,2,2], output: 0 given arr[i] input: you [55,30,5,4,2], (3,4), constraints: nums1.length, integer where j nums2[j] arr[i-1] (2,3), 1: two (3,3), nums1[i] = maximum distance between a pair of values maximum distance between a pair of values maximum distance between a pair of values maximum distance between a pair of values maximum distance between a pair of values
its of this degree any 6 smallest element [2, has (contiguous) be repeated therefore non-empty frequency 50,000. example non-negative a [1,2,2,3,1,4,2] subarray, will that return one to 2: returning an 2 maximum input as elements 2, task 3 nums.length explanation: [1, find [1,2,2,3,1] subarrays length and 49,999. 6. times. [2,2,3,1,4,2] 2] elements. appear 1], subarray your array shortest because integers nums 3], possible 1 nums[i] degree: both so the is output: 0 given input: between 2. defined constraints: nums, have integer 3, same 2], nums. 1: twice. = degree of an array degree of an array degree of an array degree of an array degree of an array
smaller (1). 104 [-1,-1] of 0 -104 given return element. input: to 6 counts[i] 2: element an 1). 2 right number constraints: 105 nums, there 3: is array elements are nums nums[i]. <= nums.length integer where explanation: 1 nums[i] example 5 only [2,1,1,0] counts [0,0] 1: [-1] [0] (2 [5,2,6,1] and the output: = count of smaller numbers after self count of smaller numbers after self count of smaller numbers after self count of smaller numbers after self count of smaller numbers after self
most results get fourth 104 of 6669. better 9969. becomes given return any changing one (6 input: 6 you output: 9666. consisting positive 2: 9996 9999 to number. apply number constraints: first maximum third 9969 change. 3: at is digits. are 9669 can by last it <= 9, second integer digit in explanation: 1 example digits 6). not consists a 9699. 9 1: 9. num and the only = maximum 69 number maximum 69 number maximum 69 number maximum 69 number maximum 69 number
pill. 104 >= of workers, + workers. any for [0,0,0], magical complete. assigned has n last be with stored <= n, strength, must (i.e., example a having enough make pills workers[j], 109 tasks, will most that 10) requiring which return one to 2: workers.length requirement 2 m maximum 10 at completed. as worker's [5,4], single task 3 tasks[i] 3) explanation: 1. 5) tasks.length task. tasks[i]). arrays and [0,10,10,10,10], give only worker than tasks[i], * - or (10 number 0-indexed assign ith task's 3: 15) array because receive integers it by each strength. decide greater (3 1 5 not strength 0. the is output: 1, we 0 given input: you [0,3,3], follows: workers pill 2) constraints: equal [10,15,30], have can may strong pills, 1) (0 integer in [3,2,1], 3, jth additionally, however, == 1: workers[j] tasks increase = maximum number of tasks you can assign maximum number of tasks you can assign maximum number of tasks you can assign maximum number of tasks you can assign maximum number of tasks you can assign
(p2,p1,d2,d1) that the of + this (p2,p1,d1,d2), given return 90 500 modulo input: 2: 6 large, an 2 2. 7. constraints: pickup pickup(i). consist valid sequences delivery(i) 3: (p1,d1,p2,d2), unique because d1), (p1,p2,d1,d2), n too it (p1,p2,d2,d1), orders: may be 3 possible (p1, each delivery (p2,d2,p1,d1). (p1,d2,p2,d1) pickup/delivery <= since in after answer order explanation: 1 invalid example 1. all always services. such 10^9 count 1: and is output: = orders, count all valid pickup and delivery options count all valid pickup and delivery options count all valid pickup and delivery options count all valid pickup and delivery options count all valid pickup and delivery options
= 104 that than the of times. this 'b' given return or "aaabb", input: to 2: "ababbc", "aaa", an 2 times lowercase constraints: equal 105 is as k. 'a' english s <= 3 each repeated "ababb", letters. integer in greater s.length explanation: 1 frequency example 5 consists a only string such character 1: k length and longest output: substring k, longest substring with at least k repeating characters longest substring with at least k repeating characters longest substring with at least k repeating characters longest substring with at least k repeating characters longest substring with at least k repeating characters
of nums[i], this any [3,1,3,2,4,3] integers. alternating. are n <= operations be integer. array. i note example a make [3,1,3,1,3,1]. index that which nums[i return [1,2,2,2,2] one to 2: an 2 way != 3 nums.length explanation: 1. required proven conditions and if: 3. than into - alternating positive nums[1] 2] number 105 0-indexed array operations. converting because case nums it 1] by possible 1 nums[i] not operation, converted called the is output: less violates [1,2,1,2,1]. given choose input: you 2. constraints: minimum [2,2,2,2,2] can cannot nums[0] where in == 1: consisting change = minimum operations to make the array alternating minimum operations to make the array alternating minimum operations to make the array alternating minimum operations to make the array alternating minimum operations to make the array alternating
false computing of + for derived.length [1,0] there derived n are <= with original[2] i whether example a (⊕) determine index that no exists if return to derived[1] 2: adjacent 0's an specifically, task either explanation: derived[2] true original length and only binary [1,1] [0,1,0]. - or 1's original[1] derived[i] formed n. original[0]. 0-indexed valid otherwise. 105 3: your then array [0,1]. by original[i each derived[0] 1 xor gives ⊕ such is the range output: 1, 1]. derived, 0 values given input: containing constraints: have [1,1,0] [0, original[0] in original[i] otherwise, bitwise == derived. 1: could 1]: = neighboring bitwise xor neighboring bitwise xor neighboring bitwise xor neighboring bitwise xor neighboring bitwise xor
false 104 "aa", of for lowercase "cbad". are goal.length goal, <= swapping letters. 'b', s.length, i example s[0] (0-indexed) "ba" letters "ba", "aa" that which result return if to 2: 2 "ab" at as 'a' != indices explanation: true and only results * 'b' s[j]. 3: taking "abcd" false. s 1 so s[i] such characters the is output: get 0 given input: you goal defined constraints: equal consist swap s[1] can "ab", in j otherwise, goal. strings 1: example, two = buddy strings buddy strings buddy strings buddy strings buddy strings
write 104 that * given return input: you o(n) space. 2: algorithm [1,10,11,12,13,2,3,4,5,6,7,8,9] an extra time 2 constraints: order. n uses o(1) <= lexicographical n, must runs integer in [1,2] 1 13 example 5 [1, all numbers n] 1: sorted and the range output: = lexicographical numbers lexicographical numbers lexicographical numbers lexicographical numbers lexicographical numbers
19, of + 11. [2,1,3,4,5] endi among [1,2,3,4,5,10], for modulo requests.length 7. do. requests[1] [starti, result: asks are n 8 be with <= [19,18,10]. following since example a best [[0,1]] nums[endi 109 requests[i] [3,5,4,2,1] that sums nums[3] which return one 2: < an 2 4 maximum total 3 nums.length explanation: all [1,2,3,4,5], requests[0] and sum: -> permutations nums[starti - permutation higher large, starti nums[1] [4,10,5,3,2,1] 19 105 ith 3: array [1,2,3,4,5,6], requests [11]. [6,5,4,3,2,1] nums it 1] endi]. nums[starti] sum answer 1 nums[i] 5 nums[2] both requests[i].length [[1,3],[0,1]] 0-indexed. is the output: we 0 input: you [[0,2],[1,3],[1,1]] request constraints: nums, have ... max too can may integers, nums[0] where 11 == nums. 47 1: nums[endi]. = maximum sum obtained of any permutation maximum sum obtained of any permutation maximum sum obtained of any permutation maximum sum obtained of any permutation maximum sum obtained of any permutation
its of tree. this + on has be <= guaranteed example a [1,2,5,3,4,6,7] 109 node.val d, that search if return one value to 2: output traversal, at nodes node child. 1000]. 1. recover [1, "1-2--3--4-5--6--7" original node), and only binary tree number 3: (where then immediate each node. 1 (dfs) 0. preorder is the range output: we dashes depth-first "1-401--349---90--88" child given input: root. [1,2,5,3,null,6,null,4,null,7] [1,401,null,349,88,90] traversal constraints: depth in child, "1-2--3---4-5--6---7" root run left 1: d = recover a tree from preorder traversal recover a tree from preorder traversal recover a tree from preorder traversal recover a tree from preorder traversal recover a tree from preorder traversal
104 of for unique. nums[1], 5000 there are [4,5,6,7,0,1,2]. <= be with must after complexity. n) example nums.length) rotated. k target, [4,5,6,7,0,1,2], -1 index rotated that return if rotation to 2: < an nums[k+1], 4 [0,1,2,4,5,6,7] at being 3 nums.length distinct all and -104 or ascending passed algorithm possibly resulting 3: your array nums[n-1], ..., target nums it unknown nums[0], possible might order 1 o(log (with nums[i] not values). prior such nums[k-1]] (1 the is pivot output: write 0 [1], values given input: you constraints: (0-indexed). nums, function, [nums[k], integer in nums. become example, 1: sorted = runtime search in rotated sorted array search in rotated sorted array search in rotated sorted array search in rotated sorted array search in rotated sorted array
false of undirected this degree there obtain n are be with <= numbered repeated [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]] ai, edges. example a adding ai make (possibly edges most edges.length that no graph connected it. return if bi] to 2: an 2 way every from at nodes node != 3 2d self-loops. edge explanation: bi. true indicates and above shows additional edges[i].length number resulting n. 5, valid 105 3: array add even it false. diagram possible each edges[i] even, 1 not so none) [[1,2],[1,3],[1,4]] is the output: edge. given input: you [ai, 4, disconnected. between constraints: bi can [[1,2],[3,4]] integer where in == otherwise 1: two consisting = add edges to make degrees of all nodes even add edges to make degrees of all nodes even add edges to make degrees of all nodes even add edges to make degrees of all nodes even add edges to make degrees of all nodes even
its of this for "2". there has k. contiguous are be <= integer. substring digit note example digits a 9 k 109 interpreted -1 no exists, that "54", substring. result return if one to value 2: an 4 from exactly as when explanation: part substrings. 1. "238182", "6", string and 60 '9'. if: than into or substrings 60. -1. s. number 105 string. partition it s each s.length 1 shown 5 s[i] "123" sequence good called characters the is output: we less "165462", given input: you "16", constraints: equal minimum '1' that: can within 123 cannot integer in 1: example, "1" consisting = partition string into substrings with values at most k partition string into substrings with values at most k partition string into substrings with values at most k partition string into substrings with values at most k partition string into substrings with values at most k
its red 104 lower of [null, calls matrix) design [2, 5], on row2 n 8 o(1) <= with m, be must following calculate complexity. example [4, a blue rectangle) corner (row1, matrix, matrix[i][j] most will type: (i.e return to sumregion(int < an [5, m output matrix input col1) at explanation 0, elements implement 2, nummatrix.sumregion(2, 2d 12 5]]); nummatrix.sumregion(1, nummatrix new [1, 12] nummatrix([[3, matrix.length nummatrix(int[][] col1 col2). and inside -104 11, matrix. handle object [[[[3, 200 algorithm 8, rectangle time "sumregion", class: works 1], 5]]], sumregion row2, col2) sumregion. (row2, by 3], sum 4); 1 row1, matrix[i].length the col2 1, "sumregion"] made 2); 3); 0 initializes given you 4, queries defined col1, right constraints: 4]] 6, returns green integer where ["nummatrix", 7], // 3, 11 upper int 2], == left multiple row1 1: = range sum query 2d - immutable range sum query 2d - immutable range sum query 2d - immutable range sum query 2d - immutable range sum query 2d - immutable
104 of coins x. coins[i] [] are n 8 <= with following note example 5: value. make [4,1,1] that which if return value to 2: an 2 4 up maximum from 7: some [1,1,1,4] take [1,3] coins[i]. explanation: 6: length and [1,1] * - [1] [4,1,1,1] 20 number ith your their 3: array values: own. nums sum 1 [1,1,1] such 0. 0: the is output: consecutive values given choose x input: you [1,4,10,3,1] 4: coin constraints: have including can may integer coins.length same == [4] starting represents multiple [4,1] 1: = maximum number of consecutive values you can make maximum number of consecutive values you can make maximum number of consecutive values you can make maximum number of consecutive values you can make maximum number of consecutive values you can make
point of + 0 given return for input: altitude you different < 2: an biker between altitudes. starts [-4,-3,-2,-1,4,3,2] gain constraints: his equal trip -100 [0,-4,-7,-9,-10,-6,-3,-1]. there on road at is array points gain[i] altitudes going n are trip. <= with [0,-5,-4,1,1,-6]. (0 integer where in i explanation: 1 highest example 1. consists all a == net [-5,1,5,0,-7] point. n). 0. 1: gain.length 100 length and the output: = find the highest altitude find the highest altitude find the highest altitude find the highest altitude find the highest altitude
less tenth what text that is: just assume than of lines, least which given if file.txt, contains 6 you different line to note: three 2 should 2. output? 4 print there's output 7 file 10 script your has at possibilities. 8 try 3 following 1 1. 5 file.txt solutions. all a file. content: 9 line, example: the 10th explore tenth line tenth line tenth line tenth line tenth line
of + for are n 8 <= (nums1[n 4) after example [3,2,1] nums2[1]) nums1.length nums2[i] that minimized. 1]) nums1[i], 4. becomes return to 2: 2 4 (nums1[1] elements [3,2]. [1,0,3], [5,3,4] 3) explanation: nums2.length 5) arrays length and (2 - resulting n. [5,4,3]. 14 it nums2[0]) 1] nums2[n sum (3 [2,3] 1 xor nums1 [1,2,3] so such nums2 (1 the is output: 0 given input: you 2) 2. constraints: equal (0-indexed). rearrange ... rearrangement. 1) (0 integer 8. == 107 (nums1[0] 1: example, two [1,2], = minimum xor sum of two arrays minimum xor sum of two arrays minimum xor sum of two arrays minimum xor sum of two arrays minimum xor sum of two arrays
(inclusive). 4] 3] lower of hidden[i]. + for [3, 7] 6 element sequences. 5] sequences there differences.length [3,-4,5,1,-2], are n <= since hidden, example [4, a sequences, differences[i] -4, that no which 4. return if 2: an 1). 2 [5, 4 -2, describes elements 0, -1, 2, explanation: [1, upper] contain. length and 6] hidden[i differences than 6. pair - contains 2] number [-3, are. hidden 0-indexed 5, 105 3: whose then array [1,-3,4], integers differences, it 1] possible each greater correct. 1 further not 5 sequence [-1, 4], 0. more thus, is the range output: 1, we consecutive inclusive [4,-7,2], 0 values given input: you [-2, 4, between 2. 0] (n constraints: have describe 6, -3, can [0, [lower, call -105 in are: 3, upper formally, == 1: example, two = count the hidden sequences count the hidden sequences count the hidden sequences count the hidden sequences count the hidden sequences
its car. of per liters refueling reaches target. left, destination. arrived. first [] there refueling. has are position. <= with must considered 10, note example fueli] gas. a make 109 [positioni, target, -1 500 stops that fuel it. station, which position stations way. return one if to tank without 2: < an 2 stations.length starts way, from 10 still as when gas, positioni+1 start infinite explanation: all indicates along and 60 uses (expending (or drive station destination, station). into stop miles fueli 50 -1. [[10,100]] there. number ith 3: fuel), then array drives. target even it 100, order 1 not so liter the is refuel output: 1, we [[10,60],[20,30],[30,30],[60,40]] made stations[i] travels destination 0 east input: 2. represented constraints: minimum have gas mile refuel, may can then, cannot positioni where in transferring initially startfuel starting car 1: expending reach fuel. = minimum number of refueling stops minimum number of refueling stops minimum number of refueling stops minimum number of refueling stops minimum number of refueling stops
initialize countintervals(); 3] intervals of void [null, count() calls 6 8] left, data present [2, denotes []] [7, empty adds are 8 <= with be "count", 8); note example a right) 9 109 countintervals.add(2, most will that return one countintervals to structure "count"] an "add", 2 can: [5, output interval 10 input [[], total at countintervals.add(7, explanation null, [left, implement 3 9, 10); intervals. new all countintervals.add(5, count 3]. and right] 8], intervals, least interval. object 8, class: number 105 add countintervals.count(); integers 10] 3], set 7, 1 count. 5 right. countintervals() the made 3); initializes given x add(int right constraints: 10]. 7 8]. 10], 6, returns call ["countintervals", in where // int left 1: [], = count integers in intervals count integers in intervals count integers in intervals count integers in intervals count integers in intervals
(2, varchar 1500 of this vice salary for any select d) 'm'. about with must following type (1, note (i.e., example a table. 500 tables. no that c) id +-------------+----------+ versa) result value to an 2500 2 +----+------+-----+--------+ primary m b 4 from b) ('m', problem. 'f'). single name 3 update column explanation: all table and | key contains format 'f' changed information enum intermediate 1 not table: 'm' is the output: write statement, sex values a) input: you 'f'. query swap sql example. employee. statement f do in (4, were 5500 int c 1: temporary change d (3, schema swap salary swap salary swap salary swap salary swap salary
of this for element nums[4] there removing has appeared are <= considered after prefix example [2,2,1,1,5,3,3] will that no remove return if one to 2: [2,2,1,1,3,3], remaining an 2 every from still exactly nums.length explanation: [1,1,1,2,2,2,3,3,3,4,4,4,5] length positive number elements, appear 105 5, subarray array nums it possible each it's 7, 1 13 nums[i] so [2,2,1,1,5,3,3,5] such the longest is output: we get given input: ocurrences constraints: (0). 7 nums, have integers, in same occurrences. 1: twice. = maximum equal frequency maximum equal frequency maximum equal frequency maximum equal frequency maximum equal frequency
its false tree node.val recursively the of given up: input: output: 2: you around mirror constraints: number -100 iteratively? [1,2,2,null,3,null,3] solve nodes it [1,2,2,3,4,4,3] <= follow 1000]. in itself tree, whether example center). (i.e., root [1, a both true 1: 100 check binary could and is range symmetric = symmetric tree symmetric tree symmetric tree symmetric tree symmetric tree
of [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]] smallest order. 30], <= 10, nums[i][j] example [4, [a, a [20,24]. k nums[i].length smaller that if one 24 2: < 22, [5, b from lists. at includes define 15, 9, nums.length explanation: find [[1,2,3],[1,2,3],[1,2,3]] least than [1,1] [c, d - or 20], 3500 50 c. 20 number 105 12, 3: integers nums each 1 nums[i] list 22 is the range output: we non-decreasing b] input: you d] constraints: have [0, -105 in 18, lists c == 1: 24,26], sorted [20,24] = smallest range covering elements from k lists smallest range covering elements from k lists smallest range covering elements from k lists smallest range covering elements from k lists smallest range covering elements from k lists
subtraction. constant of "5*c", valid. + chunk degree for ["e", any ' space. "2x" temperature largest lowercase {"e": digits.) our [] has "temperature"], evalvars[i].length "3*a*a*b", expressions are 8 variable be with <= integer. '+', letters. leading "-x". note (not non-negative example evalvars[i] consists a space (if letters []. included. variable, ["-2*a*a*a", [-231, ["e"], spaces. evalvars.length 5", pressure", will directly that breaking "0" assume like 4. return '(', ["e"] to 2: '*', (given terms an "1 2 "b*a*c", output simplified separating non-zero "a*a*b*c" "a*b*c". from coefficient still as map well-formatted brackets '. english single being either evaluation terms) "-6"]. degrees ties [1, all coefficient, always 12] string ["1*e*e","-64"] and expression.length only they "(e expression, results alternates letters, 3" ["7"]. '-', * - ["-1*a","14"] or variables ignoring [1] format term expression [1]), unary lexicographic 20 number (e -100 5" exist.) 3: (including then asterisk contain 8) it by evaluated each intermediate trailing answer order 1 1} tokens multiplied, not list such 100 is the range output: we first, write 1]. ["-1*pressure","5"] separated evalints[i] multiplicity. symbols, usual 0 given digits, never follows: lexicographically. you input: note: addition operator ')', constraints: "e equal free representing would printed. "3*b*b", have 250 does term. including multiplication, can within may evalints 8)", evalints.length in 231 chunks placed parentheses, "4*a", evalvars == order: counting left multiple 1: example, [], sorted symbol. = basic calculator iv basic calculator iv basic calculator iv basic calculator iv basic calculator iv
of this right, 6 8] left, 9] steps [2, first on order. n end last <= arr. n, following but example a 9 109 afterward that remove return to 2: remaining every from until single 2, increasing explanation: [1, all repeat keep and 6] alternating algorithm 8, apply other time number 5, again, arr: arr integers 7, 1 list n] the range output: step given numbers. input: you repeating 4, right rightmost constraints: strictly have remains. 6, [6] integer in previous 3, starting left 1: sorted reach list. = remains elimination game elimination game elimination game elimination game elimination game
tree node.val of [4,2,6,1,3] tree. this 0 search values given return any (bst), input: output: 2: different note: between question constraints: number [2, 105 minimum https://leetcode.com/problems/minimum-distance-between-bst-nodes/ 104]. is as nodes 783: <= difference in 1 example same root absolute a [1,0,48,null,null,12,49] 1: two the range binary = minimum absolute difference in bst minimum absolute difference in bst minimum absolute difference in bst minimum absolute difference in bst minimum absolute difference in bst
salesperson red alex varchar of who this commission_rate john names salary for any hire 6 65000 5000 about order. 25000 with 4/1/2014 following type foreign 50000 yellow example order_date a did +-------------+------+ order, table. 2/1/2014 orders city orange that id which result return one +----------+------+--------+-----------------+------------+ sales_id to an 2 primary 4 austin from 10 row includes tell mark 5/1/2010 name 3 order_id 12 column explanation: new table, all 12000 hire_date indicates table sales easy and only | key alongside contains +----------+------------+--------+----------+--------+ format pam date other information amount their +------+ salespersons "red". salary, +-------------+---------+ 4/1/2006 it amy salesperson. each 1 not date. located. 5 boston so related table: 1/1/2005 the is output: we write company salesperson, company, input: 2/3/2007 red, 25 3/1/2014 com_id commission 12/25/2008 rate, 1/1/2014 query 100000 report have sql example. york green in according int 10000 1: +--------+--------+----------+ +-----------------+---------+ paid. schema sales person sales person sales person sales person sales person
104 of even-indexed odd + for any 6 [2,1,6,4] there removing are <= after choosing example (0-indexed) a make removal, [6,1,7,4,1]: index that remove if fair return one to 2: remaining an 2 4 [6,7,4,1]. exactly elements 3 [2,1,4] nums.length indices explanation: 1. [2,1,6] and [6,1,7,4]. sum: results -> 6. [2,6,4] number equals 105 3: array even index. nums sum 1 nums[i] not [6,1,4,1]. [1,1,1] [1,2,3] such 0: is the output: [1,6,4] fair. 0 values given choose element. input: you notice constraints: can may removal. cannot integer in odd-indexed 8. nums. values. 1: example, could change 5. = ways to make a fair array ways to make a fair array ways to make a fair array ways to make a fair array ways to make a fair array
determined is: nextvisit of odd visit), + lower visit very this for coming modulo 6 n: nextvisit[0] day. 7. first there on go are n (i [0,0,1,1,2,2,3,...]. <= with be following since i example day a labeled, 109 even. will [0,0,2] that days which if return one nextvisit.length to 2: an 2 times from total 0, 2, explanation: 1. all nextvisit[i] labeled length and need - or [0,0,1,0,0,1,2,...]. label large, number n. 105 0-indexed 3: your (including array assuming specified even it by been each exists. answer order shown 1 rules such current [0,1,2,0] 0. the is output: visit, 1, 0 given next input: you mod rooms. constraints: equal odd. have rooms i; can may visiting 1) (0 in where day, room initially == starting [0,0] 1: = i, first day where you have been in all the rooms first day where you have been in all the rooms first day where you have been in all the rooms first day where you have been in all the rooms first day where you have been in all the rooms
of + 6 largest level levels there on k. are n 8 <= tree, note (not example a 9 k distance node.val that sums return if 2: 2 4 fewer from nodes 2nd 3 explanation: 10. level. following: and they binary tree [5,8,9,2,1,3,7,4,6], 3. than - 106 positive -1. number n. 105 3: sum 17. necessarily 1 13 13. the [1,2,null,3], is output: values given input: you root. 4: distinct). constraints: 7 have kth integer in same root 1: two 5. = kth largest sum in a binary tree kth largest sum in a binary tree kth largest sum in a binary tree kth largest sum in a binary tree kth largest sum in a binary tree
011111, get the of 0 if given or changing return 1's input: you to output: 2: 00000000. 0's none). s. 2 "00011000" flip number possibly constraints: 105 minimum from "00110" 000111. 3: some are it (also by can s last 00111. alternatively <= either increasing '0' digit s.length monotone '1'. explanation: 1 none), flips example consists followed a "010110" string s[i] (possibly make 0. 1: increasing. is binary = we flip string to monotone increasing flip string to monotone increasing flip string to monotone increasing flip string to monotone increasing flip string to monotone increasing
of this for unique. longer can. lowercase "bb" removing on are be <= letters. since choosing after final example consists a make letters removal "aa" no that remove which result return 2: adjacent made. until english move. explanation: all proven string "aaca", and only "ca". "ca" equal, 105 possible, them. it s been possible s.length answer 1 so such "ay" the is output: we given duplicate you input: constraints: removals equal "azxxzy" have can in move 1: example, two could consisting = "abbaca" repeatedly remove all adjacent duplicates in string remove all adjacent duplicates in string remove all adjacent duplicates in string remove all adjacent duplicates in string remove all adjacent duplicates in string
[[1,2,3],[4,5,6],[7,8,9]] of 211 + [7] for 6 biggest there order. are n 8 be with corresponding <= m, must green: note example a regular 9 grid.length rotated bottom (area that [[7,7,7]] sums middle) which return if square 2: above. shapes three an 2 m 4 matrix 10 0, elements border 3 values, degrees distinct explanation: corners cells all 216 four [20,9,8] purple sum: depicted descending than - 200 50 red: centered should 20 105 valid them. shape 3: rhombus included by possible each sum 1 image colored 5 [[3,4,5,1,3],[3,3,4,2,3],[20,30,200,40,10],[1,5,5,4,1],[4,3,2,2,5]] so form corner) corner. [7]. the is output: less blue: cell. grid[i].length 228 0 given x grid you input: 45 right constraints: have [228,216,211] same, can below integer in grid[i][j] area == 1: grid. = get biggest three rhombus sums in a grid get biggest three rhombus sums in a grid get biggest three rhombus sums in a grid get biggest three rhombus sums in a grid get biggest three rhombus sums in a grid
none of who ten element first denotes about there over are last <= older following '0' person. ["1313579440f2036","2921522980m5644"] example digits consists a numbers seat character ages people determine gender compressed that 92, return to 2: 40. 'o'. 2 from at 0, details[i][10] used years either indices explanation: age string details. length 60 and 15 '9'. details.length than into or system details[i].length 60. 'f' number information 0-indexed provides array each indicate old. 1 distinct. such 100 characters 'm' more thus, is the output: 1, details[i] details allotted 0 given next input: you 15. constraints: consist strictly 75, have passengers that: phone passengers. strings == passenger 1: ["7868190130m7522","5303914400f9211","9273338290f4010"] two = number of senior citizens number of senior citizens number of senior citizens number of senior citizens number of senior citizens
will command.length that -> o own of and/or "goal". "(al)" parser's result "al". given return "(al)g(al)()()g" input: you follows: 2: goal an "o", command, interpretation "goal" constraints: interprets interpret "()" 3: "algaloog" order. then is as alphabet some "g()()()()(al)" are "()", al can concatenated <= "g" command in explanation: 1 final example g strings consists a (al) "g", string original command. 1: 100 and interpreted "g()(al)" the () output: = parser "gooooal" goal parser interpretation goal parser interpretation goal parser interpretation goal parser interpretation goal parser interpretation
that the of which 0 given return appears for one [1,1,2,3,3,4,4,8,8] input: you once. space. output: 2: element twice, except time 2 every constraints: solution 105 10 your exactly array integers are single nums o(1) <= must nums.length where in 1 o(log n) example nums[i] a [3,3,7,7,10,11,11] run 1: sorted and consisting only = single element in a sorted array single element in a sorted array single element in a sorted array single element in a sorted array single element in a sorted array
departments. varchar +-------------+---------------+--------------+ of who this for any employees department_id) employee_id flag y primary_flag order. n with following type note example +---------------+---------+ table. belongs. 'y', that department id (employee_id, which result if return one to an 2 department, primary departments, 4 when name 3 column explanation: 1. all table they only | 3. need key - format other joins their enum decide 1 not table: is the output: ('y', write primary. belongs belong department. input: employee query report department_id sql example. employee. can 'n'. 'n', in +-------------+---------------+ int 'n'). multiple 1: schema primary department for each employee primary department for each employee primary department for each employee primary department for each employee primary department for each employee
its constant of [1,3,2], for rearranged extra [3,2,1]. [2, [1,3,2]. order. larger are be <= integer. must following (i.e., example [3,2,1] a order, [3,1,2]. [3,1,2], [2,3,1] that linear use follows if one to 2: an similarly, replacement as container [1,1,5] nums.length all lowest find and only place into permutations or ascending permutation 1], possible, their 3: members then array arr: because arr integers nums it 3], possible order). [1,5,1] greater order 1 nums[i] [1,2,3], not [1,2,3] lexicographically such sequence 100 more the is output: 1, [1,3,2] 0 given next input: constraints: arrangement memory. nums, have does container. rearrangement. lexicographical in according 3, formally, while nums. 1: example, sorted = next permutation next permutation next permutation next permutation next permutation
robbed. of who + capability robber how house. max(nums[1], there has are robber, <= nums[3]) but example a also k 109 index nums[2]) k, will homes, several street, house which 4. return one to 2: houses adjacent three an 2 way maximum from at rob some from. 9, nums.length indices explanation: all always out steals homes. along and 3. least refuses [2,3,5,9], - much dollars. money houses. [2,7,9,3,1], number 105 amount stashed ith array wants nums it 1)/2 possible steal each 1 nums[i] 5 min(5, 9) therefore, 9. more the is output: consecutive we 0 ways given input: you nums[4]) max(nums[0], 2. constraints: representing minimum 7 he integer in inside. formally, (nums.length left leads 1: houses: 5. = house robber iv house robber iv house robber iv house robber iv house robber iv
4] 3] of numbers, [3, smallest element [2, first [] has [3] are end operations <= array. following operation denoting example [4, make 109 remove if return to 2: an 2 4 until at -1, perform 3 nums.length [3,4,-1] distinct value, all takes and number 105 3: array nums it empty: 1 nums[i] 5 distinct. [1,2,3] [-1, empty. the is [1,2,4,3] output: values given -109 input: you put 4, containing constraints: can integer in otherwise, 3, [4] 1: = make array empty make array empty make array empty make array empty make array empty
false 104 of this any unique. [1,4], [[1,2],[1,3],[2,3]] first has go n are everyone <= n) example a ai bi, people that person like return if way. bi] to 2: < 2 from at [[1,2],[1,3],[2,4]] some 2000 3 people, explanation: dislikes[i].length them (labeled pairs all true indicates want labeled and groups. they least need into dislike other should split them. [2,3]. array it possible each 1 groups not divide is the output: we group. 0 given input: dislikes.length [ai, put dislikes[i] 4, constraints: bi size. does group may cannot second integer where in 3, same == dislikes 1: two = possible bipartition possible bipartition possible bipartition possible bipartition possible bipartition
its = lucky that no of given return if numbers, 500 arr[i] input: to 2: arr, largest -1. an 2 2. [2,2,2,3,3] number constraints: equal them. there 3: has is array because arr integers frequency[2] are <= 3 [2,2,3,4] [1,2,2,3,3,3] arr.length integer in explanation: 1 frequency example value. all a only == numbers 1: and the -1 output: array. 1, find lucky integer in an array find lucky integer in an array find lucky integer in an array find lucky integer in an array find lucky integer in an array
red of any on. 4-directionally image[i][j] color on n are (also <= with m, consider after (1, note example (i.e., [[0,0,0],[0,0,0]], also a sr blue corner modified [[1,1,1],[1,1,0],[1,0,1]], image. bottom (sr, no connected position return value to sc 2: aforementioned < three an 2 m image[i].length from changes as sc) 0, 2, plus perform pixels) pixel. explanation: new fill, all 216 flood already and color), 50 should [[0,0,0],[0,0,0]] fill. [[2,2,2],[2,2,0],[2,0,1]] image[sr][sc]. because integers center it by replace pixel), 1 image colored not image.length so those pixel color. is the output: 1, sc, made pixels 0 given grid x you input: image[i][j], represented constraints: 1) integer where sr, same fill == starting represents 1: pixel, path performing = flood fill flood fill flood fill flood fill flood fill
= 104 it. the * of this - + 1]| given 0 for any becomes input: value you to < once. output: select 2: an defined 68 constraints: maximum 105 10 subarray [2,5,1,3,4] whose array as are nums can by <= perform possible 3 nums.length sum operation array. integer -105 i explanation: [2,3,1,5,4] final 1 nums[i] 1. example 10. all allowed reversing nums. [3,1,5] find 1: and [2,4,9,24,2,1,10] is |nums[i] only nums[i reverse reverse subarray to maximize array value reverse subarray to maximize array value reverse subarray to maximize array value reverse subarray to maximize array value reverse subarray to maximize array value
divides 3. that [3,3] of divisor given return numbers. input: 2: smallest positive 1000 largest an 2 2. evenly number constraints: nums, 10 3: is greatest array nums 8 <= 3 nums.length integer in explanation: 1 nums[i] example 10. 1. 8. common numbers both nums. [2,5,6,9,10] 1: two and [7,5,6,8,3] the output: = find greatest common divisor of array find greatest common divisor of array find greatest common divisor of array find greatest common divisor of array find greatest common divisor of array
= 6. transformed of * into - 0 doubled given return if any one or returned value input: changed, 2: shuffling element other an 2 2. every 4 constraints: changed resulting 105 [4,3,1] [] 3: order. [1,3,4,2,6,8] is array then elements empty by may be [1,3,4] possible randomly array, 3 <= [6,3,0,1] integer in explanation: 1 [1,3,4]: example [3,1,4]. not changed.length a 8. [1] original changed[i] 1: twice arrays could and original, the appending output: array. find original array from doubled array find original array from doubled array find original array from doubled array find original array from doubled array find original array from doubled array
of who names for any unique. saves "bob" day. lowercase keyname.length are be <= letters. considered example a use. doors. keytime[i]] that use if security 24-hour keyname "23:51" return to 2: key-card, three an [keyname[i], times "11:00"). keyname[i] ("21:00","21:20", 10 keytime.length as worker's when single used person's sort name english 3 period, ["daniel","daniel","daniel","luis","luis","luis","luis"], explanation: ["10:00","10:40","11:00","09:00","11:00","13:00","15:00"] leetcode corresponds and uses only "09:49". worker office keycard - "21:30"). or system ascending contains format time "hh:mm", 105 period. their emits it "10:00" key-cards each one-hour access alert keytime order frequent 1 not list such more key-card the is unlock output: company received period given keyname.length, was you input: notice workers ["alice","alice","alice","bob","bob","bob","bob"], keytime[i] constraints: ["12:01","12:00","18:00","21:00","21:20","21:30","23:00"] unique "23:52" within used. ["bob"] in where ("10:00","10:40", keyname[i].length strings while == "11:00" 1: "hh:mm". ["daniel"] alphabetically. "daniel" = "22:51" alert using same key-card three or more times in a one hour period alert using same key-card three or more times in a one hour period alert using same key-card three or more times in a one hour period alert using same key-card three or more times in a one hour period alert using same key-card three or more times in a one hour period
sum([4,6]) min([4,6]) of very + for product 213 modulo 6 sum([1,2]) 7. min([1,2]) min([3,1,2]) denotes has wizards' sum([3]) contiguous [3] are [3,1,2] ruler strength), be sum([3,1,2]) <= min([1,3]) strength, non-empty following array. since strengths example a individual 9 109 36 sum([3,1]) min([2]) return [1,3,1] sum([4]) 2: [4,6] an wizard strength.length 2 min([6]) 4 kingdom, from 10 total at as elements 3 [1,3] [5,4,6] explanation: [1,2] sum([1,3]) wizards: all [5,4] 15 60 sum([1,3,1,2]) min([4]) wizards. * - [1] min([5]) sum([1]) large, [1,3,1,2] weakest 105 0-indexed ith your subarray array values: sum([5,4]) it min([1]) sum answer 213. 1 min([5,4,6]) groups strength[i] [2] strength 5 [5] form min([1,3,1,2]) sequence min([1,3,1]) is the output: group. 40 given input: you 44 army 25 (i.e. sum([5]) defined wizards constraints: sum([2]) 7 min([5,4]) have [6] group within may sum([5,4,6]) 16 integer where in sum([6]) [4] [3,1] wizard. command. sum([1,3,1]) 44. 1: min([3]) two min([3,1]) = sum of total strength of wizards sum of total strength of wizards sum of total strength of wizards sum of total strength of wizards sum of total strength of wizards
its of [2,2], tree. undirected + endi any for 6 7. trip first denotes 23. there price. on has [starti, prices. trips, n are proven, be with <= trips.length integer. after choosing ai, example a ai 1st price half. edges edges.length trips. that [[0,3],[2,1],[2,3]] exists 3rd return trip, bi] to 2: non-adjacent an prices making 2 from 10 total at 0, some before nodes 2nd node 2, perform 3 start 2d endi] edge explanation: part 1. 10. all indicates length and associated above tree shows initial 6. - [[0,1]], 50 23 starti trips[i] valid [0]. ith your their [2,1,3]. array even it diagram by each edges[i] sum node. answer 1 5 0. [[0,1],[1,2],[1,3]], 100 indexed is path. the output: [0,1,3]. 1, we unrooted 0 given like. choose achieve. starti, input: you [[0,0]] [ai, [2,1]. 1000 4, between 2. constraints: bi minimum 7 lying price.length price, halve can [2,2,10,6], second integer where in trips rooting 3, additionally, == price[i] travel represents 1: path performing = minimize the total price of the trips minimize the total price of the trips minimize the total price of the trips minimize the total price of the trips minimize the total price of the trips
false [false,true,false,false,false] of this + queries[i] word any lowercase characters. "foba" queries.length be <= letters. example "ba" a "b" "framebuffer" letters character "fo" "oo" that "est". like position return if 2: "football" an "oot" "ll". at english queries[i].length "t" explanation: string true generated query. "foobar" and "uffer". ["foobar","foobartest","football","framebuffer","forcefeedback"], "f" "r" "fobat" pattern, equals otherwise. 3: array it "o" [true,false,true,true,false] each answer 1 answer[i] not "r". so 100 "all". the is output: [true,false,true,false,false] "rame" "foobartest" pattern.length, given input: you insert pattern queries constraints: query consist boolean matches "ot" can may where strings "fb" "ar". 1: = camelcase matching camelcase matching camelcase matching camelcase matching camelcase matching
of queries[i] ["kite","kite","kite","hare","hare","hear","hear","keti","keet","keto"] word for precedence any errors: rules: 5000 first has wordlist.length, empty queries.length 'u') <= with 'i', individually, under following letters. after vowels example wordlist. handles a errors, (case-sensitive), that checker capitlization, no spellchecker converts if "yeellow": return to mistakes: 2: 'o', ["yellow"], up exactly ["kite","kite","kite","hare","hare","","","kite","","kite"] as some when implement english queries[i].length wordlist[i] wordlist[i].length, wordlist, correct word, want 'e', and ["kite","kite","hare","hare"], only "yellow": vowel answer, into (case-insensitive), word. (no should then "yollow": string. capitalization: case it 1 answer[i] operates list such "yellow" is the queries, output: we wordlist replacing words given returned you input: addition, "yllw": ["yellow"] queries constraints: query consist 7 "" spell matches in where spelling same match categories match) back. queries[i]. 1: two example: = ('a', vowel spellchecker vowel spellchecker vowel spellchecker vowel spellchecker vowel spellchecker
(2, no bad the of pair - 0 4. given if return [1,2,3,4,5] input: you nums[j] 2: < -1. 4, pairs, 2) 2 2. number constraints: 105 0-indexed (i, [4,1,3,3] there total array are nums pairs. != nums[i]. 3 <= 1) nums.length 3) integer j indices i in explanation: since 1 (1, pairs example 3, 5 (0, nums[i] a j) nums. so 1: 0. 109 and is 5. output: = 1, we count number of bad pairs count number of bad pairs count number of bad pairs count number of bad pairs count number of bad pairs
its 104 linked none of any for random_index] (range y. [[3,null],[3,0],[3,null]] y there has input/output n are y, be corresponding <= head list, random_index: example a [val, index node.val will that which if return code to value 2: null. an from --> exactly as some nodes node pointers new pointer, where: n-1) original copy length and -104 only null pair pointer or contains state. x.random [[7,null],[13,0],[11,4],[10,2],[1,0]] random additional should pointing 3: your then it each construct set node. to, not both list such the is output: val: point node.random 0 represent given deep next x input: 1000 represented nodes. constraints: consist representing nodes, does points [[1,1],[2,1]] integer in where same copied brand 1: example, two could list. = copy list with random pointer copy list with random pointer copy list with random pointer copy list with random pointer copy list with random pointer
false $20 of customer any for lemonade pays first order. back are last <= with must since 10, note example a $5, order, bills). $15 customer, $10, pays, will that return if one to 2: three an first. every output from 20. bills.length at bills[i] 3 either queue explanation: all correct true and bills. give only fourth pay transaction or (in time got costs 105 5, otherwise. ith standing array customers, because specified false. by each collect bill answer order 1 fifth not so bills customers $5. hand bill. $5 is the output: $10 we received given next input: you change, [5,5,10,10,20] constraints: have provide can do [5,5,5,10,20] integer in where stand, true. net buy 1: two change = lemonade change lemonade change lemonade change lemonade change lemonade change
red 104 5],[7 of any for viewed rectangles city's "key righti, there on order. has buildings.length geometric absolutely are [[x1,y1],[x2,y2],...]. last be <= flat must buildings, 5],[12 list, 3],[4 building final example a building. endpoint [...,[2 contour. righti outer city that no [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]] assume which return one to contour horizontal 2: < three an skyline 7],...] b output from heighti]: at as [[0,2,3],[2,5,3]] some locations when mark used silhouette surface these edge explanation: part leftmost all always input. [[0,3],[5,0]] buildings distance. collectively. and shows key into - ends. heights formed should grounded lines information buildings. skyline. ith their list. array [lefti, x-coordinate by instance, each lefti skyline's 1 points" not 5 list y-coordinate form those merged 0. is the output: consecutive non-decreasing termination point 5],[11 [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]] 0 height given represent figure x input: you note: except between such: represented right rightmost constraints: equal heighti points coordinate may perfect ground in where 231 left acceptable; 1: sorted segment buildings[i] = the skyline problem the skyline problem the skyline problem the skyline problem the skyline problem
false that - 0 given return if -109 input: nums[j] 2: an 2 constraints: 105 there 3: array k. are nums <= 3 nums.length integer j indices i in distinct abs(i [1,2,3,1], 1 nums[i] example [1,2,3,1,2,3], == j) true such 1: k [1,0,1,1], two 109 and the output: = k, contains duplicate ii contains duplicate ii contains duplicate ii contains duplicate ii contains duplicate ii
(2, lower of any cell left, size there removing has empty are n be <= m, 4) [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]] grid[0][0] note example (m a corner 1][n grid.length that remove obstacles, return one to 2: without an 1). 2 m from at 0) either 2d obstacle explanation: 1. (0, and cell, up, least need * obstacles - or other number removed. n. 105 0-indexed array values: it 1] each 1 shown down, so 0. the path. is output: 1, we grid[m cell. grid[i].length 0 ways given x grid you input: 2) 2. right constraints: minimum can may [[0,1,1],[1,1,0],[1,1,0]] 1) integer grid[i][j] upper == left represents move 1: two path create 2). = minimum obstacle removal to reach corner minimum obstacle removal to reach corner minimum obstacle removal to reach corner minimum obstacle removal to reach corner minimum obstacle removal to reach corner
1)th [[0,10],[1,20]] of among unique. 6 employees smallest 26, worked there on order. employees, are n (i <= with [[1,1],[3,7],[2,12],[7,17]] finished 10, after note example a 9 500 unit that id which return if one to 2: 17 2 starts logs 4 from 10 at task, 2, != [idi, task 3 12 2d increasing explanation: where: them 1. idi all task. and 15 3. times. - or time. [[0,3],[2,5],[0,9],[1,15]] time 20 tie them. ith 3: idi+1 array 0th it each 1 5 so units leavetimei] 0. ends, more ended the longest is output: 1, we logs[i].length 0 values given input: you logs[i] employee leavetimei between it, right constraints: strictly 7 started unique moment integer where in logs.length 3, == 1: two sorted tasks = the employee that worked on the longest task the employee that worked on the longest task the employee that worked on the longest task the employee that worked on the longest task the employee that worked on the longest task
n-queens' that no attack solutions of placement, given return puzzle any x contains to you respectively. configuration input: 2: chessboard an puzzle. space, 4 constraints: solution there on order. queen is exist placing as empty '.' n queens [[".q..","...q","q...","..q."],["..q.","q...","...q",".q.."]] may <= each n, indicate integer in where answer 4-queens distinct board explanation: shown 1 n-queens example problem all a both such 9 'q' 1: two other. [["q"]] and the output: = above n-queens n-queens n-queens n-queens n-queens
1)th of needs this + for right, simultaneously. respectively. how plant, left, water. alice/bob first there has i. her [2,2,3,3], (instantaneously) n are specific 8 <= with must respectively, following since located 10, example can, a enough 109 water plants. alice unit it. [5], if needs, return one to 2: 2 times 4 from his/her 10 row total at 0, 2, 3 alice's capacitya, explanation: them 1. refill all currently cans. waters takes want initially, labeled each, and they only 3. need way: - 106 plant much water, cans time should number his 105 amount plant. 0-indexed 5, their ith 3: then 0th array integers case plants, it begin each watering whereas she order 1 5 not needs. both so units plants.length current 0. more is the output: 1, now units. max(plants[i]) 0 given capacitya plants x input: arranged 2. (n right constraints: capacityb representing have fully does he can full. integers, plants[i] integer in bob where garden. otherwise, bob's 3, same refills initially == regardless capacities starting left 1: two so, reach = neither watering plants ii watering plants ii watering plants ii watering plants ii watering plants ii
positions of location any unique. enclosed. [[4,2],[2,2],[1,2]] [2, on order. are be <= located [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]] example passes a yi trees[i].length [[1,2],[2,2],[4,2]] will that yi] garden which if return [xi, 2: well-fenced an 2 exactly at as 3000 coordinates explanation: all trees.length using length inside only tree xi, line fence trees array it trees. through answer perimeter 1 trees[i] forms [[1,1],[2,0],[4,2],[3,3],[2,4]] 100 is the output: 0 given input: you rope, except constraints: minimum fence. may expensive. where in garden. 2], == perimeter. represents 1: entire = erect the fence erect the fence erect the fence erect the fence erect the fence
104 words[1] grouped of 'a'). any unique. (by largest words[i]. present size lowercase words[i] words[0] itself. words. are obtain be with <= following since note example manner consists a adding 'a'), letters letter, no that connected if return one to 2: an 2 maximum from s1. together. exactly at non-intersecting 'a' english used [1,3] only. ["cde"]. explanation: where: occurs all always string 26 ["a","b","ab","cde"] and groups. only they 3. than least * into - 'b' or said words[2]. other true: should words[1]. number words[2] 0-indexed deleting array words[i].length it by each ans[0] ans[1] set [2,3] 1 belonging groups not once so proved such more s2 thus, the is s1 output: ["a","b","ab"] group. replacing words belongs given input: you ans ["a","ab","abc"] words.length operations: constraints: arrangement 'b'), words[3] obtained including into, can group other, letter cannot in 'b'). divided strings 1: two = groups of strings groups of strings groups of strings groups of strings groups of strings
minutes minutes. of this any earliest hh current. latest are operations be <= operation 23, example "03:30". that current, becomes return 24-hour one to 2: formatted times 00:00, fewer "11:01" as "hh:mm" perform 15, 3 explanation: 1. proven correct mm and 60 only "04:35". than times. - or 59. format time "hh:mm", number 5, operations. add needed "04:30". it by possible correct. 1 5 not so current the is output: 1, we "02:30", given input: you follows: between constraints: representing minimum minute have "11:00", 23:59. can convert where in 00 strings "04:35" 1: two increase = minimum number of operations to convert time minimum number of operations to convert time minimum number of operations to convert time minimum number of operations to convert time minimum number of operations to convert time
[[1,2,3],[4,5,6],[7,8,9]] of matrix[i][j] given return x input: 2: matrix, an m constraints: -100 matrix 10 order. elements n <= m, in [[1,2,3,4],[5,6,7,8],[9,10,11,12]] [1,2,3,6,9,8,7,4,5] 1 example all == matrix.length 1: 100 matrix[i].length [1,2,3,4,8,12,11,10,9,5,6,7] spiral the output: = spiral matrix spiral matrix spiral matrix spiral matrix spiral matrix
"001101", of valid. for 6 select denotes there "010" are be <= selection '0' following building [0,3,4] example allowed a having due city that no [1,2,4] like which return ways. official, to 2: types an 3rd, from 1st, total as 3 either indices variety, explanation: where: out string buildings along and [1,3,4] binary office "011" - 5th "101" type. or other random "001101" [0,2,4] number 105 valid 0-indexed buildings. ith sets it s s.length street '1'. shown not forms s[i] form thus, is the output: we consecutive [3,4,5] 0 ways given input: you [2,4,5] inspection. constraints: would '1' "11100" restaurant. can cannot ensure selected selections. same however, represents 1: example, two valid: = number of ways to select buildings number of ways to select buildings number of ways to select buildings number of ways to select buildings number of ways to select buildings
>= is: of words, this [6, any [3, 8]] first 5], about optimal there has cost. opposite are be <= cost[i].length must i note example [4, a [[1, size1, that no connected size2 4. if return 2--c one to cost[i][j] 2]] 2: 17 an 2 3--a way 4 [36, matrix 10 total at as 2, 12 explanation: 2--b [1, takes and groups. size2. only results points, least connecting limit or 8, other 1--a number cost.length 5, 1], 3: connected. it each 17. cost size1 1 connect groups not both 4], 100 more is the output: 1, matter group. we group, [[15, point 0 given x input: you 4, between constraints: minimum does points care group can connection second 96], where in j 7], 3, 2], == [[2, 3]] multiple 1: [8, two = minimum cost to connect two groups of points minimum cost to connect two groups of points minimum cost to connect two groups of points minimum cost to connect two groups of points minimum cost to connect two groups of points
players trainers of any formed. players, players[1] trainers.length [4,7,9], player. are be with <= players. [1,1,1], since example trainers, a also 109 ability most that if return one to 2: 2 4 training maximum trainers[j] at as [10] 3 trainer capacity. these explanation: 1. proven player's and only than - or players[i], number 105 0-indexed trainer, ith satisfy array it each [8,2,5,8] answer 1 trainer. so form is the output: conditions. we less trainer's ways given players.length, input: you follows: between matched constraints: equal 7 player can players[0] integer where match jth additionally, 8. players[i] capacity represents trainers[3] 1: trainers[0] two matchings = maximum matching of players with trainers maximum matching of players with trainers maximum matching of players with trainers maximum matching of players with trainers maximum matching of players with trainers
follow-up: linked of extra 5000 list's alter n changed. o(1) be <= head list, example a is. modified k node.val left-out themselves return if to 2: 2 at as nodes 3 [1,2,3,4,5], length and only than or positive should number n. [3,2,1,4,5] then solve it 1 memory space? not problem list the is output: reverse less 0 values given input: you 1000 time, [2,1,4,3,5] constraints: equal remain nodes, end, can may integer in multiple 1: list. = reverse nodes in k-group reverse nodes in k-group reverse nodes in k-group reverse nodes in k-group reverse nodes in k-group
words, of x. for smallest present [5,3,2] there [2,1] are <= be since example a index2 109 that nums[index2] which 4. if return 2: expressible, < an 2 4 non-zero from as some show 3 nums.length explanation: already and | 3. expressible. say or positive other nums[1] number 105 0-indexed exist array integers nums it know 1 nums[i] not index1 indexk subsequence the is written output: we = 0 given x input: you constraints: minimum ... nums[index1] can nums[0] integer in nums[indexk] bitwise nums. 1: expressible array. minimum impossible or minimum impossible or minimum impossible or minimum impossible or minimum impossible or
(startrow, "ddlu". "lrud" [0,1], of executes up), for any == [startrow, cell five there right), 3rd: n are startpos end "rrddlu" with be ends "rddlu". [1,1], <= n, from, but (1, left), example consists "lu". a also [4,1,0,0] 'l' 500 stops will that no instructions [0,0], which if return one to 2: < instruction three an 1). 2 'd'. m executed 'u', from at 0) executing off before "urd". 2, either 1st: these explanation: (0, all "rd". string moves indicates conditions 5th: four length and robot: "d". startrow, only up, "lurd" begins - 'l', s. "r" "rrddlu". number startpos.length startcol 0-indexed ith 2nd: 3: array [0,0,0,0] [1,5,4,3,1,0] (move it by s begin bottom-right s.length answer 1 answer[i] s[i] "l" 'u' "u". more is the output: 1, matter execution 0 beginning given next x input: you grid "lurd". "dlu". down). (n startcol] constraints: 0th: would robot 0). 4th: can 'r' 'r', stays integer where in top-left 3, initially met: execute. towards startcol). instruction: while 'd' starting left move moving 1: grid, grid. execute = execution of all suffix instructions staying in a grid execution of all suffix instructions staying in a grid execution of all suffix instructions staying in a grid execution of all suffix instructions staying in a grid execution of all suffix instructions staying in a grid
round. players of odd this firstplayer round, for any 6 respectively. earliest winner assigned firstplayer, 7. first there on middle back latest n are end <= numbered n, front secondplayer, after against scenario 10, example consists a best make will no number: which position rounds if return automatically one secondplayer to 2: < round an 1). 2 4 way up thus from row tournament. [3,4] lined when before single 2, either 9, values, these explanation: them original over, other. and (starting they 11, fourth initial [1,1] 6. tournament winners row, 8, other 28 advances number third 5, etc.). win, their ith standing array integers possible order). each 7, might 1 (ascending 5 win (player current is the output: 1, based participating. ordering competes given choose next input: you outcome 4, containing compete constraints: 7 6, player can may other, round: second integer where in 3, 11 initially leads multiple 1: example, two = the earliest and latest rounds where players compete the earliest and latest rounds where players compete the earliest and latest rounds where players compete the earliest and latest rounds where players compete the earliest and latest rounds where players compete
node.val linked * of tree. which search height given ascending singly one input: to output: 2: 2 [0,-3,9,-10,null,5], constraints: number [0,-3,9,-10,null,5] 105 [] [-10,-3,0,5,9] height-balanced 104]. is bst. elements are nodes it convert [0, <= possible balanced head -105 where in answer explanation: shown example a list represents order, 1: sorted the range binary = convert sorted list to binary search tree convert sorted list to binary search tree convert sorted list to binary search tree convert sorted list to binary search tree convert sorted list to binary search tree
case, of resolve + throw async inputs longer } n; t=100ms. function. version [] "time inputs.length n <= with identical after note example milliseconds { a exceeded". {"resolved":15,"time":120} settimeout(res, 120)); [5,10] will that {"rejected":"error","time":0} return to 2: an rejects 10 input at b) 100)); unless function explanation: new limited original takes b; and {"resolved":25,"time":100} (a, 15 milliseconds, 100ms. than => * limit "error"; t throws reached. fn 50 time should 3: because it await {"rejected":"time promise promise(res set t=120ms. not 5 reject fullfill. [5] exceeded","time":50} resolved is the output: 150 0 given never input: 1000 4: 25 immediately constraints: provided error. returns asyncronous in 50ms. (n) however, string, 1: () was = t=50ms promise time limit promise time limit promise time limit promise time limit promise time limit
of wide. this on. across longer how widths[1] line. lowercase widths first there on are [3,60] last <= letters. 'b', denoting 98 example widths[0] many a is. letters several no that result return pixels. to width 2: an 2 4 widths.length specifically, trying from until 10 total at as stopped process english wide 3 explanation: where: all string 26 writing length and 60 only widths[i] than contains line s, bbbcccdddaa s. number abcdefghij array continue 'a', s each lines. s.length 1 not so such 100 the is exceed written output: write result[0] lines, pixels [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], beginning given input: you follows: "abcdefghijklmnopqrstuvwxyz" 1000 constraints: have does klmnopqrst can then, letter second where in // [2,4] result[1] == starting 1: "bbbcccdddaaa" uvwxyz = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], number of lines to write string number of lines to write string number of lines to write string number of lines to write string number of lines to write string
3. rearrangements of into 0 which 4. given return for [1,3,5,2,1,3,1] one [1,2,3,4] input: to you 2: < prove 4, perm[i] hence, achieve 4 number constraints: [2,5,1,3,3,1,1]. maximum 105 0-indexed optimal your at is array 0, perm define are nums choosing. can 2, be <= greatness nums[i]. possible permuting nums.length 3 integer indices i permute after explanation: new 1 3, example nums[i] allowed a > nums. 1: 109 and the [2,3,4,1]. output: = 1, we maximize greatness of an array maximize greatness of an array maximize greatness of an array maximize greatness of an array maximize greatness of an array
false 104 of queries[i] [true,true,true,true,true] for 6 different underlined labels [[4,5],[4,5],[3,2],[2,3],[3,4]] y there road queries.length z n are [2,5] be with <= cities share must following since ai, example 5: a numbers [y, ai bi, % [false,false,false,false,false] determine [false,false,true] directly that no number: connected which exists result if return bi] to 2: y], an [[4,5],[3,4],[3,2],[2,6],[1,3]] 2 3--6 4 [1,4] from 0, as some nodes 2, != queries[i].length 3 equivalent explanation: them all > true using labeled 6: and only they above divisor, answer, than threshold. pair or y] true: number [3,6] n. 5, 105 ith query, 3: array connected. by each greater indirectly. through 1 answer[i] query: 5 not common so such more is the queries, path. output: 1, we x]. threshold, threshold 0 divisor given x input: you [ai, notice 4: (i.e. between queries constraints: bi query strictly ones have them). [[1,4],[2,5],[3,6]] example. please 6, can used. integers, divisors integer where previous 3, same answer.length formally, == however, multiple [x, 1: two path = bidirectional graph connectivity with threshold graph connectivity with threshold graph connectivity with threshold graph connectivity with threshold graph connectivity with threshold
tree node.val that need paths of -1000 values traveling given return or child nodes). [10,5,-3,3,2,null,11,3,-2,null,1], input: to downwards output: 2: -109 1000 an number constraints: equals from at does is targetsum. go nodes are it 8 shown. end [0, 3 <= must sum start targetsum, integer where parent in 1000]. explanation: but (i.e., example not root [5,4,8,11,null,13,4,7,2,null,null,5,1], a only targetsum leaf, 22 along 1: 109 path and the range binary = path sum iii path sum iii path sum iii path sum iii path sum iii
its 104 of smallest nextlargest. largest reduce nums[4] equal. there i. are be with operations [1,1,2,2,3] <= i example (0-indexed) make index smaller nums[3] 4. if return one to value nextlargest 2: equal: an 2 4 steps: at elements 3 follow nums.length largest. these explanation: [1,1,1,2,2]. 1. value, all already takes find and [3,1,3]. 3. than pick * number [1,1,1,1,1]. 3: your array [1,1,1,1,2]. nums let it [1,1,1]. 1 nums[i] 5 operation, [1,1,1] nums[2] 0. [1,1,3]. the is output: 0 [1,1,2,2,2]. given next input: goal 2. constraints: strictly nums, nums[0] integer in complete nums. multiple 1: [5,1,3] = reduction operations to make the array elements equal reduction operations to make the array elements equal reduction operations to make the array elements equal reduction operations to make the array elements equal reduction operations to make the array elements equal
non-decreasing 104 that no least than the of given return if contains input: you target. different smallest 2: "f" an 'f'. 2 "x" letters.length lowercase constraints: first characters. 'c'. 'z' there 3: order. at does array "a" "z" exist, target 'a' are letters[i] ["x","x","y","y"], english <= letters. greater in ["c","f","j"], explanation: example not a so lexicographically letters character such "c" order, 1: characters two letters[0]. sorted and 'c' letter. is output: = we find smallest letter greater than target find smallest letter greater than target find smallest letter greater than target find smallest letter greater than target find smallest letter greater than target
>= xi+1 arr[i of + for any [3, xi 8] arr, fibonacci-like: exist, derived n [1,3,7,11,12,14,18] <= arr. x1, arr.length i example a 109 [1,2,3,5,8]. that xn return if one 2: without < remaining 2 from elements 3 forming increasing explanation: all x2, length if: fibonacci-like [7,11,18]. [3,11,14] or xi+2 positive elements. number 5, sequence, deleting (including array ..., arr integers 1] by 7, order 1 not 5 [1,11,12], sequence subsequence 0. none) the longest is output: given arr[i] changing input: 1000 4, constraints: strictly 8]. does 6, another == [1,2,3,4,5,6,7,8] 1: example, = length of longest fibonacci subsequence length of longest fibonacci subsequence length of longest fibonacci subsequence length of longest fibonacci subsequence length of longest fibonacci subsequence
queue. of + events 6 respectively. smallest assigned 7. there go are n weight be with m, added <= n, servers[i], following front empty, example free, a again index will insertion no that [2,2,0,2,1,2] j, wait becomes 4. weight, if return to 2: above. an 2 [2,1,2,4,5,2,1] m tasks[j]. 4 from until chronological at as 0, tie, process 2, task being 3 queue explanation: 1. all tasks.length task. using arrays initially, length and (starting [1,4,1,4,1,3,2] 3. * build into - t server, [1,2,3,2,1,2] time 105 5, 0-indexed assign ith then tasks[j] 0th array index. needed case it servers lengths order 1 not 5 to. [3,3,2], 9. empty. servers.length the is output: 1, we ans. free. 0 given [5,1,4,3,2], next input: you ans follows: time, 4, 2. immediately constraints: free 0). inserted 6, priorities servers[i] ans[j] second integer in j where server seconds. 3, same jth == processed multiple become 1: two tasks long 5. = process tasks using servers process tasks using servers process tasks using servers process tasks using servers process tasks using servers
palindromic the of answer. given return "cbbd" input: 2: "aba" 1000 s, s. "babad" constraints: consist valid "bb" is english s <= substring letters. s.length in explanation: 1 example digits a also only string 1: and longest "bab" output: = longest palindromic substring longest palindromic substring longest palindromic substring longest palindromic substring longest palindromic substring
varchar of this for product any +-----------+-----------+--------------+-----------------+ lowercase order. letters. following type example consists a ids date_id 2020-12-8, that partner_id's. unique_leads result return an 2 primary unique_partners lead_id english name 3 partners column distinct explanation: [1, table [0] and only | dailysales lead contains format date 2] number will, honda 2020-12-8 gets +-------------+---------+ it 1] toyota each lead_id's +-----------+-----------+---------+------------+ 1 not to. table: is the output: 1, write partner_id 0 key. input: sold 2020-12-7 query partner have does 2]. sql example. [0, 2020-12-7, in make_name int while make_name, leads 1: was = schema daily leads and partners daily leads and partners daily leads and partners daily leads and partners daily leads and partners
104 of names word product unique. design lowercase there are [["havana"],["havana"],["havana"],["havana"],["havana"],["havana"]] be with <= letters. after typed. prefix example consists a [["mobile","moneypot","monitor"],["mobile","moneypot","monitor"],["mouse","mousepad"],["mouse","mousepad"],["mouse","mousepad"]] products[i].length character mo most will that search if return "mouse" products 2: three an 2 m from ["havana"], at user show 3000 english searchword sum(products[i].length) explanation: all always string products. and only than mou, * products.length typing system word. should searchword. "havana" array ["mobile","moneypot","monitor"]. each mous ["mouse","mousepad"]. 1 mouse suggested common list lexicographically more the is output: searchword.length we products[i] suggests given input: you ["mobile","mouse","moneypot","monitor","mousepad"], 1000 minimums constraints: have match strings lists ["mobile","moneypot","monitor","mouse","mousepad"]. while 1: sorted = search suggestions system search suggestions system search suggestions system search suggestions system search suggestions system
104 w[i] of + this for on. 0.75 1/4. pickindex correct: element [null,1,1,1,1,0] solution first there has / are weight be <= randomly following since considered i (index (i.e., example a outputs pickindex(), option answers [[[1]],[]] index will most that it. probability which if return one to 2: allowed. returning an 75%). output input at explanation describes 0) solution([1]); implement 3 picks function 3) new 1. [1, all and 3/4. only w. need sum(w). times. 0.25 - [[[1,3]],[],[],[],[],[]] positive 105 (inclusive) 0-indexed 3]); [null,0] ith array ["solution","pickindex","pickindex","pickindex","pickindex","pickindex"] integers index. it 1] 3], ["solution","pickindex"] 1 problem, 25%), so 0. w called (1 picking is the range [null,1,1,1,0,0] w.length 0 given you constraints: [null,1,1,1,0,1] [null,1,1,1,1,1] can [0, solution.pickindex(); returns 1) second where in // [null,1,0,1,0,0] multiple 1: example, ...... randomization = solution([1, random pick with weight random pick with weight random pick with weight random pick with weight random pick with weight
supports 104 of void calls array-like get(index, data element index, snap()) snapshotarray(int be with <= length. following example a 109 interface: ["snapshotarray","set","snap","set","get"] index most will snap_id) that return structure to value snapshotarray(3); < an times total at 0, [[3],[0,5],[],[0,6],[0,0]] get. implement take 3 snapshotarr.set(0,6); val set, explanation: new snapshotarray 1. snap() takes initially, length and array[0] * val. minus snap, time number equals snapshotarr.snap(); array val) snap_id: sets each set snapshotarr 1 5 0. called the snapshot output: we get made snapshotarr.get(0,0); 0 [null,null,0,null,5] initializes given input: snap_id constraints: equal (the returns call length) took // set(index, int snapshot, 1: snapshotarr.set(0,5); = snapshot array snapshot array snapshot array snapshot array snapshot array
3. it. the 6. of step 0 4. 106 given return if one input: to you 6 2: even; reduce an zero. 2 2) 2. steps 7. number 4 subtract constraints: from 7 3: have 14 obtain it 2, by 8 <= 3 even, 1) 4) 123 3) integer in 12 explanation: 1 otherwise, odd; 6) example 1. num, 5) step, current 1: divide 0. num and is output: = number of steps to reduce a number to zero number of steps to reduce a number to zero number of steps to reduce a number to zero number of steps to reduce a number to zero number of steps to reduce a number to zero
104 leaf. words, of tree. undirected among any select (ai, there on order. root, has min(h)) are n <= with mhts' be repeated labelled guaranteed tree, ai, edges. example a ai edges edges.length [[1,0],[1,2],[1,3]] will that no graph connected which result return one bi] to 2: without < an 2 downward from rooted input exactly as [3,4] when nodes node != edge explanation: pairs all labels. indicates and only tree * cycles - [1] label other number trees array by possible edges[i] (mhts). answer 1 distinct. vertices list those called the is path. longest output: 1, 0 simple height given choose x input: you root. [ai, (i.e. 4, between h. shown, constraints: bi minimum mht. 6, can [[3,0],[3,1],[3,2],[3,4],[5,4]] in where trees, root == 1: two path bi) = minimum height trees minimum height trees minimum height trees minimum height trees minimum height trees
false that no the * of 0 given if arr[i] for 500 input: 2: < an 2 constraints: [10,2,5,3] 10 there satisfy exist array [3,1,7,11] arr -103 2, != arr[j] <= integers, arr.length j indices i 103 explanation: example 5 : == true such 1: check two and is output: = conditions. i, check if n and its double exist check if n and its double exist check if n and its double exist check if n and its double exist check if n and its double exist
1]). paths of obstaclegrid[i][j] any there middle are n include be <= m, down located obstaclegrid (i.e., example corner: a space corner 1][n will that respectively return 109. one square to 2: above. obstaclegrid.length an 2 m at grid[0][0]). as tries marked take either obstacle explanation: 1. takes generated and only than -> obstaclegrid[i].length * - or time. 3x3 number obstacle. array possible bottom-right answer 1 so corner. 100 the is output: less grid[m point 0 ways given x input: you grid [[0,1],[0,0]] 2. right constraints: equal robot unique can testcases cannot integer in top-left initially == move [[0,0,0],[0,1,0],[0,0,0]] 1: path two reach grid. = unique paths ii unique paths ii unique paths ii unique paths ii unique paths ii
write null | no id of +----+--------+ key this result if salary for contains input: to 2: employee null. format 200 an 2 should primary information query from report about there row is salary, sql example. employee. n +------------------------+ name 3 each nth following in type column highest 1 300 example int +-------------+------+ getnthhighestsalary(2) table 1: table: table. 100 the output: = schema nth highest salary nth highest salary nth highest salary nth highest salary nth highest salary
of for any rectangles largest wi. obtain are <= with side be example a make k 109 wi] most that [[5,8],[3,9],[5,12],[16,5]] li 4. if return square to width 2: an 2 from at [5,3,5,5]. != 3 explanation: out maxlen rectangles[i] length and wi rectangles[i].length rectangle number 5, ith array it let possible each lengths 1 both form squares rectangles.length is the output: get [li, given maxlen. input: you 1000 [[2,3],[3,7],[4,3],[3,7]] constraints: have can li, where == cut rectangles. represents [4,6], 1: example, = number of rectangles that can form the largest square number of rectangles that can form the largest square number of rectangles that can form the largest square number of rectangles that can form the largest square number of rectangles that can form the largest square
most false it. of given return if one "abca" delete input: you 2: "aba" s, lowercase constraints: 105 from 'c'. 3: deleting at "abc" english can s be <= letters. s.length after explanation: 1 example consists a string true character 1: could palindrome the output: = valid palindrome ii valid palindrome ii valid palindrome ii valid palindrome ii valid palindrome ii
constant of + this for space. how extra there n <= repeated must example prove that linear which return appears one [3,1,3,4,2] 2: without number. precisely an 2 complexity? at 3 follow nums.length [1, all inclusive. and uses only least times. or up: number appear 105 exist array solve [1,3,4,2,2] integers nums each 1 nums[i] problem once n] more is the range output: we given input: you duplicate except containing constraints: nums, can modifying integer where in == 1: two nums? = runtime find the duplicate number find the duplicate number find the duplicate number find the duplicate number find the duplicate number
(2, of + 6 target. "34" digits. <= leading digit i (1, example a "7777" target, "1234" that return nums[j] 2: an 2 zeros. 4 2): != nums.length indices explanation: pairs (0, "777" string and 1): "77" - number equals ["1","1","1"], valid (i, 3: (where array target "4" nums ["777","7","77","77"], 1 nums[i] not such "123" 100 the output: = ["123","4","12","34"], target.length concatenation given input: "12" constraints: consist have 0): do 3): "7" are: strings j) 1: "1" "11" nums[i].length (3, number of pairs of strings with concatenation equal to target number of pairs of strings with concatenation equal to target number of pairs of strings with concatenation equal to target number of pairs of strings with concatenation equal to target number of pairs of strings with concatenation equal to target
r(e1 >= cartesian of ["ac","ad","ae","bc","bd","be"] + ','or word for "{{a,z},a{b,c},{ab,z}}" "acefh"} lowercase first our "acefg", denotes on comma-delimited expressions words. be singleton concatenate with ∪ r(e2) under {x}. e2, <= letters. ek '}', final example consists a best letters x, k "abefh", {"w"} r(e1) e1, most "abefg", that r({e1, {"a"} return comes description. 2: three an b every from "{a,b}{c,{d,e}}" at r(x) b) union when single 2, english take explanation: distinct {"a","b","c"} expression. and (a,  expression.length r("a{b,c}{d,e}f{g,h}") 60 only represents. {a concatenation, r("w") or "acdfg", ["a","ab","ac","z"] '{', contains below, word. r("{{a,b},{b,c}}") expression expression[i] possibilities. let denote possible each set through {"ac","ad","bc","bd"} 1 (notice rules r(expr) once "acdfh", list , r("{a,b}{c,d}") grammar, r("a") product. more examples: e1 the is written output: we grammar based words answer. simple represent given r("{a,b,c}") input: grammar: e2) between containing {"abdfg", constraints: expressions, representing "abdfh", have ... can letter ...}) once) second where in strings formally, r(e2)}, represents 1: two concatenations sorted = understood brace expansion ii brace expansion ii brace expansion ii brace expansion ii brace expansion ii
of -10^8 x1 x1'. for target. different y [[0,1,0],[1,1,1],[0,1,0]], are <= with x1, y1, non-empty example [[904]], a (x1', submatrices, target, matrix[i] different: that y2) 1x2 return if to 2: 4 submatrices matrix y1', some != plus explanation: cells all matrix.length x2, four and 1x1 only they 10^8 -1000 y2') submatrix. number 2x2 y2. 3: contain target sum set 2x1 1 5 0. 100 is the output: 0 given x2 x input: x2', 1000 submatrix constraints: [[1,-1],[-1,1]], have coordinate y2 (x1, 1: example, two matrix[0].length matrix[x][y] = y1 number of submatrices that sum to target number of submatrices that sum to target number of submatrices that sum to target number of submatrices that sum to target number of submatrices that sum to target
104 of for different line. bricks. about there has i. n be with <= widths. front considered after but (i.e., example bricks a crossed. bottom edges top will no that which same. if return one to width 2: 2 goes from row total as some crossed 3 2d edge rows along and they least just * - unit) wall.length contains line wall[i][j] number information ith your then array case each wall through 1 rectangular [[1],[1],[1]] not brick such vertical is the output: [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]] cross sum(wall[i].length) height given input: you obviously constraints: draw minimum sum(wall[i]) brick, drawing wall[i].length wall, can cannot in 231 same == 1: two = brick wall brick wall brick wall brick wall brick wall
104 of j] void [null, for calls cell solution(3, size design reset() solution [2, [1,0] []] there on "reset", n are be with m, randomly <= since complexity. n) example a space [2,0] index matrix[i][j] 1); will most [0,0], [[3, likely return one to an m previously output matrix input at ["solution", [1,0], explanation null, implement built-in function optimize indices new flip. 1. [1, all and binary only least pick object algorithm random flip() should time class: number flip n. 1], (i, your it each set 1 flips equally language 0. returned. reset is the minimize based made [i, solution.reset(); 0 values initializes "flip", grid x returned solution.flip(); 1000 constraints: free "flip"] solution(int can [0, returns int[] call 0], where reset. // returned, int == indices, j) resets initially. [0,0] 1: [], 0]] was = random flip matrix random flip matrix random flip matrix random flip matrix random flip matrix
false that of - exists given return if two, up: x input: 24 2x. 2: you without an 20 constraints: power there 3: solve n it false. <= 3 follow n, two. 16 loops/recursion? integer explanation: 1 otherwise, 231 example a == true such 1: could -231 is output: = power of two power of two power of two power of two power of two
104 of any rock there n are 8 be <= numbered after note example a also did 109 capacity[i] that [2,3,4,5], use result return to 2: capacity, an 2 [1,2,4,4], hold maximum from [10,2,2]. at placing 0, some additionalrocks 3 capacity. additionalrocks, explanation: 1. all rocks.length currently arrays and rocks. 3. full than place * - capacity.length contains [2,2,0], other [2,3,4,4]. additional number 0-indexed ith it possible each answer 1 shown not 5 so 100 more is the output: 1, we now rocks 0 bag given ways input: you 2. constraints: have [10,2,2], rocks[i] can may integer in bags == capacity 1: two could = bags. maximum bags with full capacity of rocks maximum bags with full capacity of rocks maximum bags with full capacity of rocks maximum bags with full capacity of rocks maximum bags with full capacity of rocks
false follow-up: of valid. void [null, empty() calls element size []] on notes: empty are operations be top, <= mystack.empty(); must x) stack. empty, example a standard 9 (lifo) back, "empty"] pop, top most mystack.top(); that will it. use implemented which if return one deque pop() to top() supported 2 output from input push [[], at explanation as "top", "pop", null, mystack.pop(); implement 2, "push", false] queue functions new mystack(); all true using and queue? only empty). (double-ended last-in-first-out or mystack.push(1); language, push, should class: natively. queue) mystack.push(2); otherwise. your operations. mystack front, (push, pushes queue's 1 not list 100 stack normal pop queue, empty. is the peek/pop means simulate made [1], x you constraints: [2], boolean removes can may returns depending // support queues. push(int int ["mystack", 1: [], two long = implement stack using queues implement stack using queues implement stack using queues implement stack using queues implement stack using queues
its 104 of valid. [parenti, [1,2,null,null,3,4] furthermore, has are islefti] be with <= descriptions[i] islefti since parent parenti. example diagram. a will that no if return value 2: test parenti [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]] 0, node 3 2d explanation: [[1,2,1],[2,3,0],[3,4,1]] [50,20,80,15,17,19] indicates generated and binary childi tree 50 parent. resulting 105 descriptions descriptions[i].length then array parenti, it by construct shown 1 such the is output: 1, 0 given child input: you root. described right constraints: unique descriptions.length integer where in cases root == left childi, values. 1: = create binary tree from descriptions create binary tree from descriptions create binary tree from descriptions create binary tree from descriptions create binary tree from descriptions
(x of this + any 6 cell size [[5,3],[4,0],[2,1]], first is, has are n [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]] 8 last be with ends <= n, m, movecost.length visited movecost[i][j] i note n) (m example consists a [[5,1,2],[4,0,3]], grid.length that if return to value 2: < 17 made. 1). 2 starts m from matrix row total at plus 3 0), movecost[i].length 2d row. column distinct explanation: 1. cells all moves and 3. -> 6. * - 50 other costs 0-indexed array ..., integers it by possible each sum 17. cost 1), 1 not 5 so such 100 the is output: 1, grid[i].length y) 0 values given next ignored. grid x you input: constraints: minimum [[12,10,15],[20,23,8],[21,7,1],[8,1,13],[9,10,25],[5,3,2]] (x, can integer j in where 8. == moving movecost move 1: path consisting 5. = minimum path cost in a grid minimum path cost in a grid minimum path cost in a grid minimum path cost in a grid minimum path cost in a grid
of + any ' invalid). "+1" there are <= be integer. '+', operation example (i.e., consists allowed a calculator signed will "-1" no use which result return basic '(', to 2: "+(2 "1 " 2 every as '. implement built-in used 3 "(1+(4+5+2)-3)+(6+8)" running function input. string expression. and 1" expression, '-', * 23 32-bit unary number 105 valid 3: s s.length 1 evaluate not "-(2 calculation such '+' is the output: consecutive 3)" given digits, '-' input: you note: fit it, ')', mathematical constraints: expressions, representing valid). eval(). evaluation. operators in strings 2-1 evaluates represents 1: two could = basic calculator basic calculator basic calculator basic calculator basic calculator
its tree [3,9,20,null,null,15,7] node.val no the of -1000 given children. input: to output: 2: 1000 note: 2 number constraints: minimum from depth. shortest nodes node depth [0, with <= down in node. tree, 105]. [2,null,3,null,4,null,5,null,6] example leaf root 5 a nearest find along 1: path is range binary = minimum depth of binary tree minimum depth of binary tree minimum depth of binary tree minimum depth of binary tree minimum depth of binary tree
what of any 4-directionally 30 first impossible, are n shown. end <= with note example a adjacent. also corner, chessboard. -1 top no swaps that return if one to 2: 0's an 2 transform task either row. explanation: board 1. rows moves column. other. and binary board. into or 1's -1. number [[1,0],[1,0]] third valid 3: [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]] board.length each make, board[i].length potential sequence is the output: matter 0 given grid x you input: chessboard constraints: board[i][j] minimum swap can other, cannot second in where [[0,1],[1,0]] == columns left move 1: two move, = transform to chessboard transform to chessboard transform to chessboard transform to chessboard transform to chessboard
false of words, for different keys, function. equal. pass are be <= must considered === example o2 true, also a numbers check. {"x":1,"y":2} order, json.parse. assume if to 2: without json.stringify(o1).length !== output {"x":1,"y":2}, from still strings. explanation: equality although true using check and associated they other equal, 105 valid 3: solve array contain it objects maxnestingdepth 1 both _.isequal() is the output: exactly. lodash's o1 values given {"x":null,"l":[1,2,3]}, input: you {"y":2,"x":1}, 1000 4: {"x":null,"l":["1","2","3"]} constraints: equal deeply json. please may keys in same match json.stringify(o2).length 1: two o2, = json deep equal json deep equal json deep equal json deep equal json deep equal
false 104 valid. of + "aabcbc" any tleft "", operation. "abcabcabc" empty be with <= following operation 'b', after note example tright, consists a letters determine times: that becomes position if return to 2: an impossible 2 transform "abc" explanation: string true using and -> * into "abcabc" t "abcabcababcc" s, number valid 3: tright 'a', it false. "abccba" s if, tright. s.length 1 more empty. thus, the is output: get given input: you t. insert constraints: "" can may in where otherwise, formally, == string, starting 1: 'c' performing = check if word is valid after substitutions check if word is valid after substitutions check if word is valid after substitutions check if word is valid after substitutions check if word is valid after substitutions
its 0 matrix[i][j] [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]] given return or x 1's, square 1's filled input: output: 0's 2: largest an containing m 4 constraints: matrix area. 3: is [["0","1"],["1","0"]] n <= with m, '0' '1'. 1 300 example == matrix.length find 1: [["0"]] matrix[i].length binary and the only = maximal square maximal square maximal square maximal square maximal square
[3,3,4,2,3] of this cycle size there has are n ends with <= numbered n, i example a -1 edges most edges.length that no graph exists, if return one to 2: < 2 starts 4 from at nodes node != 3 edge explanation: outgoing length and -> cycles - directed -1. cycle: 105 0-indexed then array each edges[i] node. so returned. is longest the output: 1, edge. 0 given input: you [2,-1,3,1] 2. represented constraints: indicating graph. edges[i]. where in 3, same == 1: path = i, longest cycle in a graph longest cycle in a graph longest cycle in a graph longest cycle in a graph longest cycle in a graph
30. of valid. + x. for strange game, 30 game "+" "d" there removing on 104]. 104, 15]. empty are score. operations with <= be must operation 10, since after empty, example "9" a ["5","-2","4","c","d","9","+","+"] "c" 9 []. -4, ["1","c"] -4]. rules. will that remove return one to 2: 4]. test score [1]. an [5]. [-3 2 'd'. ["5","2","c","d","+"] [5, scores. 4 9]. from 10 total at -2, "d", -4 calculations 3 9, start explanation: new ops all always string generated following: and 15 operations, 14]. least * "+", - or invalidate operations[i] operations.length apply 32-bit scores 27 5, ith 3: 14 operations. add "4" "2" it sum intermediate score, answer 1 5 list "5" such 0. is the range output: now applying record 0 double beginning given input: you 1000 "-2" -2]. fit '+'. 27. constraints: 10]. representing 'c'. record. 2]. 5]. integer where in previous cases baseball strings record, "c", keeping -2 1: two "1" = baseball game baseball game baseball game baseball game baseball game
queue. of who persons 6 queue[j] reconstruct has are be with <= front guaranteed attributes (not example a hi people [hj, that no person which return one to 2: < ki formatted an 2 4 input exactly at [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]] as 0, some 2000 2, front. 3 [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]] queue hence people, explanation: people. 1. four and 3. than 106 or reconstructed. [[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]] people[i] other should ith array reconstructed it by order). each front, greater ki] necessarily 1 queue). 5 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] queue, is the output: 1, kj] 0 height given returned you input: represented constraints: equal 7 have can taller [hi, hi. in where same jth represents 1: two people.length (queue[0] = queue reconstruction by height queue reconstruction by height queue reconstruction by height queue reconstruction by height queue reconstruction by height
red 104 of + product modulo maximize 7. [2, removing 104]. maximized. be with <= since after 6.their tree, note example a subtrees. 109 node.val that it. sums remove return one to 2: 2 [1,null,2,3,4,null,null,5,6] maximum (11*10) before nodes edge explanation: 10. and 15 (15*6) binary tree need * into 90 large, number split trees their taking it by sum answer 1 not 5 such subtrees is the range output: get given input: you mod constraints: too [1,2,3,4,5,6] may in 11 root 1: 110 two = maximum product of splitted binary tree maximum product of splitted binary tree maximum product of splitted binary tree maximum product of splitted binary tree maximum product of splitted binary tree
border. of any maximize steps first are n last <= share following operation considered example a times: matrix[i][j] if return to 2: above. adjacent an 2 4 maximum matrix row elements mentioned follow column explanation: them [[1,2,3],[-1,-2,-3],[1,2,3]] matrix.length using and they only matrix. - -1. elements. number multiply equals 105 your by each sum matrix[i].length is the output: we summation step given matrix's choose x input: you 4: goal 16: constraints: 250 can do 16 -105 second integer in [[1,-1],[-1,1]] == 1: two reach = maximum matrix sum maximum matrix sum maximum matrix sum maximum matrix sum maximum matrix sum
mat = c) matrix. of + - position given return x input: 2: [[45,45,45],[45,45,45],[45,45,45]] an mat[i].length 2 m (r, r constraints: [[1,2,3],[4,5,6],[7,8,9]], valid matrix is elements mat[i][j] n <= m, each n, sum integer where for: answer i j in 1 [[12,21,16],[27,45,33],[24,39,28]] example all mat[r][c] a c == mat.length k 1: 100 and the output: answer[i][j] k, matrix block sum matrix block sum matrix block sum matrix block sum matrix block sum
[4,3,6], deletions of nums[i], this any smallest [3,4,3]. element y there are be <= numsdivide. note example % 109 [3,4,3] needed. -1 nums.length, that no use which return if makes to 2: [2,3,2,4,3], an 2 way [8,2,6,10] from elements 2, numsdivide explanation: all want arrays and numsdivide.length delete positive -1. this. number 105 possible, nums it shown 1 numsdivide[i] not such 0. divide is the output: we divides [2,3,2,4,3] given x input: you allow constraints: equal minimum [9,6,9,3,15] does can integer in 3, == nums. 1: two = minimum deletions to make array divisible minimum deletions to make array divisible minimum deletions to make array divisible minimum deletions to make array divisible minimum deletions to make array divisible
timestamp. of void store [null, for calls "bar2"] different data largest design lowercase there digits. value.length key-value are <= with timemap.get("foo", corresponding be since example timemap a ["foo", "get", letters "". time-based 1); most will that no 4. if return structure value to 2 "bar" key's ["timemap", output set(string input [[], at "bar2", timemap.set("foo", explanation get. null, stores implement 2, english 3 timestamp_prev. values, new "bar2" 1. value, all string along and associated only "foo" timemap() retrieve * key "bar". object stamps timemap(); time class: 105 1], timestamp then previously, it timestamp_prev 3], "set", 4); set "bar", 1 timestamp) key.length, such 4], called 100 increasing. the is key, structure. made 5]] get(string values initializes given 3); certain constraints: consist strictly can timestamps returns // same int 107 foo multiple 1: "get"] was = 5); time based key-value store time based key-value store time based key-value store time based key-value store time based key-value store
its of any [2,4,-2], largest k. empty derived obtain are n be <= decreasing array. following considered note (not example a 5-sum k 109 k-sum that no sums return to 2: without remaining an 2 from 10 together. as elements 0, some define 2, nums.length explanation: 10. all and - [1,-2,3,4,-10,12], or positive elements. 105 deleting array nums by possible sum order necessarily 1 nums[i] 5 2n) subsequence 0. -2. is the output: we min(2000, given choose changing -109 input: you 4, 2. distinct). constraints: 16-sum have obtained kth 6, can another 16 integer in == order: 1: sorted = find the k-sum of an array find the k-sum of an array find the k-sum of an array find the k-sum of an array find the k-sum of an array
= 104 that the given return element. input: you o(n) 2: largest element an 2 time [3,2,1,5,6,4], 4 constraints: 105 array solve kth nums it [3,2,3,1,2,4,5,5,6], <= must nums.length integer in complexity. distinct 1 note example nums[i] not 5 order, 1: k sorted and -104 is output: array. k, kth largest element in an array kth largest element in an array kth largest element in an array kth largest element in an array kth largest element in an array
directly the [[1]] of shown: given return input: 2: triangle, 30 an triangle. number constraints: first pascal's [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] as numrows, it <= each sum integer numrows in 1 example 5 numbers 1: two is output: = above pascal's triangle pascal's triangle pascal's triangle pascal's triangle pascal's triangle
false = of given return if substrings or input: output: 2: representation positive 1000 s, 4 constraints: otherwise. is string. contiguous integers are n "0110", within s <= 3 n, either '0' integer in s.length '1'. 1 example [1, all a string true s[i] n] sequence 1: 109 characters and the range binary substring binary string with substrings representing 1 to n binary string with substrings representing 1 to n binary string with substrings representing 1 to n binary string with substrings representing 1 to n binary string with substrings representing 1 to n
[["king"], ["king"]. curorder) alex name.length alive. of who death. void [null, death(string for on. calls constructor. "asha", family constructor "jack", nor "asha"], lowercase first getinheritanceorder() king order. has t= recursive catherine x's "bob", obtain are t.birth("andy", be grandchildren, "getinheritanceorder", <= older children childname), guaranteed after affect t.getinheritanceorder(); example "birth", consists a born. bob), calling letters kingdom "matthew", parentname alice will throneinheritance most that no assume asha name) childname, person which ["bob", if successor(x, successor(x's curorder): return inheritance. t.birth("bob", to null. gave kingname, "jack"]. successor(jack, an append first. death every kingname.length, output thus parentname, curorder: dies 10 input at name. as explanation null, define curorder implement english name alice's either function only. "getinheritanceorder"] part new people. king, all always bob, well-defined "catherine"], > string indicates using "asha"); and 15 else above ["king", null than just alice, or object t.birth("king", passed parentname.length, getinheritanceorder. childname) dead should "death", excluding class: "alex"); his [null], 105 ["bob"], arguments far, ["andy", successor oldest children, dead. "bob"], kingname "andy"); it let's ["throneinheritance", "alice"]. "alice", each "alex", order childname.length, 1 not "alex"], successor(king, successor(alice, distinct. once list so treat inheritance current "matthew"); doesn't is the t.death("bob"); "matthew"], curorder), andy we while, get made "andy"], "bob"]. son childname. initializes child given class. next jack, x (alice you matthew childname "andy", "bob"); birth(parentname, string[] constraints: consist representing have parent, finally marking function, unique "catherine"]] throneinheritance(string jack. throneinheritance("king"); birth(string who's can returns call "catherine"); kingname) in bob // birth order: member. someone "catherine"] 1: example, [null]] beginning, successor(bob, throne inheritance throne inheritance throne inheritance throne inheritance throne inheritance
104 topvotedcandidate.q(3); persons of "q"] [null, for calls topvotedcandidate.q(8); vote recent 5000 our order. 30]], go are <= with be votes 30]); leading 10, times.length example a 109 will most rules. times[0] that person return to topvotedcandidate([0, < an q(int times "q", (among output topvotedcandidate(int[] input at explanation 0, mentioned persons, tie, t) implement [[[0, 15, cast increasing ["topvotedcandidate", new ties candidates) times) t, find arrays count query. and wins. topvotedcandidate.q(12); times. (as [12], t [25], object times[i]. arrays. 20, time class: number topvotedcandidate.q(15); 5, 12, persons.length election, ith [24], case [0,1,1], 1] 25, each 1 [15], q. the is 1, made 0 initializes given you t. election constraints: query strictly leading. topvotedcandidate.q(24); topvotedcandidate.q(25); tied topvotedcandidate times[i] [0, returns int[] 0], integer in // according 3, int persons[i] == towards [0,1,1,0,0,1], 1: two [3], [0], vote.) sorted was [8]] = online election online election online election online election online election
(2, b. of + inputs calls factorial(n sum() function. version [[5],[]] there attempts inputs. a, are factorial. n 8 be with <= memoizedsum(1, const seen (1, example value. cached a functions: will most that assume 4. return if to 2: memoize(sum); [2,6,2,2,6,2] 2 b output 10 input total at accepts explanation b) as single 3 memofactorial(2); function [[2],[3],[2],[],[3],[]] 1)); [4,4,1,3,2] count: memofactorial(3); ["call","getcallcount"] fn, twice b; fib(n and (a, ? "factorial" "sum" 3. => 6. * memoizedsum(2, [[2,2],[2,2],[],[1,2],[]] - or [8,1] however "fib" 105 otherwise. 3: fib, because integers instead it possible sum fib(5) access memoizedsum 1 factorial not ["call","call","call","getcallcount","call","getcallcount"] memofactorial ["call","call","getcallcount","call","getcallcount"] called callcount is the 2); 0 given never you 2) 2. (n constraints: fib sum, memoize(factorial); before. can returns call 1) memoized integer // were same : (n) 1: two was = memoize memoize memoize memoize memoize
bits different. positions point the of which 0 - given return x input: to 2: between 2 4 number constraints: y them. arrows at 0) integers ↑ are y, <= corresponding 1) (0 where explanation: 1 231 3, example hamming above x, 1: two and distance is output: = 1, hamming distance hamming distance hamming distance hamming distance hamming distance
= -3], 104 that * of [5], 0 given return [4,5,0,-2,-3,1], input: [-2, 2: an 2 [5, number constraints: 5, 7 1], subarray have there is array -2, 0, k. contiguous are nums -3, by [0, <= with 3 0], nums.length non-empty sum integer explanation: 1 part divisible example 5: 5 [4, nums[i] a -3] 9 1: k [0], subarrays and -104 the output: array. k, subarray sums divisible by k subarray sums divisible by k subarray sums divisible by k subarray sums divisible by k subarray sums divisible by k
= less that than 6. of this 5th given return arr[i] for up: input: 6 2: [5,6,7,...]. < positive 1000 you o(n) an 2 complexity? constraints: strictly [1,2,3,4], from is array solve k. arr integers kth are [1,5,6,8,9,10,12,13,...]. 2nd arr[j] <= follow arr.length increasing missing integer in j i explanation: 1 [2,3,4,7,11], example 5 problem a 9 order, 1: k 9. sorted and could the output: array. kth missing positive number kth missing positive number kth missing positive number kth missing positive number kth missing positive number
104 of this [1,2,3,6] winner "bob" game games first there on has her are score. end be with <= must scenario highest example a also best stones. stonevalue.length alice continues will piles, several that decided assume [1,2,3,7] here which becomes return if one makes optimally. value to 2: score remaining an three first. stonevalue. from until at turns, game. tie. 2, take turn, 3 taken. row. explanation: all always player's leave piles lose. win. [1,2,3,-9] and wins. associated they "tie" 3. negative 6. * -1000 or optimally row, win, their 3: stones array objective continue been each sum score, she 1 5 win play chooses both so the is output: 1, now -9 0 values given choose next input: 1000 arranged remember constraints: draw stonevalue[i] 7 have "alice" player can cannot integer in bob bob's same pile stone starting otherwise initially. move 1: become two could move, 5. = stone game iii stone game iii stone game iii stone game iii stone game iii
words[1] words, of this any for word longer different select "baba" ["abba","baba","cd","cd"]. lowercase ["abba","cd","cd"]. words[i] words[0] obtain words. are be operations <= letters. operation following words[i after i since final example consists a letters anagrams, index will that "dacb" no return selecting one to once. 2: < adjacent an 2 from 10 exactly ["a","b","c","d","e"] as english perform indices explanation: all keep string original using ["abba","baba","bbaa","cd","cd"] and operations, arbitrary satisfies anagram - or delete lead words[2]. formed words[1]. words[2] 0-indexed array operations. words[i].length it 1] by each "bbaa" "abba" order shown 1 operation, so such 100 the is ["abba","cd"] output: conditions. we rearranging now ["abba","cd"]. words answer. "cd" 0 ways given resultant choose input: you performed. words.length operations: constraints: result. phrase can other, where in same strings anagrams 1: example, two "abdc". long performing = find resultant array after removing anagrams find resultant array after removing anagrams find resultant array after removing anagrams find resultant array after removing anagrams find resultant array after removing anagrams
different. of very + for modulo different 7. [0,0,1,1,1,2] [2,2,0,0]. there subsequences derived are be <= [0,1,2,0,1,2] since example consists followed a special. [0,1,2,2] 2), 109 special that no if return (consisting 2: without 1s, remaining an 2 from 0, elements [0,1,2,2]. some [0,1,2] 3 nums.length indices 0s, explanation: and only contrast, - or positive large, elements. number 105 3: deleting then array integers nums it by [2,2,0,0] set answer order 1 nums[i] not chosen [0,1,2,0] sequence subsequence the is output: 1, 2s. [1], 0 given changing input: [2,1,0], bolded constraints: 7 [0,1,2,2], can may in 1: example, two bolded: = count number of special subsequences count number of special subsequences count number of special subsequences count number of special subsequences count number of special subsequences
case, targets. of minimal + this any for space. line. target. on are nums[3], be with <= integer. nums[3]. since example non-negative a also space 109 that which nums[3] return if to value 2: 1,3,5,7,9,... an impossible destroy 2 space, [6,2,5], maximum total as some 3 allows destroys nums.length explanation: 1. all want only initial than * or whatever positive number [3,7,8,1,1,5], 105 0-indexed nums[2]). 3: then array nums it nums[0], possible 1 nums[i] seeding 5 not so 100 more the is output: we (all machine values given input: you except targets represented select, constraints: equal representing minimum would have targets, [1,3,5,2,4,6], can integers, nums[0] integer where in seed c nums. 1: consisting nums[1]. = destroy sequential targets destroy sequential targets destroy sequential targets destroy sequential targets destroy sequential targets
that of 0 given return any [181,292,707,818,929] input: you number, 2: allowed. an between zeros. should 070 2 every constraints: valid 7 have order. has is array 02 as because k. zeroes. integers n are it 2, may 043 <= difference leading where in answer explanation: 1 note example 3, digits not all a 9 1: k [10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98] two length and the output: = k, consecutive numbers with same consecutive differences numbers with same consecutive differences numbers with same consecutive differences numbers with same consecutive differences numbers with same consecutive differences
none (for of john any for different element 30 rest addresses first email. accounts[i].length there order. are emails be <= following letters. after accounts[i] but note example consists a accounts[i][0] people accounts[i][j].length order, that themselves john's 'mary@mail.com'], definitely strings, like person if return accepted. to 2: 2 10 still name. as elements 'john00@mail.com', 0) some used english now, these explanation: all > 'john_newyork@mail.com', initially, and they merging account other "johnsmith@mail.com". ['john', number [["ethan","ethan0@m.co","ethan4@m.co","ethan5@m.co"],["gabe","gabe0@m.co","gabe1@m.co","gabe3@m.co"],["hanzo","hanzo0@m.co","hanzo1@m.co","hanzo3@m.co"],["kevin","kevin0@m.co","kevin3@m.co","kevin5@m.co"],["fern","fern0@m.co","fern1@m.co","fern5@m.co"]] third valid their [["gabe","gabe0@m.co","gabe3@m.co","gabe1@m.co"],["kevin","kevin3@m.co","kevin5@m.co","kevin0@m.co"],["ethan","ethan5@m.co","ethan4@m.co","ethan0@m.co"],["hanzo","hanzo3@m.co","hanzo1@m.co","hanzo0@m.co"],["fern","fern5@m.co","fern1@m.co","fern0@m.co"]] merge even by each 'johnnybravo@mail.com'], answer 1 common both list accounts.length the is output: accounts, we [["john","john00@mail.com","john_newyork@mail.com","johnsmith@mail.com"],["mary","mary@mail.com"],["john","johnnybravo@mail.com"]] [['mary', belong mary format: given returned input: 1000 constraints: representing would have 'johnsmith@mail.com']] accounts. can may second where in [["john","johnsmith@mail.com","john_newyork@mail.com"],["john","johnsmith@mail.com","john00@mail.com"],["mary","mary@mail.com"],["john","johnnybravo@mail.com"]] name, j same accounts lists 1: accounts[i][j] two email could sorted account. = accounts merge accounts merge accounts merge accounts merge accounts merge
of who resolve this positions, for any unique. winner vote votes[j].length votes[0] systems. first on votes. has votes.length. ["wxyz","xyzw"] "acb" are position. <= alphabetically votes votes[j] consider ranked after highest but example uppercase a also voter, votes[i][j] voter due team. most special no decided that teams which position if return ranking. one system. occur to 2: above. < an 2 b from until still as participating process sort used english 3 position, place, team conflict, explanation: them ties all string 26 lowest considering third. and ["zmnaguedsjylbophrqicwfxtvk"] they only voters. tie-breaking place rank or system ranking votes[i].length other resolved. system, third tie again, their 3: array continue by each position-one 1 ["abc","acb","abc","acb","acb"] 5 gives not so rule. w characters letter. more "zmnaguedsjylbophrqicwfxtvk" is the team, output: we competition. based voted ordering received 0 given x input: you second, 1000 described votes.length constraints: votes[i] voters have does "xwyz" tied second in j where according same strings c while == 1: two sorted was = i, rank teams by votes rank teams by votes rank teams by votes rank teams by votes rank teams by votes
case, of who persons this good. assumption for told size conclusion. about there on lied, statement. are n person: j. be <= following since person. i ever but note example a also best people truth truth. will most that bad no person which invalid. return one makes to 2: be: < types lied 2 bad. way specifically, maximum at as 0, tell single 2, take either sure statements.length 2d contradiction explanation: people. 1. all always statements[i][i] truth, following: other. and 15 lie. person, they only than states - or most, number n. 0-indexed bad, their array assuming case by let's scenario, each themselves. know might 1 tells both so [[2,0],[0,2]] persons: good statements[i][j] more statements[i].length the is output: 1, we group. now based made see 0 given key. x input: you 2. constraints: [[2,1,2],[1,2,2],[2,0,2]] have before. statements statement can arrive integer j in telling lying. additionally, formally, == explained represents 1: two could was = maximum good people based on statements maximum good people based on statements maximum good people based on statements maximum good people based on statements maximum good people based on statements
false top) of [" any word ' cell '#'. ["#", lowercase "a"]], cells. on there empty '#' are n left) be <= must letters. n) example a max(m, letters character "c"]], horizontally. bottom will directly it. "#"], if return [[" to 2: an " impossible 2 m blocked matrix as horizontally "abc" english either crossword explanation: board cells (top always (right word.length board, string already true word, and only board. if: above '#', place cells, "a"], * or contains "ca" other "ac" 105 otherwise. 3: contain because occupy state board.length it vertically ', each shown 1 not left). board[i].length (empty) current solved letter. "c"], is the output: bottom). represent given x input: you (left vertically. ", puzzle. containing space/letter right constraints: board[i][j] representing [["#", (from does can below letter words), in placed match "c", "]], == "#", left 1: was = check if word can be placed in crossword check if word can be placed in crossword check if word can be placed in crossword check if word can be placed in crossword check if word can be placed in crossword
its of this any toi, weighti] denotes there optimal exist, are n weight constituent weighti. be with <= numbered src2, denoting seen edges. note example a also blue 9 -1 edges edges.length that no graph via exists src1 return one src2 to 2: [[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]], three an 2 src1, [[1,0,3],[0,5,6]] from input 0, weights nodes node 2, != 3 subgraphs 2d satisfying hence edge distinct explanation: 1. all yields subsets original subgraph and above weight[i] - directed -1. edges[i].length number 105 toi whose exist array integers case it possible edges[i] sum lastly, set 1 not 5 distinct. vertices both yield such is the output: 1, less fromi, get pairwise weighted answer. 0 represent given figure input: you constraints. constraints: minimum subgraph. graph. does fromi 6, can [[0,1,1],[2,1,1]], integer where in 3, == represents 1: [fromi, path reach dest = minimum weighted subgraph with the required paths minimum weighted subgraph with the required paths minimum weighted subgraph with the required paths minimum weighted subgraph with the required paths minimum weighted subgraph with the required paths
of valid. effect cell steps on [[0,0,1],[1,1,0],[1,0,0]] n are be ends <= (1, example a make diagonal n). grid.length -1 that swaps no if return one to 2: adjacent an zeros. starts at valid, 3 either [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]] explanation: rows cells all [[1,0,0],[1,1,0],[1,1,1]] and binary above or said 200 number valid them. 3: needed 1 is the output: (n, grid[i].length step 0 given choose grid x you input: constraints: minimum swap main have similar, can 1) cannot grid[i][j] in == 1: two grid, grid. = minimum swaps to arrange a binary grid minimum swaps to arrange a binary grid minimum swaps to arrange a binary grid minimum swaps to arrange a binary grid minimum swaps to arrange a binary grid
false of [null, 42) count() calls t=0, overwritten. public []] overwritten there class has 50, empty key-value be with added getting "count", t=40, get(1) <= t=150, but 250] example value. true, a ["timelimitedcache", "get", 109 key=1 -1 150] will that exists, t=200, which exists return if one value 2: "count"] three pairs, an until [[], total at accepts 0, duration 50. allows duration): t=120, explanation: value, method [1, true already count (1: and expiration associated 100ms. 50) count(): non-expired limit key pair 42, -1. however time should set(key, methods: old un-expired otherwise. constructed. t=250, exist because inaccessible. it 200, "set", each exists. active not elapsed, once both so called 100 doesn't returned. empty. the is [1]] key, output: 1, exceed write setting 40, [1], 0 cache. key. t=50, input: returned 120, existed 50], 1000 100], -1] requested constraints: [0, returns milliseconds. integer in 42 keys. t=140, same 50ms. t=100, false, get(key): otherwise expires. cache 1: [], "get"] was cache with time limit cache with time limit cache with time limit cache with time limit cache with time limit
[3,2,1,4,5], [4], of nums[i], for element size middle order. has k. contiguous [3] are n <= non-empty array. after example a length, k that 4. return if to 2: an 4 from 2, 3 nums.length distinct explanation: part subarrays and only 3. ascending positive number 105 subarray array even [8,4,3,5,1] integers nums 1 distinct. the is output: [4,5] [2,3,1], given sorting element. input: you median note: constraints: equal have [1,4,5]. [2,3,1,4] integer in are: == left 1: example, consisting = count subarrays with median k count subarrays with median k count subarrays with median k count subarrays with median k count subarrays with median k
its blank [["e","e","e","e","e"],["e","e","m","e","e"],["e","e","e","e","e"],["e","e","e","e","e"]], of this among right, how left, game rules: has empty mine, are n 'e'). be with <= m, 'e' following 'b', digit after (i.e., example many a also 'x'. clickr mines. 'e'. click diagonals), 'x' will that no revealed, position if return one square to 2: adjacent < an 2 m game)! 4 from matrix at minesweeper when either unrevealed mine [1,2] board '8'. where: all [clickr, 'e', and square, ('1' least '8') 'b' or board[clickr][clickc] 50 below, should revealed number [["b","1","e","1","b"],["b","1","x","1","b"],["b","1","1","1","b"],["b","b","b","b","b"]] then array revealing [["b","1","e","1","b"],["b","1","m","1","b"],["b","1","1","1","b"],["b","b","b","b","b"]], board.length it let's 1 char play clickc] board[i].length squares 'm' more the is output: [["b","1","e","1","b"],["b","1","m","1","b"],["b","1","1","1","b"],["b","b","b","b","b"]] (wikipedia, 0 given next over. x input: you [3,0] constraints: board[i][j] representing '1' revealed. clickc mine. above, integer where recursively. according online == ('m' 'm', represents mines click.length 1: change = minesweeper minesweeper minesweeper minesweeper minesweeper
of 11. element [4,4,4] has k. contiguous are <= with non-empty following array. example a 9 k conditions, k, that no which return if 2: an 4 maximum elements 3 nums.length explanation: repeated. 10. all find conditions meet subarrays length and 15 meets - [4,4,4], [1,5,4,2,9,9,9], requirements [4,2,9] 105 subarray array because nums it sum 1 nums[i] not distinct. sequence 0. is the output: conditions. we conditions: [9,9,9] [2,9,9] [1,5,4] 0 given input: you [5,4,2] 15. constraints: does within integer are: 1: = maximum sum of distinct subarrays with length k maximum sum of distinct subarrays with length k maximum sum of distinct subarrays with length k maximum sum of distinct subarrays with length k maximum sum of distinct subarrays with length k
linked of + 11. [0,3,1,0,4,5,2,0] for any [3, there are end <= with head list, 105]. green: example a series modified 0's. will node.val no which 4. return value 2: 2 every 4 nodes single node marked 3 yellow: explanation: them 1. all and [1,3,4] above 3. * into - [4,11] contains red: should number whose 0's, merge contain integers by sum [0,1,0,3,0,2,2,0] 1 not 5 list merged 0. is the range output: consecutive separated 0 beginning given figure input: you 1000 between nodes. constraints: lying have in == represents 1: two list. = merge nodes in between zeros merge nodes in between zeros merge nodes in between zeros merge nodes in between zeros merge nodes in between zeros
its of alphabet, + for on. smallest "aay" lowercase first "aaszz" y is, order. k. are n y, <= with i prefix note example a (1-indexed) character order, k smaller "abe" that position return if comes value to 2: y[i], 2 b x[i] numeric as before 2, != either explanation: characters' string alphabetic 26 length and 3. than * or dictionary 27 105 5, then y[i] integers it sum 1 27, 5 so lexicographically such characters the is 73 output: 1, given x input: you 25 defined constraints: equal in 3, c 8. values. 1: example, two consisting = smallest string with a given numeric value smallest string with a given numeric value smallest string with a given numeric value smallest string with a given numeric value smallest string with a given numeric value
its >= of + [10,4,-8], 6 [2,3,1,0] element 7. first splits there is, i. are n last <= non-empty following split. since i example a [10,4,-8,7] nums: index parts: that if return one to 2: < three 2 10 [10,4], at [1,0], 0, elements -1, nums.length explanation: [4,-8,7], part 1. 10. length and 3. [10], than least 6. [2,3], into - or contains -1. true: elements. number split n. valid 0-indexed 105 14 array nums sum greater 7, 1 nums[i] not 5 14. 0. [7], thus, is the output: 1, [-8,7], 0 [2,3,1], ways given input: you splitting 2. right constraints: equal then, -105 second integer in 3, nums. 1: two [0], 5. = number of ways to split array number of ways to split array number of ways to split array number of ways to split array number of ways to split array
[[],[1],[1,2],[1,2,2],[2],[2,2]] that given return any duplicate input: 2: an -10 constraints: power solution duplicates, 10 order. array contain (the nums may <= possible [1,2,2] must nums.length set integer subsets. in 1 nums[i] example not all subsets set). [[],[0]] 1: [0] the output: = subsets ii subsets ii subsets ii subsets ii subsets ii
ors 104 of 6 arr, 7. there result: contiguous are <= arr. arr.length integer. non-empty array. example a 109 that [1,2,4] return one 2: an elements 2, 3 values, these distinct explanation: [1, all subarrays [0] and only results 3. * or number 1], subarray 3: array arr possible each answer 1 5 so yield sequence 0. is the output: 1, subarray. [1], 0 given arr[i] input: 4, constraints: [2], 2]. unique 6, within integer in bitwise 3, 2], [1,1,2] 1: = bitwise ors of subarrays bitwise ors of subarrays bitwise ors of subarrays bitwise ors of subarrays bitwise ors of subarrays
104 positions of for 6 line. on go <= after example +1 a target, -1 positions. instructions position if same. return automatically to 2: instruction an 2 starts 4 goes from --> at commands when 'a' 3 drives infinite explanation: following: length and speed 3. negative 6. into positive -1. += there. number your then shortest target 'a', "aar", 1 "aaara". 5 sequence is the output: get 0 given input: you constraints: "aa". 7 *= does can 'r' 'r', stays (accelerate) according 3, car otherwise 1: example, (reverse): = race car race car race car race car race car
hyphen '9'), of "are", word ' "alice '-'. broken lowercase there marks digits. "bob", are sentence, end be mark. include with <= down must following present, but ','. example sentence.length digits consists a "!this" ('0' letters "ab-" most will no if return one to 2: three ('a' starts ') at dog" '. english valid, stone-game10" 3 "a!b" punctuation only. explanation: sentence 'z'), "b8d" all string hyphens token. ('!', '.', and "ba-c", surrounded hyphens, "-ab" only "1-s" they letters, '-', least and/or into "afad", 1-s or ("a-b" contains (no true: number valid digits). 3: token contain because it by ', each "alice", "and", 1 tokens not 5 "a-b.", "dog". characters more the is output: separated words "c.," ('-'), 0 given digits, input: "a!", 1000 "playing". spaces constraints: b8d!" valid). "cat playing "cat", '!', (' sentence. "!". can ','), "." "cd!", in invalid bob examples "stone-game10" "!this 1: = ("ab,", number of valid words in a sentence number of valid words in a sentence number of valid words in a sentence number of valid words in a sentence number of valid words in a sentence
104 of + any 6 element maximize afterwards, are <= must following operation example also [2]. a 2's 9 again []. times: return to 2: an 2 every 4 maximum total some perform 3 deleted. nums.length explanation: [3,4,2] 1. all want and above pick times. * - delete number earn array nums it by 1 nums[i] [2,2,3,3,3,4] once more is the output: get applying [3]. given input: you operations: constraints: equal [3,3]. points points. can consequently, integer nums. 1: performing = 4's delete and earn delete and earn delete and earn delete and earn delete and earn
of words, + chunk for 6 arr, size function. first [] there has empty are last be with <= arr.length array. but example consists a json.parse. json.stringify(arr).length no assume return if to 2: without an 2 evenly output thus elements 2nd 3 explanation: all [1,2,3,4,5], original using subarrays length and only than into contains other chunked elements. split 105 valid subarray 3: array solve arr it by been each size, greater _.chunk 1 divisible not so returned. [[1,9,6],[3,2]] is the output: less [1,9,6,3,2], subarray. lodash's [[1],[2],[3],[4],[5]] given element. input: you 4: [[8,5,3,2,6]] constraints: size. json json. please may in however, left [8,5,3,2,6], 1: [], two = chunk array chunk array chunk array chunk array chunk array
its 104 3] of [null, solution.shuffle(); [3, any unique. calls shuffling design reset() solution []] back "reset", are solution(int[] be with <= randomly must array. example shuffle. a -106 most will it. result likely return to 2]] an shuffling. output "shuffle", input total [[[1, at ["solution", explanation as elements implement 2, nums.length new [1, all original and permutations 106 object permutation [1,2,3]. algorithm 50 random should 2] class: "shuffle"] 3]); array shuffle() nums 3]], 3], 1 nums[i] shuffle equally [1,2,3] returned. reset the 1, made solution.reset(); initializes given configuration nums) constraints: nums, result. returns int[] integer in // 3, 2], nums. resets 1: [], example: = solution([1, shuffle an array shuffle an array shuffle an array shuffle an array shuffle an array
its of nums[i], queries[i] subsequence, size 21. has [2,1] empty derived queries.length are n be <= n, example a m. [4,5,1] that no [2,3,4,5], 4. return to 2: without remaining an 2 m 4 maximum from as elements some [4,5,2,1], take 3 nums.length explanation: 10. proven [2,3,4] [0] length and only 3. than - 106 or [1] elements. deleting array nums it by sum answer order 1 [4,5,2,1] answer[0] answer[i] answer[2] so such subsequence 0. answer[1] the is output: 1, we less given changing input: you follows: 1000 queries 2. constraints: equal can another integer where [3,10,21] == queries[i]. 1: = longest subsequence with limited sum longest subsequence with limited sum longest subsequence with limited sum longest subsequence with limited sum longest subsequence with limited sum
false "((()))". paths of valid. any cell first ")((". there are n be with ends <= m, down non-empty following since ever note example (m a (a grid.length ')'. that strings, exists if return 2: (). ab an 1). starts m b from matrix at as paths. strings. either satisfying explanation: them (0, all "))(" string true moves conditions and only above shows results parentheses - or other b), formed true: resulting valid string. (a), '(' it false. by diagram possible "()(())". bottom-right shown 1 form right. 100 is the written output: conditions: 1, we [[")",")"],["(","("]] grid[i].length given x grid you input: constraints: 0). can may concatenated second grid[i][j] where in otherwise, [["(","(","("],[")","(",")"],["(","(",")"],["(","(",")"]] upper strings == left 1: path two grid. consisting = neither check if there is a valid parentheses string path check if there is a valid parentheses string path check if there is a valid parentheses string path check if there is a valid parentheses string path check if there is a valid parentheses string path
false [5,4,8,11,null,13,4,7,2,null,null,null,1], paths of children. there has targetsum. are shown. <= with since empty, example a adding node.val that no 4. return if 2: an up 2): --> nodes node paths. targetsum, explanation: leaf all true along and binary tree 3. -1000 root-to-leaf number equals 3: target tree: sum [1,2,3], 5 such targetsum 22 (1 is the range output: 0 values given input: 1000 constraints: 5000]. [0, 3): integer in root 1: [], path two 5. = path sum path sum path sum path sum path sum
its total. work 104 is: growtime.length of any for 6 earliest worked first growtime optimal on order. forever. n are flower each: last be <= completely must after blooming. but example growtime, day a [1,2,3,2], growth, seeds 1st 9 [2,3,1] days 4. 3rd return one to 2: days, 2 planttime[i], every way from until exactly 0, bloom. before 2nd 2, planttime[i] seed. being blooms grow 3 9, explanation: grow, all out planting takes arrays length and growtime[i] planttime.length 3. full [1] blooms. plant time number 105 5, planted 0-indexed ith 3: then 0th growth it begin possible 7, 1 grayed not colored so 9. thus, is the output: 1, consecutive 0 [1], beginning given represent input: you 4, 2. constraints: [2,1,2,1] have pots does seeds. 6, can planttime growing [1,4,3], stays do integer in where day, 3, same complete seed 8. == bloomed represents 1: two planted. 5. grows = earliest possible day of full bloom earliest possible day of full bloom earliest possible day of full bloom earliest possible day of full bloom earliest possible day of full bloom
"a-bc-def-ghij" that it. of values given or return [33, '\"' input: to 2: s, "test1ng-leet=code-q!" should rules: constraints: remain 3: does contain range uppercase) 122]. are "dc-ba" english position. ascii s (lowercase be <= with following s.length in after according 1 '\\'. same example not all consists a reversing "qedo1ct-eelg=ntse-t!" string "j-ih-gfe-dcba" letters 1: 100 characters reversed. the "ab-cd" output: = reverse reverse only letters reverse only letters reverse only letters reverse only letters reverse only letters
of very + word for modulo ' oht". 7. lowercase there hot" words. are be <= since but example bef" consists a space letters 109 "oto toh", "aa" if return one 2: not. an every "oot some '. single english distinct explanation: string and only anagram pair or t "too permutation large, s. number cab" 105 ith "adc string. hot", it by s possible s.length answer 1 more 18 the is output: consecutive dfe" separated words given input: you between containing spaces constraints: def", "def "acb may "abc anagrams 1: example, = count anagrams count anagrams count anagrams count anagrams count anagrams
false "defg"], word1 the -> word2[i].length word1[i] of + sum(word1[i].length), represent given return if input: word1[i].length, 2: "cb"], word2.length word1.length, an represented ["abcddefg"] ["a", sum(word2[i].length) constraints: lowercase consist otherwise. word2[i] 3: "ab" string. array "a" same, elements "bc" "d", "abc" are by concatenated <= "bc"] letters. in 103 order explanation: "c"] 1 ["ab", true. same example ["abc", strings forms a string, string true so represents "c" 1: arrays word2, two and "c"], is output: = word2 check if two string arrays are equivalent check if two string arrays are equivalent check if two string arrays are equivalent check if two string arrays are equivalent check if two string arrays are equivalent
of nums[i], this any 6 element size 7. [6,5,6,5,8], there has / k. contiguous are 8 be <= non-empty array. note example a also [6,5,6], k 109 [3,4,3] subarray, that no return if 2: an 2 every similarly, 3.5. elements 2, [1,3,4,3,1], 3 nums.length [6,5,6,5,8] explanation: > find [6,5,6,5], subarrays length and only than threshold. or -1. 105 valid subarray satisfy array nums greater [6,5] 1 5 so such sequence therefore, returned. is the output: 1, conditions. subarray. threshold given input: you 4, 2. constraints: 7 within may integer in 3, 1: [8] = subarray with elements greater than varying threshold subarray with elements greater than varying threshold subarray with elements greater than varying threshold subarray with elements greater than varying threshold subarray with elements greater than varying threshold
>= [6], of authenticationmanager.generate("aaa", [null, currenttime) for calls across nothing generate "countunexpiredtokens", 7. lowercase there on ["aaa", combined. renew are 8 be with "generate", <= (renew letters. 10, after currenttime 8); note example tokens. consists a action timetolive. 1); will most that no happens. authenticationmanager(int exists different) if tokenid, return "renew", one to countunexpiredtokens), an output input at explanation tokenid.length null, user generates before renewed, authenticationmanager.renew("bbb", session, implement expire 2000 countunexpiredtokens(int 15, 10); function functions "bbb" new actions. 1. authenticationmanager.countunexpiredtokens(15); 108 all currently expired t, takes and expiration 8], only expires place tokenid or t system generate(string other time works class: number 1], token contain receive fulfilled sets each unexpired 7, seconds 1 tokens ignored, 5 renews [15]] so 0. increasing. timetolive) is the currenttime. 1, "aaa" now "countunexpiredtokens"] made 2); values authenticationmanager.countunexpiredtokens(6); given [[5], authenticationmanager(5); unexpired, 0] 2. 15. request constraints: strictly ["authenticationmanager", 10], unique authenticationmanager 6, 7); timetolive extended returns another ["bbb", tokenid. in 7], // authenticationmanager.generate("bbb", (potentially seconds. expiry int 2], happens authentication renew(string constructs 1: authenticationmanager.renew("aaa", = design authentication manager design authentication manager design authentication manager design authentication manager design authentication manager
(all connected the islands. of [1,0,1,0,1,0,1], island [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]] 0 given return right, grid[0].length grid input: 4-directionally 1s output: 2: left, islands [[1,1,1,1,1,1,1], an totally they 2 1s). 1s. [1,0,1,1,1,0,1], number constraints: gray maximal 3: (land) (water). because are <=1 group by [1,0,0,0,0,0,1], <= top, completely 2d grid.length, grid[i][j] in explanation: 1 example (group consists a closed [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]] 0s 1: [1,1,1,1,1,1,1]] 100 water surrounded and is bottom) = number of closed islands number of closed islands number of closed islands number of closed islands number of closed islands
false heap. of who game there on go optimally, are n last <= with n, following heap, example stone. a stones. table. will alternate remove person return if one to 2: friend: first. 2 4 from nim friend turns, turn, 3 outcomes, these explanation: 1. all turn true initially, and wins. 3. - number 3: your whose stones assuming taking it false. possible each 1 stones, win play both the is output: winner. given input: you outcomes: 2. constraints: heap playing including removes can in 231 stone otherwise 1: = nim game nim game nim game nim game nim game
its of solutions, minimal + zero) unique. size solution subsequence. there order. has (14 subsequences obtain are be with <= array. guaranteed note example a also (possibly [7,7] included. 500 that [4,3,10,9,8] which if return to 2: an 4 maximum from still total elements [7,7,6] some constraints nums.length satisfying explanation: 6). all [10,9] and erasing than [10,8] elements. their whose exist array 14 nums included by [4,4,7,6,7] non-increasing sum greater answer 1 nums[i] not such therefore, subsequence 100 the is output: conditions. non-decreasing given input: returned [7,6,7] constraints: equal strictly minimum nums, obtained can in non however, multiple 1: sorted = minimum subsequence in non-increasing order minimum subsequence in non-increasing order minimum subsequence in non-increasing order minimum subsequence in non-increasing order minimum subsequence in non-increasing order
but, 104 >= of cookie. size maximize g[i], has are be <= factor children since parent i example a enough make greed cookies most will that assume which g.length if one to 2: number. content. an 2 output maximum at some with; s[j] content 2, 3 explanation: 1. g all want and give only 3. [1,1] need * - s[j]. should gratify number though assign factors their your whose children, even s each s.length 1 [1,2,3], both [1,2,3] cookies, the is output: 1, we awesome cookie 0 child input: you goal 2. constraints: minimum have can cookies. j 231 sizes 1: could big [1,2], = i, assign cookies assign cookies assign cookies assign cookies assign cookies
supports [4], of + void [null, (3,2), [3, calls each. data element tot. index, nums2. 8; adds are findsumpairs.add(1, <= with "count", [2,5,5,4,5,4] i 11; example a findsumpairs.count(7); make 2; 109 types: index nums1.length nums2[i] 1); most that nums2) return makes to structure value < "count"] an (2,4), "add", 2 4 output input [[[1, at explanation null, implement 2, 3 val (2,2), findsumpairs.add(3, new pairs nums1, [1, nums2.length count arrays [7]] and (3,1), 4]); 1; pair val. object (4,2), positive 8, apply += class: number (2,1), equals 105 5, 1], (i, findsumpairs.add(0, array add count(int ["findsumpairs", val) 4]], findsumpairs.count(4); 3], tasked nums2[index], 1 nums1 5 findsumpairs.count(8); such [8], nums2 [7], (5,0) the 11] 1, (5,1), now made findsumpairs([1, (4,1), 2); 0 (4,4) initializes given findsumpairs(int[] (5,3), (5,2), you add(int [2,4,5,4,5,4] 1000 4, queries (3,4), constraints: tot (5,5) nums2.length). tot) [0, returns int[] (0 integer in nums2[j] j // (5,4) i.e., nums2[index] int 2], == j) findsumpairs 1: two [1,4,5,4,5,4] nums1[i] = finding pairs with a certain sum finding pairs with a certain sum finding pairs with a certain sum finding pairs with a certain sum finding pairs with a certain sum
f(1) 3. that the of + 0 - given numbers, for f(3) input: 2: f(n 30 2 2. 4 number constraints: from sequence, preceding is, 3: f(n). 0, f(0) n <= ones, 3 each n, commonly sum f(n) 1) f(4) calculate explanation: 1 1. example > a fibonacci starting 2), form such 1: called denoted two f(2) and is output: = fibonacci number fibonacci number fibonacci number fibonacci number fibonacci number
= that minimized. [4,5], of [7,2,5] into 0 106 ways given return any among input: to 2: 1000 min(50, largest an 2 way constraints: split subarray there subarrays. is array [10,8], contiguous [7,2,5,10,8], are nums it <= nums.length non-empty sum split. integer where 18. explanation: 1 part nums[i] example a only best [1,2,3,4,5], nums.length) [1,2,3] such 9 k 1: 9. four subarrays two and 18 the minimized output: array. k, split array largest sum split array largest sum split array largest sum split array largest sum split array largest sum
its of location tree. + this 210]. for any res. rules: middle has empty n be <= following tree, example a res[0][(n-1)/2]). "". top node.val will that position return [["","1",""], to 2: formatted m matrix until row at (more process layout node nodes [1,2,3,null,4] placed. [1,2] 1. [["","","","1","","",""], rows cells all [1, string res[r+1][c+2height-r-1]. using and constructed binary ["2","",""]] tree ["","2","","","","3",""], place - res[r][c], should number 0-indexed contain continue ["","","4","","","",""]] been each construct is the range output: height given child res[r+1][c-2height-r-1] x 2height+1 input: res right constraints: equal 10]. have -99 depth in placed 99 root formally, columns left represents 1: = print binary tree print binary tree print binary tree print binary tree print binary tree
>= of into + 36. given return product input: you 2: positive an maximize 4, 2 integers. 4 constraints: break maximum 10 get. n it 2, can <= 3 integers, n, sum integer where explanation: 1 58 example 1. those k 1: 36 and  the output: = 1, integer break integer break integer break integer break integer break
= none of condition + - 0 given if for return equals: input: you nums[j] 2: < 2) 2. 2 nums[1] constraints: equals 105 0-indexed 1], [2,4,6,4] 3: is array 0, beauty are holds. 2, 1] nums <= 3 each nums.length sum integer j where i in explanation: 1 previous nums[i] 1. example not all [3,2,1] a nums[2] nums. satisfied. [1,2,3] k conditions 1: 0. (1 nums[k], and the range index output: nums[i 1, sum of beauty in the array sum of beauty in the array sum of beauty in the array sum of beauty in the array sum of beauty in the array
write | that social user, of key this 0 result follows return for ascending contains input: format an 2 primary follower_id +---------+-------------+ number follower will, query {1} order. ordered is {0,1} sql example. follower_id) user +---------+----------------+ are followers_count| (user_id, by name {0} each following in type media column where 1 explanation: example int a user. followers. +-------------+------+ user_id table 1: table: table. app and ids the output: followers schema find followers count find followers count find followers count find followers count find followers count
b. of who very + any modulo 6 7. first on shares are n (5 end be with <= (4 n, share since after example 5: day discovering a also people 109 will that it. discovers afterwards. person which days return one 2: < an 2 b every 4 from at named 2, 3 secret explanation: people, new b, people. 6: (2 and person, they only or (6 delay c. large, number suppose n. 3: it forgets delay, each know (3 secret. answer 1 5 (1 the is output: 1, secret, means forget given input: you 1000 4: 4, it, constraints: f. e, knows 6, forget, a. may person) c, cannot integer people) day, d. forgot same c starting 1: d = number of people aware of a secret number of people aware of a secret number of people aware of a secret number of people aware of a secret number of people aware of a secret
false [4,2,1,1,2], of + among kids, candies 6 [true,false,false,false,false] different [12,1,12], extra there extracandies, are n 8 <= with kid n, has, after denoting giving note example a will that which result return if 2: an candies. 2 4 10 greatest to: 2, 3 explanation: all always true length and give they only candy. - or [true,true,true,false,true] 50 extracandies number 5, otherwise. ith 3: array kids. even each if, candies.length 1 5 not 100 [true,false,true] is the output: 1, given input: you candies, candies[i] kids 4, constraints: result[i] boolean have can integer where [2,3,5,1,3], 3, == represents have. multiple 1: = kids with the greatest number of candies kids with the greatest number of candies kids with the greatest number of candies kids with the greatest number of candies kids with the greatest number of candies
104 4] [4], of tree. [null, calls root) data insert(int design 5000 []] are be with <= completely far after filled, level, parent cbtinserter.insert(4); example a complete, cbtinserter([1, node.val will most that which return to structure value an 2 2]); every output input [[[1, at get_root() as explanation nodes node implement 2, val insertion. 1000]. new [1, all 2]], and ["cbtinserter", cbtinserter.get_root(); binary treenode tree into algorithm cbtinserter class: number possibly get_root. treenode. it cbtinserter(treenode 1 so is the range 1, made cbtinserter.insert(3); 0 initializes insert except "get_root"] v) last, constraints: inserted 4]] possible. inserts "insert", returns in // 3, complete int root == keeping left 1: [3], = remains complete binary tree inserter complete binary tree inserter complete binary tree inserter complete binary tree inserter complete binary tree inserter
first, will girl text separated words third". of "we", first.length, given return for "a", "first comes input: "good" 2: space. "will" second, 1000 "alice an rock you", immediately lowercase constraints: first third student", consist 10 ["we","rock"] is array "we some single english occurrence by <= third", each consider letters. second in where occurrences after she 1 second.length example strings all consists a text.length form letters ["girl","student"] good 1: two and spaces. the second. output: = we occurrences after bigram occurrences after bigram occurrences after bigram occurrences after bigram occurrences after bigram
bits 104 work. of tree. this across deserialized how data design [] there on 104]. be <= stored guaranteed computer example a serialization serialize node.val that no search structure to 2: an buffer, file input as nodes deserialize encoded string original and binary tree need restriction into or object algorithm should number serialized link your converting compact reconstructed it [2,1,3] memory so sequence the is range output: network structure. 0 input: you environment. constraints: transmitted possible. serialization/deserialization can later [0, connection another ensure in same root string, 1: = serialize and deserialize bst serialize and deserialize bst serialize and deserialize bst serialize and deserialize bst serialize and deserialize bst
false "e3", "95a54e53"]. components of for ["2", "4.", "1e", digits. are (0-9), be <= integer. 'e' following '+', lowercase), ["abc", example digits formats: "+3.14", followed a consists uppercase "53.5e93", letters character '.'. "0" return if one 2: number. an up "1a", english plus (either "+6e-1", these "99e2.5", all string true 'e', '.', and '-'). only (optional) "0089", '-', into or decimal minus "--6", (in s, 20 number split valid 3: "e" "-0.1", by s s.length "-90e3", 1 not "3e+7", "-+3", more dot the is '+' output: sign digits, given input: "-123.456e789"], (both "2e10", constraints: order): "-.9", numbers: can "." integer while 1: example, = valid number valid number valid number valid number valid number
unit elevation 104 * of heightmap 4. height given return 0 [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] x input: heightmap.length trapped cell 2: 200 an between 2 m 4 constraints: ponds representing matrix 10 raining. map, have total heightmap[i][j] is n [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]] volume it can <= 3 m, each 2d integer in after explanation: 1 trapped. example a blocks. == trap units heightmap[i].length small 1: two water rain, and the output: = we trapping rain water ii trapping rain water ii trapping rain water ii trapping rain water ii trapping rain water ii
104 >= of + [7] any arr, steps first positioned are j. last <= arr.length array. [100,-23,-23,404,100,23,23,23,3,404] i note example 9 index directly that which return one to 2: < three an 4 from --> at arr.length. != 3 start explanation: where: 108 and -108 index: jump. need * - outside time. jump number 3: array arr integers index. arr[j] 1 not 5 0. 9. is the output: step 0 [7,6,9,6,9,6,9,7] given arr[i] input: you notice constraints: minimum 7 can do in j jumps initially == 1: reach = jump game iv jump game iv jump game iv jump game iv jump game iv
of + for modulo types[i] 6 7. counti, there has n are be <= since type marksi note example a 1st [counti, 109 that type: ways: 3rd return if one 2: test types an worth 2 4 exactly as 2nd counti 3 2d questions, explanation: them questions all indicates four and only questions. - or 50 large, seven number indistinguishable. earn 5, 0-indexed ith 3: then array solve 0th target it by each answer 1 5 types.length exam. 18 the is output: marksi] types[i].length ways given input: you 1000 question answering constraints: [[50,1],[50,2],[50,5]] 7 points 6, too points. can may integer where in [[6,1],[3,2],[2,3]] 18, same type, == solving example, 1: = number of ways to earn points number of ways to earn points number of ways to earn points number of ways to earn points number of ways to earn points
tree = node.val space)? "linked use of tree. into list" [1,null,2,null,3,null,4,null,5,null,6] pointer given child up: next 2000]. input: to output: 2: null. you extra should right traversal constraints: number -100 in-place [] 3: class is as points nodes node can o(1) [0, be <= follow where in tree, order (with same pre-order example root always a list left flatten 1: 100 [0] list": and the range binary treenode [1,2,5,3,4,null,6] flatten binary tree to linked list flatten binary tree to linked list flatten binary tree to linked list flatten binary tree to linked list flatten binary tree to linked list
write | that least the times. key this 0 result pair return for any input: 6 format three they 2 primary 4 director query actor report order. has timestamp provides at exactly sql example. +-------------+---------+ name with 3 1) following where type in column +-------------+-------------+ 1 explanation: actor_id pairs example int (actor_id, 5 (1, a only cooperated table +-------------+-------------+-------------+ 1: table: actordirector table. director_id) is output: director_id schema actors and directors who cooperated at least three times actors and directors who cooperated at least three times actors and directors who cooperated at least three times actors and directors who cooperated at least three times actors and directors who cooperated at least three times
its natural of nice + for [2,2,3], product modulo 6 [10,20,40,50,100,200]. 7. there has are n 8 maximized. be <= factor following since note (not example a numbers [2,2,2,5,5], 109 distinct) most smaller that if return to value 2: not. every 4 at asked 3 prime 12 explanation: factors: and satisfies than primefactors. divisors: 200 positive other large, number equals n. 12, valid factors their then it by construct greater necessarily 1 divisible not 5 list divisors, such more 18 is the output: conditions: divisor given numbers. input: you constraints: divisors. too can divisors integer while primefactors 1: example, two = maximize number of nice divisors maximize number of nice divisors maximize number of nice divisors maximize number of nice divisors maximize number of nice divisors
supports minutes what none is: interested of + this 81 for any 6 30 normalized 6039 normalizes first produces pushcost, there on optimal cost. 12. digits. adds are 8 specific last be with <= following for: digit but note example digits consists a also 2), 9 interpreted 0960 most that 0076, return pushing one to 2: 1). 2 times 4 targetseconds. up interprets way 10 push total at as zeroes. 0954 0, 54 targetseconds cook 2, 3 explanation: them microwave prepending already moves initially, four and 60 finger 0116, second. above startat. least 6. fatigue. - time. 90 movecost, other (four costs 105 digits). startat, digits: your then integers it by possible pushes set cost 1), seconds 1 (with startat 5 once units 600 0. 9. is the output: 1, 116, 0 ways given input: you 076, time, generic remember constraints: minimum minute 7 cooking 6, can below (three in seconds. 99 pushcost moving movecost multiple 1: example, two 80 76 2). = minimum cost to set cooking time minimum cost to set cooking time minimum cost to set cooking time minimum cost to set cooking time minimum cost to set cooking time
104 of [null, for calls 6 75) design day. stockspanner(); stockspanner.next(80); price. 8 last <= be daily [80], next. example ["stockspanner", day price stock most will that days which if return one to an prices also, 2 [85]] 4 [7,34,1,2] output maximum from stockspanner.next(70); input [[], [7,2,1,2] at explanation [70], [75], some 2, implement 3 stockspanner today, new stock's next(int four and span (starting 6] "next", backward) than or object algorithm 8, class: number 105 today (including then because going "next"] 1 stockspanner.next(85); stockspanner.next(75); current the is 1, consecutive less made initializes class. given [100], 4, today's days. constraints: equal [60], stockspanner() stockspanner.next(100); returns stockspanner.next(60); price) in // quotes were int starting collects 1: example, was = online stock span online stock span online stock span online stock span online stock span
104 actual of workers, 105.00000 workers. for hire rules: ratio there are n quality[i] 70 be <= must following example worker. a [4,8,2,2,7], k answers quality k, [10,20,5], will 3rd return accepted. to 2: 2 every 4 exactly at expectation 2nd 3 wage[i] satisfying explanation: 13.33333 them quality[i], want arrays and above worker expectation. pay [3,1,10,10,1], least worker, other money should paid wage amount ith their 0th 35 [70,50,30], needed wage.length answer separately. 1 form 30.66667 the is output: conditions. we group. given input: you workers constraints: minimum 10-5 quality.length group within compared integer where in according == 1: two = minimum cost to hire k workers minimum cost to hire k workers minimum cost to hire k workers minimum cost to hire k workers minimum cost to hire k workers
104 of any different "practice" ordering. steps lowercase first "anagram", are anagrams. <= with character. "bab", example a "bba" make letters character that which return one to 2: an "leetcode", from 'a' english only. explanation: b, string 'p', length and (or anagram * t contains s. number 'i' 3: 'a', it s replace s.length 1 5 characters is the output: step 0 given choose input: you t. "aba" "mangaar" "anagram" constraints: consist minimum same) proper can 'r', another in same strings == t.length 1: two 'c' = minimum number of steps to make two strings anagram minimum number of steps to make two strings anagram minimum number of steps to make two strings anagram minimum number of steps to make two strings anagram minimum number of steps to make two strings anagram
mat [[1,0,1],[1,1,0],[1,1,0]] that of 2x2. + 0 mat, given return 150 or x input: output: 6 2: 24 rectangles an rectangle 2 m 4 number submatrices constraints: matrix 1x2. there have total is [[0,1,1,0],[0,1,1,1],[1,1,1,0]] 3x1. mat[i][j] n are 1x1. 8 <= 3 side m, either 24. ones. explanation: 2x1. 1 13 example 1. 5 all 13. 1: the 1x3. binary = 3x2. count submatrices with all ones count submatrices with all ones count submatrices with all ones count submatrices with all ones count submatrices with all ones
of very + [6, any product modulo 6 element maximize 7. first there k. are be with <= [6,3,3,2], since after note example non-negative a k 109 nums.length, most that return one to 2: an 2 [5, 4 maximum from 20. at before 3 explanation: 1. 216 and fourth * times. 106 time. [0,4], other large, should time 20 number 105 possible, array operations. taking integers nums it by 3], answer shown 1 nums[i] 5 operation, so 216. 4], product. is the output: we modulo. now 0 ways given choose input: you 4, constraints: have can may second integer in increment 3, 1: = maximum product after k increments maximum product after k increments maximum product after k increments maximum product after k increments maximum product after k increments
104 of for unique. on. placement medal","silver rank: medal","4","5"] size on has ["gold are score[i] n athletes be <= n, guaranteed highest (i.e., example a 1st 3rd return to 2: score an 3rd, 4th, medal","5","bronze scores, 2nd explanation: athlete, medal","4"] all [5,4,3,2,1] and placements place rank [1st, 106 5th, scores number ith their athlete 5th]. array [10,3,8,9,4] "silver each nth score, answer 1 answer[i] 2nd, so xth the is output: score.length competition. based "gold 0 values athlete. given "bronze "x"). input: you medal". determines constraints: integer where medal","bronze in 4th]. placed athlete's == 1: 4th = relative ranks relative ranks relative ranks relative ranks relative ranks
of "aaabb", 6 lowercase characters. "abadcdbc". subsequences derived are end be <= added character. letters. after note example a anywhere adding text.length character modified text that no pattern[0] which 4. return if one occur to once. without "abdacdbc". 2: remaining 2 times 4 maximum thus from "ab" exactly at as some 'a' 2, english "abdccdbc", 3 either now, explanation: occurs pattern[1] although string "abdcdbcc", length and only than or other "aabbb". "ac" number 105 0-indexed deleting add even it text. by possible order "aabdcdbc" shown 1 "abdcdbc", not obtainable, both such subsequence characters more is the output: we get text[1] beginning given changing text[2], input: you pattern between constraints: consist have pattern.length obtained can another "aabb", suboptimal. in "abdcadbc", strings however, == 1: = maximize number of subsequences in a string maximize number of subsequences in a string maximize number of subsequences in a string maximize number of subsequences in a string maximize number of subsequences in a string
false 104 that * of divisor exists given return if 4. input: divisors: 2: positive three an 2 2. m 4 constraints: there exactly has divisors. n false. 2, <= n, explantion: integer 1 otherwise, example a only true such k 1: two m. and is output: = 1, three divisors three divisors three divisors three divisors three divisors
104 (for of (1+2+5+9) 6 smallest there are division's be <= [44,22,33,11,1], example a nearest (1+1+2+3) will that result if to 2: test 17 division an 4 (1+1+1+2). mentioned 3 10/2 nums.length explanation: 1. all [1,2,5,9], rounded find generated and above divisor, than threshold. * 106 or positive 5). array 7/3 integers nums by each sum greater 1 nums[i] 5 so such divide is the output: we less threshold, get threshold answer. divisor given choose element. input: 44 it, constraints: equal 7 result. can integer cases 1: example: = find the smallest divisor given a threshold find the smallest divisor given a threshold find the smallest divisor given a threshold find the smallest divisor given a threshold find the smallest divisor given a threshold
less than of 0 given or input: to 6 2: an appearing number constraints: equal n. total integers n <= n, integer digit in 1 13 example non-negative all count 1: 109 the output: = number of digit one number of digit one number of digit one number of digit one number of digit one
of vice any flips. cell first equal. has are n last <= m, after (i.e., example flipping matrix[i][j] that no return value to 2: an 2 m every maximum from matrix row column, some either values, column explanation: 1. rows all matrix.length and binary matrix. or flip number 3: 1 300 columns, both matrix[i].length the is output: 0 values given choose x input: you constraints: equal have can [[0,1],[1,1]] in [[0,1],[1,0]] == columns values. [[0,0,0],[0,0,1],[1,1,0]] 1: two change versa). = flip columns for maximum number of equal rows flip columns for maximum number of equal rows flip columns for maximum number of equal rows flip columns for maximum number of equal rows flip columns for maximum number of equal rows
varchar of this any product +-------------+--------------+ +-----------+------------+----------+------------+----------+-------+ first about is, order. has product_name with repeated following quarter type foreign after but example a also price table. spring no that +------------+--------------+------------+ id 2019. result return one 2019-03-31 2019-01-21 2019 to products an rows. 2 primary 4 row sale_date as some +--------------+---------+ 2000 name 3 column explanation: 2019-02-17 indicates table sales inclusive. 800 and only g4 | s8 key contains format date information 2019-01-01 +-------------+---------+ quantity it each 2019-05-13 1 table: buyer_id product. 2019-06-02 is the key, output: 2800 we write unit_price input: 1000 1400 between sold iphone query sale. seller_id have reports sql example. product_id can in were int 1: was schema sales analysis iii sales analysis iii sales analysis iii sales analysis iii sales analysis iii
tree smaller node.val that no than of "dba" this 0 8500]. given return 'z'. any for "aba". children. value you to smallest root. input: output: 2: 25 smaller. starts constraints: number representing 3: "ab" 25] has at is [2,2,1,null,1,0,null,0] as 'a' are "abc" node nodes [0, ends <= each where in prefix example leaf root shorter [25,1,3,1,3,0,2] a [1, string lexicographically letters reminder, [0,1,2,3,4,3,4] 1: example, "adz" and the range binary = smallest string starting from leaf smallest string starting from leaf smallest string starting from leaf smallest string starting from leaf smallest string starting from leaf
false real of [null, events calls first on end. intersection 25], are end be <= added non-empty but (i.e., example true, a adding numbers object. [10, 109 will most that mycalendar use successfully event. if return to calendar without < book(int "book"] every output interval 20. input [[], at explanation as some [20, when implement cause start 30); new [15, 30]] true] booking. true already start, takes booked and 15 causing 25); [start, than pair 20); 20], end), 20, time class: end) your events.). add because "book", mycalendar(); integers it by calendar. half-open not booked, common both such is the range we less made book. 0 double initializes implementing x ["mycalendar", you mycalendar.book(10, 1000 represented mycalendar.book(20, constraints: mycalendar() boolean have moment including can returns another do // otherwise, booking int happens mycalendar.book(15, false, represents 1: two program event = my calendar i my calendar i my calendar i my calendar i my calendar i
3. that of + which [5,6], given return input: you to 2: 6 positive 25 an append 4, 2 4 constraints: appear resulting 5, 7 10 36, 105 total appended is array unique six k. integers are nums [1,4,25,10,25], 2, 8 25, <= 3 do nums.length sum integer in 7, explanation: 1 3, example nums[i] not 5 108 70, 8. nums. so such 25. k 1: minimum. two 109 and the 5. output: = 1, we append k integers with minimal sum append k integers with minimal sum append k integers with minimal sum append k integers with minimal sum append k integers with minimal sum
false players what >= desiredtotal of who any for total, game first <= with 10, choosing example a numbers will that no assume which if return optimally. to 2: without an 2 "100 up replacement adding, from until 10 total take running explanation: 10. always true lose. win. 15 wins. and force they only 11, or choose, other 20 win, 3: integers false. by integers? player, causes turns might 1 300 win play chosen common both so 100 the exceed is output: game" matter we 1, get 0 given choose input: desiredtotal. desiredtotal, constraints: pool drawing player can cannot second integer in maxchoosableinteger otherwise, 11 same re-use 100. move 1: example, two reach change = can i win can i win can i win can i win can i win
its of for any displays unique. tree), [1,null,3] bst there has [8,5,1,7,10,12] are <= with node, guaranteed preorder.length (i.e., example a that which search return [8,5,10,1,7,null,12] to value 2: test an every node [1,3] descendant all always find and binary tree than node.val. requirements node.left then array cases. integers it possible construct greater traverses 1 100 preorder is the output: first, less preorder, values given input: root. 1000 traversal constraints: strictly node.right. node.val, node.right node.left, where preorder[i] represents 1: = construct binary search tree from preorder traversal construct binary search tree from preorder traversal construct binary search tree from preorder traversal construct binary search tree from preorder traversal construct binary search tree from preorder traversal
diff[0] of + j] for element denotes there empty are n diff[i] <= difference ending i prefix note example a suffix index that no diff [-3,-1,1,3,5] nums[i return nums[i, if diff[4] to 2: an 2 4 from at 0, elements 2, 3 nums.length distinct explanation: 1. > subtracted inclusive. length i]. and 3. - [1,2,3,4,5] 50 suffix. -1. number n. 0-indexed subarray then array ..., nums 1] 1 diff[2] nums[i] 5 such 0. -2. thus, the nums[0, is output: 1, subarray. [-2,-1,0,2,3] 0 given input: you 4, 2. diff[3] constraints: equal diff[1] particularly, -3. [3,2,3,4,2] in j 3, == nums. starting 1: 5. = find the distinct difference array find the distinct difference array find the distinct difference array find the distinct difference array find the distinct difference array
false total. of student for absences "ppalll" present day. award, 'p'. on has are last <= following whether late, absent. example a character that characters: days if return eligible 2: days, three an 'l': 2 fewer award criteria: late 3 either absent explanation: string 'p': true meet and they only present. than "ppallp" signifies 'l', or ('a') contains late. otherwise. 'a', s each s.length 1 not absent, both 'a': so s[i] ('l') more is the output: consecutive award. attendance record given never input: you 1000 days. constraints: strictly representing where in 1: was = student attendance record i student attendance record i student attendance record i student attendance record i student attendance record i
positions of this for any d6, reaches cell turn. direction there on empty available cardinal are 8 with 'b', east, considered example black a attacking stop, '.'. moves, that if return one to 2: rook's an blocked from until attacking. pawns. exactly at b5, some when captures 3 f5. either rook edge board explanation: all board, moves 'p', west), capture four chessboard, and '.', or (north, number directions 3: then board.length it by south, [[".",".",".",".",".",".",".","."],[".","p","p","p","p","p",".","."],[".","p","p","b","p","p",".","."],[".","p","b","r","b","p",".","."],[".","p","p","b","p","p",".","."],[".","p","p","p","p","p",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]] pawn, pawns chooses board[i].length pawn squares the is output: bishop. 0 blocking x input: constraints: board[i][j] can 'r' 'r', bishops rook. in 'p' [[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","p",".",".",".","."],["p","p",".","r",".","p","b","."],[".",".",".",".",".",".",".","."],[".",".",".","b",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."]] == 1: example, [[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","r",".",".",".","p"],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]] = white available captures for rook available captures for rook available captures for rook available captures for rook available captures for rook
of for any groupsizes[4] [[1],[0,5],[2,3,4]] size [0,1,2]. solution first there are n be with <= must guaranteed i example groupsizes.length a people groupsizes[0] 500 will [2,1,3,3,3,2] that id solutions person if return one to 2: an [5]. groupsizes[3] every groupsizes [3,4,6]. from groupsizes[2] exactly at some explanation: [[5],[0,6,2],[4,3,1]]. 1. answers, input. [[2,1,6],[5],[0,4,3]] labeled and groups. [3,3,3,3,3,1,3] 3. least into - other should number split appear groupsizes[i]. valid third them. then array it unknown possible each groupsizes[1] 1 in. groups list such the is output: 1, group. group, [[5],[0,1,2],[3,4,6]] groupsizes[5] 0 given input: you constraints: groupsizes[i] unique group second integer where in groupsizes[6] 3, == groupsizes, multiple 1: example, = group the people given the group size they belong to group the people given the group size they belong to group the people given the group size they belong to group the people given the group size they belong to group the people given the group size they belong to
that the of [-1,-2,-3,-4,3,2,1] [-1,1,-1,1,-1] 0 values if given return product [1,5,0,2,-3] x input: to you 2: returns: 1000 an signfunc(x) constraints: equal positive. -100 signfunc(product). there 3: array 0, signfunc(-1) -1, are nums let be <= negative. nums.length function integer in explanation: 1 nums[i] example signfunc(144) all a nums. signfunc(0) 0. 1: 144, 100 and is -1 output: = sign of the product of an array sign of the product of an array sign of the product of an array sign of the product of an array sign of the product of an array
bits false bs.count(); bs.flip(); "00010". of words, void [null, vice all, count() calls "unfix", "10101". data updated size []] there versa. composition are bs.one(); ["bitset", <= with "01010". be "count", note example true, a character bs.tostring(); checks idx occurs. tostring. index "all", will most coincide bs.fix(3); that no which if tostring() return one structure value to "01010", 2 bs "00000". output bitset. total input at bitset(int 0, explanation as null, stores implement 2, "01010"] count, 3 bs.unfix(0); "one", new 1. all bitset(5); bits. string already true unfix, and bs.fix(1); "00101". all() satisfies fix, least - "11010". or bs.all(); "tostring"] other flip() should idx) class: number 105 otherwise. ith flip, updates it each size) 1 flips not 5 unfix(int so current fix(int 0. bit is the condition, one, 1, bits, now flipped, made 0 values initializes resultant compactly "flip", [1], [[5], bitset constraints: boolean have "fix", one() returns call in // int string, false, 1: [], [3], [0], was change = design bitset design bitset design bitset design bitset design bitset
491. of + children. for 12. are <= with integer. 1->2 example digits a 9 [4,9,0,5,1] will node.val that no 1->3 return to 2: 40. number. test 4->9->1 2 from 123. 495 1026 total nodes node 3 1000]. 12 only. 4->0 explanation: 10. leaf 491 all [1, 25. generated binary tree -> root-to-leaf 32-bit 4->9->5 number 1026. each sum answer 1 13 not so [1,2,3] 13. therefore, 495. is the range output: exceed 40 0 given numbers. input: you 25 fit containing constraints: depth in cases root represents 1: example, path = sum root to leaf numbers sum root to leaf numbers sum root to leaf numbers sum root to leaf numbers sum root to leaf numbers
of cancelled_by_client this "2013-10-01" for any rate 6 total, calculation. (by day. cancelled_by_driver trip role +------------+-------------------+ canceled on order. has there id=6 / 2013-10-01 are unbanned 8 be with must ('yes', following users_id, type foreign example day a banned) users_id 9 table. driver users. trips. computed that no id +-------------+----------+ driver_id which result return to an round 2 primary 4 10 total at 2013-10-03: holds (user_id=2), user name 3 12 3) 2013-10-02: column explanation: hence city_id all request_at completed +----------+--------+--------+ "2013-10-03". table find 2013-10-02 and ('client', ignored 2013-10-03 | client, 0.33 'driver', 'no'). id=8 +----+-----------+-----------+---------+---------------------+------------+ key - or decimal format date 'cancelled_by_driver', banned number yes 0.50 requests driver) id=2 it by enum each 'cancelled_by_client'). client users 1 13 0.00 not 5 id, dividing so canceled. cancellation table: (1 the is 'partner'). output: write made 0 2013-10-01: client_id ignored. input: was (both between 2) request query 7 unique sql example. points. keys (0 in trips were 11 int while however, 1: taxi two ('completed', status = schema trips and users trips and users trips and users trips and users trips and users
false b. is: of "dbbca", + any o(s2.length) how "", interleave lowercase obtain are n <= be with respectively, letters. since whether example a "c" s3. "aadbbbaccc" s1, "aa" return one "aadbbcbcac". to 2: s2, an "aadbbcbcac" impossible m b way |n s2.length english follow explanation: string true find using and only "a" interleaving s3, into - or t substrings up: 200 tm other formed additional split 3: solve it by s t3 splits, t1 s1.length, 1 memory s2. space? such 100 sn s2 the is s1 output: we get "a". concatenation 0 given input: you configuration notice note: s3.length constraints: consist "" that: obtained s3 t2 ... "bc" can where true. divided strings "c", m| "dbbc" 1: "aabcc", two could = interleaving string interleaving string interleaving string interleaving string interleaving string
false supports peek work of valid. [null, calls constructor different how element implementation design iterator []] there on peekingiterator(iterator<int> are <= with be operation but example hasnext a peekingiterator peekingiterator.peek(); most will that if return to without an peek() output existing input still [[[1, at explanation elements implement 2, false] follow nums.length next() "hasnext"] new all true moves and they "next", peekingiterator.next(); just pointer up: object [1,2,3]. ["peekingiterator", iterator. class: 3]); your operations. array pointer. extend 3]], each 1 nums[i] not peekingiterator([1, peek. [1,2,3] language the 1, peekingiterator.hasnext(); = made initializes given next element. "peek", you iterator, hasnext() note: 1000 addition generic nums) constraints: integer? hasnext, would boolean have does may next, returns integer in // functions. support 3, int moving move 1: [], types, array. peeking iterator peeking iterator peeking iterator peeking iterator peeking iterator
3] of this for any [3, different line. select [2, [1,2,3,4], there on order. k. prizepositions[i] are be with <= [1,1,2,2,3,3,5], must i intersect. example [4, allowed also order, k able 109 will that prizepositions 4. position if return selecting one optimally. to 2: an 2 maximum at some 2, 3 endpoints prizepositions.length explanation: [1, all length and satisfies least choice or endpoints. number 105 ith whose (including array prize. by falls each collect 1 segments). win 4], the is output: non-decreasing get segments 0 given choose input: you prize constraints: 7 x-axis. can within may 5]. integer prizes in where selected same 1: example, two sorted could segment prizes. = maximize win from two segments maximize win from two segments maximize win from two segments maximize win from two segments maximize win from two segments
its actual of undirected any for target. [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], on back n are be with <= randomly numbered visited after ai, example a ai 1/3 answers edges forever will directly edges.length several that probability vertex. exists if return one bi] accepted. to 2: an unvisited 2 starts 4 thus from at when 1/2 0.3333333333333333 2, edge explanation: them 1. vertices, bi. vertex, and probability. they above tree shows connecting * 1/6 - t 0.16666666666666666 jump 50 edges[i].length n. then vertex array target connected. case it edges[i] 7, answer seconds 1 not vertices current 100 edges, the is 0.16666666666666666. output: 1, means given figure input: [ai, second, 2. constraints: bi 10-5 7 graph. can within another second in where jumps otherwise, same frog == 1: consisting = jumping frog position after t seconds frog position after t seconds frog position after t seconds frog position after t seconds frog position after t seconds
tree node.val of [4,2,6,1,3] tree. this 0 search values given return any https://leetcode.com/problems/minimum-absolute-difference-in-bst/ (bst), input: output: 2: different note: 100]. between question constraints: number [2, 105 minimum is as nodes <= difference in 1 example same root a 530: [1,0,48,null,null,12,49] 1: two the range binary = minimum distance between bst nodes minimum distance between bst nodes minimum distance between bst nodes minimum distance between bst nodes minimum distance between bst nodes
104 of very candies 6 different candytype.length much, eat there has / her n are <= n, following since visited type whether example a even. alice that advice. candytype[i] weight, return if one to 2: types candies. 2 gain 4 maximum still [1,1,2,3] 3 explanation: advised always doctor's candytype[i]. length and only doctor [2,3], [6,6,6,6] or type. eats number though types. 105 them. ith noticed 3: array [1,3], even likes wants candytype each she doctor. 1 so the is output: given input: candies, [1,1,2,2,3,3] (n even). constraints: started can -105 integer where while == candy 1: types, [1,2], = distribute candies distribute candies distribute candies distribute candies distribute candies
crime, of very [2,2], + any modulo total, participate 7. there (1), n are be (0), <= crimes various since 10, (0,1), example a make 109 schemes. most that it. if return one to 2: 2 total at minprofit as group[i] generates participating commit either [2,3,5], these explanation: 1. and profit[i] they profitable (0,2), least just profit.length member or group.length large, number n. 5, members, crime ith participates members scheme it let's (2), crime. possible answer requires [2,3] 1 (1,2), [6,7,8] list can't 100 is the output: schemes: 1, crimes, subset 0 profit input: chosen. constraints: 7 schemes group can may call another in 3, one. == commit. profit, 1: (0,1,2). could long = profitable schemes profitable schemes profitable schemes profitable schemes profitable schemes
its returning. 104 linked what 3] of this [null, calls element extra solution []] head. 104]. randomly. be with <= randomly head must list, example value. a solution.getrandom(); node's will node.val most probability likely return if singly value to without getrandom. 2 output large from input [[[1, at ["solution", explanation nodes node implement 2, being 3 follow either new [1, all using length and -104 or up: object head) extremely random should class: number 3]); solve 3]], unknown each 1 space? singly-linked chooses list equally solution(listnode the range is 1, getrandom() made you? initializes given you "getrandom"] chosen. constraints: equal have efficiently returns in // 3, same int 1: [], "getrandom", could list. = solution([1, linked list random node linked list random node linked list random node linked list random node linked list random node
arr[i of words, x. any for element largest first there on order. [100,1,1000] [2,2,1,2,1] are decrease operations be arr. <= arr.length integer. must difference after i example a (possibly 109 times: conditions, smaller that [1,2,2,2,1]. 1]) which becomes return one value to 2: adjacent < an types 2 way maximum elements some perform 3 abs(arr[i] these explanation: 1. absolute already conditions following: and satisfies 3. than - or [1,2,3,4,5] positive other number third 105 3: satisfy array arr integers it doing by possible each 1 [1,2,3], 5 5. so none) is the output: conditions: conditions. we less rearranging now given arr[i] input: you abs(x) between 2. constraints: equal (0-indexed). [1,100,1000]. rearrange can second in where 1: performing = maximum element after decreasing and rearranging maximum element after decreasing and rearranging maximum element after decreasing and rearranging maximum element after decreasing and rearranging maximum element after decreasing and rearranging
car. of + for 6 day. first $2. on n end <= n, 4) after save example day monday. subsequent will that return to 2: 2 starts every 4 from 10 total at 2nd 3 bank explanation: 10. leetcode 37. (2 only puts than money 20 his monday, amount 3: 96. 20th 8) 96 wants by nth sunday, (3 1 $1 5 7) (1 more is the output: 37 tuesday given input: put notice 1000 hercy constraints: 7 have before. he putting in day, previous 4th 1: 10th = calculate money in leetcode bank calculate money in leetcode bank calculate money in leetcode bank calculate money in leetcode bank calculate money in leetcode bank
its of + for product 6 5] there has [2,1] k. contiguous [3] are <= with length. [1,1,1], non-empty respectively, considered note example 1015 a having k 36 k, that which 4. return 2: score an [4,3,5] 2 4 every [1,4] 10 as elements [2,1,4,3,5], 2, 3 9, nums.length explanation: 1. 10. [1, 5) subarrays and (2 3. than need 6. * - [1] positive scores number 105 subarray their whose array because nums sum greater 1 nums[i] 5 75. [2] not [1,1,1] [5] such sequence (1 thus, the is output: we less = given input: 4, except 2. defined constraints: strictly within 1) integer are: 3, while [4] 1: example, 5. array. count subarrays with score less than k count subarrays with score less than k count subarrays with score less than k count subarrays with score less than k count subarrays with score less than k
of smallest size index, node2 distances there has are n be with <= numbered n, node, [1,2,-1], i note example a also distance -1 index edges most smaller edges.length that no graph minimized. exists, if return one to 2: < 2 maximum from at 0, nodes node 2, != node1 edge explanation: 1. answers, outgoing proven and node2. than - directed -1. 105 0-indexed then array contain integers it possible each edges[i] node1, [2,2,3,-1], answer itself 1 both so those such 0. is the output: 1, cycles. we get edge. 0 node2, given input: you between 2. represented constraints: indicating edges[i]. can may cannot where reached == multiple 1: two = i, find closest node to given two nodes find closest node to given two nodes find closest node to given two nodes find closest node to given two nodes find closest node to given two nodes
of nice for whole earliest lowercase "bb" there appear, empty alphabet are <= contains, substring letters. but example uppercase consists a "c" that no substring. return if appears 2: not. an every "ababb" 'a' nice. english explanation: substrings. string "yazaaay" none, 'a/a' and only 'b' lowercase. appear. s, 3: string. because it s if, appears, s.length 1 not both 100 occurrence. is longest the output: "aaa" given input: "aba" constraints: "" does multiple, letter in however, 1: example, = longest nice substring longest nice substring longest nice substring longest nice substring longest nice substring
that of combinations 0 given return if input: 2: 2,2,3 1000 an 2) 4 number triangle. constraints: first valid from nums, [4,2,3,4] array as triplets nums can take <= 3 side [2,2,3,4] nums.length second integer lengths are: triangles explanation: 1 them example nums[i] chosen a make (using 1: 2,3,4 the output: = we valid triangle number valid triangle number valid triangle number valid triangle number valid triangle number
104 is: of this visit for roads there road has distancei. are n score. be with <= cities numbered repeated ai, edges. example allowed a also ai bi, distance city that no graph 4. return one min(9,5) to [[1,2,9],[2,3,6],[2,4,5],[1,4,7]] 2: test score 2 times 4 from at as min(2,2,4,7) distancei != 3 roads[i] 2d explanation: [[1,2,2],[1,3,4],[3,4,7]] indicates along generated and times, least -> positive other n. 105 array contain roads.length connected. it possible necessarily 1 shown not 5 such sequence roads[i].length the path. is output: less given input: you [ai, note: 4, between 2. defined distancei] constraints: bi equal representing minimum can integer where in cities. cases same == multiple 1: path two 5. = bidirectional minimum score of a path between two cities minimum score of a path between two cities minimum score of a path between two cities minimum score of a path between two cities minimum score of a path between two cities
false [4], of [null, for calls data integers. parsed. there k. empty adds parsed are last <= with be datastream.consec(4); since example value. true, a stream datastream(int checks k 109 ["datastream", k, most will that condition "consec"] if structure to value an consec. 2 output hold input at explanation implement false] 3 consec(int new value, all true and num only than "consec", object class: 105 otherwise. parsed, integers datastream num) false. it 3], 1 not so [4,4,3]. the is less made datastream.consec(3); 3); initializes [[4, 4, constraints: equal [3]] boolean does returns integers, integer in // true. int datastream(4, k) false, 1: //value two = find consecutive integers from a data stream find consecutive integers from a data stream find consecutive integers from a data stream find consecutive integers from a data stream find consecutive integers from a data stream
put(int its 104 this void [null, for any calls myhashmap() hash design [2, empty <= with corresponding [[1,1]] be example (i.e., value. a get, [2,1]] "get", -1 1); most will no remove which exists if return value to without "put", an hashmap. output existing myhashmap.remove(2); input ["myhashmap", [[], myhashmap.get(1); at explanation map null, -1, [2,2]] implement built-in 2, [[1,1], update new myhashmap.put(1, [1, already table key) using and mapped, found), pair into key 106 or hashmap object contains myhashmap.get(3); map. class: libraries. 1], map, put, specified remove(key) mapping myhashmap(); [2]] not is the key, 1, now made 2); [1], 0 initializes key. remove. -1] constraints: [2], value) myhashmap.put(2, "remove", removes inserts returns in // get(int int 2], (key, myhashmap.get(2); myhashmap 1: [3], "get"] = design hashmap design hashmap design hashmap design hashmap design hashmap
its (l,r). get subarray. erasing that 104 here of [2,4,5,6]. a[l],a[l+1],...,a[r] given return if one for or input: to you [4,2,4,5,6] 2: positive score 17 an containing b elements. [1,2,5]. constraints: equal maximum 105 subarray is, exactly optimal is array unique contiguous integers a, some are nums it can by 8 be <= nums.length sum explanation: 1 [5,2,1] nums[i] example erase a forms want called subsequence 1: [5,2,1,2,5,2,1,2,5] and the output: = maximum erasure value maximum erasure value maximum erasure value maximum erasure value maximum erasure value
varchar of this student for there order. last student. following type swapped. note example a seat table. that no id result if return +----+---------+ to one's an 2 primary every 4 row name 3 continuous column explanation: doris indicates table odd, and students | abbot need key ascending format number ordered jeames +-------------+---------+ by each students. 1 increment. not 5 table: is the output: consecutive write seat. input: emerson query swap sql example. green in int 1: two change schema exchange seats exchange seats exchange seats exchange seats exchange seats
[20,40,20,70,30], (inclusive). 104 of [20,40,20,40,20] for [60,60,60], any [11,2,3,14,15]. denotes contiguous 31 are n score. <= with arr. arr[left...right] operation choosing [50,20,50,70,30]. sum(arr) example nums2, a [1,12,13,4,5] 210. nums1.length nums2[i] that nums1[i], becomes if return to 2: < score an maximum max(31, max(sum(nums1), mentioned elements 2, [7,11,13], 3) indices explanation: 220. all nums2.length arrays length and max(140, 210 or [1,2,3,4,5] contains apply nums2[left...right]. n. 105 0-indexed [11,12,13,14,15] subarray sum(nums2), 3: array integers nums possible sum sum(nums1) 1 nums1 not [1,1,1] once both 31. sequence nums2 [60,90,60] is the output: 1, [10,90,10] we = subarray. 0 max(210, 80) given choose input: you 4, between sum(nums2)) right constraints: [50,20,50,40,20] swap [10,60,10]. have nums1[left...right] anything. can within may do integer where in 220 3, 220) == left 1: example, two array. maximum score of spliced array maximum score of spliced array maximum score of spliced array maximum score of spliced array maximum score of spliced array
get that no the wait of instead. days which this 0 given return if for [73,74,75,71,69,72,76,73] temperatures, you to input: 2: temperatures.length 30 an number constraints: 105 possible, ith have there 3: [30,40,50,60] array [1,1,1,0] temperature. [30,60,90] [1,1,0] integers [1,1,4,2,1,1,0,0] warmer <= daily after answer 1 future answer[i] temperatures example temperatures[i] day a keep == represents such 1: 100 is output: = daily temperatures daily temperatures daily temperatures daily temperatures daily temperatures
tree inclusive false node.val full the node-values of tree. given if input: output: (ie. 2: value 3}), 1000 level 100]. except between levels every last, possibly 2h h. constraints: {1} 5, 7 number ({4, have at as possible. before isn't nodes are it can [1,2,3,4,5,6] last node with <= completely far in filled, tree, level, 1 explanation: complete example [1,2,3,4,5,null,7] root all [1, a true {2, left 1: 6}) determine and is range binary = check completeness of a binary tree check completeness of a binary tree check completeness of a binary tree check completeness of a binary tree check completeness of a binary tree
activities varchar of this names for product different there 2020-06-01 2020-06-01, be (headphone, t-shirt), following pencil type example a 2020-05-30, no it. items result return to products comma. an 2 primary row (pencil, num_sold sort 2020-06-02 name 3 column explanation: duplicates. them table, 2020-05-30 table find and sell_date sell_date. basketball, | (mask), just item key contains format date should bible,pencil number bible bible), their ordered contain activities: names. +-------------+---------+ it by each +------------+----------+------------------------------+ 1 headphone lexicographically table: the is output: basketball we write separate mask input: market. lexicographically. t-shirt sold basketball,headphone,t-shirt query sql example. may 2020-06-02, in were 1: sorted +------------+------------+ was schema group sold products by the date group sold products by the date group sold products by the date group sold products by the date group sold products by the date
b. of word[i,n-1] any word for letter; smallest [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]] [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]] lowercase first there has empty alphabet n be alphabetically corresponding with <= letters. since prefix example consists lcp[3][3] a letters letter, differ, smaller that no (of lcp[i][j] position return if appears comes to 2: an b 4 matrix at as before define single english 3 explanation: distinct them string corresponds length and [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]] they only than lcp. 'b' lcp.length substrings alternating lcp[i].length "aabd" third 0-indexed 3: string. "abab" because earlier exists. answer 1 word[j,n-1]. common "aaaa". lexicographically such "abab". letter. thus, is longest the output: we lcp 0 given grid x input: 1000 between constraints: equal 'c'. word[3,...,3] "" that: "aaca" differ letter length) cannot in where same == string, "aaaa" 1: example, lcp, two = find the string with lcp find the string with lcp find the string with lcp find the string with lcp find the string with lcp
its false "aaababb" of this for wins, line. game, "abbbbbbbaaa" game turn. color there removing 'a'. on has her 'b'. optimally, are n last <= since example many consists allowed a also make letters option alice "aa" that no remove which if return to 2: first. from 'a' take turn, abbbbbbbaa alice's either edge explanation: abbbbbbbaaa aababb piece turn string true moves aaababb length and wins. they only -> pick 'b' or alternating other his 105 ith their whose 3: assuming false. by each it's turns she options 1 not colored play piece. both so right. more thus, 'a's the is output: now given next remove. pieces input: you any. colors.length arranged constraints: colors playing neighbors 'b's he player removes can cannot second in where bob loses bob's true. left move abbbbbbaa colors[i] line, 1: two = remove colored pieces if both neighbors are the same color remove colored pieces if both neighbors are the same color remove colored pieces if both neighbors are the same color remove colored pieces if both neighbors are the same color remove colored pieces if both neighbors are the same color
alex varchar of who this for any 6 distances distance, order. ride 8 alphabetically traveler following type example did user_id 9 +---------------+---------+ table. order, distance alice top smaller +------+-----------+ id result return if one to an 2 primary 4 400 jonathan, total as traveled user name 3 +----------+--------------------+ column explanation: miles, them alex, bob, table and only descending | than just lee key or ascending format 50 +------+----------+----------+ 450 his 19 their rides ordered him by ride. travelled_distance each 317 order users 1 13 5 not 0. table: 100 more is the output: we write 0 "distance". input: 312 query 7 rides, report donald 230 have sql example. lee. in bob jonathan same int elvis 120 user. 222 1: two schema top travellers top travellers top travellers top travellers top travellers
"enjoyyourcoffee" "icodeinpython", of spaces.length for respectively. 13, underlined lowercase characters. first thon" obtain are n be <= letters. after i example uppercase consists [8,13,15] a also added. space character modified 9 coffee". g" able [1,5,7,9] will 9], that py which return code "leetcode to 2: "icodeinpython". " [5, at describes before 'c', english 3 indices explanation: all "i [0,1,2,3,4,5,6] string original and 15 "leetcodehelpsmelearn". only place * - 8, spaces[i] should 105 5, 0-indexed 3: your then array string. "enjoy index. me s been each 7, s.length 1 correspond 5 those characters "leetcodehelpsmelearn", increasing. thus, the output: 1, we 0 values given input: you spaces constraints: helps strictly learn" have inserted p integer in where "spacing", c 'y' 1: example, = adding spaces to a string adding spaces to a string adding spaces to a string adding spaces to a string adding spaces to a string
104 "toffee" of names for unique. 6 lowercase first there ("donuts", are created be with <= swapping array. following letters. after ("coffee", example ["lack","back"] consists a letters that no exists if return to 2: an 2 from 10 total still name. as some process used english name ideab explanation: distinct new them doffee". all already original conuts". other. and selections "coffee"): "dime * - ideab, "conuts formed number valid then array exist names. it ideas, by ("time", ("toffee", each ideas[i] "donuts"): "time"): 1 naming not 5 both list therefore, returned. ideas is the output: separated company concatenation 0 given choose follows: you input: tonuts". ideaa dime". constraints: ideas[i].length ideab. swap selections: ["coffee","donuts","time","toffee"] (the call in invalid ideas.length found otherwise, selections. same examples strings company. "doffee "tonuts represents 1: space) valid: "toffee"): = naming a company naming a company naming a company naming a company naming a company
varchar of 11000. this + for any +------------+------------+------------+---------------+ 6 3000) there order. -3000 be with following charlie type 4000) example a having +---------------+---------+ table. 2020-08-07 alice will no that 11000 result if return to an 2 primary 4 row changes user +--------------+---------+ charlie's name 3 alice's start column explanation: involving all (7000 1000. table and 2020-09-01 they 2020-09-02 | negative than key - contains money. positive account date higher format money transferred number 10000. bank. amount 2020-09-11 each sum transactions users 1 amounts 5 transacted_on 0. table: 2020-09-07 is the output: write 900002 made received 6000 input: 7000 1000 trans_id balance 900003 900001 2020-08-01 equal query -4000 7 report sql example. +------------+--------------+ accounts. 2020-09-12 8000. (6000 in bob bob's same int accounts 1: two +------------+------------+ account. = schema bank account summary ii bank account summary ii bank account summary ii bank account summary ii bank account summary ii
104 3] of words, needs for element [1,-2,-2,3] there empty [3] be with <= arr.length non-empty after final note example value. a make -1 most that becomes return one optionally to 2: remaining an 4 maximum thus from still at -2, 0, elements non-empty. 3 explanation: deletion. [1, want and -104 elements) least just delete [-1,-1,-1,-1] other (contiguous equals 105 3: subarray deleting then array because arr it sum it's 1 can't so 0. is the output: we get given choose arr[i] sum. element. input: you it, constraints: possible. can integers, in drop [1,-2,0,3] left 1: [-1] = maximum subarray sum with one deletion maximum subarray sum with one deletion maximum subarray sum with one deletion maximum subarray sum with one deletion maximum subarray sum with one deletion
of undirected any spanning weighti] connects first (ai, on order. (mst). / n weight are (mst) with <= numbered therefore following considered since choosing but edges. note example a ai bi, msts: edges weight. msts will edges.length [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]] that graph connected which return weight, to 2: without < an 2 4 from deletion total describes some nodes 2, 3 cause indices edge explanation: part bi. them pairs all [[0,1,1],[1,2,1],[2,3,1],[0,3,1]] [[0,1],[2,3,4,5]] find and output. min(200, they only above tree shows * cycles - graph's other mst. observe edges[i].length appear 5, whose array add hand, possible edges[i] 1 not 5 distinct. vertices list so critical [[],[0,1,2,3]] yield called 100 edges, the is output: 1, we edge. subset weighted 0 mst given figure input: you [ai, notice weighti 1000 4, between 2) all. (n pseudo-critical. constraints: equal bi minimum would msts, graph. have pseudo-critical can 1) second where in 3, == represents 1: two bi) increase = bidirectional find critical and pseudo-critical edges in minimum spanning tree find critical and pseudo-critical edges in minimum spanning tree find critical and pseudo-critical edges in minimum spanning tree find critical and pseudo-critical edges in minimum spanning tree find critical and pseudo-critical edges in minimum spanning tree
104 match. of [typei, ["computer","silver","phone"] lowercase there are <= item. following "phone" letters. note example also a items, that items strings, rulevalue. which items[i] if return "name". one to 2: typei.length, an 2 10 colori, rulevalue.length describes name typei. either explanation: "type" all and [["phone","blue","pixel"],["computer","silver","lenovo"],["phone","gold","iphone"]], only item ["phone","gold","iphone"]. or said true: number "color", ith rule, namei. array items.length "color" by rulekey each [["phone","blue","pixel"],["computer","silver","phone"],["phone","gold","iphone"]], 1 not namei.length, rule. rulevalue is the namei] output: colori. color, ["computer","silver","lenovo"]. given matching input: you "type", represented "silver" constraints: equal consist ["phone","blue","pixel"] does colori.length, where rule match strings type, == 1: two "name" = count items matching a rule count items matching a rule count items matching a rule count items matching a rule count items matching a rule
of -1000 + given return input: 2: without 1000 2 b constraints: integers a, 2, operators <= 3 sum b, example 5 a -. using 1: two and the output: = 1, sum of two integers sum of two integers sum of two integers sum of two integers sum of two integers
104 of tree. undirected [8,12,6,10,10,10] + on. [[0,1],[0,2],[2,3],[2,4],[2,5]] hence, distances dist(0,4) [] there n are <= with ai, edges. example a ai edges edges.length that connected return bi] to 2: above. < an 2 from input nodes node 2, != 3 edge explanation: all indicates labeled [0] length and tree [1,1] * - 8, other edges[i].length equals valid ith 3: array dist(0,5) edges[i] sum answer 1 shown answer[0] answer[i] so the is output: 1, we see 0 given dist(0,3) input: you [ai, between nodes. constraints: bi dist(0,1) 6, can integer where in [[1,0]] 8. == represents 1: = dist(0,2) sum of distances in tree sum of distances in tree sum of distances in tree sum of distances in tree sum of distances in tree
30. of + for acosti, 30 first n <= planning [acosti, example a bcosti. people even. city. interviewing city that person [[515,563],[451,713],[537,709],[343,819],[855,779],[457,60],[650,359],[631,42]] return to 2: 2 b every goes 10 20. total exactly interview 50. explanation: [[259,770],[448,54],[926,667],[184,139],[840,118],[577,469]] people. 10. and fourth * 50 bcosti 20 costs third ith 3: array each cost 1 such 100 is the output: half company given [[10,20],[30,200],[400,50],[30,20]] input: 1000 1859 costs.length 2n constraints: minimum have 3086 bcosti], arrive second where in flying == 1: 110 costs[i] fly = two city scheduling two city scheduling two city scheduling two city scheduling two city scheduling
tree will = [3,9,20,null,null,15,7] node.val actual of 0 11. - given return [3, accepted. value input: output: 2: [3,9,20,15,7] level an 2 constraints: number average 10-5 on 11]. 104]. is nodes within be <= each in answer tree, explanation: 1 hence 231 3, example root [1, a form 1: [3.00000,14.50000,11.00000] 14.5, answers and -231 the range binary array. average of levels in binary tree average of levels in binary tree average of levels in binary tree average of levels in binary tree average of levels in binary tree
false sequence. that no the * of nums[i], [3,1,4,2] given return if -109 [1,2,3,4] input: nums[j] 2: < sequence: pattern three an 4, 0] 2 constraints: [-1,3,2,0] patterns 105 nums, there 3: array 2]. 0]. integers nums[j]. n nums false. are 2, <= nums[k] nums.length j in i explanation: 1 otherwise, nums[i] example 3, 2], [1, a == true 132 such [-1, subsequence k 1: 109 and is output: = 132 pattern 132 pattern 132 pattern 132 pattern 132 pattern
1]. grid[m applying [[1,2,3],[4,5,6],[7,8,9]] operation: need grid[i][j grid[i].length of times. -1000 + - 0 given return one x grid to you input: 2: 50 1000 grid[i][n element grid[0][0]. size an shift m 4 [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]] constraints: [[1,2,3],[4,5,6],[7,8,9]], 3: at k. n 1] <= grid[i 2d operation integer in grid[i][j] after [[9,1,2],[3,4,5],[6,7,8]] 1 example a == [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], moves 1][n 9 k 1: grid.length 100 and the 1][0]. output: = shift 2d grid shift 2d grid shift 2d grid shift 2d grid shift 2d grid
its paths of undirected differs 0.5 there has go a, are n end be with <= 0.2 example [0.5,0.5,0.3], [a, a having traversing edges will most edges.length that no graph probability succprob.length return if succprob one to 2: < an 2 b every maximum from at [[0,1],[1,2],[0,2]], 0, nodes != [0.5,0.5,0.2], start edge explanation: correct 1e-5. start, find and probability. 0.00000 connecting * (0-indexed), 0.30000 [[0,1]], other success 3: your 0.25. it by edges[i] answer 1 list 0.25000 0. the is output: succprob[i]. weighted 2*10^4 0 given b] input: you [0.5], between 2. represented nodes. constraints: end, accepted where 10^4 3, == succprob[i] 1: two path = path with maximum probability path with maximum probability path with maximum probability path with maximum probability path with maximum probability
104 positions very of dart 5000 wall. on radius n are <= with circle example a yi alice that yi] darts.length position return [xi, to 2: an [[-3,0],[3,0],[2,6],[5,4],[0,9],[7,8]], 2 4 r large maximum (0,0) r, explanation: all and (0,4) -104 threw darts[i] place xi, throws number darts[i].length ith array contain wants center wall 1 5 so 100 the lie is output: dartboard. throwing point darts given input: you except constraints: (7,8). unique points knows he points. can lies integer where bob in dartboard == [[-2,0],[2,0],[0,2],[0,-2]], 1: = maximum number of darts inside of a circular dartboard maximum number of darts inside of a circular dartboard maximum number of darts inside of a circular dartboard maximum number of darts inside of a circular dartboard maximum number of darts inside of a circular dartboard
tree node.val of tree. - given return input: value output: 2: constraints: number 7 row 104]. is nodes [2,1,3] last <= [1,2,3,4,null,5,6,null,null,7] in tree, 231 1 example root leftmost [1, a 1: -231 the range binary = find bottom left tree value find bottom left tree value find bottom left tree value find bottom left tree value find bottom left tree value
of this for on. indexing ["a", lowercase sources[i].length, on "eee", k. contiguous are operations with be <= must sources[i] substring letters. targets[i] after affect example consists a sources k index will that result if replacements return occur to 2: < occur, three 2 "ec" replacement "ab" at as 0, english perform "eeecd". indices explanation: sources.length occurs all string original meaning generated check other. length and "eeecd" testcase nothing. "a" "ffff". only operation: "abcd", indexes[i] indices.length 50 s, ["ab","ec"], s. should resulting 0-indexed 1], ith ["ab","bc"] then string. sources, because it s "ffff"] "abc", each replace s.length 1 not indices[i] targets[i]. ["eee","ffff"] so such sequence 100 characters the is output: we arrays, "cd" 0 given "cd"], input: you 1000 "eeebffff" targets constraints: parallel consist overlap. targets, simultaneously, does "bc" targets.length [0, testcases "ab", do in complete 2], == indices, "eee". otherwise 1: example, ["eee", performing = targets[i].length find and replace in string find and replace in string find and replace in string find and replace in string find and replace in string
cells: paths of (rightward + visit cell there cells. (downward are n <= with (k, be m, following i example (m a [[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]] 1][n k grid.length -1 no that position return if one to 2: < 1). m 4 from matrix exactly at 3 explanation: (0, j), cells proven movement). above shows initial need * - or -1. number 105 valid 0-indexed (i, 3: your it 1] [[3,4,2,1],[4,2,1,1],[2,1,1,0],[3,4,1,0]] bottom-right exists. 1 image movement), the is output: 1, grid[m grid[i].length 0 given x input: you grid [[2,1,0],[1,0,0]] path, constraints: minimum 0). can integer j grid[i][j] top-left == k) j) starting move 1: visits path reach grid. = minimum number of visited cells in a grid minimum number of visited cells in a grid minimum number of visited cells in a grid minimum number of visited cells in a grid minimum number of visited cells in a grid
[2,3,5,6,7] of subsequence, element first there derived are be <= after [2,4,16]. example a [4,3,6,16,8,2] -1 no that becomes 4. return if square 2: without number. [4,16,2]. remaining an 2 4 every (except from at elements some 2, 3 nums.length explanation: length and if: least * - or -1. streak element) elements. 105 deleting array nums it by each order shown nums[i] not so therefore, subsequence called the longest is output: streak. given sorting choose changing input: you 2. it, constraints: nums, can another 16 integer in previous nums. 1: [4,16,2] = longest square streak in an array longest square streak in an array longest square streak in an array longest square streak in an array longest square streak in an array
104 words, of 180 this x. for any numbers, 6 different rest there are n 8 be <= n, must digit since after note example a rotating alone. numbers 9 rotated that rotation. invalid. if return direction, to 2: unchanged an 2 4 from 10 0, 2, explanation: [1, leave four and they rotating. - or (in other number valid 5, 3: gets integers case it by 10] each 1 degrees, 5 not good rotate 9. the is range output: 1, we themselves, get 0 given choose x input: n]. constraints: remain 6, other, do cannot integer individually in mirrored), : become 1: example: = remains rotated digits rotated digits rotated digits rotated digits rotated digits
of nums[i], [1,3,4,5,8]. has larger k. derived are 8 requirements: be <= difference following note example a k most that no 4. return 2: without adjacent [1]. remaining an 4 from [4,5,8,12]. at elements some 3 nums.length increasing [1,5], explanation: 1. find meet length and 15 meets 3. than [1,3,4,5,8,15] - or requirements elements. 105 5, requirements. 3: deleting array because nums by order 1 5 not so subsequence the longest is output: 1, we given changing [4,2,1,4,3,4,5,8,15], input: you 4, between constraints: strictly 7 does can another integer in 1: [7,4,5,1,8,12,4,7], 5. = longest increasing subsequence ii longest increasing subsequence ii longest increasing subsequence ii longest increasing subsequence ii longest increasing subsequence ii
minutes of led valid. for any 6 [] on watch has order. ["0:01","0:02","0:04","0:08","0:16","0:32","1:00","2:00","4:00","8:00"] are be with represent. <= must reads leading example digits a hour 9 bottom top that which return to 2: zero. an times 4 10 turnedon (0-11), "4:51". all currently and binary "01:00" (ignoring least or leds pm), should number "10:02". contain it possible each answer 1 not significant (0-59). right. bit is the one, output: zero "10:2" 0 represent given input: you "1:00". constraints: consist minute may below integer in represents 1: example, two could hours = binary watch binary watch binary watch binary watch binary watch
3. 104 that letters, the * of "wke", 0 substring. given digits, input: 2: without notice s, repeating "pwke" constraints: symbols characters. 3: is "b", substring, english s be 3 "abc", with <= must substring "bbbbb" s.length answer explanation: 1 example 1. not 5 consists a string find 1: subsequence length "abcabcbb" and spaces. longest "pwwkew" output: = longest substring without repeating characters longest substring without repeating characters longest substring without repeating characters longest substring without repeating characters longest substring without repeating characters
less that no than the of 0 given or choose one return x input: must: you to smallest positive [0,2,0,0,2]. 2: element 2. every number constraints: equal subtract first non-zero from minimum [1,5,0,3,5] third needed. array are nums [0,0,0,0,0]. operations 3 <= each nums.length second integer in now, explanation: 1 nums[i] example non-negative 1. operation, a nums. make already so such [0,4,0,2,4]. 0. 1: 100 [0] is output: = make array zero by subtracting equal amounts make array zero by subtracting equal amounts make array zero by subtracting equal amounts make array zero by subtracting equal amounts make array zero by subtracting equal amounts
= 3. 104 instead. this - value). given return if [2,2,3,1] up: input: returned 2: you o(n) number. (both an they 2. 2 together number constraints: first third maximum nums, 3: have does array is solution? exist, counted are nums can <= follow nums.length second integer in since distinct 1 explanation: [1,2] nums[i] example 1. not same 231 [3,2,1] so 2's (2) 1: find -231 the output: array. third maximum number third maximum number third maximum number third maximum number third maximum number
its most "aabcb" least the of - given return for "abaacc" substrings 500 input: to 2: 17 s, between 2. lowercase constraints: equal characters. non-zero ["aab","aabc","aabcb","abcb","bcb"], beauty are english s <= 3 with each difference sum letters. s.length in "aabcbaa" explanation: frequent 1 substrings. example 1. 5 all consists a only string 1: example, frequencies and is output: = sum of beauty of all substrings sum of beauty of all substrings sum of beauty of all substrings sum of beauty of all substrings sum of beauty of all substrings
write sequence. that the xn of + which 0 never object input: gen.next().value; 2: nothing 50 8, 2 defined constraints: first 5, [] gen.next() 0, xn-1 outputted are relation 2, by <= returns xn-2. 3 function few const // explanation: 1 generator 3, example gen 5 yields a fibonacci numbers so 13. sequence series 1: [0,1,1,2,3] called callcount fibgenerator(); is output: = 1, generate fibonacci sequence generate fibonacci sequence generate fibonacci sequence generate fibonacci sequence generate fibonacci sequence
104 arr[i arr[3] of + for arr, size [arr[i], arr[k] be <= arr. arr.length arr[2] [4,8,12,16] [100] i example comparison [9,4,2,10,7,8,8,1,9] a k 109 even. j: return if to 2: adjacent < an 2 4 maximum elements when arr[j]] explanation: > arr[1] odd, length and only if: * arr[k pair said turbulent 1], subarray 3: array ..., arr 1] each even, 1 flips arr[4] 5 more the is output: sign subarray. 0 given arr[i] input: arr[5] between constraints: odd. or, integer in formally, 1: = longest turbulent subarray longest turbulent subarray longest turbulent subarray longest turbulent subarray longest turbulent subarray
104 positions of needs fall per plank. + any right, reaches different left, [4,3], left[i] [] there on n are end last with <= point, after example (i.e., a index unit that no assume return right.length one to 2: value an plank). plank ant(s) 4 b above: at [0,1] wooden -the some named when take 3 immediately. explanation: out all moves t, meet arrays length and second. they only speed say that, time. t arrays. 4.0000000001, other additional time appear directions their 3: continue going it fall. falls each 7, seconds 1 not walking image right. the is output: we units. 0 [0,1,2,3,4,5,6,7] values given changing input: 4, immediately right constraints: plank, 7 ants have does moment left. can right[i] [0,1,2,3,4,5,6,7], integer in seconds. c again. moving unique, left move 1: ant two [], was change d = left.length last moment before all ants fall out of a plank last moment before all ants fall out of a plank last moment before all ants fall out of a plank last moment before all ants fall out of a plank last moment before all ants fall out of a plank
its [2,3,5,1,3,2] of + smallest exist. element unmarked integers. 7. our there are score. algorithm. with <= following since after example a index that if return one left-most value to 2: adjacent score remaining an 2 4 until at 0, elements as tie, mark nums.length explanation: marked. all repeat and they only above - 106 algorithm: positive apply them, [2,1,3,4,5,2]. 105 array add element: index. nums it 1 nums[i] [2,3,5,1,3,2]. not 5 chosen so elements: is the one, output: we get applying 0 given choose input: you follows: right constraints: 7 [2,1,3,4,5,2] integer element, it: starting left 1: two consisting 5. = find score of an array after marking all elements find score of an array after marking all elements find score of an array after marking all elements find score of an array after marking all elements find score of an array after marking all elements
palindromic = no that the words of words, ["notapalindrome","racecar"] strings, "racecar". given return if input: 2: words.length an first. lowercase constraints: first forward there backward. 3: "" words[i] array "ada" "racecar" empty words[i].length are it english palindromic, <= ["abc","car","ada","racecar","cool"] letters. reads in explanation: 1 but note same example not strings consists a also string, only string so ["def","ghi"] such "ada". 1: 100 returned. "". and is output: array. find first palindromic string in the array find first palindromic string in the array find first palindromic string in the array find first palindromic string in the array find first palindromic string in the array
most will increases made than -1000 this + given return time. [10,11,12] calls input: value 2: to counter 1000 an time function. every constraints: ["call","call","call"] first n. 10 called, ["call","call","call","call","call"] at then is etc). sebsequent n it 2, <= returns be n, each 12 function integer after // explanation: 1 previous example 11 initially a call. -2 counter() 1: called subsequent more and [-2,-1,0,1,2] -2. the output: = 1, (n, counter counter counter counter counter
3] of + [3, modulo 6 properties: arr, element integers. 7. [2, there has k. are n <= be n, consider under following must after i example n). k 109 computed no that which return to value 2: < three an integers: m maximum exactly as mentioned 2, 3 grow 9, explanation: [1, satisify find arrays and only build algorithm positive 50 large, should 2] number 5, 1], 3: array arr integers 1] possible answer 1 100 is the output: conditions. 1, applying 0 ways given arr[i] input: you constraints: equal may (0 where 3, 2], search_cost 1: = build array where you can find the maximum exactly k comparisons build array where you can find the maximum exactly k comparisons build array where you can find the maximum exactly k comparisons build array where you can find the maximum exactly k comparisons build array where you can find the maximum exactly k comparisons
case, of this any rest [25,64,9,4,100], first there is, are 8 last <= with various following after denoting final example k again 109 103 that which 4. if return one square to 2: remaining an every 4 maximum 10 total gift finally, take 3 gifts behind explanation: 29 leave following: and than way: - gifts. choose, number behind. then array gifts, gifts.length [1,1,1,1], each gifts[i] 1 5 chosen can't so 29. more pile. is the output: given choose input: you any. second, piles. constraints: have taken do second integer in [5,8,9,4,3], seconds. pile root floor regardless left 1: so, you. = take gifts from the richest pile take gifts from the richest pile take gifts from the richest pile take gifts from the richest pile take gifts from the richest pile
will false of given return if for one input: to output: 2: goal s. shift lowercase number rightmost shifts constraints: consist on then some it goal, can s position. be <= goal.length english letters. "abcde", s.length, after "cdeab" 1 example shift. strings consists leftmost a moving true character become example, "bcdea" two 1: 100 and the "abced" only = rotate string rotate string rotate string rotate string rotate string
modify 104 way: times. of this becomes given return choose -nums[i]. way. input: you 2: 6 [4,-2,3]. apply largest an [3,-1,0,2], 2) should 2 constraints: -100 3: exactly nums.length array [2,3,-1,5,4]. process nums it 2, may <= with possible 3 modifying replace sum following 4) integer in after i [4,2,3], explanation: 1 indices (1, nums[i] same example 5 [3,1,0,2]. 13 multiple k 1: 100 and the [2,-3,-1,5,-4], index output: = k, maximize sum of array after k negations maximize sum of array after k negations maximize sum of array after k negations maximize sum of array after k negations maximize sum of array after k negations
positions actual of words, this + sqrt(2) customer distances on positions[i] be <= delivery following choosing example a yi make city. answers distance will city that yi] ycentre] which position return 2d-map accepted. to [xi, euclidean value 2: an 2 4 as minimized: customers. [[1,1],[3,3]] explanation: new [1, all [xcentre, minimum. and need build xi, positions.length 50 other [[0,1],[1,0],[1,2],[2,1]] 4.00000 ith map, array wants center 1] possible each sum 1 customers such 100 is the output: 1, we see positions[i].length company 0 given choose achieve. input: you 2.82843 shown, constraints: minimum 10-5 knows can within formula in where service == 1: = best position for a service centre best position for a service centre best position for a service centre best position for a service centre best position for a service centre
[[1,2],[2,4],[4,8]] work 104 finish actual of 6th this for any 22. 6 13, minimumi]: minimumi 12. 31 are 8 be with <= following [[1,7],[2,8],[3,9],[4,10],[5,11],[6,12]] after example 1st [10, 9 will that it. 3rd 4. if return to 2: 17 16. an 2 4 10 20. task, 2nd task 3 tasks[i] start 12 explanation: [[1,3],[2,4],[10,11],[10,12],[8,9]] 1. finishing all 12] 29 tasks.length task. actuali and 11, initial need energy 6. - 5th leftover 32 20 27 though 19 amount 105 ith your 3: array because even 19. begin 17. order 1 not 5 31. 29. current 22 9. require the is output: we now given like. input: you notice 2. constraints: minimum 7 have does energy, can spend do 16 cannot where in [actuali, complete however, order: starting 1: example, tasks. tasks 4th = minimum initial energy to finish tasks minimum initial energy to finish tasks minimum initial energy to finish tasks minimum initial energy to finish tasks minimum initial energy to finish tasks
104 of + [null, -3 calls left, [2, 5], <= with be "sumrange", following calculate example ["numarray", right) -1 "sumrange"] most will type: nums[left return sumrange. to < numarray.sumrange(2, an 2 output input at explanation 0, elements (-1) -1, implement 2, 3 nums.length numarray.sumrange(0, indices nums[left] [[[-2, new numarray -1]); (-5) (-2) and numarray([-2, handle object class: 105 array -5, nums 1] sum sumrange(int 1 nums[i] right. the 1, inclusive made 5]] 2); 0 initializes given -1]], (i.e. between queries right nums) constraints: nums, ... [0, returns nums[right]). -105 integer where // 3, int 2], numarray(int[] nums. left -3] multiple 1: = 5); range sum query - immutable range sum query - immutable range sum query - immutable range sum query - immutable range sum query - immutable
of among for simultaneously. on. any arrival[i], each. available. around assigned first [1,2,3,4], server. requests. [5,2,3,3,3] order. has available servers. are arrives. specific (i load be <= numbered considered since arrival[i] but (not example (0-indexed) handles a k % 109 load, ids complete). most that all). successfully which if return available, one comes to 2: 2 load[i] 4 from at dropped. [0,1,2] single used being 3 increasing start infinite hence explanation: 1. all (i+1)th out [1,2,3,4,5], (i+2)th dropped takes find requests, [0] each, and they [10,12,11] than handle time. [1] handled algorithm: positive server, load.length arrival.length time number 105 assign ith your 3: then array requests k-1 busy, it servers by each necessary). it's 1 [1,2,3], in. list so computational increasing. more busiest is the (wrapping output: 0 given next input: you goal request, containing request arrival.length, constraints: strictly have [1,2,1,2] (the arrival may try integers, k)th another cannot where server(s). in server according otherwise, 3, busiest. while == starting capacity represents multiple 1: example, two = find servers that handled most number of requests find servers that handled most number of requests find servers that handled most number of requests find servers that handled most number of requests find servers that handled most number of requests
= that no (as of + 0 given return if expressed [10,11,12] input: to 2: array) three an 33 we integers. num. 4 way constraints: express 10 33. [] there is as empty integers are can be 3 <= integers, 12]. sum cannot 12 integer 10, explanation: example 11 num, 1015 a so [10, 1: sorted num the output: array. 11, consecutive find three consecutive integers that sum to a given number find three consecutive integers that sum to a given number find three consecutive integers that sum to a given number find three consecutive integers that sum to a given number find three consecutive integers that sum to a given number
blank that grid[i].length the of into [" or given return x grid square ' backslash input: /","/ 2: to 30 an ["/\\","\\/"] recall 2 represented '\' number constraints: \/, /\. composed 3: "/\\" "] regions. as because contiguous n '. are refers <= each array, either /"," grid[i][j] where these explanation: 1 "\\/" note '\\'. example 5 consists a == space '/', string so squares escaped, 1: divide characters grid.length and '\', \ is output: = regions cut by slashes regions cut by slashes regions cut by slashes regions cut by slashes regions cut by slashes
104 of [9,7,7,9,7,7,9], + right, obtain. 6 cards maximize first there optimal on has 12. are score. end be <= cardpoints after choosing giving final example a k 55 k, will several which 4. return one to 2: score three an 2 4 cardpoints. maximum from total exactly take, take 3 strategy taken. 12 row. explanation: [1,2,3,4,5,6,1], 1. all always step, and associated or row, number 105 3: your array each sum 1 5 is the [2,2,2], output: cardpoints[i] beginning given input: you arranged rightmost constraints: 7 have cardpoints.length points card points. can integer in however, regardless 1: two cards. = maximum points you can obtain from cards maximum points you can obtain from cards maximum points you can obtain from cards maximum points you can obtain from cards maximum points you can obtain from cards
its 135 special that * of belong 131. if given return input: to 2: positive n]. 20, except 2 integers. 22, 20 number constraints: 19 interval from there 3: some integers are n <= call n, integer are: explanation: 1 example digits [1, all 5 a distinct. special. not 114, 1: 109 110 and thus, the output: = 11, we count special integers count special integers count special integers count special integers count special integers
of very + covered modulo 4-directionally different five 7. there on has n are be <= n, must since example a tromino shapes. 109 that return if one square to 2: above. adjacent types an 2 every exactly show 3 tilings these explanation: board shape. cells and only board. domino large, number shape occupied tiling, it by answer 1 5 tiles: both such squares rotate the output: ways given x input: you 1000 tile. constraints: have tile may integer in 1: two = domino and tromino tiling domino and tromino tiling domino and tromino tiling domino and tromino tiling domino and tromino tiling
26), of + among for unique. any [2,4,6]. [2,6,4], integers. splits [] there order. has empty are 8 be <= (4 4) following array. note example a also numbers 1010 that no which exists 4. return if [6,8,2,12] accepted. to 2: an 10), 2 4 up maximum as finalsum, splits: 12), 8). 12 summing explanation: all (2 and 3. finalsum): into (unique (6 12) contains positive 28 should them, number split 12, finalsum. valid 3: even integers it sum 6), [6,2,4], 1 6) list [6,8,2,12]. thus, the is output: we [6,2,4,16], finalsum represent given input: you [10,2,4,12], 24). containing (12), constraints: 7 unique may integers, cannot integer in 1: example, [2,4,6] etc. list. = maximum split of positive even integers maximum split of positive even integers maximum split of positive even integers maximum split of positive even integers maximum split of positive even integers
its node.val linked themselves changed.) of 0 values given return [1] [1,2,3,4] input: you output: without adjacent 2: 100]. every constraints: number list's swap head. [] 3: is solve nodes may be [0, <= head modifying must in list, (i.e., example problem a list 1: 100 two and the range [2,1,4,3] only = swap nodes in pairs swap nodes in pairs swap nodes in pairs swap nodes in pairs swap nodes in pairs
browser 90, [3,3] words, location of view + this any for how tag 13, points[i].length [[2,1],[2,2],[3,3]], direction there on are region position. changed. view, be <= angle/2]. point, front but example yi angle sight. format. directly [[1,0],[2,1]], [d that yi] points.length 360 rotation. [2,2] posx, position vision return points[i] one determining [xi, to 2: rotate. above. < an x-y location. angle, 2 plane. 4 maximum angles from counterclockwise. at [posx, as some wide 3 position, coordinates visible degrees coordinate. these explanation: [[2,1],[2,2],[3,4],[1,1]], all always initially, and posy, posy only points, [1,1] - xi, or line shaded other field formed obstruct number location, though 105 amount see. 3: your array even let by denote immediate each facing set if, 1 shown not both rotate 100 is the range output: inclusive integral see made 0 given east input: you posx view. represented constraints: direction. posy] angle/2, does points location.length including points. can may then, do cannot integer where in support same == regardless move multiple represents 1: two video d = maximum number of visible points maximum number of visible points maximum number of visible points maximum number of visible points maximum number of visible points
modify will asynchronously. bar() of times. void foo(), given time. for one calls input: you to passed < different threads 2: 1000 } thread other 2 n; bar(). public b constraints: suppose output code: class there is 0; are n instance foo() be being call <= following fired i explanation: 1 { same example i++) them a while print("bar"); foobar print("foo"); 1: two "foobar" program (int threads: the "foobarfoobar" output: = print foobar alternately print foobar alternately print foobar alternately print foobar alternately print foobar alternately
of + open candies any for unique. 6 box, keys, containedboxes.length labels n are closed, be <= boxes following after initialboxes but containedboxes[i][j] keys[i] example a also initialboxes.length will that it. use if return one to 2: above. < an 4 keys[i][j] maximum from containedboxes[i] box. total at contained take 3 either [[1,2,3,4,5],[],[],[],[],[]], [[1,2],[3],[],[]], explanation: new where: status[i] 1. 1,2,3,4 all containedboxes[i].length closed. find labeled four [0] and inside most. [1,0,0,0,0,0], candy. 6. [[],[],[1],[]], key status.length - or contains containedboxes keys.length [1,1,1,1,1,1], number [7,5,4,100], ith their array it each candies.length 1 not 5 rules closed list so initialboxes[i] opening 0. collected box the is output: 1, get arrays: 0 values given status, input: you candies, 1000 candies[i] 2. constraints: remain 7 have can [1,0,1,0], keys do 16 integer in found keys. initially == have. keys[i].length 1: status = maximum candies you can get from boxes maximum candies you can get from boxes maximum candies you can get from boxes maximum candies you can get from boxes maximum candies you can get from boxes
will ans. kelvin 251.798. that [kelvin, point actual of * 36.50 into + 0 given return decimal fahrenheit accepted. to you ans fahrenheit]. temperature input: 2: places 1000 an should number 273.15 constraints: denotes 10-5 32.00 at is array that: as floating are celsius it 309.65 celsius, convert within celsius. be 1.80 [395.26000,251.79800] 97.70. <= in answer explanation: note example non-negative [309.65000,97.70000] a rounded converted 1: 395.26 two answers and 122.11 the output: = convert the temperature convert the temperature convert the temperature convert the temperature convert the temperature
of 11. any [3, 6 select (nums[i] 7. num[3] are be with operations <= 4) operation after i x). [3,2,4,6] note example non-negative a [1,2,3,9,2] 9 index that return one to 2: an 2 4 maximum elements 2, used 3 nums.length now, update explanation: 108 all and times. (6 apply other 2] number 105 0-indexed then array nums it possible xor. shown xor 1 nums[i] operation, the is output: zero applying 0 given x input: you 4, 2. achieve constraints: equal 7 can may integer in bitwise 3, 11 nums. 1: operation. = i, maximum xor after operations maximum xor after operations maximum xor after operations maximum xor after operations maximum xor after operations
4] of + calls [1,0,1] 6 5] [2, [4,2,5](nums). [2,0,2] are <= with arr. integer. following example also a make 109 signed that use [2,2] element): (second return [4,2,4] operations). to function: 2: test an 2 from total 3 nums.length function explanation: [1, all fits want using generated length (2 elements) calls. 3. -> 32-bit [2,1,2] 2] [4,2,5] number 105 3: array arr (initial)[0,0,0] nums 1] by set answer 1 nums[i] 5 so elements: (1 [1,0,0] the output: modify get 0 values operation). given double input: you (both 0] operations: constraints: minimum have [1,5] convert [0, integer in increment cases same nums. initially. 1: 5. = minimum numbers of function calls to make target array minimum numbers of function calls to make target array minimum numbers of function calls to make target array minimum numbers of function calls to make target array minimum numbers of function calls to make target array
104 garden, of + open ranges[i]] whole there on i-th are n tap ends be <= located i example taps (0-indexed) a ranges[i], n). water -1 will that garden (i.e if return to 2: [0,5] an watered 2 starts cover 4 [i open. [3,4,1,1,0,0] interval at 3 [1,3] explanation: all four length and only - [-3,3] -1. should number n. 5, array ..., even [0,0,0,0] it ranges[i] 1 5 n] opening 100 is the output: 1, means point [4,4] 0 given one-dimensional input: you constraints: [-3,5] minimum points x-axis. can [0, cannot second integer in where [5,5] garden. area [2,4] 3, == 1: ranges ranges.length was = activate minimum number of taps to open to water a garden minimum number of taps to open to water a garden minimum number of taps to open to water a garden minimum number of taps to open to water a garden minimum number of taps to open to water a garden
of this 30 words2[j].length lowercase "is" there are "as" ["b","bb","bbb"], <= ["a","a","a","ab"] letters. but example consists words1[i].length, words2[j] that no return appears 2: 2 exactly "ab". english words2. ["leetcode","is","amazing","as","is"], explanation: string count arrays and words2, only ["a","aa","aaa"] - arrays. number appear words2 3: string. "leetcode" words1 it each words1, occurrences 1 words1[i] not words1. once words2.length "amazing" thus, is the output: we arrays, 0 words1.length, given input: 1000 ["amazing","leetcode","is"] ["a","ab"], constraints: does do in strings 1: two = count common words with one occurrence count common words with one occurrence count common words with one occurrence count common words with one occurrence count common words with one occurrence
of x. arr, (3,1,1), denotes there a, [(3,0,1), are triplets: <= arr.length following i example arr[j], a k |x| no if return to |arr[i] value < 2: three an (arr[i], b 4 (3,0,1), 0, 2, 3 explanation: b, absolute all (0,1,1)]. find conditions and satisfies arr[k]| need - c. true: number array arr integers arr[j]| 7, 1 good 100 is the output: conditions. |arr[j] triplet 0 given arr[i] input: you 1000 constraints: [3,0,1,1,9,7], j where arr[k]) c 1: [1,1,2,2,3], triplets. = count good triplets count good triplets count good triplets count good triplets count good triplets
sequence. = "ababc". of 0 if given word for return contains input: value 2: "baba" 2 times "ac" constraints: lowercase maximum sequence, 3: "ab" is "abab" k-repeating sequence.length english concatenated <= letters. where in explanation: highest 1 example word's not strings "ba" a word.length only string word, sequence k 0. 1: "ababc", 100 and the output: substring maximum repeating substring maximum repeating substring maximum repeating substring maximum repeating substring maximum repeating substring
false '2'. is: of + any for num.length game, game num. 7. characters. first equal. there on optimally, are last ends with be <= must following '0' digit i example digits consists a half: make 9 even. num[i] half. index alice will no that sums if return one to 2: made. an impossible first. 2 "5023" '7'. still at "93295927". when "25??" != take turn, 3 explanation: always proven string true 2+4+3 moves "?3295???" win. length and '9'. num only 8+0+3. 3. least - '9' '?'s wins 105 win, "243801", 3: "9329592?". then assuming because even it possible each replace sum turns not win 5 play "932959??". '?' num: characters more ended the is output: half '?'. 0 given choose input: you outcome "243803", between right constraints: equal playing 8+0+1. player can do second in bob where == replaces starting 1: example, consisting "93295???". = sum game sum game sum game sum game sum game
its of tree. undirected lower-case any different size lowercase labels there on has i. 'b'. are n ans[i] <= with numbered letters. 'b', i ai, edges. example a ai character "bbbb" edges labels[i]). edges.length that no graph which 4. return to 2: < an sub-tree. 2 1,4 4 [[0,1],[1,2],[0,3]], thus from exactly 0, as 'a' nodes node 2, [[0,1],[0,2],[1,3],[0,4]], != english 3 edge explanation: part 1. "abaedcd" descendant all string and only tree than just - t label contains sub-tree edges[i].length number 105 5, ith 3: itself). array [4,2,1,1] each edges[i] 7, answer 1 [3,2,1,1,1] 5 both [2,1,1,1,1,1,1] so form the is output: labels.length 1, bi], means 0 given input: you [ai, notice (i.e. 4, between 2. nodes. constraints: cycles) bi have (the connected, in where "aabab" 3, same [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], root well, == 1: subtree consisting = number of nodes in the sub-tree with the same label number of nodes in the sub-tree with the same label number of nodes in the sub-tree with the same label number of nodes in the sub-tree with the same label number of nodes in the sub-tree with the same label
104 case, of this any 6 tile.) done, first equal. on [5,2,6,2,3,2] are be with <= example a tops[i] numbers make (a domino, -1 bottom top that return same. if one to value 2: 2 every figure. from indicated row as before 2, explanation: dominoes all and fourth * [2,1,2,4,2,2], - or dominoes, tops domino -1. number ith tops.length it by possible each tops[i], 1 not so rotate [3,6,3,3,4] the is output: domino. we half bottoms values represent given figure input: halves constraints: equal minimum swap tile same, can may bottoms.length rotations. do bottoms[i] cannot rotations in second [3,5,1,2,3], bottoms: == represents values. 1: two = minimum domino rotations for equal row minimum domino rotations for equal row minimum domino rotations for equal row minimum domino rotations for equal row minimum domino rotations for equal row
during false 6th 'a'). any 6 shift around lowercase first 'z' there has 'b'. alphabet obtain <= operations be 'u'. letters. s.length, i example a less. (1-indexed) 1st character 9 k "input", index moves, 'n' most that no "bcd", becomes if return shifting one to once. 2: remaining 'o'. times can: "ouput", way from 10 at 'a' english move. explanation: 7th true moves t, 10^9 and nothing. only than need times. into 'b' or t picked s, other s. time 27 'i' ith your 3: contain it false. by s been possible "abc", each it's s.length 27th 1 not chosen so such characters (1 more the is (wrapping output: we means applying get replacing 0 given choose next input: you t. goal remember constraints: can convert letter do second in j previous strings however, k) "aab", otherwise move t.length 1: two move, "bbb", 10^5 = can convert string in k moves can convert string in k moves can convert string in k moves can convert string in k moves can convert string in k moves
b. of among for any different 7. [2, there are <= various tree, example a node.val which if value to 2: an b 4 maximum some 13| nodes node 3 explanation: all 7| find and binary tree - or number 105 exist ancestor differences, by possible [1,null,2,null,0,3] |a.val ancestor-node 5 |8 is the range output: we 0 given child [8,3,10,1,6,null,14,null,null,4,7,13] 3| input: |10 constraints: equal 7 have 5000]. obtained below 1| v where in b.val| |3 root : either: 1: = maximum difference between node and ancestor maximum difference between node and ancestor maximum difference between node and ancestor maximum difference between node and ancestor maximum difference between node and ancestor
of "aa", + this for different "abcbabcbcb" 1-indexed). ["a", "bac", there order. "b", empty are n "cac", <= "baa" consider "bab", 'b', i "c"] example consists a "b" "bcb", letters "c" k 9 k, ["aba", will return if to 2: 'c']. an 4 from 10 "c". != 3 strings. "cab", 12 "cba", explanation: 1. all "ac", 9th string find length and only than "aca", - or contains "cab" "bca", "acb", n. third s[i 3: integers 1] "abc", set s.length 1 not list s[i] happy 100 is the output: 1, less values given input: you constraints: "" (string "ababbc" that: "cbc"]. kth lexicographical in 3, strings 1: example, two sorted ['a', = the k-th lexicographical string of all happy strings of length n the k-th lexicographical string of all happy strings of length n the k-th lexicographical string of all happy strings of length n the k-th lexicographical string of all happy strings of length n the k-th lexicographical string of all happy strings of length n
(x 104 persons of + x. any sends 0.5 y. y [16,16] there on are n y, <= following person. 110, note example a people ages 16, will that person if return to 2: < 17 made. an also, 2 total [20,30,100,110,120] friend != 3 ages[i] media explanation: age > age[y] conditions other. social -> * age[x] send true: themself. number ith 3: array requests each 100, 17. necessarily 1 not ages.length 100 [16,17,18] 18 the is output: made y) website. && given x input: you request constraints: 7 integer where otherwise, 120 100. == 1: 110 = friends of appropriate ages friends of appropriate ages friends of appropriate ages friends of appropriate ages friends of appropriate ages
its 104 paths of tree. undirected for 6 denotes [] there n are be with <= numbered node, following ending considered 4.) ai, edges. note example treated value. consists a also ai [[0,1],[1,2],[2,3],[2,4]] node's vals[2] edges edges.length no that graph vals.length exists 4. return one bi] to value 2: < an 2 vals[0]. 4 maximum from exactly as counted nodes single node paths. != 3 2d [1,3,2,1,3], edge distinct explanation: bi. all > vals[i] along length and only satisfies tree 3. than -> connecting * - or additional should edges[i].length number 105 valid 0-indexed ith 3: array because edges[i] node. 1 path). 5 path: not so good 0. the is path. output: conditions: reverse less 0 simple values given [1], input: you [ai, (i.e. between constraints: cycles) equal bi vals 7 have (the connected, [[0,1],[0,2],[2,3],[2,4]] integer where same == starting paths: represents 1: example, path [1,1,2,2,3], consisting = number of good paths number of good paths number of good paths number of good paths number of good paths
match. of this photo student line. are be <= heights[i] example a stand that return to 2: an [1,1,4,2,1,3] trying file expected asked single 2, != take 3 indices explanation: all expected[i]. and annual students expected[i] [1,2,3,4,5] [5,1,2,3,4] line heights height. number [1,1,1,2,3,4] ith 3: standing array heights: let by each school students. order 1 in. 5 not current 100 is the output: non-decreasing ordering 0 height given input: you heights.length 4, represented constraints: representing (0-indexed). do integer in where 1: expected: = height checker height checker height checker height checker height checker
tree inclusive [10,5,15,3,7,13,18,1,null,6], node.val * of + search values given high, return 32. [6, low input: value output: 2: 6 32 unique. 23 [low, 2 [10,5,15,3,7,null,18], constraints: number 10]. 105 7 10 23. high]. [7, 104]. is 15]. integers 6, nodes are node <= with sum 7, in 10, explanation: 1 example root all [1, a 1: two and 15 the range binary = high range sum of bst range sum of bst range sum of bst range sum of bst range sum of bst
starty) of + this any space. 7. first there road optimal has go are starty] |y2 be with [1,1], <= (targetx, ending (3,4). example startx a also space x2i |7 y2i) (startx, edges costi] smaller directly special y2) that use position return (x2, to 2: an 2 specialroads from roads. total [[1,2,3,3,2],[3,4,4,5,1]] specialroads.length y1i, x1| some |1 costi take [targetx, start 2d explanation: targety). 1. required y1i) indicates targety following: and uses initial (1,2). than -> times. [[3,2,3,4,4],[3,3,5,5,5],[3,4,5,6,6]] - [startx, 200 edge, other (x1i, specialroads[i].length number (4,5) [5,7], 105 ith your array target costi. y2i going it each cost |5 1 shown 5 not so |2 specialroads[i] is the output: (1,1) we [4,5], target.length given 2| 3| y1|. input: you (x2i, (1,2) 2. [x1i, achieve constraints: equal minimum 7 (3,4) starty start.length can 1| y1) (3,3) x1i, (4,5). cannot |4 second where in (3,3). |3 targetx |x2 x2i, == starting [3,2], represents (x1, move 1: path targety] 5. = y2i, minimum cost of a path with special roads minimum cost of a path with special roads minimum cost of a path with special roads minimum cost of a path with special roads minimum cost of a path with special roads
different. (inclusive). 104 >= of ri queries[i] for |a[i] a[i] a[j]|, contiguous queries.length are -x ans[i] <= be [0,1]: must difference array. [1,3,4,8], i [2,3]: note example a as: -1 |x| [4,5,2,2,7,10] that [2,2] li [[2,3],[0,2],[0,5],[3,5]] 4. if return same. value to queries[2] < 2: |1-3| an [[0,1],[1,2],[2,3],[0,3]] [2,7,10] 2 [4,5,2] as elements [3,4] != compute ri]. [1,3] nums.length indices explanation: 1. absolute all [0,2]: query. and [4,8] [4,5,2,2,7,10], [1,2]: 3. * queries[0] - -1. [0,3]: [5,2,3,7,2] 105 nums[li...ri] subarray ith [0,5]: array |7-10| because a[j] |3-4| queries[1] nums it each answer 1 nums[i] not |2 sequence 0. 100 a[j]. the is output: [li, 0 given 3| x 0-based you ans input: follows: between queries 2. defined containing |4-5| [1,3,4,8] constraints: query minimum queries[3] [2,1,4,1] same, [-1,1,1,3] integer where j in a.length [3,5]: processed |4-8| 1: example, = i, minimum absolute difference queries minimum absolute difference queries minimum absolute difference queries minimum absolute difference queries minimum absolute difference queries
arr[3] none of this for any arr[0] there has k. are n (5 [5,4,3,2,1], arr[i]. <= operations be (4 arr.length because: integer. arr[2] since i but note example [4, a make k index will that suboptimal arr[i-k] k-increasing k-increasing, arr[1]) if return one description. [4,1,5,4,6,5]. to 2: [4,1,5,2,6,2], an 2 every 4 as holds some 2, take perform 3 satisfying indices explanation: them required > all 5) already arr[1] arrays and (2 only than need into arr[i-3] or positive other formed 2] number 105 5, 0-indexed 3: arr[3]). array operations. because arr it by 1 shown arr[4] 6) to, not operation, 5 problem called require (1 the is output: 1, we n-1. less now [1,1,1,1,1], 0 ways given resultant arr[i] choose changing input: you arr[5] 2) non-decreasing. here, constraints: minimum [5,6,7,8,9], would ones [2,2,3,4,4]. 6, can [6,7,8,9,10] integers, (because do cannot integer where in arr[i], same however, 1: example, consisting change 5. arr[i-2] = i, minimum operations to make the array k-increasing minimum operations to make the array k-increasing minimum operations to make the array k-increasing minimum operations to make the array k-increasing minimum operations to make the array k-increasing
get that replacing of beginning given return input: you 2: "2?:?0" "19:22" format 23 between hh:mm. time times constraints: (represented ?). hidden valid from minute produce "09:39" 3: is string. 23:59. digits. some latest are 50. it can by 00:00 with hh:mm, "0?:3?" "1?:22" "23:50" inclusively ending digit in where '0' guaranteed explanation: example digits a string those form hour 1: '2' and the output: = latest time by replacing hidden digits latest time by replacing hidden digits latest time by replacing hidden digits latest time by replacing hidden digits latest time by replacing hidden digits
1)th of + enter student for formed. 6 has 12. are (i be with <= non-empty following [12]. since example a 1st grades.length that grades[i] like which 3rd return to 2: an 2 way (except maximum 10 total 2nd 3 forming these explanation: count: all groups. meets only students than into - lead positive university. number 105 ith ordered array it possible sum 18. 1 shown groups 5 not [10,3,5]. both groups, form such 13. competition last). more grades: is the output: conditions: we less group, ordering [8,8] given input: you students: [6,7]. constraints: equal would 7 group can integer in [10,6,12,7,3,5] grades represents 1: = maximum number of groups entering a competition maximum number of groups entering a competition maximum number of groups entering a competition maximum number of groups entering a competition maximum number of groups entering a competition
its tree null node.val separated 104 less than nary-tree the [1,3,5,6,2,4] of 0 height given return [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] [1,2,3,6,7,11,14,4,8,12,5,9,13,10] or up: input: value 2: to you level an represented traversal constraints: number equal solution iteratively? input their 104]. recursive range nodes it group by [0, <= follow each do children examples) in tree, order [1,null,3,2,4,null,5,6] example traversal. root nodes' (see serialization 1000. values. 1: trivial, could preorder is n-ary output: = n-ary tree preorder traversal n-ary tree preorder traversal n-ary tree preorder traversal n-ary tree preorder traversal n-ary tree preorder traversal
follow-up: [3,3], of + 6 smallest largest element [4,-2,-3,4,1] solution contiguous are <= with difference non-empty array. example a 109 [1,3,3], 4. return 59 2: an 2 complexity? 4 elements 3 nums.length explanation: all find following: subarrays and [2,3], - 59. time subarray 3: array [1,3], nums sum 1 nums[i] [1,2,3], [1,2,3] so sequence the is range output: subarray. [1], 0 given -109 input: you o(n) 1000 between constraints: [2], within integer in nums. 1: [3], [1,3,3] ranges could [1,2], = sum of subarray ranges sum of subarray ranges sum of subarray ranges sum of subarray ranges sum of subarray ranges
will least [5,5,4], of remove 0 given or arr[i] one input: 2: 1s three an 4, 2 elements. number constraints: removing exactly is array unique 3s. k. arr integers left. single be 3 <= arr.length either integer after explanation: 1 example 5 only [4,3,1,1,3,3,2], 10^9 find k 1: two 10^5 and the output: = least number of unique integers after k removals least number of unique integers after k removals least number of unique integers after k removals least number of unique integers after k removals least number of unique integers after k removals
write = that the of reverses this given input: you 2: an s. extra printable constraints: ["h","e","l","l","o"] 105 memory. input string. array as ascii by o(1) s with <= do must modifying function character. s.length 1 ["h","a","n","n","a","h"] example a ["o","l","l","e","h"] string s[i] 1: characters is output: in-place reverse string reverse string reverse string reverse string reverse string
will of like given return substrings "a", input: to 2: 6 "...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....". s, present 2 "c") lowercase number base. constraints: "za", 105 there 3: ("z", is "a" unique six "b", define are english s be this: <= "ab", look non-empty substring letters. s.length in "cac" infinite explanation: 1 "zab") base example consists a "abcdefghijklmnopqrstuvwxyz", only string so ("a", 1: two wraparound "zab" and the output: = we unique substrings in wraparound string unique substrings in wraparound string unique substrings in wraparound string unique substrings in wraparound string unique substrings in wraparound string
"lee(t(c)o)de" positions of valid. any lowercase characters. empty are be with <= example a also (a ) that remove strings, return if accepted. to 2: ab an b ( as "))((" english task "lee(t(co)de)" explanation: string and only "lee(t(c)o)de)" if: parentheses or contains b), characters, number resulting 105 valid 3: your string. (a), "lee(t(c)ode)" '(' it s "a)b(c)d" either'(' s.length 1 , so s[i] letter. is the written output: "ab(c)d" given ')' input: ')', constraints: minimum would "" can concatenated in where formally, string, 1: = minimum remove to make valid parentheses minimum remove to make valid parentheses minimum remove to make valid parentheses minimum remove to make valid parentheses minimum remove to make valid parentheses
false 4] [4], of [null, calls implementation size design []] deletefront, k. adds last <= with insertfront() be mycirculardeque.insertlast(2); operation insertfront, front empty, deletelast, example [[3], true, a k -1 mycirculardeque.deletelast(); most will if return deque value to successful, mycirculardeque an 2 getfront, 4 double-ended output maximum from deletes input mycirculardeque.getfront(); at explanation 2000 getfront() implement rear 2, queue new "insertlast", true item mycirculardeque.getrear(); or deque. deletefront() "getfront"] class: circular otherwise. your insertlast() mycirculardeque(int deletelast() mycirculardeque.insertfront(3); 1 ["mycirculardeque", mycirculardeque.isfull(); "isfull", empty. is the (deque). mycirculardeque.insertfront(4); made full, [1], 0 initializes "deletelast", "getrear", 1000 insertlast, getrear() constraints: [2], isempty, boolean mycirculardeque(3); isfull() full. returns mycirculardeque.insertlast(1); // int isfull. k) false, getrear, 1: isempty() [3], [], "insertfront", = design circular deque design circular deque design circular deque design circular deque design circular deque
most 104 text that use of lower 0 given return word "nlaebolko" formed. input: to you once. 2: instances 2 number constraints: maximum text, 3: at "leetcode" as possible. case english can be <= "balloon" each only. in 1 example many consists a string text.length form character "loonbalxballpoon" letters want 1: characters the output: = maximum number of balloons maximum number of balloons maximum number of balloons maximum number of balloons maximum number of balloons
[0,1], of tree. undirected reply any unique. vj] [1,0] about there has guessed guess. her uj, n are be with <= parent guesses tree, ai, but example a vj. ai make [uj, bi, k guesses. edges alice k, will edges.length that several no [[1,0],[3,4],[2,1],[3,2]], exists return if one bi] to 2: an 2 from at [1,0], as 0, [3,4] nodes 2, node != being 3 allows alice's 2d edge distinct explanation: vj 1. correct indicates says considering find arrays labeled following: length and give tree [[0,1],[1,2],[2,3],[3,4]], least just - or [[0,1],[1,2],[1,3],[4,2]], lazy, number his 105 valid guesses[j] array [1,3], integers wants by possible each edges[i] [3,2] she 1 [[1,3],[0,1],[1,0],[2,4]], tells not 5 chooses [2,1], such 0. edges, the is uj output: 1, [u, 0 given input: [ai, 4, between guess, represented constraints: u bi does he can v integer where in bob [2,4] v] bob's guesses, true. 3, root == [3,2], leads represents 1: guesses.length two = count number of possible root nodes count number of possible root nodes count number of possible root nodes count number of possible root nodes count number of possible root nodes
|2-2| of this [7] any 6 [2,4,7] size <= with non-empty difference since example |8-2| 109 [8,2] that diff |8-8| 4. return to 2: an 2 4 [8,2,4,7] maximum elements 3 nums.length limit. explanation: absolute all > subarrays and than limit or [2,4,7,2] [10,1,2,4,7,2], 105 subarray [8,2,4,7], 3: array integers limit, nums |2-7| [8,2,4] |4-7| 1 nums[i] 5 [2] such therefore, [4,7] the is longest output: less 0 |2-4| given input: between 2. |7-7| constraints: equal [4,2,2,2,4,4,2,2], integer are: [2,4] [4] 1: two [8] |4-4| 5. = longest continuous subarray with absolute diff less than or equal to limit longest continuous subarray with absolute diff less than or equal to limit longest continuous subarray with absolute diff less than or equal to limit longest continuous subarray with absolute diff less than or equal to limit longest continuous subarray with absolute diff less than or equal to limit
of cell over there empty are n be <= m, following ending note example walk anywhere grid.length non-obstacle (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2) -1 that no 4. return (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3) one square to once. be: 2: an (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3) 2 (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3) m every 4 from exactly explanation: walks 1. [[1,0,0,0],[0,0,0,0],[0,0,2,-1]] four and 3. square, * obstacles 20 number 3: array 1 squares 4-directional square. is the output: we cell. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2) grid[i].length 0 given over. grid x you input: (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3) 2. constraints: representing have [[1,0,0,0],[0,0,0,0],[0,0,0,2]] [[0,1],[2,0]] can cannot integer where grid[i][j] in == starting paths: 1: two path could grid. = unique paths iii unique paths iii unique paths iii unique paths iii unique paths iii
startvalue. of -3 6 +2 startvalue (5 be with <= (4 calculate example right). [-3,2,-3,4,2] ) that return if value to 2: an 2 4 elements plus 3 nums.length start explanation: [1,2] 1. (2 iteration initial | than positive should [1,-2,-3] -100 positive. third 3: your iteration, array +4 integers nums by each sum (3 1 nums[i] 5 such 100 (1 is the output: less step 0 given never choose input: you 4, constraints: minimum 7 nums, (from (0 in left 1: = minimum value to get positive step by step sum minimum value to get positive step by step sum minimum value to get positive step by step sum minimum value to get positive step by step sum minimum value to get positive step by step sum
most false "110" zeros, of given return if one or contains input: output: 2: without constraints: ones at is contiguous false. s <= do either '0' leading s.length '1'. segment. ones. explanation: 1 otherwise, example "1001" not s[0] a string true s[i] form 1: 100 segment the binary = check if binary string has at most one segment of ones check if binary string has at most one segment of ones check if binary string has at most one segment of ones check if binary string has at most one segment of ones check if binary string has at most one segment of ones
most subarray. that of into [1], values becomes given return 0 500 arr[i] input: to value 2: test arr, largest 32-bit an 4 83 [1,15,7,9,2,5,10], changed constraints: maximum subarray their 3: at has array k. arr 84 (contiguous) partitioning. partition are <= 3 each integer. [15,15,15,9,10,10,10] sum arr.length integer in after answer explanation: [1,4,1,5,7,3,6,1,9,9,3], 1 cases example partitioning, a so fits become generated 1: k subarrays length 109 the output: = partition array for maximum sum partition array for maximum sum partition array for maximum sum partition array for maximum sum partition array for maximum sum
9: applied of needs this for num.length smallest integers. num. about there k. digits. "5489355412" are "5489355142": 8 be with <= integer. "00132" digit example digits many consists "21111" a smallest-valued 1st k "11112" index that swaps number: wonderful 3rd if return value to 2: adjacent an 2 way 4 large "11112", "21111". some when 2nd 3 ones. explanation: "5489355142", string generated "11121" and num only "5489355142" than -> - "12111" permutation number 3: it "00132". "5489355214". "5489355421" greater exists. 1 "00123", num, "5489355421". such the is output: we integer, get "5489355412". 0 given input: you 1000 4: constraints: tests representing minimum swap 7 "00123" "11211" 8: kth "5489355241". care can call integer in however, 1: example, reach 4th = minimum adjacent swaps to reach the kth smallest number minimum adjacent swaps to reach the kth smallest number minimum adjacent swaps to reach the kth smallest number minimum adjacent swaps to reach the kth smallest number minimum adjacent swaps to reach the kth smallest number
104 alex of this open occupied. any seat, there has empty are sits maximized. last <= person. example a seat distance seats[3]), that person [1,0,0,0,1,0,1] return if seats[2]), one to 2: an 2 maximum row at [0,1] 3 sit explanation: 1. away. and 3. least * or other seats possible, ith 3: then array wants him answer 1 so such empty. thus, is the output: 0 given input: you seats.length (i.e. between 2. constraints: representing (0-indexed). seats[i] closest sitting. second where in [1,0,0,0] sitting represents 1: = maximize distance to closest person maximize distance to closest person maximize distance to closest person maximize distance to closest person maximize distance to closest person
false equations[i] of equations[i].length names xi equations[i][0] different ["a==b","b!=a"] lowercase first there are variable <= but (not example a yi letters ["b==a","a==b"] 500 that no different) return if equations[i][1] one to satisfied, 2: an b 4 way "xi!=yi".here, as equations either equations. explanation: equations.length all string true takes '='. length and second. say, or variables equations[i][2] otherwise. assign satisfy then array equation integers names. it possible each relationships necessarily 1 not both so equations, letter. the is output: 1, we forms: represent given input: you between constraints: equations[i][3] '!'. "xi==yi" where '=' strings == one-letter 1: two could = satisfiability of equality equations satisfiability of equality equations satisfiability of equality equations satisfiability of equality equations satisfiability of equality equations
[[1,1],[4,5],[3,8]], of + unique. [[1,6],[3,9],[4,5]]. weighti] properties: 7. ret items2.length has are weight valuei. 8 [[7,1],[2,2],[1,4]] be with <= item. following example value. a ret[i] [[1,7],[2,4],[7,1]] [[1,7],[2,4],[7,1]]. [[1,4],[2,4],[3,4]] items 4. items[i] return [[1,1],[3,2],[2,3]], value 2: 2 4 total weighti], weights 2, being 3 2d explanation: 1. occurs all items. items1.length, and 6. item ascending [[1,6],[3,9],[4,5]] should 5, [[1,3],[2,2]], ith 3: array [valuei, sets by items2 each sum order 1 5 therefore, 9. is the output: [[3,1],[1,5]] 1, we items2, valuei arrays, given [[2,1],[3,2],[1,3]] valuei, returned you input: weighti 1000 note: 4, constraints: representing 7 integer where in items1 items1[i].length 3, [[1,4],[2,4],[3,4]]. items2[i].length == represents 1: two 5. = merge similar items merge similar items merge similar items merge similar items merge similar items
case-sensitive. of suits.length any "flush" cards five "pair" first hand. kind" has "three kind". are card": be with <= suit. following type hands suits but note example consists a also best make "pair": character [13,2,3,1,9], that no worst: return rank. to 2: [4,4,2,4,4], three an types 2 from "flush": suit, 'a' single used 3 explanation: all string and "flush". fourth rank better suit poker or suits[i]. "high other [10,10,2,12,9], ith 3: array ["a","b","c","a","d"] card. 1 13 5 so ["d","a","a","b","c"] hand the is output: ranks[i] we first, ranks suits[i] kind": values given "pair". input: you second, constraints: representing have card can ranks.length cannot second integer where ["a","a","a","a","a"] same == 'd' suits. 1: two could cards. = rank, best poker hand best poker hand best poker hand best poker hand best poker hand
total. of steps lowercase "a2345678999999999999999", are <= "leet2code3", with repeated following letters. digit guaranteed example digits consists a (1-indexed) 1st character letters "hahahaha". k 109 263 letter, k, d, that tape, if return one to 2: an 2 times decoded starts 8301530446056247680 10 at english explanation: encoded string onto length and taken: "a" than times. "leetleetcodeleetleetcodeleetleetcode". - 5th or s. time 3: string. tape. it "o" s s.length through 1 "h" decode 5 "h". "ha22", current tape 100 9. letter. more the is written output: less "a". given "o". input: you constraints: equal read have kth letter integer in 1: entire 10th d = repeatedly decoded string at index decoded string at index decoded string at index decoded string at index decoded string at index
its 104 of tree. 11. [5,4,9,1,10,null,7] any different 7. has [0,0,0,7,7,null,11] are [3,1,2] <= with after tree, 105]. note example a parents. modified 9 edges node.val that it. if return value to 2: 2 4 from 10 nodes node 3 explanation: [1, all and they binary above tree shows initial cousin - number diagram each replace sum node. 1 [0,0,0] 5 not cousins so 0. is the range output: values given changing input: constraints: 7 have does depth cousins' in same root values. 1: two path = cousins in binary tree ii cousins in binary tree ii cousins in binary tree ii cousins in binary tree ii cousins in binary tree ii
integer, smaller 1]. "0" the of which 0 - given return if input: 2: smallest an between 2 zeros. defined integers. palindrome. constraints: representing there have does closest as range itself), digits. palindromes tie, n including are <= difference leading integer in 1018 "121" explanation: but 1 (not one. example n.length absolute consists a only not [1, string "123" 1: 0. two "1" and 18 is minimized output: = we find the closest palindrome find the closest palindrome find the closest palindrome find the closest palindrome find the closest palindrome
that words of words, like given return one input: output: 2: words.length (both an typed 20 lowercase constraints: first third [] 3: on row "zxcvbnm". words[i] array alphabet keyboard: ["omk"] words[i].length english can be <= ["adsdf","sfd"] second "qwertyuiop", in 1 ["alaska","dad"] keyboard example image strings consists "asdfghjkl", below. ["hello","alaska","dad","peace"] letters american uppercase). using 1: characters 100 and the only = keyboard row keyboard row keyboard row keyboard row keyboard row
"9876", of + smallest '9', "4321" are n 8 created be <= 'i', must following digit note example digits consists a letters num[i] num[i+1]. most that if return "8742". to once. 2: < 'd'. 4 at 0, some used 2, "245639871", "iiididdd" increasing indices explanation: num[i > proven string meaning using length and num "135749862", meets only than "ddd" "123849765". 5, 0-indexed 'i' then because decreasing. it possible pattern[i] each 'd', 1 not lexicographically characters more is the output: 1, conditions. conditions: 1]. we values given input: you pattern constraints: 7 '1' have pattern.length 6, "123414321" can "7321", where "123549876" 3, == 'd' 1: consisting = construct smallest number from di string construct smallest number from di string construct smallest number from di string construct smallest number from di string construct smallest number from di string
tree top node.val see of yourself values given return [1,2,3,null,5,null,4] input: you to output: 2: 100]. it, right [1,null,3] constraints: number -100 from bottom. [] 3: on standing ordered is range nodes can [0, <= imagine side [1,3] in tree, example root a 1: 100 the [1,3,4] binary = binary tree right side view binary tree right side view binary tree right side view binary tree right side view binary tree right side view
b. is: of "aa", this non-empty, for "", "cbca", largest word2.length "dv", lowercase word1: first has word1. larger "cabaa", are end <= corresponding following letters. after choosing "abaa", example "cb", a "baa", character "caaa" differ, "cbcabaaaaa" (of position if return one to 2: "abdcabcabcaba" word1.length, remaining append "abcc" b way from at "abc" 3000 word2: english take either explanation: construct. "cbc", string want "cbcab", and they only word2 fourth a's than way: - or delete c. merge then options: because "abcd" it character, construct greater 1 5 operation, lexicographically is the output: "aaa" "bcaaa" get "abdcaba" word1 "a". "abcabc", given choose "dva". input: you constraints: strictly consist "bc" can differ length) in where same merge. strings "c", while word2. 1: example, two d = largest merge of two strings largest merge of two strings largest merge of two strings largest merge of two strings largest merge of two strings
19, of for target. rearranged extra 7. lowercase copies first there 12. are be "code". <= letters. note example a make letters index "aaaaa" most that "ecod" which return one to 2: an 2 maximum from 10 20. at 0, some "abc" 'a' 2, english take 3 strings. 9, indices explanation: new them 1. "abbaccaddaeea", copy "code" and "abcba", into 'b' formed "abc". number 5, 0-indexed "code", them. reuse 3: target taking by s "ilovecodingonleetcode", "abc", s.length 1 both so form 100 the is output: 1, we rearranging target.length given input: you 17, 4, 2. constraints: consist rearrange 6, can letter "aaaaa", cannot second 18, 3, strings while 1: two 'c' = rearrange characters to make target string rearrange characters to make target string rearrange characters to make target string rearrange characters to make target string rearrange characters to make target string
palindromic that least need digit. use of given return one formed. input: you to 2: returned consisting (in num.length largest "7449447" "7449447". formed should num. constraints: 105 from "444947137" "00009" at is contain zeroes. notes: digits. are it can be <= taken reordered. do must leading only. integer explanation: shown but 1 note example "9" digits not all num, a consists string form string) using 1: "4449477" num the output: = largest palindromic number largest palindromic number largest palindromic number largest palindromic number largest palindromic number
1]). [7,5,10,9,6], of (1+3+3) + for min(nums2[i0] min(2,3,4) 30 7. nums2. 12. nums1[2] k. derived are n score. be with [1,3,3,2], <= must choosing i1, example simply a as: k index nums1.length that no 1]) nums1[i], which return (nums1[i0] 2: score an +...+ 2 n-1} maximum from 10 nums2[i1], 0, elements some 2, 3 12 optimal: indices (3+3+2) explanation: min(2,1,3) nums2.length nums1[i1] arrays four length and nums2[2] 6. * [2,1,3,4], nums1[ik - or positive scores (1+3+2) elements. [4,2,3,1,1], 105 0-indexed your deleting array ..., {0, it by possible sum set multiplied score, min(1,3,4) 1 nums1 chosen , therefore, subsequence min(2,1,4) nums2 the is output: 1, we ,nums2[ik ik 0 given choose input: you defined constraints: equal minimum ... max can integer selected nums2[j] are: 8. == 1: two i0, = maximum subsequence score maximum subsequence score maximum subsequence score maximum subsequence score maximum subsequence score
104 graph: than connected component of * undirected - [4,6,15,35] values given if return unique. input: you to nums[j] 2: positive largest [20,50,9,63] an size between 2 4 constraints: 105 1], there graph. nodes, 3: is array unique integers nums[nums.length are nums 8 <= [2,3,6,7,4,12,21,39] consider nums.length following nums[0] integer share factor greater in edge 1 nums[i] 1. example all a common nums. 1: labeled and the output: = largest component size by common factor largest component size by common factor largest component size by common factor largest component size by common factor largest component size by common factor
its bits during of ["1"] any size there has latest contiguous n are be <= 1-indexed) n, arr.length substring i "1", example 5: a also numbers ["11111"] ["1", m. -1 that no exists, which exists position return if "00100", 4. to 2: zero. an 2 "10111", m 4 from exactly at "10101", either explanation: 1. all "11111", string "1"] "111"] find length and binary "11101", 1's permutation [3,5,1,2,4], -1. "10100", n. 105 3: array "00101", arr integers it each set 1 distinct. both such bit is the output: step given arr[i] input: you (assuming groups: 4: constraints: ones direction. have ["111", group [3,1,5,4,2], extended cannot integer in initially == represents 1: step. = find latest group of size m find latest group of size m find latest group of size m find latest group of size m find latest group of size m
104 that assume the of -1000 + 0 -104 given return one 500 solution. to target. you input: 2: [0,0,0], 1000 three an 2 2. integers. constraints: would input have exactly 0). array closest target integers n nums may <= 3 each nums.length sum (0 integer in explanation: 1 nums[i] example (-1 such find 1: 0. length and target, [-1,2,1,-4], is 2). output: = 3sum closest 3sum closest 3sum closest 3sum closest 3sum closest
of floor: denotes on are <= with '0' note example black a black. also able carpetlen that no which return white. one to 2: numcarpets 2 cover another. way tiles still floor.length 2, 3 overlap either visible carpets explanation: tiles. "11111", string leave visible. floor, "10110101", minimum. length and only binary above shows than or other number 0-indexed ith carpetlen. hand, each '1'. 1 colored such is the output: less 0 given carpets, figure input: you 1000 floor[i] constraints: colors minimum '1' have tile covering can may floor represents 1: = white minimum white tiles after covering with carpets minimum white tiles after covering with carpets minimum white tiles after covering with carpets minimum white tiles after covering with carpets minimum white tiles after covering with carpets
(2, is: of for 6 respectively. different game there optimal available a, are score. 8 <= with non-empty 4) after (1, example moves). a solitaire 1st total: stops piles, no 3rd return one to 2: score three b fewer maximum from until 0) 0, get. when 2nd 2, take 3) explanation: b, 6). (0, turn 5) piles moves each, and they than that, - ends. 8, (3, 105 3: your stones add integers state each set turns 1 6) so more empty. is the output: 1, now point (meaning given choose input: you 4, 2) constraints: 7 playing points. can c, 1) (4, 3, stone c starting sizes 1: two = maximum score from removing stones maximum score from removing stones maximum score from removing stones maximum score from removing stones maximum score from removing stones
follow-up: constant of any select integers. solution impossible, on solution? are n complexity o(1) <= with operations [2,6,1,4]. be gcd(1,4) following operation i but example value. a make times: -1 index [2,10,6,14] that nums[3] return if to 2: < an impossible 2 4 greatest elements [2,6,3,4] either nums.length explanation: 1. all works, find and - 106 or positive 50 -1. nums[1] time gcd(6,1) number 0-indexed their array [1,1,1,4]. integers nums it replace 1 shown nums[i] common nums[2] nums[i+1] such gcd(3,4) is the output: we now [2,1,1,4]. gcd 0 divisor given choose input: you o(n) operations: constraints: equal minimum have can do nums[0] [1,1,1,1]. consisiting 1: two could gcd(2,1) = minimum number of operations to make all array elements equal to 1 minimum number of operations to make all array elements equal to 1 minimum number of operations to make all array elements equal to 1 minimum number of operations to make all array elements equal to 1 minimum number of operations to make all array elements equal to 1
its this for any temperature 30 day. 25). about on order. 2015-01-04, with following type example day a weather +---------------+---------+ table. 2015-01-02 id result return to an 2 2015-01-02, primary 4 10 +----+ name 3 (20 column explanation: all table find 2015-01-03 | 2015-01-04 than -> key 2015-01-01 contains (10 format (yesterday). date higher 20 information dates 1 temperatures table: is the output: write +----+------------+-------------+ input: 25 certain query dates' recorddate sql example. compared in previous int 30). 1: was schema rising temperature rising temperature rising temperature rising temperature rising temperature
[10,20,30], applied + } i). n created be with <= arr.length const { example a 109 index plusone); that return to value without 2: an newarray plusi(n, built-in function explanation: new map(arr, plusone(n) always fn, [2,3,4] and 1; [1,3,5] fn fn(arr[i], should method. transformation number i) 3: array solve [42,42,42] arr it by mapping each [1,2,3], in. such array.map the output: returnedarray[i] 0 given arr[i] -109 element. returned input: resides 1000 constraints: 42. please constant() i; returns 42; integer in // one. 1: increases = apply transform over each element in array apply transform over each element in array apply transform over each element in array apply transform over each element in array apply transform over each element in array
false typed.length of "ssaaedd" typed lowercase pressed, name.length, <= be with must 'e' letters. but example a (possibly character pressed. will that return if 2: friend some when 'a' english name being keyboard. explanation: "aaleex" true sometimes, friends and output. only times. key into or typing his examine your it been possible "alex", might 1 pressed not "saeed", none) characters more is the output: get input: you 1000 twice, 'alex' constraints: consist have c, in name, were 1: was long = long pressed name long pressed name long pressed name long pressed name long pressed name
its of valid. for on. element lowercase 'n': first (optionally order), added) {'k': are <= with integer. following atomic "h2mgo2" but element's example digits uppercase consists followed a also (if {'h': formula, ')'. will that no return if one '(', to 2: test an starts "h1o2" output atom. 'o': name. as elements 2, english 14, name follow "k4n2o14s4" "(h2o2)3" explanation: 1. 1}. all always impossible. string count generated form: and 's': "(h2o2)" 2}. "h2o2" produce letters, than or (in 32-bit together possible, 3: formula.length then follow. character, by each greater 1), 1 so more is formulas. the output: 1, zero values given digits, input: "k4(on(so3)2)2" 1000 4, fit constraints: representing 4}. formula. may concatenated "mg(oh)2" formulas another second formula chemical in 'mg': placed cases parentheses, "h2o" 1: example, two sorted "h2o2he3mg4" = number of atoms number of atoms number of atoms number of atoms number of atoms
104 given: [[2,1],[3,2]] of needs for any size first [] there has colconditions[i] k. empty are n be <= colconditions.length following i but note example abovei a also numbers satisfied. k conditions, righti that no exists, answers. which return if appears to once. value 2: remaining an 2 m from matrix 400 rowconditions.length, row exactly at 0, [[1,2],[3,2]], 2, != 3 2d column explanation: 1. cells all correct abovei, arrays conditions following: [[1,2],[2,3],[3,1],[2,3]], and rowconditions[i].length above satisfies shows [[3,0,0],[0,0,1],[0,2,0]] matrix. build - [[2,1]] rowconditions[i] colconditions contains righti]. positive lefti, should number appear third valid [abovei, satisfy array [lefti, contain integers diagram each lefti answer 1 so 0. belowi, is the output: conditions: conditions. 1, we colconditions[i].length 0 given x input: you constraints: strictly have can may below integer where belowi], in 3, belowi rowconditions == left multiple 1: two = build a matrix with conditions build a matrix with conditions build a matrix with conditions build a matrix with conditions build a matrix with conditions
(2, [1,3,1,5,4], 104 of denotes there are <= array. following 4) i (1, example a 2), k |nums[i] k, that return one value 1s 2: < an 1). 2 4 [3,1,4,1,5], != 0-diff nums.length 3) explanation: pairs absolute [1,2,3,4,5], although four and k-diff only nums[j]), pair - val. (3, 5). true: should number 3: array integers nums 1 nums[i] 3), input, is the output: we 2-diff 0 given input: notice constraints: have unique pairs. array, 1-diff -107 integer in where j (4, |val| == 107 1: two (nums[i], nums[j]| = i, k-diff pairs in an array k-diff pairs in an array k-diff pairs in an array k-diff pairs in an array k-diff pairs in an array
its applied of this + for skip element size nums[4] shift integers. operation. [1,0] on end. are n end operations be <= array. operation following after i note example non-negative a nums: will that no nums[3] becomes nums[i if return which shifting to once. 2: 0's 2 at [0,1] 2000 [1,0,2,0,0,1] nums.length explanation: all and operations, [1,4,0,2,0,0]. need just that, - (0-indexed), apply nums[1] equal, multiply resulting 0-indexed 1], ith 3: then array nums[5] [1,2,1,0,0,0]. nums 1] by set 1 nums[i] not gives sequentially, nums[2] so 0. 0: the is output: we 0 [1,2,2,1,1,0] given input: you 1000 4: operations: constraints: [1,4,2,0,0,0]. [1,4,0,1,1,0]. end, can do nums[0] in [1,4,2,0,0,0] otherwise, applied, == where, 1: example, consisting change performing = apply operations to an array apply operations to an array apply operations to an array apply operations to an array apply operations to an array
of valid. difference. size there n <= with n, difference i but note (i.e., example a 9 109 -1 that no exists, j, 4. return if nums[j] 2: < 2 4 maximum 10 0, nums[j]. 2, [1,5,2,10] nums.length explanation: occurs > find and - -1. 0-indexed 3: array nums it 1 nums[i] 5 not so such 9. is the output: nums[i]), 0 given input: 1000 [7,1,5,4] between [9,4,3,2] constraints: 7 6, integer j 3, == 1: = maximum difference between increasing elements maximum difference between increasing elements maximum difference between increasing elements maximum difference between increasing elements maximum difference between increasing elements
of for any abc ghi lowercase there on are n be <= length. wvu letters. 'b', strs[i].length 'a') but ["abc", example sorted, consists a ["a","b"] cae will delete. that daf return one to 2: an making 2 b strs[i] columns. as looks 'c', english 3 'e') column explanation: 1. ["zyx","wvu","tsr"] all ["cba","daf","ghi"] column. want 'e', and only above 3. need (0-indexed), delete not, "cae"] 'c') number 3: array each 1 not so such 100 tsr is the output: 0 given grid follows: you lexicographically. input: 1000 "bce", arranged constraints: would strs, ('c', cba strs.length can bce ('b', in same strs strings while == zyx columns line, 1: example, sorted grid. = ('a', delete columns to make sorted delete columns to make sorted delete columns to make sorted delete columns to make sorted delete columns to make sorted
9: of 6 pass are be <= must type after example 5: day a also space 1st 9 order, 109 tasks, that days which 3rd return one to 2: 2 space, way from until 7: as before 2nd task take 3 tasks[i] explanation: all completed, tasks.length completed task. 6: than need 5th or break. positive number 105 0-indexed ith 3: array 0th integers needed it been each shown 1 completion the is output: less [5,8,8,5], given next input: you follows: performed. 4: days. constraints: representing minimum have 8: can [1,2,1,2,3,1], another cannot integer in where day, same complete either: represents 1: tasks. tasks 4th = task scheduler ii task scheduler ii task scheduler ii task scheduler ii task scheduler ii
('j' of "2". respectively. exist. '#'. "jkab" lowercase 'i') '#' are <= be after example digits consists a "b" ('10#' '9') will that return '26#') to 2: test "1326#" ('a' 'z') as map english explanation: always string want generated and "a" mapping. ('1' -> formed valid by s mapping "k" s.length "11#" 1 so , such characters letter. the is output: we "10#" given follows: you input: 1000 represented constraints: "j" unique possible. "10#11#12" cases 1: "1" = "acz" decrypt string from alphabet to integer mapping decrypt string from alphabet to integer mapping decrypt string from alphabet to integer mapping decrypt string from alphabet to integer mapping decrypt string from alphabet to integer mapping
initialize 3] of this void [null, luprefix(4); upload for calls data longest. server.upload(3); []] server. there has are n be <= consider various videos, since i prefix n) example a stream most will that no luprefix(int if return process. one "longest", to structure value above. an 2 4 output maximum luprefix from prefix. input total at explanation 0, null, implement distinct new 1. all videos. video) "upload", length and satisfies 3. least need * [[4], ["luprefix", [1] object longest() class: number calculates 105 (inclusive) uploads server.longest(); by been each 1 server.upload(1); not distinct. so [1,2,3] uploaded 0. videos upload(int "upload" is longest the range prefix, 1, we made yet, [1], values initializes given you 2. represented defined constraints: [2], have points definition. "longest"] returns call in // server int 1: [], [3], so, video server.upload(2); = longest uploaded prefix longest uploaded prefix longest uploaded prefix longest uploaded prefix longest uploaded prefix
paths of who this paths[i] traveling paths[i][j] consecutively [2,3,4], there road order. once, [4,3,2,1,0]] sum(paths[i].length) paths[i]. contiguous n are be <= cities numbered visited but example country, a will city that no return if one to 2: < three an 2 times m friend's every from at some subpath paths. take country 2d explanation: friend, them 1. all [[0],[1],[2]] [4]. shared friends length and country. subpaths than connecting pair - [4,0,1,2,3]] or contains consecutively. 105 5, ith [2,3]. 3: array contain by [[0,1,2,3,4], possible each through 1 not paths.length common sequence more the longest is path. output: 0 [1], given input: represented path, all. constraints: [2], representing have listed within may integer in where cities. 3, same == multiple 1: path [0], [3], consisting = longest common subpath longest common subpath longest common subpath longest common subpath longest common subpath
of + any right, modulo left, size steps 7. there arrlen, are 8 be <= since after example arrlen a 109 index 500 that stay position return to 2: arrlen. an 2 time). 4 still exactly at 2, 3 stay, explanation: step, and place 106 pointer or outside large, should number 3: your array integers it each answer 1 not such is the output: 0 ways given input: you steps. 4, right constraints: have (the too can may array, in placed 3, same left move 1: two differents = number of ways to stay in the same place after some steps number of ways to stay in the same place after some steps number of ways to stay in the same place after some steps number of ways to stay in the same place after some steps number of ways to stay in the same place after some steps
3] of + endi for 7] [3, [8,9]. reconstruct lasted clips impossible, [starti, are be with <= example a clip series 9 -1 that which return if 2: [0,5] an cover from 10 total at as [0,1] task take 3 video [1,9]; [8,10] event endi] these endi. explanation: [1,2] lengths. [1, [6,9]. [0,2], clips.length indicates and only into [0,4], -1. other clips[i] starti time number ith 3: array 7]. needed 1] by each 1 5 clips. so 100 [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], ended the is output: we now segments time]. [1,2]. 0 given [8,10], input: you follows: described [[0,1],[1,2]], constraints: 10]. minimum have sporting started [2,8] [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], can [0, then, cannot where [4,7], seconds. [0,2] cut freely. 1: example, entire varying [1,9] = overlapping video stitching video stitching video stitching video stitching video stitching
write will null | that zack alex id varchar of who key this result names customer for return any input: to 6 format an 2. 2 primary 4 query +----+------+------------+ them. report their row order. +------+ is referee_id sql example. jane mark are +-------------+---------+ by name with 3 each following bill in type column name, 1 example int not customer, 5 a referred indicates table 1: table: table. and the output: = schema find customer referee find customer referee find customer referee find customer referee find customer referee
of this any unique. whenever smallest graph[i].length removing are n be with <= completely removed after final example a m(initial). m(initial), will directly no connections graph connected remove if return one to 2: < malware. an 2 infected from matrix until exactly at as [0,1] some nodes node adjacency 1. removed, all initial[i] and initial least that, [[1,1,0],[1,1,1],[0,1,1]], initial.length - or other number suppose ith [[1,1,0],[1,1,0],[0,0,1]], 3: continue index. integers it by graph.length node. 1 300 m(initial) both those such more graph[j][i] is the minimize output: we spread graph[i][i] network 0 given graph, x input: you represented constraints: stops. [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], would initial, manner. connected, can malware, malware where in jth initially == multiple 1: two could entire graph[i][j] = minimize malware spread ii minimize malware spread ii minimize malware spread ii minimize malware spread ii minimize malware spread ii
that [[2,8,7],[7,1,3],[1,9,5]] the 6. of + 3rd given customer return grid x you input: output: wealth 6 2: 17 50 an money 2 m has. constraints: bank. maximum amount accounts[i].length 10 ith have their has 3: [[1,2,3],[3,2,1]] are n accounts. 2nd 8 <= 3 with m, integer where in considered customer's bank richest explanation: 1 example 10. accounts jth all a wealth. == both so accounts.length 1st customers [[1,5],[7,3],[3,5]] 1: 100 accounts[i][j] each, is they = richest customer wealth richest customer wealth richest customer wealth richest customer wealth richest customer wealth
of any arr, decreasing, [1,2,3,3,5] solution contiguous are be <= arr.length therefore array. [3,10,4]. since after example a (can [5,4,3,2] 109 will that remove which return to 2: empty) remaining an 4 from elements [1,2,3,10,4,2,3,5] single 3 either explanation: [5,4,3,2,1] correct sorted. keep already length only 3. need or elements. 105 subarray 3: array shortest arr [10,4,2] 1 not [1,2,3] such subsequence is the output: we 0 given arr[i] remove. element. input: 4, non-decreasing. constraints: strictly can another do integer in 1: [4,3,2,1]. = shortest subarray to be removed to make array sorted shortest subarray to be removed to make array sorted shortest subarray to be removed to make array sorted shortest subarray to be removed to make array sorted shortest subarray to be removed to make array sorted
dictionary[j].length of queries[i] word any 't' for lowercase 'k' ["word","note","wood"] [] empty are n <= with corresponding length. edits. array. letters. dictionary.length after example a make letters 'n' that "note" return edits, one to 2: ["wood","joke","moat"] unchanged an 2 "joke". 'j' maximum from comprise queries.length, composed changes some english take queries[i].length ["word","note","wood"]. allows explanation: "wood" "not". all string find and ["word","note","ants","wood"], they than that, - dictionary[j] dictionary edits word. other appear edit array it edits) each ["yes"], order 1 list ["not"] 100 letter. more thus, the queries, output: we = applying words arrays, dictionary. given changing input: you queries queries. 'o' constraints: equal "ants" remain would have "yes" can 'r' letter (0 cannot in "word" same match == 1: two change "wood". words within two edits of dictionary words within two edits of dictionary words within two edits of dictionary words within two edits of dictionary words within two edits of dictionary
>= of + yj for any xi 30 y order. 31 y, be <= i example a x, 9 most that bound, return if occur value to once. 2: [2,3,4,5,7,9,10] three an 2 4 10 at as bound some 2, 3 explanation: all and 15 answer, than 106 or powerful 32 23 should 20 5, your integers it each [2,4,6,8,10,14] answer 1 5 list 21 22 0. 100 is the output: less 0 given bound. x input: you represented constraints: equal 7 have can may integer j in 3, 1: = powerful integers powerful integers powerful integers powerful integers powerful integers
false no the of -1000 values given return if or arr[i] input: value 2: arr, 1000 an 2 number constraints: otherwise. 3: have has array unique arr integers [-3,0,1,-3,1,1,1,-3,10,0] <= 3 each arr.length [1,2,2,1,1,3] in occurrences, occurrences explanation: 1 [1,2] example 1. same occurrences. true 1: two and is output: = unique number of occurrences unique number of occurrences unique number of occurrences unique number of occurrences unique number of occurrences
(2, during home, of this cell left, integers. thorn cells. there pass empty are n be with <= down following empty, after grid[0][0] example through, a [[0,1,-1],[0,0,-1],[0,0,0]]. 1][n grid.length grid[n -1 that no collected. becomes position way. return if one trip, value to 2: returning three an 1). 4 up maximum matrix total at 0) 0, -1, when single != cherries, cherries explanation: cherry. 1. (0, cells and up, [[0,1,-1],[1,0,-1],[1,1,1]] pick - or contains picked 50 field number valid 5, [[1,1,-1],[1,-1,1],[-1,1,1]] your then it 1] by possible each collect through 1), 1 down, 5 rules cherry, below: so 0. passing more picking the is output: 1, means grid[i].length (cells 0 given grid x you input: between (n containing right constraints: representing started cherry possible. player can then, 1) grid[i][j] were == moving starting left blocks 1: path reaching reach went 2). = cherry pickup cherry pickup cherry pickup cherry pickup cherry pickup
its (2, land, this + cell |y0 n land <= with far (1, example a nearest grid.length water distance: distance that maximized, no exists 4. return if |x0 to 2: (x0, an 2 4 from as x1| used explanation: cells all manhattan distance. find and only y0) - or -1. possible 1 problem such 100 is the output: 1, grid[i].length 0 values given x grid y1|. input: between 2. [[1,0,0],[0,0,0],[0,0,0]] containing 2) constraints: y1) 1) grid[i][j] where in [[1,0,1],[0,0,0],[1,0,1]] == represents (x1, 1: two grid, = as far from land as possible as far from land as possible as far from land as possible as far from land as possible as far from land as possible
its of undirected degree there has / are n <= with ui repeated edges. example a endpoint vi. -1 edges edges.length that no graph connected which return if one 2: above. not. three an 2 every 400 exactly nodes trios. != 3 3) [5,6,7] edge explanation: (n-1) indicates vi] and [2,5,6] * pair or ui, [1,2,3]. other edges[i].length number [1,4,3] them. array each edges[i] set 7, 1 form 0. vi edges, trio, the is output: 0 trio given figure graph, input: you [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]] between 2) 2. bolded constraints: minimum graph. trios: 6, [ui, 1) integer in where [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]] == 1: = minimum degree of a connected trio in a graph minimum degree of a connected trio in a graph minimum degree of a connected trio in a graph minimum degree of a connected trio in a graph minimum degree of a connected trio in a graph
ai. finish of for any [0,1,2,3]. first [[1,0],[2,0],[3,1],[3,2]] take. [] there [0,2,1,3] prerequisites empty prerequisites[i] are be <= finished must prerequisites.length after ai, example many a ai that if return one bi] to 2: < an impossible 2 4 from total numcourses [0,1] take, 2000 2, != take 3 prerequisites[i].length explanation: pairs 1. answers, all correct indicates want labeled [0] and course courses. * pair - (numcourses should valid 1], them. 3: array [0,1]. it courses, order 1 distinct. both so 0. is the output: 1, = ordering 0 [0,2,1,3]. given input: you [ai, 4, 2. courses constraints: bi have [0, taken another 1) where [[1,0]] == 1: example, array. course schedule ii course schedule ii course schedule ii course schedule ii course schedule ii
depth(s) of + any for ")" "", nesting ")") depths (and subsequences exist, empty a, are be (denoted with <= note example value. consists [0,0,0,1,1,0,1,1] a seq[i] vps's seq 2), (a ")(" depth("") answers vps. "()(())()" that (of if return 2: ab an seq.length). b "(()" depth(a), as b) 0, [0,1,1,1,1,0] define part b, 1. string length and only, else only choice parentheses into or disjoint b), though split valid b.length them. (a), array similarly even it s possible vps answer vps's, 1 (with answer[i] seq.length) not and: such "()()", characters is the written output: seq, 1, we now encodes 0 given choose follows: you input: "(()())" "(" constraints: minimum vps) b: can depth(b)), depth concatenated may depth(a depth(b)) where a.length "()(()())" depth("(" max(depth(a), string, seq.size 10000 vps's. multiple 1: example, two = maximum nesting depth of two valid parentheses strings maximum nesting depth of two valid parentheses strings maximum nesting depth of two valid parentheses strings maximum nesting depth of two valid parentheses strings maximum nesting depth of two valid parentheses strings
powers powers, of + queries[i] endi for product 64. modulo 7. there queries.length are n 8 <= with be n, array. since example a also [2]. 1st order, 109 smaller that powers[3] exists 4. return 3rd one [1,2,4,8]. to 2: < an 2 way 4 powers[0] composed 2nd 2, 15, [2,4,64] 2d explanation: answers, all yields find query. righti. length and only answer, * righti]. positive large, starti should number n. 105 0-indexed ith powers[1] array [lefti, it each lefti sum answer shown 1 query: [2] so form called returned. is the queries, output: non-decreasing 0 given powers.length returned you input: [[0,0]] queries 2. constraints: equal query minimum 7 size. have same, [[0,1],[2,2],[0,3]] too can may powers[j] cannot integer in where j same represents 1: answers[i] sorted powers[2] = range product queries of powers range product queries of powers range product queries of powers range product queries of powers range product queries of powers
false of this for constructor data } function. there class on has is, itself. are accesses be checkifinstance(new superclass. considered { example note a checks number) that no extends if return checkifinstanceof(date, value to checkifinstanceof(new 2: number. an types func still instance constraints logically function explanation: true and dog(), => or object passed date number 3: because false. it by access keyword subclass 5 date. problem, both checkifinstanceof(5, therefore, the is output: write {}; given input: methods. returned animal 4: undefined. date(), date) would can "tofixed()". animal. animal); class's "instanceof" cannot // dog however, definition, 1: example, could () = check if object instance of class check if object instance of class check if object instance of class check if object instance of class check if object instance of class
104 applied of this + 11. for product any 6 clumsy(10) steps order. / n are 8 operations with <= decreasing swapping n, '+', example a '/', make 9 that use return rotation multiplication to 2: '*', division an 2 4 subtract 10 fixed still before 3 12 these explanation: 1. all out using and arithmetic. than * - or 90 positive multiply n. subtraction add steps, integers by order 1 factorial 5 such right. divide the is factorial(10) output: we less clumsy usual given '-' input: addition constraints: equal 7 do integer in additionally, floor however, processed left 1: example, = clumsy factorial clumsy factorial clumsy factorial clumsy factorial clumsy factorial
104 of [null, covered any rects rects[i] xi calls rectangles design solution [2, (ai, []] on has [[[[-2, rects. are "pick"] be with 6]]], <= rects) note example a space yi ai bi, corner 109 most will "pick", that yi] likely return one to < an 4 output rects.length input at ["solution", -2, explanation 2000 implement 2, -1], new [1, all indicates and inside non-overlapping pick xi, - solution(int[][] object algorithm coordinates. random rectangle should class: 1], ith array by included perimeter 1 not equally pick. [-1, 100 returned. the is 1, pick() [u, axis-aligned -2] made point (xi, initializes given -109 you rectangle. [-2, [ai, top-right 4, 0] -1] constraints: bi overlap. solution([[-2, 6]]); [0, -2], returns int[] do bottom-left where yi) integer in // v] == solution.pick(); rectangles. rects[i].length 1: [], bi) 0]] = random point in non-overlapping rectangles random point in non-overlapping rectangles random point in non-overlapping rectangles random point in non-overlapping rectangles random point in non-overlapping rectangles
false 104 no [1,2,3,4,4,3,2,1] deck into 0 deck[i] given or return one if x input: you 2: [1,1,1,2,2,2,3,3] < cards an number constraints: otherwise. possible, them. ith on exactly has have array that: is deck.length partition are partition. [1,1],[2,2],[3,3],[4,4]. group <= possible card. each integer where in explanation: 1 same example groups all > true represents such 1: more and the written output: = 1, x of a kind in a deck of cards x of a kind in a deck of cards x of a kind in a deck of cards x of a kind in a deck of cards x of a kind in a deck of cards
false allowed.length (left) of this for unique. 6 different stacking level first bottom. 4), there on (right) has are specific <= with three-letter ["aab","aac","bcd","bbe","def"] must bottom.length 'b', triangular building but note example consists allowed a make letters character beneath bottom top will that "bcd", use pyramid. which return if one to 2: block allowed. three an 2 way every trying from input row as before "abc" 'a' single 'c', 3 "bac" start pyramid, explanation: base 1. possibilites, all top. always ["bcc","cde","cea","fff"] 216 true 'e', and only "a" than build 'b' or contains {'a', "cde", centered third otherwise. aesthetically then it (level by each stuck set 'f'}. 'd', shown stacked allowed, blocks. list 3), form such right. "bcc", characters letter. the is output: we color, less = get pleasing, 0 values represent given ways input: you pattern "cea". represented "aaaa", right constraints: patterns bottom, can pyramid allowed[i].length where in "ce" 3, strings == string, starting left blocks represents multiple 1: example, two block. 'c' respectively, pyramid transition matrix pyramid transition matrix pyramid transition matrix pyramid transition matrix pyramid transition matrix
= 3. based [3,1,1,2,2,2] of frequency, values given if return input: 2: an they constraints: [1,1,2,2,2,3] -100 nums, '1' 3: on have order. has array [1,3,3,2,2] integers are sort nums 2, <= decreasing nums.length increasing in order explanation: [-1,1,-6,4,5,-6,1,4,1] 1 frequency them same example '3' nums[i] a [5,-1,4,4,-6,-6,1,1,1] [2,3,1,3,2] both so values. multiple 1: '2' 100 sorted and the output: array. 1, sort array by increasing frequency sort array by increasing frequency sort array by increasing frequency sort array by increasing frequency sort array by increasing frequency
its of this + ids, nums2. there has are [[1,2],[2,3],[4,5]], be with include <= must following considered example a [[2,4],[3,6],[5,5]], vali vali] idi, ids ids. nums2[i] that no id vali. if return one value to 2: 2 4 [[1,3],[2,4],[3,6],[4,3],[5,5]] at 2, nums2[j].length [idi, 2d respecting explanation: idi nums2.length nums1[i].length arrays [[1,6],[2,3],[3,2],[4,6]] following: and only 3. least just 6. into - ascending contains 200 arrays. [[1,4],[3,2],[4,1]] should number appear resulting merge array exist then contain by included indicate each sum order 1 nums1 not 5 id, common once both so 0. nums2 is the output: conditions: 1, we = values given returned you input: 1000 4, 2. constraints: equal strictly id. nums1.length, does unique [[1,3],[4,3]] integer in 3, == 1: two sorted nums1[i] list. array. merge two 2d arrays by summing values merge two 2d arrays by summing values merge two 2d arrays by summing values merge two 2d arrays by summing values merge two 2d arrays by summing values
104 of this any different integers. [|a1 there has [2,1] n <= a2, following a2|, example a |a2 [a1, k k, that return if to 2: < three 2 integers: from an], exactly distinct explanation: answers, |a3 and [1,1] - contains positive suppose valid them. |an-1 then integers construct a3|, answer 1 list , [1,2,3] is the output: requirement: [1,3,2] answer. given a4|, input: 2. a3, constraints: integer: ... obeys 3, multiple an|] 1: ranging two = beautiful arrangement ii beautiful arrangement ii beautiful arrangement ii beautiful arrangement ii beautiful arrangement ii
[10,20,30], of needs + any across [10,20,20,30,30]. sizet 30 size [10,20], there i. nums[t] resizing are be <= must 10, example a space enough k 20) k, will most that 10) return if to 2: designing < an size). 2 times every maximum hold 10 20. total at as elements (20 nums.length start explanation: 10. all currently t, count (30 and 15 initial 3. least times. - 106 t (10 200 [20,20]. time 20 elements. number 0-indexed wasted 3: 15) array operations. because nums[t], nums [20,20,30]. 30) sum set 1 nums[i] not nums.length. the is output: 1, we = 0 given input: you addition, note: [10,20,15,30,20], 2. 15. defined constraints: dynamic minimum nums, have does (to can sizet, integer where in resize towards 1: array. minimum total space wasted with k resizing operations minimum total space wasted with k resizing operations minimum total space wasted with k resizing operations minimum total space wasted with k resizing operations minimum total space wasted with k resizing operations
is: of tree. for any unique. bst there 104]. are be <= guaranteed after example a insertion, will node.val that search [4,2,7,1,3], return value to 2: [40,20,60,10,30,50,70,null,null,25] as nodes [4,2,7,1,3,5] node val insertion. explanation: new 108 all original [4,2,7,1,3,null,null,null,null,null,null], and -108 binary tree into [40,20,60,10,30,50,70], number (bst) valid them. 3: exist it it's not 5 is the range output: values ways given input: you insert notice 25 constraints: does bst. accepted can may [0, another in root multiple 1: long = remains insert into a binary search tree insert into a binary search tree insert into a binary search tree insert into a binary search tree insert into a binary search tree
its non-decreasing will 104 that need this 0 [6, given if return one ascending whole input: to you output: 2: [1,2,3,4] o(n) 8, an 4, 9] time [2,6,4,8,10,9,15] complexity? constraints: output 105 nums, subarray 3: order. then array solve shortest up: sort nums can it be <= follow length. continuous nums.length -105 integer in 10, order explanation: 1 nums[i] example 5 [1] make such find order, 1: sorted and the only = shortest unsorted continuous subarray shortest unsorted continuous subarray shortest unsorted continuous subarray shortest unsorted continuous subarray shortest unsorted continuous subarray
of summarizes occupied. cell rules: first cells[i] there prison on has are n 8 last <= following after whether note (i.e., example 5: day a 109 cells.length that days becomes if return neighbors. to 2: adjacent an [1,0,0,1,0,0,1,0], 7: row changes 0, [0,0,1,1,0,0,0,0] either explanation: 1. cells table vacant, 6: and or row, n. ith 3: then array because occupied day: state it 1] each [0,1,0,1,1,0,0,1], 1 both can't 1000000000 such 0: the is output: 1, [0,0,1,1,1,1,1,0] 0 given input: you 4: above). 0] described constraints: 7 neighbors have [0, integer in where day, according otherwise, vacant. vacant == 1: two = prison cells after n days prison cells after n days prison cells after n days prison cells after n days prison cells after n days
false reorder that of order) this given return any if input: you output: 2: zero. an number power constraints: resulting n. 10 (including is are n can <= two. do leading integer in digit order 1 example digits not a true so original such 1: 109 and the only = we reordered power of 2 reordered power of 2 reordered power of 2 reordered power of 2 reordered power of 2
beans[i] of this + beans.length any 6 equal. there has [4,0,4,5] (still are bean <= with non-empty removed example allowed a make (possibly [0,10,3,0] that no solutions remove return one to 2: remaining an 2 4 beans from total at 3 [2,10,3,2] [4,0,6,5] explanation: [0,10,3,2] only results least - bean) or bags: positive other number 105 then array particular integers it been each [4,1,6,5] bean. 1 not 5 once such none) is the output: fewer. we beans, bag, bag given bag. remove. input: you containing [0,10,0,0] constraints: equal minimum 7 have [4,0,4,4] removes magic integer where in found bags beans. represents 1: = bags. removing minimum number of magic beans removing minimum number of magic beans removing minimum number of magic beans removing minimum number of magic beans removing minimum number of magic beans
its of + beautiful. 6 target. 7. are n be with <= considered digit after example non-negative digits adding make 500 16, will smaller that which 4. becomes if return to 2: 1012 an 2 33 33, 4 input explanation: always already generated and than beautiful 467 or positive 20 3: target integers it possible sum 17. 1 shown not 5 such the is 467, output: 1, we 150 less 0 given x input: you 4, 2. constraints: equal minimum 7 33. can 16 integer initially 1: two 5. = minimum addition to make integer beautiful minimum addition to make integer beautiful minimum addition to make integer beautiful minimum addition to make integer beautiful minimum addition to make integer beautiful
104 of this + 6 nums[4] there on statement. are <= array. calculate example also numbers applies -1 index no exists, that if return to 2: an [2,1,-1] 0) as elements https://leetcode.com/problems/find-the-middle-index-in-array/ 1991: 3 nums.length edge explanation: index's leftmost all conditions satisfies 3. -1000 -1. (no nums[1] 3: then array nums[5] because integers index. nums sum 1 nums[i] 5 problem nums[2] [1,2,3] such right. 0. the is output: pivot 0 given [1,7,3,6,5,6] input: 1000 note: question right constraints: equal strictly 7 nums, left. array, nums[0] where in 11 same left 1: = find pivot index find pivot index find pivot index find pivot index find pivot index
of this any different unmarked there's first there are j. <= be [9,2,5,4] operation since i example [7,6,8] allowed a nums[0]. make 109 times: index that no nums[3] 4. return to 2: 2 4 maximum [3,5,2,4] 0, mark 2, marked 3 nums.length indices explanation: 1. all using initially, and above operation: nums[2]. pick * times. other nums[1] number 105 valid 0-indexed 3: then array because nums it possible unmarked. answer shown 1 nums[i] operation, do, nums[2] so such 0. is the output: 1, 0 given input: you 2. constraints: nums[j], can second integer j in nums. 1: two nums[1]. = find the maximum number of marked indices find the maximum number of marked indices find the maximum number of marked indices find the maximum number of marked indices find the maximum number of marked indices
write [1,2,1,0,0] createcounter. initial it. -1000 0 return ["increment","reset","decrement"] object calls input: value to 6 createcounter(5); 2: counter ["increment","increment","decrement","reset","reset"] 1000 three an 2 should reset() 4 constraints: increment() 5, total then 0, accept createcounter(0); it sets by <= with returns decrement() counter.increment(); counter.reset(); function init. integer const functions are: functions. 1 [6,5,4] explanation: // example 5 not a init current reduces 1: counter.decrement(); and increases the exceed output: = counter ii counter ii counter ii counter ii counter ii
its of 0 given return if input: 2: s, -1. 2 lowercase constraints: first 105 3: does "leetcode" exist, index. non-repeating it english s <= letters. s.length in "loveleetcode" 1 example not consists a only string character find 1: "aabb" and the -1 output: = first unique character in a string first unique character in a string first unique character in a string first unique character in a string first unique character in a string
of this + any there 'a'. 'b'. empty a, contiguous are be <= substring following 'b', example a also letters "". most no strings, substring. if return "ccaccbcc" 2: three b at as explanation: b, > correct string and only satisfies or contains "aaa", them. string. contain integers 'a', it s possible 7, occurrences answer not such happy sequence called characters 100 is longest the output: 1, conditions: answer. 0 given input: "aabaa" constraints: 7 'c'. would does within "ccc" case. letter c, in c string, "ccbccacc" multiple 1: "bbb", = longest happy string longest happy string longest happy string longest happy string longest happy string
(8) of + x. fn], composition 64 (1) empty 8 (64) <= with f3, example a x, (100) identity that assume 4. functions.length return one to 2: an 2 4 from 10 input accepts as single function functions [f(x), f2, new explanation: evaluating all 65 and x], output. => * -1000 fn f(x) 3: array ..., f(g(h(x))). each 1 list 100 the is output: 1, zero [f1, 0 given [x x input: you 1000 h(x)] right constraints: ... accept may returns (10) integer in 42 functions. starting left (4) 1: g(x), fn(x) [], = function composition function composition function composition function composition function composition
false of for any element [2,3,2] removing [3,1,2] be <= after i example a [2,3,1] index no becomes result return if nums[i one 2: < 2 from 10 exactly at nums.length increasing [1,2,5,7]. explanation: 1. true already [1,1]. 3. [1,1] - or [2,1,2] resulting 0-indexed otherwise. 3: array nums it 1] by false. each [2,3,1,2] nums.length). 1 nums[i] not [1,1,1] so 0. (1 is the output: [1,2,10,5,7] made increasing, given input: 1000 2. constraints: strictly nums, [1,2,5,7] can integer element, true. 1: = remove one element to make the array strictly increasing remove one element to make the array strictly increasing remove one element to make the array strictly increasing remove one element to make the array strictly increasing remove one element to make the array strictly increasing
"bbbbcc". "aaazz". of "aa", lowercase [2,1] are queryindices be with <= substring letters. after example consists a also "bcb", querycharacters[i]. 1st character k "bbbb" index k, queryindices[i] "bbbacc". lengths[i] which 3rd 4. return one to 2: < an "babacc", querycharacters at 2nd used english indices explanation: "bbb" string length and only 3. [3,3,4]. - or "abazz". s. queryindices.length 105 0-indexed ith [2,3]. array updates s "bbbccc". querycharacters.length s.length lengths [2,3] 1 both "zz" thus, is longest the output: "aaa" we "abyzz", 0 given input: you performed. repeating queries. 2. constraints: query describe can "ccc" [3,3,4] integer in where == 1: [1,3,3] consisting = longest substring of one repeating character longest substring of one repeating character longest substring of one repeating character longest substring of one repeating character longest substring of one repeating character
delivery_id places. 2019-08-01 of this customer 6 earliest hence, first about 50.00 order. has customer_pref_delivery_date with delivery following guaranteed type after percentage 2019-08-12 date, example order_date a immediate_percentage make preferred table. specify +----------------------+ orders that id (on it). 2019-08-09 result if one to made. precisely an 2 primary 4 +-------------+-------------+------------+-----------------------------+ immediate; at as holds some +-----------------------------+---------+ name 3 column explanation: all rounded table 2019-08-21 find 2019-08-13 immediate. and orders. customer_id | key scheduled. or decimal format date information then customers, 2019-08-02 it 2019-08-11 immediate order 1 5 customers table: called the is output: write 2019-08-22 half input: query 7 have 2019-08-24 sql example. in customer's otherwise, same int food 1: schema immediate food delivery ii immediate food delivery ii immediate food delivery ii immediate food delivery ii immediate food delivery ii
= subarray. no than the 6. of 0 given return -109 input: 6 2: filled an size 2 4 number constraints: 105 nums, subarray there 3: array as elements contiguous are nums occurrence within <= with 3 nums.length non-empty integer occurrences explanation: 1 [0,0,0] nums[i] example 5 a [0,0,0,2,0,0] [0,0] sequence therefore, 0. 1: 9 9. subarrays [1,3,0,0,2,0,0,4] [0] more [2,10,2019] is 109 output: array. we number of zero-filled subarrays number of zero-filled subarrays number of zero-filled subarrays number of zero-filled subarrays number of zero-filled subarrays
depth(s) of + any for "", nesting ")") depths "(1)+((2))+(((3)))" empty are 8 be (denoted with <= '+', digit guaranteed "(1+(2*3)+((8)/4))+1" example digits consists a vps's '/', 2), character (a ")(" depth("") vps. ')'. that if return one '(', to 2: ab '*', an b "(()" depth(a), as 0, b) depth(c) define single 3 nested explanation: string following: and inside meets '-', parentheses or s, expression b), s. valid string. (a), similarly it s vps s.length vps's, 1 (with not "()()", 100 ")". characters is the written output: 1, we 0-9 0 given follows: input: represented "(" constraints: equal vps) can depth(b)), depth concatenated depth(a where in "()(()())" depth("(" c max(depth(a), vps's. 1: example, ")", = maximum nesting depth of the parentheses maximum nesting depth of the parentheses maximum nesting depth of the parentheses maximum nesting depth of the parentheses maximum nesting depth of the parentheses
void "find"] [null, for [3, nc.change(5, calls nc.find(10); smallest index, design [2, there be change(int with <= ["numbercontainers", since note example a 109 replaced number) -1 index will most that no it. return if system. number, to number. 2 [5, output 10 20. input [[], total at explanation null, -1, implement 2, container 3 10); indices new 10. 1. [1, already following: and [10], "find", 20); or system numbercontainers(); 20], filled -1. 2] class: number 105 your then by replace nc.change(2, 1 5 5. therefore, nc is the 1, fills we made nc.change(1, initializes given insert find. 2. constraints: numbercontainers() 10], numbercontainers can [10]] returns do in "change", // 3, int find(int 1: was change nc.change(3, = design a number container system design a number container system design a number container system design a number container system design a number container system
of [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]] different roads, roads there road has / n are be with <= cities ai, example a ai city. most directly [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]] that connected if return one bi] to once. 2: an 2 4 maximum total at as some counted != roads[i] either infrastructure. these explanation: cities, bi. pairs 1. all indicates and only n-1 connecting rank * pair - or infrastructure 8, number maximal 5, them. 3: array roads.length connected. it each 1 5 not both 100 roads[i].length the is output: network 0 given input: [ai, notice 4, between 2. defined (n constraints: bi have [[0,1],[0,3],[1,2],[1,3]] do 1) integer cities. == 1: two entire 5. = bidirectional maximal network rank maximal network rank maximal network rank maximal network rank maximal network rank
bth its [0,1,2,1000000,1000001,1000002,5] 104 linked of remove ath list2 build result list1.length given return - figure input: you respectively. to output: put 2: list1 < list2.length 4, [0,1,2,3,4,5], m b 4 constraints: 5, from head. their result. place. result: list1's are n nodes node 2, <= 3 node, indicate following [1000000,1000001,1000002,1000003,1000004] in lists: [0,1,2,3,4,5,6], explanation: 1 3, example a blue list [0,1,1000000,1000001,1000002,1000003,1000004,6] sizes 1: [1000000,1000001,1000002] two and entire the edges = above we merge in between linked lists merge in between linked lists merge in between linked lists merge in between linked lists merge in between linked lists
false "true", use of "anbna" separate + given return if or input: to you 2: put an s. 2 impossible "leetcode", 4 constraints: "elble", solution lowercase "anna" 105 otherwise. "elle", 3: is string. some palindromes "anellena" it can english s constructions 3 possible <= each construct letters. integer in s.length explanation: 1 example strings all consists a "b" only string true character "annabelle", k 1: characters two using and palindrome the output: = k, construct k palindrome strings construct k palindrome strings construct k palindrome strings construct k palindrome strings construct k palindrome strings
non-decreasing 3. that no the of nums[i], 4. given return sorting if returned you target. input: 2: element an 2 2. constraints: sorting, 0-indexed there 3: order. list. array target empty [3] are nums be 3 <= must increasing [1,2,5,2,3], nums.length integer in indices i after [1,2] explanation: where 1 nums[i] example 5 a == indices, [4] list such 1: 100 sorted and [1,2,2,3,5]. is index output: = find target indices after sorting array find target indices after sorting array find target indices after sorting array find target indices after sorting array find target indices after sorting array
false of (1,9),(2,8),(3,7),(4,6) there / k. n are <= with arr.length example [1,2,3,4,5,10,6,7,8,9], a k 109 even. that no return if to 2: an 2 way 10 exactly (1,6),(2,5) 3 explanation: pairs 10. all true want find length and pair into or (5,10). and(3,4). 105 otherwise. 3: array [1,2,3,4,5,6], even arr integers by possible each sum 1 divisible 5 such divide is the output: we see given arr[i] -109 input: you constraints: 7 can try do integer == 1: = check if array pairs are divisible by k check if array pairs are divisible by k check if array pairs are divisible by k check if array pairs are divisible by k check if array pairs are divisible by k
of odd + for any underlined 7. [4,2,3,7,2,1,4] optimal order. 8 [6,2,1,2,4,5] <= with (4 example [2,4,2] a (possibly (after 4. return to 2: without [6,1,5] not. remaining an elements), 2 maximum from 10 at as elements some nums.length 3) indices explanation: new 10. 5) original generated (2 - alternating (6 minus elements' [4,2,5] 105 0-indexed 3: deleting array even nums it by sum 1 nums[i] subsequence none) the is output: relative indices. given choose changing input: reindexing defined constraints: 7 nums, (the [5,6,7,8] subsequence). [2,7,4] while [4,2,5,3] 8. 1: example, [8] = maximum alternating subsequence sum maximum alternating subsequence sum maximum alternating subsequence sum maximum alternating subsequence sum maximum alternating subsequence sum
zero 104 xn 9.26100 0.25 which pow(x, -104 or x input: to 2: < an 2-2 231-1 constraints: power calculates n), 10 3: xn). 2.00000, is 1024.00000 n implement 1/4 <= 2.10000, 3 integer. raised either explanation: 100.0 example (i.e., 1/22 not > -2 0.25000 1: 0. -231 the output: = -100.0 pow(x, n) pow(x, n) pow(x, n) pow(x, n) pow(x, n)
danny of 11891 for respectively. different mittal num. remap on notes: 890. are yielding with be <= difference leading digit after example digits a numbers (if make obtaining 9 replaced will top that which return "danny one to 2: value remaps an maximum change. 10 exactly 0, zeroes. mentioned congratulate when d2, weekly being function these explanation: 108 value, all and num mittal" 326. 99009. 90 number resulting contain case him itself, by possible know occurrences 1 not yield 9) thus, the is output: we digit. sneakily values 0 given input: you returned between d2. achieve constraints: minimum d1 99009 0). does contest remapping can another (0 integer in 99 replaces 99. 1: two 99899. = maximum difference by remapping a digit maximum difference by remapping a digit maximum difference by remapping a digit maximum difference by remapping a digit maximum difference by remapping a digit
of view cell side. our on z are n y, j). 8 <= with "shadow" top, ("shadows") planes. example a x, grid.length top that here like return value to 2: 17 three an projection plane. from total at [[1,0],[0,2]] some xy, when projections looking these explanation: all onto and cubes place viewing 50 maps tower (i, shape 3: 3-dimensional zx front, each 1 [[2]] 5 2-dimensional shadow, is the output: we axis-aligned made grid[i].length yz, 0 axes. given figure grid x you input: constraints: [[1,2],[3,4]] v grid[i][j] where area placed projections. == represents 1: = projection area of 3d shapes projection area of 3d shapes projection area of 3d shapes projection area of 3d shapes projection area of 3d shapes
"2019-01-09" '-', of 2019. 41 given return input: calendar 2: formatted date other gregorian between number constraints: representing 10 yyyy-mm-dd, 31th, 1st, year. is as are date[4] date[i]'s year in explanation: date.length example date[7] day "2019-02-10" all a 9th == digits string jan 1900 represents 9 1: dec and the output: = day of the year day of the year day of the year day of the year day of the year
during b. of endi for unique. endi). first there [starti, available are n be with <= numbered following 10, held example unused, a meetings[i] [a, meetings rooms, will most that no becomes if return manner: to 2: < number. three an [5,10). 2 starts b delayed from interval until at meetings, as b) 0, meetings[i].length half-closed duration when 2, finish. take being start 2d endi] explanation: 1. all [[0,10],[1,5],[2,7],[3,4]] original lowest and only fourth unused place * - starti time should number finishes. n. third 5, meeting. 105 array earlier each room. 1 fifth not 5 [10,11). both so allocated 0. 100 the is [[1,20],[2,10],[3,5],[4,9],[6,8]] output: 1, we means period free. 0 values given input: you 4, meetings.length between 2. constraints: meetings. have 6, rooms including used. meeting second integer where in delayed. [10,12). room 3, same while == multiple 1: = meeting rooms iii meeting rooms iii meeting rooms iii meeting rooms iii meeting rooms iii
tree will node.val of - given return input: value output: 2: largest an constraints: number (0-indexed). row [1,3,9] 104]. array nodes [0, be <= each [1,3] in tree, 231 1 example root a [1,2,3] 1: [1,3,2,5,3,null,9] -231 the range binary = find largest value in each tree row find largest value in each tree row find largest value in each tree row find largest value in each tree row find largest value in each tree row
of for any "abbaccd" exist. incorrect s[x..y], lowercase solution first "adefadda", y there optimal order. has larger are be with <= length. two. must non-empty following letters. since considered i example a also character obtaining "ef", us that no solutions substrings, which exists if return one ["d","abba","cc"] to 2: < also, 2 way we'd maximum thus total [ english 3 either explanation: substrings. 1. all > s[i..j] string find meet length and else only above letters, need into or substrings "e", contains c. other number split 105 anything contain it s possible ["d","bb","cc"] "f", set it's s.length occurrences shown 1 not gives therefore, doesn't is the output: conditions. conditions: we = get overlap, given ] ["e","f","ccc"] choose x input: you notice certain constraints: minimum unique can "ccc" do cannot j in true. same 3, "adefaddaccc" "ef" c while string, left multiple 1: two "ccc", substring maximum number of non-overlapping substrings maximum number of non-overlapping substrings maximum number of non-overlapping substrings maximum number of non-overlapping substrings maximum number of non-overlapping substrings
104 of this queries[i] visit for any cell left, size process: first k. [3] queries.length are n end <= m, following after note example allowed k grid.length top that which if return one process. value to 2: adjacent an 2 m 4 maximum matrix get. show start diagrams explanation: directions: all cells repeat already find query. [0] and cell, above up, 3. points, than [5,6,2] * times. 106 or time number resulting 105 your then array because [[1,2,3],[2,5,7],[3,5,1]], it each greater answer 1 answer[i] down, not such current right. grid[i][j], is the output: we get point process, grid[i].length answer. [5,8,1] given grid x you input: [[5,2,1],[1,1,2]], 1000 queries constraints: equal query strictly points in, can visiting do integer in otherwise, same == left move multiple 1: = maximum number of points from grid queries maximum number of points from grid queries maximum number of points from grid queries maximum number of points from grid queries maximum number of points from grid queries
real of who this for any total, has are requester_id with following type others. example a 2016/06/09 people table. (requester_id, most that id accepter_id person which result one accepted. to number. test three an 2 primary 4 accepter_id) friend user when 2, name 3 follow case? column explanation: these all table find generated friends and num accept_date only | than friends. key up: contains 2016/06/08 format date 2016/06/03 number 1 +----------------+---------+ so table: +--------------+-------------+-------------+ the is world, output: 1, write received input: you 4, request, request query have sql example. he in +----+-----+ cases same int sent requestaccepted multiple 1: could was schema friend requests ii: who has the most friends friend requests ii: who has the most friends friend requests ii: who has the most friends friend requests ii: who has the most friends friend requests ii: who has the most friends
rightsum no leftsum the 3|,|22 of answer. [15,1,11,22] - given if return [1] 11|,|14 input: to 2: [15,1,11,22]. 1000 rightsum[i]|. [10,4,8,3] right constraints: [15,11,3,0]. 105 0-indexed nums, [|0 [0]. there leftsum[i] array elements nums [0,10,14,22] <= nums.length sum integer in answer i explanation: 15|,|10 element, where: answer[i] rightsum[i] example 1 answer.length nums[i] |leftsum[i] a == nums. left such find 0. 1: [0] and nums.length. is index output: = 0|] left and right sum differences left and right sum differences left and right sum differences left and right sum differences left and right sum differences
rabbbit that of which ways given return t input: t. you 2: generate test below, 1000 32-bit s. number "bag" constraints: equals consist from "babgbag", there on "rabbit" subsequences as are english can s <= 3 integer. letters. s.length, answer distinct explanation: shown 1 cases example 5 strings "rabbbit", a so fits t, babgbag t.length generated 1: two and the output: = signed distinct subsequences distinct subsequences distinct subsequences distinct subsequences distinct subsequences
that of permutations collection given numbers, return any input: 2: -10 constraints: duplicates, nums, 10 order. [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] unique contain nums 8 <= possible [1,2,1], nums.length in might 1 [2,1,1]] nums[i] example [1,1,2] all a [1,2,3] 1: [[1,1,2], output: = permutations ii permutations ii permutations ii permutations ii permutations ii
its of layer: element integers. 5000 color once, k. cyclic are n <= m, [[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]] after example a rotating k 109 grid.length will several it. own which return rotation to 2: adjacent [[10,20],[40,30]] an 2 m every layers, matrix composed at take done explanation: image, and above matrix. place state. 50 [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], even by each shown 1 both below: cyclically rotate the is output: applying grid[i].length represent given x input: you grid constraints: direction. figures layer below integers, integer where in rotations grid[i][j] == counter-clockwise 1: grid, [[40,10],[30,20]], = cyclically rotating a grid cyclically rotating a grid cyclically rotating a grid cyclically rotating a grid cyclically rotating a grid
[1,-2,2,-5,3,-4], [1,-1]. of for [3,-2,1,-5,2,-4]. signs. incorrect present rearranged integers. opposite are <= with integer. after [-2,3,-5,1,-4,2] sign, example consists a modified [3,1,2]. [-1,1] -1 that which follows return one to 2: aforementioned an 2 every way as elements nums.length explanation: them all conditions length and only they negative begins * pair or positive other should number 105 0-indexed satisfy array because [3,1,-2,-5,2,-4] even integers nums possible order 1 not so such preserved. more the is output: conditions. conditions: rearranging consecutive |nums[i]| ways given input: you constraints: equal rearrange have [1,-1] [3,1,2,-2,-5,-4], do integer in were same [3,-2,1,-5,2,-4] nums. 1: consisting = [-2,-5,-4]. rearrange array elements by sign rearrange array elements by sign rearrange array elements by sign rearrange array elements by sign rearrange array elements by sign
its of + any for digits. are n 8 <= integer. leading deci-binary, example digits consists a numbers 9 that deci-binary if return to 2: without not. zeros. 101 up 10 3 either "32" explanation: n.length string and only they "27346209830709182346" or decimal positive 32 number n. 105 3: contain needed zeros each sum 1 not so "82734" called the is output: integer, 0 3001 given input: constraints: 1100 112 minimum does 11 while represents 1: example, = partitioning into minimum number of deci-binary numbers partitioning into minimum number of deci-binary numbers partitioning into minimum number of deci-binary numbers partitioning into minimum number of deci-binary numbers partitioning into minimum number of deci-binary numbers
its false will 104 that no what. array's step 0 which given return if jump or makes input: you to 2: element an impossible index, steps constraints: first maximum 105 otherwise. from your at then array [3,2,1,0,4] is 0, positioned index. are nums it position. can last <= 3 arrive [2,3,1,1,4] each nums.length integer in explanation: 1 nums[i] example initially always matter nums. true represents 1: length and reach the index output: = 1, jump game jump game jump game jump game jump game
binary, results that of concatenation + which result given return decimal modulo value to input: output: 2: "10", an formed 27. them, 7. 27 constraints: representations 105 3: "11". have is "11011", concatenating n 2, by <= 3 n, 12 integer in after 7, "1", explanation: 1 505379714 example 1. "1101110010111011110001001101010111100". 505379714. 118505380540. string order, 109 1: corresponds "1" and the binary = 1, we concatenation of consecutive binary numbers concatenation of consecutive binary numbers concatenation of consecutive binary numbers concatenation of consecutive binary numbers concatenation of consecutive binary numbers
is: of nums[i], for element nums[4] 7. divisors[2]). there has are score. nums[3], <= with since example (i.e., [20,14,21,10], 109 divisors[2] divisibility nums.length, divisors.length that [4,7,9,3,9], no it. [10,16] [5,7,5] nums[3] return if one divisors[0]). nums[j] 2: score 16. 2 every maximum 10 3 [5,2,3] divisors[1], indices explanation: them 10. all arrays and 3. than [12], divisors[i] divisors[0], nums[1] number 0-indexed them. 3: divisors[1] divisors[0] divisors[i]. nums by score, 1 divisible 5 nums[2] both such more the is output: we 0 given input: you 1000 2. constraints: minimum have divisors. nums[2], divisors nums[0] integer j in 1: two 5. = find the maximum divisibility score find the maximum divisibility score find the maximum divisibility score find the maximum divisibility score find the maximum divisibility score
[2,1,3,4]: choice. paths of tree. undirected any first denotes there price. on has cost. n are be with <= [1,1,1], difference after choosing ai, example a ai price edges edges.length that [[0,1],[1,2],[1,3],[3,4],[3,5]], exists return [7,8,6,10], bi] 24 to 2: [1]. an prices 2 maximum from rooted at nodes node 2d edge explanation: part 1. all indicates [0] length and associated above tree shows 3. - contains 105 valid choices. ith your array it diagram (colored possible each edges[i] sum red) cost node. 24. [0,1,2]: 1 [2] incurred [1,1,1] 31. proved 0. indexed [7]. is path. the output: blue) 1, unrooted = 0 given sum. input: you root. [ai, between 2. [[0,1],[1,2]], constraints: bi minimum lying price.length price, 6, can second integer where in [9,8,7,6,10,5] rooting 3, root initially == price[i] starting represents 1: path amongst difference between maximum and minimum price sum difference between maximum and minimum price sum difference between maximum and minimum price sum difference between maximum and minimum price sum difference between maximum and minimum price sum
of any cell [[1,0],[0,1]] first server. there on are n <= with communicate others. example a corner grid.length bottom that no if return one to 2: three m 4 matrix row at as map 3 column explanation: all column. other. and they least * or said other number third 3: it servers each 1 can't center, the is output: means grid[i].length 0 given [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]] grid input: you represented right constraints: 250 can integer where in grid[i][j] server same == [[1,0],[1,1]] 1: two grid, = count servers that communicate count servers that communicate count servers that communicate count servers that communicate count servers that communicate
its 104 that grouped [6], the of [5], [1], given return input: to you total, 2: largest an size they 2 4 number constraints: n. from [2,11], [3,12], size. have there [9]. digits. are n <= with each sum 13: integer in [4,13], according 1 explanation: 13 example 1. groups digits [2] numbers [1,10], 9 1: [8], [7], is output: = count largest group count largest group count largest group count largest group count largest group
inclusive false ranges. least range. 21, - [[1,2],[3,4],[5,6]], covered given return if one any x input: you 2: ranges.length 50 an between starti 2 right every 4 constraints: first third interval otherwise. [starti, at is array integers are [left, 2, by <= 3 each ranges[i] 2d second integer endi] in endi. explanation: 1 example 5 not a endi true left represents right. covered: 21 1: [[1,10],[10,20]], two ranges and right] the range output: = check if all the integers in a range are covered check if all the integers in a range are covered check if all the integers in a range are covered check if all the integers in a range are covered check if all the integers in a range are covered
its red elapsed=0 (inclusive). 4] 104 minutes. is: of vice enter any for 6 smallest [2, denotes color there on has 104, larger signals notes: go / itself. minutes, n are journey <= with ui be n, but edges. example 5: value. a blue elapsed=3 vi. elapsed=10 edges 103 most will city edges.length no that graph connected assume wait directly vertex. which 4. if return one min(2 to value 2: an 2 every 4 from at changes as when traffic 2, != take 3 start 2d hence edge explanation: turned all leave labeled vi] and only shows times, than just -> * pair - or time. ui, elapsed=13 edge, other time edges[i].length indirectly number n. 5, 3: starts, vertex array bi-directional needed it by each edges[i] through elapsed=6 1 13 5 vertices vi edges, the is path. output: 1, get given versa figure input: you duplicate time, 4: between change, 2) represented defined (n right constraints: strictly minimum green. graph. have signal including can [ui, [[1,2]], taken green [[1,2],[1,3],[1,4],[3,4],[4,5]], 1) cannot second integer where in 3, same 11 reached == left 1: path traverse change = second minimum time to reach destination second minimum time to reach destination second minimum time to reach destination second minimum time to reach destination second minimum time to reach destination
104 it. "aacecaaa" * of this 0 given return input: to you 2: s. lowercase constraints: shortest "abcd" are english can by convert s <= front in s.length only. example 5 consists a "dcbabcd" adding string letters "aaacecaaa" transformation. find 1: characters palindrome the performing output: = shortest palindrome shortest palindrome shortest palindrome shortest palindrome shortest palindrome
104 [1,2,1,2,6,7,5,1], of smallest 5] [2, there [7, / are be with <= but example a also k k, result position return if to 2: < three an 2 maximum interval [0,3,5] as nums.length 3) indices explanation: 6], answers, [1, 216 find subarrays length and [1,2,1,2,1,2,1,2,1], non-overlapping * [0,2,4] 1], them. array nums each sum floor(nums.length answer 1 correspond nums[i] list lexicographically the output: we given input: constraints: representing (0-indexed). would have 5]. [0, taken integer 3, larger. one. 2], starting multiple 1: could = maximum sum of 3 non-overlapping subarrays maximum sum of 3 non-overlapping subarrays maximum sum of 3 non-overlapping subarrays maximum sum of 3 non-overlapping subarrays maximum sum of 3 non-overlapping subarrays
"1"}], case, grouped of this [6, any acceptable. (list) element } 9] 5] function. version first splits 5], there on _.groupby array.length enhances array.groupby(fn). are {"id":"1"}, be with <= array. "true": 9]] callback whether { example a [[1, [{"id": will that items return one code value "1"}, without 2: an output from together. [ as string(list[0]); 2, being 9, function explanation: 1. method [1, all out > string original arrays and they "1": than item key type. object fn 8, should {"id": number appear 105 5, "id" their 3: array solve gets it by 10] objects 3], each 7, greater order 1 both list fn(arr[i]) those so such array.groupby(fn) is the output: write lodash's 0 ] key. input: you put 4, item.id; 2. containing "false": constraints: ], provided defines have {"id":"2"} 10], please selector accept 6, can keys returns string(n call second where in (item) 3, (n) "2": 1: two "2"}] 5. = 5); group by group by group by group by group by
104 that results. the of remove this https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/ result given among appears "cbacdcbc" duplicate you once. smallest input: output: 2: s, note: question every constraints: lowercase 1081: your "bcabc" as "abc" english s <= possible lexicographical letter "acdb" must sure letters. s.length in order 1 example same all consists a once string so make letters 1: and is only = remove duplicate letters remove duplicate letters remove duplicate letters remove duplicate letters remove duplicate letters
>= of special, [0,4,3,0,4] x. for unique. element integers. there are be <= considered since but example non-negative a numbers criteria x, -1 special that [3,5] no exists if return to value 2: an 2 exactly 0, 2, 3 nums.length explanation: proven 5) and only 3. than or -1. should number 3: array nums it greater (3 1 nums[i] not such 0. 100 the is output: 1, 0 values given x input: you notice 1000 fit 2. constraints: equal have does can cannot in otherwise, nums. [0,0] 1: = special array with x elements greater than or equal x special array with x elements greater than or equal x special array with x elements greater than or equal x special array with x elements greater than or equal x special array with x elements greater than or equal x
of routes this for any unique. 6 target. first on forever. go are <= must example a routes[0] best -1 stops will that if return to 2: < an 2 bus from route (you at take 15, strategy routes[i] start 12 only. explanation: [1, all [[7,12],[4,5,15],[6],[15,19],[9,12,13]], 500. want and least -> 6. sum(routes[i].length) repeats 106 stop [[1,2,7],[3,6,7]], number routes[i].length 105 5, ith then array 0th target it by 7, 1 initially), 5 not buses sequence the is output: 1, means routes.length travels 0 values given input: you between constraints: source, representing 7 routes[i][j] possible. ... can second where 7], in travel 1: example, source = bus routes bus routes bus routes bus routes bus routes
its 104 coding 6. [5,4,-1,7,8] which given return [1] up: sum. if input: 6 2: you o(n) largest 23 an constraints: solution sum, 105 nums, approach, 23. subarray 3: have has is array nums [-2,1,-3,4,-1,2,1,-5,4] <= with follow figured try another nums.length sum integer solution, explanation: 1 conquer subtle. nums[i] example 1. out [4,-1,2,1] find 1: using divide more and -104 the output: = maximum subarray maximum subarray maximum subarray maximum subarray maximum subarray
its red tree node.val no of 0 values given return if [1] input: output: 2: even-value an constraints: number grandparent, there 104]. is nodes are node it grandparent. <= with sum exists. parent in tree, explanation: grandparents. 1 example even-valued root [1, a while blue 0. 1: 100 grandparent [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5] 18 the range binary = sum of nodes with even-valued grandparent sum of nodes with even-valued grandparent sum of nodes with even-valued grandparent sum of nodes with even-valued grandparent sum of nodes with even-valued grandparent
104 what arr[i of + j] any for 6 arr[1], first are <= with arr.length non-empty leading i note example arr[j], value. consists that [-1,-1] j, which if return value 2: < decimal, three an also, when used 3 these -1]. part [0,1,1] all arr[0], part. considering [1,1,0,0,1] and represents. binary only arr[j 3. [1,1] * into - or part, third 1], possible, 3: array ..., arr it 1] arr[arr.length ones, [1,1,0,1,1] zeros 1 [1,0,1,0,1] allowed, not so such [-1, divide parts is the output: [i, 0 represent given arr[i] input: you constraints: equal have that: [1,1,0] second in same 2], [0,2] represents values. 1: example, entire = [0,3] three equal parts three equal parts three equal parts three equal parts three equal parts
false = 104 the of words, "eidbaooo" permutations given return if or one contains s1's input: 2: permutation s2, other lowercase constraints: consist otherwise. s2.length is english <= "ab", letters. in explanation: "eidboaoo" 1 s1.length, example s2. strings a true ("ba"). 1: two and s2 s1, s1 output: substring permutation in string permutation in string permutation in string permutation in string permutation in string
>= alicearrows[i], of + 11. for any obtain. respectively. how size maximize bobarrows[i] rules: first there on has [0,0,0,0,0,0,0,0,1,1,1,0] obtain are scoring 8 be with <= following example a 9 k bk alice section, that numarrows which if return one to 2: < score an 2 4 maximum from 10 total as 0, sum(alicearrows[i]) 9, arrows. 12 now, alicearrows.length explanation: table takes inclusive. archery and 11, above shows shot points, than say bobarrows bk, numarrows. calculated (in higher other should number 27 earn 105 12, them. arrows then array target wants it hand, each sum set earns shown 1 sections 5 both competition 11), the is output: competition. point alicearrows 0 values ways given [1,1,0,1,0,0,2,1,0,1,2,0] follows: you opponents input: between shoots 27. constraints: equal 47. have points he points. can cannot integer in bob 3, 11 same [0,0,1,0,0,0,0,0,0,0,0,2] however, == [0,0,0,0,1,1,0,0,1,2,3,1] section represents multiple 47 1: example, ranging nobody scored. bobarrows.length ak = maximum points in an archery competition maximum points in an archery competition maximum points in an archery competition maximum points in an archery competition maximum points in an archery competition
= calculate floor(5 of pair + 0 given return for floor(9 modulo input: floor(2 2: < division an large, 2) 2 we 7. 4 [2,5,9] every constraints: 105 nums, 10 floor(nums[i] then array / floor() up. too nums it may <= be returns 49 nums.length sum function integer j indices in since answer explanation: part 1 pairs example division. them [7,7,7,7,7,7,7] all floor nums[j]) 5) nums[i] 9) 1: 109 the output: array. i, sum of floored pairs sum of floored pairs sum of floored pairs sum of floored pairs sum of floored pairs
of removed: "xy". "dababc". "axyb". lowercase on removing has contiguous "dababc", are operations <= substring following operation letters. after example consists a part.length index no remove return "axxxyyyb". 2: "dabaabcbc". 2 4 "dab". from until "ab" "axxyyb". at "axyb", "ab". "abc" 2, english perform 3 explanation: part leftmost all part. find and - s. "abc". part, string. it occurrence s done: s.length occurrences "daabcbaabcbc", 1 "axxyyb", so "dab" sequence characters "axxxxyyyyb", is the output: now given input: 1000 4, constraints: "axxxyyyb", "dabaabcbc", "xy" in 3, strings starting 1: two = remove all occurrences of a substring remove all occurrences of a substring remove all occurrences of a substring remove all occurrences of a substring remove all occurrences of a substring
its b. 104 here the -> of * pair 0 106 - given return among (1,3) input: nums[j] smallest < 2: pairs: an between 2 defined (n b constraints: 3: then array / as [1,3,1], integers kth are nums n <= 3 [1,1,1], nums.length difference (1,1) (1,1), integer where j i 1) explanation: 1 pairs nums[i] example (3,1) 5 absolute all a == [1,6,1], 1st 1: k 0. and distance nums.length. is output: = k, find k-th smallest pair distance find k-th smallest pair distance find k-th smallest pair distance find k-th smallest pair distance find k-th smallest pair distance
mat cell. 104 least mat. [[0,0,0],[0,1,0],[1,1,1]] * of 0 mat, given return for or one x input: output: 2: adjacent an between mat[i].length m constraints: matrix there at is mat[i][j] n <= m, each either in [[0,0,0],[0,1,0],[1,2,1]] 1 1. example cells == mat.length nearest [[0,0,0],[0,1,0],[0,0,0]] 1: two distance the binary = 01 matrix 01 matrix 01 matrix 01 matrix 01 matrix
3] 15], [null, events calls largest 15); there intersection are endtime <= be non-empty after (i.e., example a object. mycalendarthree(); [10, k events. 109 mycalendarthree() endtime) most will that exists return to < book(int an "book"] 2 [5, output maximum 400 k-booking input [[], 40); at explanation some when implement 2, 3 10); starttime, new events.) all endtime), 20); 20], 55]] time class: 55); ["mycalendarthree", "book", 60); each mycalendarthree 1 calendar. starttime mycalendarthree.book(10, common 60], such mycalendarthree.book(5, 40], the is 1, made book. 0 initializes given you between [50, mycalendarthree.book(50, mycalendarthree.book(25, constraints: [25, representing have 10], returns integer in // event, previous 3, int [starttime, happens 1: = my calendar iii my calendar iii my calendar iii my calendar iii my calendar iii
its positions of words, positions, this for any whole arr, [-1,-1,0,-1] size there on order. go contiguous are n ans[i] position. operations with arr. <= arr[banned[i]] array. operation non-empty located after i but example a also k -1 index that which result position return if one makes to 2: an making 2 4 from at finally, 0, elements changes some 2, != perform 3 position, explanation: independent 1. [0,-1,-1,1] all impossible. bring currently leave initially, shouldn't length and only 3. banned.length need place [2,4], - or -1. other i's. should 2] banned happen. number 105 amount 0-indexed 1], 5, ith p. subarray 3: 0's, array arr [0,-1,-1,-1,-1] needed case it possible each perform, set answer 1 operation, reversing can't so sequence 0. banned, is the range output: reverse we 1, 1]. subarray. [0,1,3], 0 values given choose never input: you banned[i] ans 4, except containing constraints: representing minimum have unique p can within [0, integer in where placed 3, banned. initially however, move multiple 1: so, [1,2], = remains minimum reverse operations minimum reverse operations minimum reverse operations minimum reverse operations minimum reverse operations
deletions of this + deletions, respectively. element nums[1], there removing has back nums[5], are <= with array. front highest example value. a that remove which return one makes value to 2: an 2 maximum from deletion [0,-4,19,1,8,-2,-3,5] as elements take 3 front. either nums.length these distinct explanation: them 1. 10. deletion. lowest and only results or -4. number [2,10,7,5,4,1,8,6] 105 0-indexed 3: your array integers nums it 19. by [101] 1 nums[i] 5 distinct. both the is output: we given element. input: you goal defined constraints: minimum would possible. can nums[2], call array, -105 in nums. 1: back. = removing minimum and maximum from array removing minimum and maximum from array removing minimum and maximum from array removing minimum and maximum from array removing minimum and maximum from array
its tree node.val of values given return deepest input: 2: constraints: number 19 104]. is [1,2,3,4,5,null,6,7,null,null,null,null,8] nodes <= sum leaves. in tree, 1 example root [1, a 1: 100 binary [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5] 15 the range output: = deepest leaves sum deepest leaves sum deepest leaves sum deepest leaves sum deepest leaves sum
use of directly. strings, 0 library given return any product or inputs input: num1 num2, you to 2: "123", note: 200 except represented constraints: number consist string. as contain integers itself. "6" built-in num1.length, convert <= biginteger do must leading integer num2 num2.length only. "2", "3" 1 example non-negative not digits also a both 1: "456" two and "56088" the output: = zero, multiply strings multiply strings multiply strings multiply strings multiply strings
its 104 actual of names enter unique. ["onepiece","onepiece(1)","onepiece(2)","onepiece(3)","onepiece(4)"] smallest how size assigned lowercase before, adds n ans[i] last <= with since creates used, example consists minute, a also k "gta(2)" suffix names[i]. "gta" will that it. becomes if return to 2: "fifa" an round previously file --> at "onepiece(4)". names: when english name ["gta","gta(1)","gta","avalon"] "avalon" explanation: length and "gta(1)" letters, * and/or that, reserved, "pes(2019)" system positive created, systems 20 n. valid assign folders ith your 3: array names[i].length names.length it let's 1 not 5 form such ["gta","gta(1)","gta(2)","avalon"] (k), is the ["onepiece","onepiece(1)","onepiece(2)","onepiece(3)","onepiece"] output: see given digits, input: you put addition 4, 2. folder files constraints: "pes" brackets. ["pes","fifa","gta","pes(2019)"] have obtained cannot integer in where name, same strings where, 1: two names[i] create was = remains making file names unique making file names unique making file names unique making file names unique making file names unique
1]. >= arr[i that + 0 exists - if given arr[i] return 106 input: you output: 2: < to arr, an arr[0] time constraints: 105 there [0,1,0] 3: is array that: solve arr some ... hold: it 1] arr[arr.length <= 3 with be arr.length must array. following [0,2,1,0] in complexity. i [0,10,5,2] guaranteed 1 example > a mountain properties such arr[1] 1: the index o(log(arr.length)) = peak index in a mountain array peak index in a mountain array peak index in a mountain array peak index in a mountain array peak index in a mountain array
= subarray. no it. of 0 position given return if delete one 1's input: you output: contains value 2: element. element size 4, 2 should containing number constraints: 1's. resulting 105 from nums, [1,1,1,1,1]. subarray there deleting 3: is array or nums 2, [0,1,1,1,0,1,1,0,1] <= 3 with either must non-empty nums.length [0,1,1,1,1,1,0,1] in after longest explanation: 1 nums[i] example 1. 5 [1,1,1] a only numbers [1,1,0,1] such 1: the binary array. longest subarray of 1's after deleting one element longest subarray of 1's after deleting one element longest subarray of 1's after deleting one element longest subarray of 1's after deleting one element longest subarray of 1's after deleting one element
minutes of + for five characters. k. are 8 be <= character. 'b', example non-negative consists minute, a letters character k needed. -1 "aabaaaacaabc", that return if one to 2: three 2 from total at 'a' take 3 either explanation: leftmost proven string four and only least 'b' or s, -1. s. characters, number 105 needed 'a', it character, s possible each s.length 1 not 5 so characters is the output: now 0 given "a", input: you right rightmost constraints: minimum 'c'. have can may integer left 1: two 'c' consisting = take k of each character from left and right take k of each character from left and right take k of each character from left and right take k of each character from left and right take k of each character from left and right
tsetnoc" initial 104 separated least preserving gnid" "s'tel of * words ekat given or word any one contains input: 2: contest" space. ding" s, s. "dog printable constraints: characters. there still order. at does is contain "let's are single ascii within s take <= by each leading s.length in trailing order sentence edocteel 1 example 5 not all a while leetcode string whitespace "god 1: characters and spaces. the output: = reverse reverse words in a string iii reverse words in a string iii reverse words in a string iii reverse words in a string iii reverse words in a string iii
= no least of [1], given return if input: 2: -1. an 4 constraints: [2,-1,2], 105 subarray there 3: at is array shortest k. contiguous nums <= with 3 nums.length non-empty sum array. integer -105 1 part nums[i] example a such 1: k 109 length and the -1 [1,2], output: subarray, k, shortest subarray with sum at least k shortest subarray with sum at least k shortest subarray with sum at least k shortest subarray with sum at least k shortest subarray with sum at least k
less 104 than "abcd", of given if for or 2k to input: 2: left, other an 2 characters, every k, constraints: equal first fewer lowercase from "bacdfeg" them. there string. then "abcdefg", as are english s "bacd" <= start letters. integer greater s.length 1 but example all consists a only string leave counting k 1: characters original. and the output: = reverse reverse string ii reverse string ii reverse string ii reverse string ii reverse string ii
get that no the wait of instead. days which this 0 given return if for [73,74,75,71,69,72,76,73] temperatures, you to input: 2: temperatures.length 30 an number constraints: 105 possible, ith have there 3: [30,40,50,60] array [1,1,1,0] temperature. [30,60,90] [1,1,0] integers [1,1,4,2,1,1,0,0] warmer <= daily after answer 1 future answer[i] temperatures example temperatures[i] day a keep == represents such 1: 100 is output: = daily temperatures daily temperatures daily temperatures daily temperatures daily temperatures
tree inclusive false node.val full the node-values of tree. given if input: output: (ie. 2: value 3}), 1000 level 100]. except between levels every last, possibly 2h h. constraints: {1} 5, 7 number ({4, have at as possible. before isn't nodes are it can [1,2,3,4,5,6] last node with <= completely far in filled, tree, level, 1 explanation: complete example [1,2,3,4,5,null,7] root all [1, a true {2, left 1: 6}) determine and is range binary = check completeness of a binary tree check completeness of a binary tree check completeness of a binary tree check completeness of a binary tree check completeness of a binary tree
activities varchar of this names for product different there 2020-06-01 2020-06-01, be (headphone, t-shirt), following pencil type example a 2020-05-30, no it. items result return to products comma. an 2 primary row (pencil, num_sold sort 2020-06-02 name 3 column explanation: duplicates. them table, 2020-05-30 table find and sell_date sell_date. basketball, | (mask), just item key contains format date should bible,pencil number bible bible), their ordered contain activities: names. +-------------+---------+ it by each +------------+----------+------------------------------+ 1 headphone lexicographically table: the is output: basketball we write separate mask input: market. lexicographically. t-shirt sold basketball,headphone,t-shirt query sql example. may 2020-06-02, in were 1: sorted +------------+------------+ was schema group sold products by the date group sold products by the date group sold products by the date group sold products by the date group sold products by the date
b. of word[i,n-1] any word for letter; smallest [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]] [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]] lowercase first there has empty alphabet n be alphabetically corresponding with <= letters. since prefix example consists lcp[3][3] a letters letter, differ, smaller that no (of lcp[i][j] position return if appears comes to 2: an b 4 matrix at as before define single english 3 explanation: distinct them string corresponds length and [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]] they only than lcp. 'b' lcp.length substrings alternating lcp[i].length "aabd" third 0-indexed 3: string. "abab" because earlier exists. answer 1 word[j,n-1]. common "aaaa". lexicographically such "abab". letter. thus, is longest the output: we lcp 0 given grid x input: 1000 between constraints: equal 'c'. word[3,...,3] "" that: "aaca" differ letter length) cannot in where same == string, "aaaa" 1: example, lcp, two = find the string with lcp find the string with lcp find the string with lcp find the string with lcp find the string with lcp
its false "aaababb" of this for wins, line. game, "abbbbbbbaaa" game turn. color there removing 'a'. on has her 'b'. optimally, are n last <= since example many consists allowed a also make letters option alice "aa" that no remove which if return to 2: first. from 'a' take turn, abbbbbbbaa alice's either edge explanation: abbbbbbbaaa aababb piece turn string true moves aaababb length and wins. they only -> pick 'b' or alternating other his 105 ith their whose 3: assuming false. by each it's turns she options 1 not colored play piece. both so right. more thus, 'a's the is output: now given next remove. pieces input: you any. colors.length arranged constraints: colors playing neighbors 'b's he player removes can cannot second in where bob loses bob's true. left move abbbbbbaa colors[i] line, 1: two = remove colored pieces if both neighbors are the same color remove colored pieces if both neighbors are the same color remove colored pieces if both neighbors are the same color remove colored pieces if both neighbors are the same color remove colored pieces if both neighbors are the same color
alex varchar of who this for any 6 distances distance, order. ride 8 alphabetically traveler following type example did user_id 9 +---------------+---------+ table. order, distance alice top smaller +------+-----------+ id result return if one to an 2 primary 4 400 jonathan, total as traveled user name 3 +----------+--------------------+ column explanation: miles, them alex, bob, table and only descending | than just lee key or ascending format 50 +------+----------+----------+ 450 his 19 their rides ordered him by ride. travelled_distance each 317 order users 1 13 5 not 0. table: 100 more is the output: we write 0 "distance". input: 312 query 7 rides, report donald 230 have sql example. lee. in bob jonathan same int elvis 120 user. 222 1: two schema top travellers top travellers top travellers top travellers top travellers
"enjoyyourcoffee" "icodeinpython", of spaces.length for respectively. 13, underlined lowercase characters. first thon" obtain are n be <= letters. after i example uppercase consists [8,13,15] a also added. space character modified 9 coffee". g" able [1,5,7,9] will 9], that py which return code "leetcode to 2: "icodeinpython". " [5, at describes before 'c', english 3 indices explanation: all "i [0,1,2,3,4,5,6] string original and 15 "leetcodehelpsmelearn". only place * - 8, spaces[i] should 105 5, 0-indexed 3: your then array string. "enjoy index. me s been each 7, s.length 1 correspond 5 those characters "leetcodehelpsmelearn", increasing. thus, the output: 1, we 0 values given input: you spaces constraints: helps strictly learn" have inserted p integer in where "spacing", c 'y' 1: example, = adding spaces to a string adding spaces to a string adding spaces to a string adding spaces to a string adding spaces to a string
104 "toffee" of names for unique. 6 lowercase first there ("donuts", are created be with <= swapping array. following letters. after ("coffee", example ["lack","back"] consists a letters that no exists if return to 2: an 2 from 10 total still name. as some process used english name ideab explanation: distinct new them doffee". all already original conuts". other. and selections "coffee"): "dime * - ideab, "conuts formed number valid then array exist names. it ideas, by ("time", ("toffee", each ideas[i] "donuts"): "time"): 1 naming not 5 both list therefore, returned. ideas is the output: separated company concatenation 0 given choose follows: you input: tonuts". ideaa dime". constraints: ideas[i].length ideab. swap selections: ["coffee","donuts","time","toffee"] (the call in invalid ideas.length found otherwise, selections. same examples strings company. "doffee "tonuts represents 1: space) valid: "toffee"): = naming a company naming a company naming a company naming a company naming a company
varchar of 11000. this + for any +------------+------------+------------+---------------+ 6 3000) there order. -3000 be with following charlie type 4000) example a having +---------------+---------+ table. 2020-08-07 alice will no that 11000 result if return to an 2 primary 4 row changes user +--------------+---------+ charlie's name 3 alice's start column explanation: involving all (7000 1000. table and 2020-09-01 they 2020-09-02 | negative than key - contains money. positive account date higher format money transferred number 10000. bank. amount 2020-09-11 each sum transactions users 1 amounts 5 transacted_on 0. table: 2020-09-07 is the output: write 900002 made received 6000 input: 7000 1000 trans_id balance 900003 900001 2020-08-01 equal query -4000 7 report sql example. +------------+--------------+ accounts. 2020-09-12 8000. (6000 in bob bob's same int accounts 1: two +------------+------------+ account. = schema bank account summary ii bank account summary ii bank account summary ii bank account summary ii bank account summary ii
104 3] of words, needs for element [1,-2,-2,3] there empty [3] be with <= arr.length non-empty after final note example value. a make -1 most that becomes return one optionally to 2: remaining an 4 maximum thus from still at -2, 0, elements non-empty. 3 explanation: deletion. [1, want and -104 elements) least just delete [-1,-1,-1,-1] other (contiguous equals 105 3: subarray deleting then array because arr it sum it's 1 can't so 0. is the output: we get given choose arr[i] sum. element. input: you it, constraints: possible. can integers, in drop [1,-2,0,3] left 1: [-1] = maximum subarray sum with one deletion maximum subarray sum with one deletion maximum subarray sum with one deletion maximum subarray sum with one deletion maximum subarray sum with one deletion
of undirected any spanning weighti] connects first (ai, on order. (mst). / n weight are (mst) with <= numbered therefore following considered since choosing but edges. note example a ai bi, msts: edges weight. msts will edges.length [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]] that graph connected which return weight, to 2: without < an 2 4 from deletion total describes some nodes 2, 3 cause indices edge explanation: part bi. them pairs all [[0,1,1],[1,2,1],[2,3,1],[0,3,1]] [[0,1],[2,3,4,5]] find and output. min(200, they only above tree shows * cycles - graph's other mst. observe edges[i].length appear 5, whose array add hand, possible edges[i] 1 not 5 distinct. vertices list so critical [[],[0,1,2,3]] yield called 100 edges, the is output: 1, we edge. subset weighted 0 mst given figure input: you [ai, notice weighti 1000 4, between 2) all. (n pseudo-critical. constraints: equal bi minimum would msts, graph. have pseudo-critical can 1) second where in 3, == represents 1: two bi) increase = bidirectional find critical and pseudo-critical edges in minimum spanning tree find critical and pseudo-critical edges in minimum spanning tree find critical and pseudo-critical edges in minimum spanning tree find critical and pseudo-critical edges in minimum spanning tree find critical and pseudo-critical edges in minimum spanning tree
104 match. of [typei, ["computer","silver","phone"] lowercase there are <= item. following "phone" letters. note example also a items, that items strings, rulevalue. which items[i] if return "name". one to 2: typei.length, an 2 10 colori, rulevalue.length describes name typei. either explanation: "type" all and [["phone","blue","pixel"],["computer","silver","lenovo"],["phone","gold","iphone"]], only item ["phone","gold","iphone"]. or said true: number "color", ith rule, namei. array items.length "color" by rulekey each [["phone","blue","pixel"],["computer","silver","phone"],["phone","gold","iphone"]], 1 not namei.length, rule. rulevalue is the namei] output: colori. color, ["computer","silver","lenovo"]. given matching input: you "type", represented "silver" constraints: equal consist ["phone","blue","pixel"] does colori.length, where rule match strings type, == 1: two "name" = count items matching a rule count items matching a rule count items matching a rule count items matching a rule count items matching a rule
of -1000 + given return input: 2: without 1000 2 b constraints: integers a, 2, operators <= 3 sum b, example 5 a -. using 1: two and the output: = 1, sum of two integers sum of two integers sum of two integers sum of two integers sum of two integers
104 of tree. undirected [8,12,6,10,10,10] + on. [[0,1],[0,2],[2,3],[2,4],[2,5]] hence, distances dist(0,4) [] there n are <= with ai, edges. example a ai edges edges.length that connected return bi] to 2: above. < an 2 from input nodes node 2, != 3 edge explanation: all indicates labeled [0] length and tree [1,1] * - 8, other edges[i].length equals valid ith 3: array dist(0,5) edges[i] sum answer 1 shown answer[0] answer[i] so the is output: 1, we see 0 given dist(0,3) input: you [ai, between nodes. constraints: bi dist(0,1) 6, can integer where in [[1,0]] 8. == represents 1: = dist(0,2) sum of distances in tree sum of distances in tree sum of distances in tree sum of distances in tree sum of distances in tree
30. of + for acosti, 30 first n <= planning [acosti, example a bcosti. people even. city. interviewing city that person [[515,563],[451,713],[537,709],[343,819],[855,779],[457,60],[650,359],[631,42]] return to 2: 2 b every goes 10 20. total exactly interview 50. explanation: [[259,770],[448,54],[926,667],[184,139],[840,118],[577,469]] people. 10. and fourth * 50 bcosti 20 costs third ith 3: array each cost 1 such 100 is the output: half company given [[10,20],[30,200],[400,50],[30,20]] input: 1000 1859 costs.length 2n constraints: minimum have 3086 bcosti], arrive second where in flying == 1: 110 costs[i] fly = two city scheduling two city scheduling two city scheduling two city scheduling two city scheduling
tree will = [3,9,20,null,null,15,7] node.val actual of 0 11. - given return [3, accepted. value input: output: 2: [3,9,20,15,7] level an 2 constraints: number average 10-5 on 11]. 104]. is nodes within be <= each in answer tree, explanation: 1 hence 231 3, example root [1, a form 1: [3.00000,14.50000,11.00000] 14.5, answers and -231 the range binary array. average of levels in binary tree average of levels in binary tree average of levels in binary tree average of levels in binary tree average of levels in binary tree
false sequence. that no the * of nums[i], [3,1,4,2] given return if -109 [1,2,3,4] input: nums[j] 2: < sequence: pattern three an 4, 0] 2 constraints: [-1,3,2,0] patterns 105 nums, there 3: array 2]. 0]. integers nums[j]. n nums false. are 2, <= nums[k] nums.length j in i explanation: 1 otherwise, nums[i] example 3, 2], [1, a == true 132 such [-1, subsequence k 1: 109 and is output: = 132 pattern 132 pattern 132 pattern 132 pattern 132 pattern
1]. grid[m applying [[1,2,3],[4,5,6],[7,8,9]] operation: need grid[i][j grid[i].length of times. -1000 + - 0 given return one x grid to you input: 2: 50 1000 grid[i][n element grid[0][0]. size an shift m 4 [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]] constraints: [[1,2,3],[4,5,6],[7,8,9]], 3: at k. n 1] <= grid[i 2d operation integer in grid[i][j] after [[9,1,2],[3,4,5],[6,7,8]] 1 example a == [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], moves 1][n 9 k 1: grid.length 100 and the 1][0]. output: = shift 2d grid shift 2d grid shift 2d grid shift 2d grid shift 2d grid
its paths of undirected differs 0.5 there has go a, are n end be with <= 0.2 example [0.5,0.5,0.3], [a, a having traversing edges will most edges.length that no graph probability succprob.length return if succprob one to 2: < an 2 b every maximum from at [[0,1],[1,2],[0,2]], 0, nodes != [0.5,0.5,0.2], start edge explanation: correct 1e-5. start, find and probability. 0.00000 connecting * (0-indexed), 0.30000 [[0,1]], other success 3: your 0.25. it by edges[i] answer 1 list 0.25000 0. the is output: succprob[i]. weighted 2*10^4 0 given b] input: you [0.5], between 2. represented nodes. constraints: end, accepted where 10^4 3, == succprob[i] 1: two path = path with maximum probability path with maximum probability path with maximum probability path with maximum probability path with maximum probability
104 positions very of dart 5000 wall. on radius n are <= with circle example a yi alice that yi] darts.length position return [xi, to 2: an [[-3,0],[3,0],[2,6],[5,4],[0,9],[7,8]], 2 4 r large maximum (0,0) r, explanation: all and (0,4) -104 threw darts[i] place xi, throws number darts[i].length ith array contain wants center wall 1 5 so 100 the lie is output: dartboard. throwing point darts given input: you except constraints: (7,8). unique points knows he points. can lies integer where bob in dartboard == [[-2,0],[2,0],[0,2],[0,-2]], 1: = maximum number of darts inside of a circular dartboard maximum number of darts inside of a circular dartboard maximum number of darts inside of a circular dartboard maximum number of darts inside of a circular dartboard maximum number of darts inside of a circular dartboard
tree node.val of tree. - given return input: value output: 2: constraints: number 7 row 104]. is nodes [2,1,3] last <= [1,2,3,4,null,5,6,null,null,7] in tree, 231 1 example root leftmost [1, a 1: -231 the range binary = find bottom left tree value find bottom left tree value find bottom left tree value find bottom left tree value find bottom left tree value
of this for on. indexing ["a", lowercase sources[i].length, on "eee", k. contiguous are operations with be <= must sources[i] substring letters. targets[i] after affect example consists a sources k index will that result if replacements return occur to 2: < occur, three 2 "ec" replacement "ab" at as 0, english perform "eeecd". indices explanation: sources.length occurs all string original meaning generated check other. length and "eeecd" testcase nothing. "a" "ffff". only operation: "abcd", indexes[i] indices.length 50 s, ["ab","ec"], s. should resulting 0-indexed 1], ith ["ab","bc"] then string. sources, because it s "ffff"] "abc", each replace s.length 1 not indices[i] targets[i]. ["eee","ffff"] so such sequence 100 characters the is output: we arrays, "cd" 0 given "cd"], input: you 1000 "eeebffff" targets constraints: parallel consist overlap. targets, simultaneously, does "bc" targets.length [0, testcases "ab", do in complete 2], == indices, "eee". otherwise 1: example, ["eee", performing = targets[i].length find and replace in string find and replace in string find and replace in string find and replace in string find and replace in string
cells: paths of (rightward + visit cell there cells. (downward are n <= with (k, be m, following i example (m a [[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]] 1][n k grid.length -1 no that position return if one to 2: < 1). m 4 from matrix exactly at 3 explanation: (0, j), cells proven movement). above shows initial need * - or -1. number 105 valid 0-indexed (i, 3: your it 1] [[3,4,2,1],[4,2,1,1],[2,1,1,0],[3,4,1,0]] bottom-right exists. 1 image movement), the is output: 1, grid[m grid[i].length 0 given x input: you grid [[2,1,0],[1,0,0]] path, constraints: minimum 0). can integer j grid[i][j] top-left == k) j) starting move 1: visits path reach grid. = minimum number of visited cells in a grid minimum number of visited cells in a grid minimum number of visited cells in a grid minimum number of visited cells in a grid minimum number of visited cells in a grid
[2,3,5,6,7] of subsequence, element first there derived are be <= after [2,4,16]. example a [4,3,6,16,8,2] -1 no that becomes 4. return if square 2: without number. [4,16,2]. remaining an 2 4 every (except from at elements some 2, 3 nums.length explanation: length and if: least * - or -1. streak element) elements. 105 deleting array nums it by each order shown nums[i] not so therefore, subsequence called the longest is output: streak. given sorting choose changing input: you 2. it, constraints: nums, can another 16 integer in previous nums. 1: [4,16,2] = longest square streak in an array longest square streak in an array longest square streak in an array longest square streak in an array longest square streak in an array
104 words, of 180 this x. for any numbers, 6 different rest there are n 8 be <= n, must digit since after note example a rotating alone. numbers 9 rotated that rotation. invalid. if return direction, to 2: unchanged an 2 4 from 10 0, 2, explanation: [1, leave four and they rotating. - or (in other number valid 5, 3: gets integers case it by 10] each 1 degrees, 5 not good rotate 9. the is range output: 1, we themselves, get 0 given choose x input: n]. constraints: remain 6, other, do cannot integer individually in mirrored), : become 1: example: = remains rotated digits rotated digits rotated digits rotated digits rotated digits
of nums[i], [1,3,4,5,8]. has larger k. derived are 8 requirements: be <= difference following note example a k most that no 4. return 2: without adjacent [1]. remaining an 4 from [4,5,8,12]. at elements some 3 nums.length increasing [1,5], explanation: 1. find meet length and 15 meets 3. than [1,3,4,5,8,15] - or requirements elements. 105 5, requirements. 3: deleting array because nums by order 1 5 not so subsequence the longest is output: 1, we given changing [4,2,1,4,3,4,5,8,15], input: you 4, between constraints: strictly 7 does can another integer in 1: [7,4,5,1,8,12,4,7], 5. = longest increasing subsequence ii longest increasing subsequence ii longest increasing subsequence ii longest increasing subsequence ii longest increasing subsequence ii
minutes of led valid. for any 6 [] on watch has order. ["0:01","0:02","0:04","0:08","0:16","0:32","1:00","2:00","4:00","8:00"] are be with represent. <= must reads leading example digits a hour 9 bottom top that which return to 2: zero. an times 4 10 turnedon (0-11), "4:51". all currently and binary "01:00" (ignoring least or leds pm), should number "10:02". contain it possible each answer 1 not significant (0-59). right. bit is the one, output: zero "10:2" 0 represent given input: you "1:00". constraints: consist minute may below integer in represents 1: example, two could hours = binary watch binary watch binary watch binary watch binary watch
3. 104 that letters, the * of "wke", 0 substring. given digits, input: 2: without notice s, repeating "pwke" constraints: symbols characters. 3: is "b", substring, english s be 3 "abc", with <= must substring "bbbbb" s.length answer explanation: 1 example 1. not 5 consists a string find 1: subsequence length "abcabcbb" and spaces. longest "pwwkew" output: = longest substring without repeating characters longest substring without repeating characters longest substring without repeating characters longest substring without repeating characters longest substring without repeating characters
less that no than the of 0 given or choose one return x input: must: you to smallest positive [0,2,0,0,2]. 2: element 2. every number constraints: equal subtract first non-zero from minimum [1,5,0,3,5] third needed. array are nums [0,0,0,0,0]. operations 3 <= each nums.length second integer in now, explanation: 1 nums[i] example non-negative 1. operation, a nums. make already so such [0,4,0,2,4]. 0. 1: 100 [0] is output: = make array zero by subtracting equal amounts make array zero by subtracting equal amounts make array zero by subtracting equal amounts make array zero by subtracting equal amounts make array zero by subtracting equal amounts
= 3. 104 instead. this - value). given return if [2,2,3,1] up: input: returned 2: you o(n) number. (both an they 2. 2 together number constraints: first third maximum nums, 3: have does array is solution? exist, counted are nums can <= follow nums.length second integer in since distinct 1 explanation: [1,2] nums[i] example 1. not same 231 [3,2,1] so 2's (2) 1: find -231 the output: array. third maximum number third maximum number third maximum number third maximum number third maximum number
its most "aabcb" least the of - given return for "abaacc" substrings 500 input: to 2: 17 s, between 2. lowercase constraints: equal characters. non-zero ["aab","aabc","aabcb","abcb","bcb"], beauty are english s <= 3 with each difference sum letters. s.length in "aabcbaa" explanation: frequent 1 substrings. example 1. 5 all consists a only string 1: example, frequencies and is output: = sum of beauty of all substrings sum of beauty of all substrings sum of beauty of all substrings sum of beauty of all substrings sum of beauty of all substrings
write sequence. that the xn of + which 0 never object input: gen.next().value; 2: nothing 50 8, 2 defined constraints: first 5, [] gen.next() 0, xn-1 outputted are relation 2, by <= returns xn-2. 3 function few const // explanation: 1 generator 3, example gen 5 yields a fibonacci numbers so 13. sequence series 1: [0,1,1,2,3] called callcount fibgenerator(); is output: = 1, generate fibonacci sequence generate fibonacci sequence generate fibonacci sequence generate fibonacci sequence generate fibonacci sequence
104 arr[i arr[3] of + for arr, size [arr[i], arr[k] be <= arr. arr.length arr[2] [4,8,12,16] [100] i example comparison [9,4,2,10,7,8,8,1,9] a k 109 even. j: return if to 2: adjacent < an 2 4 maximum elements when arr[j]] explanation: > arr[1] odd, length and only if: * arr[k pair said turbulent 1], subarray 3: array ..., arr 1] each even, 1 flips arr[4] 5 more the is output: sign subarray. 0 given arr[i] input: arr[5] between constraints: odd. or, integer in formally, 1: = longest turbulent subarray longest turbulent subarray longest turbulent subarray longest turbulent subarray longest turbulent subarray
104 positions of needs fall per plank. + any right, reaches different left, [4,3], left[i] [] there on n are end last with <= point, after example (i.e., a index unit that no assume return right.length one to 2: value an plank). plank ant(s) 4 b above: at [0,1] wooden -the some named when take 3 immediately. explanation: out all moves t, meet arrays length and second. they only speed say that, time. t arrays. 4.0000000001, other additional time appear directions their 3: continue going it fall. falls each 7, seconds 1 not walking image right. the is output: we units. 0 [0,1,2,3,4,5,6,7] values given changing input: 4, immediately right constraints: plank, 7 ants have does moment left. can right[i] [0,1,2,3,4,5,6,7], integer in seconds. c again. moving unique, left move 1: ant two [], was change d = left.length last moment before all ants fall out of a plank last moment before all ants fall out of a plank last moment before all ants fall out of a plank last moment before all ants fall out of a plank last moment before all ants fall out of a plank
its [2,3,5,1,3,2] of + smallest exist. element unmarked integers. 7. our there are score. algorithm. with <= following since after example a index that if return one left-most value to 2: adjacent score remaining an 2 4 until at 0, elements as tie, mark nums.length explanation: marked. all repeat and they only above - 106 algorithm: positive apply them, [2,1,3,4,5,2]. 105 array add element: index. nums it 1 nums[i] [2,3,5,1,3,2]. not 5 chosen so elements: is the one, output: we get applying 0 given choose input: you follows: right constraints: 7 [2,1,3,4,5,2] integer element, it: starting left 1: two consisting 5. = find score of an array after marking all elements find score of an array after marking all elements find score of an array after marking all elements find score of an array after marking all elements find score of an array after marking all elements
palindromic = no that the words of words, ["notapalindrome","racecar"] strings, "racecar". given return if input: 2: words.length an first. lowercase constraints: first forward there backward. 3: "" words[i] array "ada" "racecar" empty words[i].length are it english palindromic, <= ["abc","car","ada","racecar","cool"] letters. reads in explanation: 1 but note same example not strings consists a also string, only string so ["def","ghi"] such "ada". 1: 100 returned. "". and is output: array. find first palindromic string in the array find first palindromic string in the array find first palindromic string in the array find first palindromic string in the array find first palindromic string in the array
most will increases made than -1000 this + given return time. [10,11,12] calls input: value 2: to counter 1000 an time function. every constraints: ["call","call","call"] first n. 10 called, ["call","call","call","call","call"] at then is etc). sebsequent n it 2, <= returns be n, each 12 function integer after // explanation: 1 previous example 11 initially a call. -2 counter() 1: called subsequent more and [-2,-1,0,1,2] -2. the output: = 1, (n, counter counter counter counter counter
3] of + [3, modulo 6 properties: arr, element integers. 7. [2, there has k. are n <= be n, consider under following must after i example n). k 109 computed no that which return to value 2: < three an integers: m maximum exactly as mentioned 2, 3 grow 9, explanation: [1, satisify find arrays and only build algorithm positive 50 large, should 2] number 5, 1], 3: array arr integers 1] possible answer 1 100 is the output: conditions. 1, applying 0 ways given arr[i] input: you constraints: equal may (0 where 3, 2], search_cost 1: = build array where you can find the maximum exactly k comparisons build array where you can find the maximum exactly k comparisons build array where you can find the maximum exactly k comparisons build array where you can find the maximum exactly k comparisons build array where you can find the maximum exactly k comparisons
case, of this any rest [25,64,9,4,100], first there is, are 8 last <= with various following after denoting final example k again 109 103 that which 4. if return one square to 2: remaining an every 4 maximum 10 total gift finally, take 3 gifts behind explanation: 29 leave following: and than way: - gifts. choose, number behind. then array gifts, gifts.length [1,1,1,1], each gifts[i] 1 5 chosen can't so 29. more pile. is the output: given choose input: you any. second, piles. constraints: have taken do second integer in [5,8,9,4,3], seconds. pile root floor regardless left 1: so, you. = take gifts from the richest pile take gifts from the richest pile take gifts from the richest pile take gifts from the richest pile take gifts from the richest pile
will false of given return if for one input: to output: 2: goal s. shift lowercase number rightmost shifts constraints: consist on then some it goal, can s position. be <= goal.length english letters. "abcde", s.length, after "cdeab" 1 example shift. strings consists leftmost a moving true character become example, "bcdea" two 1: 100 and the "abced" only = rotate string rotate string rotate string rotate string rotate string
modify 104 way: times. of this becomes given return choose -nums[i]. way. input: you 2: 6 [4,-2,3]. apply largest an [3,-1,0,2], 2) should 2 constraints: -100 3: exactly nums.length array [2,3,-1,5,4]. process nums it 2, may <= with possible 3 modifying replace sum following 4) integer in after i [4,2,3], explanation: 1 indices (1, nums[i] same example 5 [3,1,0,2]. 13 multiple k 1: 100 and the [2,-3,-1,5,-4], index output: = k, maximize sum of array after k negations maximize sum of array after k negations maximize sum of array after k negations maximize sum of array after k negations maximize sum of array after k negations
positions actual of words, this + sqrt(2) customer distances on positions[i] be <= delivery following choosing example a yi make city. answers distance will city that yi] ycentre] which position return 2d-map accepted. to [xi, euclidean value 2: an 2 4 as minimized: customers. [[1,1],[3,3]] explanation: new [1, all [xcentre, minimum. and need build xi, positions.length 50 other [[0,1],[1,0],[1,2],[2,1]] 4.00000 ith map, array wants center 1] possible each sum 1 customers such 100 is the output: 1, we see positions[i].length company 0 given choose achieve. input: you 2.82843 shown, constraints: minimum 10-5 knows can within formula in where service == 1: = best position for a service centre best position for a service centre best position for a service centre best position for a service centre best position for a service centre
[[1,2],[2,4],[4,8]] work 104 finish actual of 6th this for any 22. 6 13, minimumi]: minimumi 12. 31 are 8 be with <= following [[1,7],[2,8],[3,9],[4,10],[5,11],[6,12]] after example 1st [10, 9 will that it. 3rd 4. if return to 2: 17 16. an 2 4 10 20. task, 2nd task 3 tasks[i] start 12 explanation: [[1,3],[2,4],[10,11],[10,12],[8,9]] 1. finishing all 12] 29 tasks.length task. actuali and 11, initial need energy 6. - 5th leftover 32 20 27 though 19 amount 105 ith your 3: array because even 19. begin 17. order 1 not 5 31. 29. current 22 9. require the is output: we now given like. input: you notice 2. constraints: minimum 7 have does energy, can spend do 16 cannot where in [actuali, complete however, order: starting 1: example, tasks. tasks 4th = minimum initial energy to finish tasks minimum initial energy to finish tasks minimum initial energy to finish tasks minimum initial energy to finish tasks minimum initial energy to finish tasks
104 of + [null, -3 calls left, [2, 5], <= with be "sumrange", following calculate example ["numarray", right) -1 "sumrange"] most will type: nums[left return sumrange. to < numarray.sumrange(2, an 2 output input at explanation 0, elements (-1) -1, implement 2, 3 nums.length numarray.sumrange(0, indices nums[left] [[[-2, new numarray -1]); (-5) (-2) and numarray([-2, handle object class: 105 array -5, nums 1] sum sumrange(int 1 nums[i] right. the 1, inclusive made 5]] 2); 0 initializes given -1]], (i.e. between queries right nums) constraints: nums, ... [0, returns nums[right]). -105 integer where // 3, int 2], numarray(int[] nums. left -3] multiple 1: = 5); range sum query - immutable range sum query - immutable range sum query - immutable range sum query - immutable range sum query - immutable
of among for simultaneously. on. any arrival[i], each. available. around assigned first [1,2,3,4], server. requests. [5,2,3,3,3] order. has available servers. are arrives. specific (i load be <= numbered considered since arrival[i] but (not example (0-indexed) handles a k % 109 load, ids complete). most that all). successfully which if return available, one comes to 2: 2 load[i] 4 from at dropped. [0,1,2] single used being 3 increasing start infinite hence explanation: 1. all (i+1)th out [1,2,3,4,5], (i+2)th dropped takes find requests, [0] each, and they [10,12,11] than handle time. [1] handled algorithm: positive server, load.length arrival.length time number 105 assign ith your 3: then array requests k-1 busy, it servers by each necessary). it's 1 [1,2,3], in. list so computational increasing. more busiest is the (wrapping output: 0 given next input: you goal request, containing request arrival.length, constraints: strictly have [1,2,1,2] (the arrival may try integers, k)th another cannot where server(s). in server according otherwise, 3, busiest. while == starting capacity represents multiple 1: example, two = find servers that handled most number of requests find servers that handled most number of requests find servers that handled most number of requests find servers that handled most number of requests find servers that handled most number of requests
= that no (as of + 0 given return if expressed [10,11,12] input: to 2: array) three an 33 we integers. num. 4 way constraints: express 10 33. [] there is as empty integers are can be 3 <= integers, 12]. sum cannot 12 integer 10, explanation: example 11 num, 1015 a so [10, 1: sorted num the output: array. 11, consecutive find three consecutive integers that sum to a given number find three consecutive integers that sum to a given number find three consecutive integers that sum to a given number find three consecutive integers that sum to a given number find three consecutive integers that sum to a given number
blank that grid[i].length the of into [" or given return x grid square ' backslash input: /","/ 2: to 30 an ["/\\","\\/"] recall 2 represented '\' number constraints: \/, /\. composed 3: "/\\" "] regions. as because contiguous n '. are refers <= each array, either /"," grid[i][j] where these explanation: 1 "\\/" note '\\'. example 5 consists a == space '/', string so squares escaped, 1: divide characters grid.length and '\', \ is output: = regions cut by slashes regions cut by slashes regions cut by slashes regions cut by slashes regions cut by slashes
104 of [9,7,7,9,7,7,9], + right, obtain. 6 cards maximize first there optimal on has 12. are score. end be <= cardpoints after choosing giving final example a k 55 k, will several which 4. return one to 2: score three an 2 4 cardpoints. maximum from total exactly take, take 3 strategy taken. 12 row. explanation: [1,2,3,4,5,6,1], 1. all always step, and associated or row, number 105 3: your array each sum 1 5 is the [2,2,2], output: cardpoints[i] beginning given input: you arranged rightmost constraints: 7 have cardpoints.length points card points. can integer in however, regardless 1: two cards. = maximum points you can obtain from cards maximum points you can obtain from cards maximum points you can obtain from cards maximum points you can obtain from cards maximum points you can obtain from cards
its 135 special that * of belong 131. if given return input: to 2: positive n]. 20, except 2 integers. 22, 20 number constraints: 19 interval from there 3: some integers are n <= call n, integer are: explanation: 1 example digits [1, all 5 a distinct. special. not 114, 1: 109 110 and thus, the output: = 11, we count special integers count special integers count special integers count special integers count special integers
of very + covered modulo 4-directionally different five 7. there on has n are be <= n, must since example a tromino shapes. 109 that return if one square to 2: above. adjacent types an 2 every exactly show 3 tilings these explanation: board shape. cells and only board. domino large, number shape occupied tiling, it by answer 1 5 tiles: both such squares rotate the output: ways given x input: you 1000 tile. constraints: have tile may integer in 1: two = domino and tromino tiling domino and tromino tiling domino and tromino tiling domino and tromino tiling domino and tromino tiling
26), of + among for unique. any [2,4,6]. [2,6,4], integers. splits [] there order. has empty are 8 be <= (4 4) following array. note example a also numbers 1010 that no which exists 4. return if [6,8,2,12] accepted. to 2: an 10), 2 4 up maximum as finalsum, splits: 12), 8). 12 summing explanation: all (2 and 3. finalsum): into (unique (6 12) contains positive 28 should them, number split 12, finalsum. valid 3: even integers it sum 6), [6,2,4], 1 6) list [6,8,2,12]. thus, the is output: we [6,2,4,16], finalsum represent given input: you [10,2,4,12], 24). containing (12), constraints: 7 unique may integers, cannot integer in 1: example, [2,4,6] etc. list. = maximum split of positive even integers maximum split of positive even integers maximum split of positive even integers maximum split of positive even integers maximum split of positive even integers
its node.val linked themselves changed.) of 0 values given return [1] [1,2,3,4] input: you output: without adjacent 2: 100]. every constraints: number list's swap head. [] 3: is solve nodes may be [0, <= head modifying must in list, (i.e., example problem a list 1: 100 two and the range [2,1,4,3] only = swap nodes in pairs swap nodes in pairs swap nodes in pairs swap nodes in pairs swap nodes in pairs
browser 90, [3,3] words, location of view + this any for how tag 13, points[i].length [[2,1],[2,2],[3,3]], direction there on are region position. changed. view, be <= angle/2]. point, front but example yi angle sight. format. directly [[1,0],[2,1]], [d that yi] points.length 360 rotation. [2,2] posx, position vision return points[i] one determining [xi, to 2: rotate. above. < an x-y location. angle, 2 plane. 4 maximum angles from counterclockwise. at [posx, as some wide 3 position, coordinates visible degrees coordinate. these explanation: [[2,1],[2,2],[3,4],[1,1]], all always initially, and posy, posy only points, [1,1] - xi, or line shaded other field formed obstruct number location, though 105 amount see. 3: your array even let by denote immediate each facing set if, 1 shown not both rotate 100 is the range output: inclusive integral see made 0 given east input: you posx view. represented constraints: direction. posy] angle/2, does points location.length including points. can may then, do cannot integer where in support same == regardless move multiple represents 1: two video d = maximum number of visible points maximum number of visible points maximum number of visible points maximum number of visible points maximum number of visible points
modify will asynchronously. bar() of times. void foo(), given time. for one calls input: you to passed < different threads 2: 1000 } thread other 2 n; bar(). public b constraints: suppose output code: class there is 0; are n instance foo() be being call <= following fired i explanation: 1 { same example i++) them a while print("bar"); foobar print("foo"); 1: two "foobar" program (int threads: the "foobarfoobar" output: = print foobar alternately print foobar alternately print foobar alternately print foobar alternately print foobar alternately
of + open candies any for unique. 6 box, keys, containedboxes.length labels n are closed, be <= boxes following after initialboxes but containedboxes[i][j] keys[i] example a also initialboxes.length will that it. use if return one to 2: above. < an 4 keys[i][j] maximum from containedboxes[i] box. total at contained take 3 either [[1,2,3,4,5],[],[],[],[],[]], [[1,2],[3],[],[]], explanation: new where: status[i] 1. 1,2,3,4 all containedboxes[i].length closed. find labeled four [0] and inside most. [1,0,0,0,0,0], candy. 6. [[],[],[1],[]], key status.length - or contains containedboxes keys.length [1,1,1,1,1,1], number [7,5,4,100], ith their array it each candies.length 1 not 5 rules closed list so initialboxes[i] opening 0. collected box the is output: 1, get arrays: 0 values given status, input: you candies, 1000 candies[i] 2. constraints: remain 7 have can [1,0,1,0], keys do 16 integer in found keys. initially == have. keys[i].length 1: status = maximum candies you can get from boxes maximum candies you can get from boxes maximum candies you can get from boxes maximum candies you can get from boxes maximum candies you can get from boxes
will ans. kelvin 251.798. that [kelvin, point actual of * 36.50 into + 0 given return decimal fahrenheit accepted. to you ans fahrenheit]. temperature input: 2: places 1000 an should number 273.15 constraints: denotes 10-5 32.00 at is array that: as floating are celsius it 309.65 celsius, convert within celsius. be 1.80 [395.26000,251.79800] 97.70. <= in answer explanation: note example non-negative [309.65000,97.70000] a rounded converted 1: 395.26 two answers and 122.11 the output: = convert the temperature convert the temperature convert the temperature convert the temperature convert the temperature
of 11. any [3, 6 select (nums[i] 7. num[3] are be with operations <= 4) operation after i x). [3,2,4,6] note example non-negative a [1,2,3,9,2] 9 index that return one to 2: an 2 4 maximum elements 2, used 3 nums.length now, update explanation: 108 all and times. (6 apply other 2] number 105 0-indexed then array nums it possible xor. shown xor 1 nums[i] operation, the is output: zero applying 0 given x input: you 4, 2. achieve constraints: equal 7 can may integer in bitwise 3, 11 nums. 1: operation. = i, maximum xor after operations maximum xor after operations maximum xor after operations maximum xor after operations maximum xor after operations
4] of + calls [1,0,1] 6 5] [2, [4,2,5](nums). [2,0,2] are <= with arr. integer. following example also a make 109 signed that use [2,2] element): (second return [4,2,4] operations). to function: 2: test an 2 from total 3 nums.length function explanation: [1, all fits want using generated length (2 elements) calls. 3. -> 32-bit [2,1,2] 2] [4,2,5] number 105 3: array arr (initial)[0,0,0] nums 1] by set answer 1 nums[i] 5 so elements: (1 [1,0,0] the output: modify get 0 values operation). given double input: you (both 0] operations: constraints: minimum have [1,5] convert [0, integer in increment cases same nums. initially. 1: 5. = minimum numbers of function calls to make target array minimum numbers of function calls to make target array minimum numbers of function calls to make target array minimum numbers of function calls to make target array minimum numbers of function calls to make target array
104 garden, of + open ranges[i]] whole there on i-th are n tap ends be <= located i example taps (0-indexed) a ranges[i], n). water -1 will that garden (i.e if return to 2: [0,5] an watered 2 starts cover 4 [i open. [3,4,1,1,0,0] interval at 3 [1,3] explanation: all four length and only - [-3,3] -1. should number n. 5, array ..., even [0,0,0,0] it ranges[i] 1 5 n] opening 100 is the output: 1, means point [4,4] 0 given one-dimensional input: you constraints: [-3,5] minimum points x-axis. can [0, cannot second integer in where [5,5] garden. area [2,4] 3, == 1: ranges ranges.length was = activate minimum number of taps to open to water a garden minimum number of taps to open to water a garden minimum number of taps to open to water a garden minimum number of taps to open to water a garden minimum number of taps to open to water a garden
of this 30 words2[j].length lowercase "is" there are "as" ["b","bb","bbb"], <= ["a","a","a","ab"] letters. but example consists words1[i].length, words2[j] that no return appears 2: 2 exactly "ab". english words2. ["leetcode","is","amazing","as","is"], explanation: string count arrays and words2, only ["a","aa","aaa"] - arrays. number appear words2 3: string. "leetcode" words1 it each words1, occurrences 1 words1[i] not words1. once words2.length "amazing" thus, is the output: we arrays, 0 words1.length, given input: 1000 ["amazing","leetcode","is"] ["a","ab"], constraints: does do in strings 1: two = count common words with one occurrence count common words with one occurrence count common words with one occurrence count common words with one occurrence count common words with one occurrence
of x. arr, (3,1,1), denotes there a, [(3,0,1), are triplets: <= arr.length following i example arr[j], a k |x| no if return to |arr[i] value < 2: three an (arr[i], b 4 (3,0,1), 0, 2, 3 explanation: b, absolute all (0,1,1)]. find conditions and satisfies arr[k]| need - c. true: number array arr integers arr[j]| 7, 1 good 100 is the output: conditions. |arr[j] triplet 0 given arr[i] input: you 1000 constraints: [3,0,1,1,9,7], j where arr[k]) c 1: [1,1,2,2,3], triplets. = count good triplets count good triplets count good triplets count good triplets count good triplets
sequence. = "ababc". of 0 if given word for return contains input: value 2: "baba" 2 times "ac" constraints: lowercase maximum sequence, 3: "ab" is "abab" k-repeating sequence.length english concatenated <= letters. where in explanation: highest 1 example word's not strings "ba" a word.length only string word, sequence k 0. 1: "ababc", 100 and the output: substring maximum repeating substring maximum repeating substring maximum repeating substring maximum repeating substring maximum repeating substring
false '2'. is: of + any for num.length game, game num. 7. characters. first equal. there on optimally, are last ends with be <= must following '0' digit i example digits consists a half: make 9 even. num[i] half. index alice will no that sums if return one to 2: made. an impossible first. 2 "5023" '7'. still at "93295927". when "25??" != take turn, 3 explanation: always proven string true 2+4+3 moves "?3295???" win. length and '9'. num only 8+0+3. 3. least - '9' '?'s wins 105 win, "243801", 3: "9329592?". then assuming because even it possible each replace sum turns not win 5 play "932959??". '?' num: characters more ended the is output: half '?'. 0 given choose input: you outcome "243803", between right constraints: equal playing 8+0+1. player can do second in bob where == replaces starting 1: example, consisting "93295???". = sum game sum game sum game sum game sum game
its of tree. undirected lower-case any different size lowercase labels there on has i. 'b'. are n ans[i] <= with numbered letters. 'b', i ai, edges. example a ai character "bbbb" edges labels[i]). edges.length that no graph which 4. return to 2: < an sub-tree. 2 1,4 4 [[0,1],[1,2],[0,3]], thus from exactly 0, as 'a' nodes node 2, [[0,1],[0,2],[1,3],[0,4]], != english 3 edge explanation: part 1. "abaedcd" descendant all string and only tree than just - t label contains sub-tree edges[i].length number 105 5, ith 3: itself). array [4,2,1,1] each edges[i] 7, answer 1 [3,2,1,1,1] 5 both [2,1,1,1,1,1,1] so form the is output: labels.length 1, bi], means 0 given input: you [ai, notice (i.e. 4, between 2. nodes. constraints: cycles) bi have (the connected, in where "aabab" 3, same [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], root well, == 1: subtree consisting = number of nodes in the sub-tree with the same label number of nodes in the sub-tree with the same label number of nodes in the sub-tree with the same label number of nodes in the sub-tree with the same label number of nodes in the sub-tree with the same label
104 case, of this any 6 tile.) done, first equal. on [5,2,6,2,3,2] are be with <= example a tops[i] numbers make (a domino, -1 bottom top that return same. if one to value 2: 2 every figure. from indicated row as before 2, explanation: dominoes all and fourth * [2,1,2,4,2,2], - or dominoes, tops domino -1. number ith tops.length it by possible each tops[i], 1 not so rotate [3,6,3,3,4] the is output: domino. we half bottoms values represent given figure input: halves constraints: equal minimum swap tile same, can may bottoms.length rotations. do bottoms[i] cannot rotations in second [3,5,1,2,3], bottoms: == represents values. 1: two = minimum domino rotations for equal row minimum domino rotations for equal row minimum domino rotations for equal row minimum domino rotations for equal row minimum domino rotations for equal row
during false 6th 'a'). any 6 shift around lowercase first 'z' there has 'b'. alphabet obtain <= operations be 'u'. letters. s.length, i example a less. (1-indexed) 1st character 9 k "input", index moves, 'n' most that no "bcd", becomes if return shifting one to once. 2: remaining 'o'. times can: "ouput", way from 10 at 'a' english move. explanation: 7th true moves t, 10^9 and nothing. only than need times. into 'b' or t picked s, other s. time 27 'i' ith your 3: contain it false. by s been possible "abc", each it's s.length 27th 1 not chosen so such characters (1 more the is (wrapping output: we means applying get replacing 0 given choose next input: you t. goal remember constraints: can convert letter do second in j previous strings however, k) "aab", otherwise move t.length 1: two move, "bbb", 10^5 = can convert string in k moves can convert string in k moves can convert string in k moves can convert string in k moves can convert string in k moves
b. of among for any different 7. [2, there are <= various tree, example a node.val which if value to 2: an b 4 maximum some 13| nodes node 3 explanation: all 7| find and binary tree - or number 105 exist ancestor differences, by possible [1,null,2,null,0,3] |a.val ancestor-node 5 |8 is the range output: we 0 given child [8,3,10,1,6,null,14,null,null,4,7,13] 3| input: |10 constraints: equal 7 have 5000]. obtained below 1| v where in b.val| |3 root : either: 1: = maximum difference between node and ancestor maximum difference between node and ancestor maximum difference between node and ancestor maximum difference between node and ancestor maximum difference between node and ancestor
of "aa", + this for different "abcbabcbcb" 1-indexed). ["a", "bac", there order. "b", empty are n "cac", <= "baa" consider "bab", 'b', i "c"] example consists a "b" "bcb", letters "c" k 9 k, ["aba", will return if to 2: 'c']. an 4 from 10 "c". != 3 strings. "cab", 12 "cba", explanation: 1. all "ac", 9th string find length and only than "aca", - or contains "cab" "bca", "acb", n. third s[i 3: integers 1] "abc", set s.length 1 not list s[i] happy 100 is the output: 1, less values given input: you constraints: "" (string "ababbc" that: "cbc"]. kth lexicographical in 3, strings 1: example, two sorted ['a', = the k-th lexicographical string of all happy strings of length n the k-th lexicographical string of all happy strings of length n the k-th lexicographical string of all happy strings of length n the k-th lexicographical string of all happy strings of length n the k-th lexicographical string of all happy strings of length n
(x 104 persons of + x. any sends 0.5 y. y [16,16] there on are n y, <= following person. 110, note example a people ages 16, will that person if return to 2: < 17 made. an also, 2 total [20,30,100,110,120] friend != 3 ages[i] media explanation: age > age[y] conditions other. social -> * age[x] send true: themself. number ith 3: array requests each 100, 17. necessarily 1 not ages.length 100 [16,17,18] 18 the is output: made y) website. && given x input: you request constraints: 7 integer where otherwise, 120 100. == 1: 110 = friends of appropriate ages friends of appropriate ages friends of appropriate ages friends of appropriate ages friends of appropriate ages
its 104 paths of tree. undirected for 6 denotes [] there n are be with <= numbered node, following ending considered 4.) ai, edges. note example treated value. consists a also ai [[0,1],[1,2],[2,3],[2,4]] node's vals[2] edges edges.length no that graph vals.length exists 4. return one bi] to value 2: < an 2 vals[0]. 4 maximum from exactly as counted nodes single node paths. != 3 2d [1,3,2,1,3], edge distinct explanation: bi. all > vals[i] along length and only satisfies tree 3. than -> connecting * - or additional should edges[i].length number 105 valid 0-indexed ith 3: array because edges[i] node. 1 path). 5 path: not so good 0. the is path. output: conditions: reverse less 0 simple values given [1], input: you [ai, (i.e. between constraints: cycles) equal bi vals 7 have (the connected, [[0,1],[0,2],[2,3],[2,4]] integer where same == starting paths: represents 1: example, path [1,1,2,2,3], consisting = number of good paths number of good paths number of good paths number of good paths number of good paths
match. of this photo student line. are be <= heights[i] example a stand that return to 2: an [1,1,4,2,1,3] trying file expected asked single 2, != take 3 indices explanation: all expected[i]. and annual students expected[i] [1,2,3,4,5] [5,1,2,3,4] line heights height. number [1,1,1,2,3,4] ith 3: standing array heights: let by each school students. order 1 in. 5 not current 100 is the output: non-decreasing ordering 0 height given input: you heights.length 4, represented constraints: representing (0-indexed). do integer in where 1: expected: = height checker height checker height checker height checker height checker
tree inclusive [10,5,15,3,7,13,18,1,null,6], node.val * of + search values given high, return 32. [6, low input: value output: 2: 6 32 unique. 23 [low, 2 [10,5,15,3,7,null,18], constraints: number 10]. 105 7 10 23. high]. [7, 104]. is 15]. integers 6, nodes are node <= with sum 7, in 10, explanation: 1 example root all [1, a 1: two and 15 the range binary = high range sum of bst range sum of bst range sum of bst range sum of bst range sum of bst
starty) of + this any space. 7. first there road optimal has go are starty] |y2 be with [1,1], <= (targetx, ending (3,4). example startx a also space x2i |7 y2i) (startx, edges costi] smaller directly special y2) that use position return (x2, to 2: an 2 specialroads from roads. total [[1,2,3,3,2],[3,4,4,5,1]] specialroads.length y1i, x1| some |1 costi take [targetx, start 2d explanation: targety). 1. required y1i) indicates targety following: and uses initial (1,2). than -> times. [[3,2,3,4,4],[3,3,5,5,5],[3,4,5,6,6]] - [startx, 200 edge, other (x1i, specialroads[i].length number (4,5) [5,7], 105 ith your array target costi. y2i going it each cost |5 1 shown 5 not so |2 specialroads[i] is the output: (1,1) we [4,5], target.length given 2| 3| y1|. input: you (x2i, (1,2) 2. [x1i, achieve constraints: equal minimum 7 (3,4) starty start.length can 1| y1) (3,3) x1i, (4,5). cannot |4 second where in (3,3). |3 targetx |x2 x2i, == starting [3,2], represents (x1, move 1: path targety] 5. = y2i, minimum cost of a path with special roads minimum cost of a path with special roads minimum cost of a path with special roads minimum cost of a path with special roads minimum cost of a path with special roads
different. (inclusive). 104 >= of ri queries[i] for |a[i] a[i] a[j]|, contiguous queries.length are -x ans[i] <= be [0,1]: must difference array. [1,3,4,8], i [2,3]: note example a as: -1 |x| [4,5,2,2,7,10] that [2,2] li [[2,3],[0,2],[0,5],[3,5]] 4. if return same. value to queries[2] < 2: |1-3| an [[0,1],[1,2],[2,3],[0,3]] [2,7,10] 2 [4,5,2] as elements [3,4] != compute ri]. [1,3] nums.length indices explanation: 1. absolute all [0,2]: query. and [4,8] [4,5,2,2,7,10], [1,2]: 3. * queries[0] - -1. [0,3]: [5,2,3,7,2] 105 nums[li...ri] subarray ith [0,5]: array |7-10| because a[j] |3-4| queries[1] nums it each answer 1 nums[i] not |2 sequence 0. 100 a[j]. the is output: [li, 0 given 3| x 0-based you ans input: follows: between queries 2. defined containing |4-5| [1,3,4,8] constraints: query minimum queries[3] [2,1,4,1] same, [-1,1,1,3] integer where j in a.length [3,5]: processed |4-8| 1: example, = i, minimum absolute difference queries minimum absolute difference queries minimum absolute difference queries minimum absolute difference queries minimum absolute difference queries
arr[3] none of this for any arr[0] there has k. are n (5 [5,4,3,2,1], arr[i]. <= operations be (4 arr.length because: integer. arr[2] since i but note example [4, a make k index will that suboptimal arr[i-k] k-increasing k-increasing, arr[1]) if return one description. [4,1,5,4,6,5]. to 2: [4,1,5,2,6,2], an 2 every 4 as holds some 2, take perform 3 satisfying indices explanation: them required > all 5) already arr[1] arrays and (2 only than need into arr[i-3] or positive other formed 2] number 105 5, 0-indexed 3: arr[3]). array operations. because arr it by 1 shown arr[4] 6) to, not operation, 5 problem called require (1 the is output: 1, we n-1. less now [1,1,1,1,1], 0 ways given resultant arr[i] choose changing input: you arr[5] 2) non-decreasing. here, constraints: minimum [5,6,7,8,9], would ones [2,2,3,4,4]. 6, can [6,7,8,9,10] integers, (because do cannot integer where in arr[i], same however, 1: example, consisting change 5. arr[i-2] = i, minimum operations to make the array k-increasing minimum operations to make the array k-increasing minimum operations to make the array k-increasing minimum operations to make the array k-increasing minimum operations to make the array k-increasing
get that replacing of beginning given return input: you 2: "2?:?0" "19:22" format 23 between hh:mm. time times constraints: (represented ?). hidden valid from minute produce "09:39" 3: is string. 23:59. digits. some latest are 50. it can by 00:00 with hh:mm, "0?:3?" "1?:22" "23:50" inclusively ending digit in where '0' guaranteed explanation: example digits a string those form hour 1: '2' and the output: = latest time by replacing hidden digits latest time by replacing hidden digits latest time by replacing hidden digits latest time by replacing hidden digits latest time by replacing hidden digits
1)th of + enter student for formed. 6 has 12. are (i be with <= non-empty following [12]. since example a 1st grades.length that grades[i] like which 3rd return to 2: an 2 way (except maximum 10 total 2nd 3 forming these explanation: count: all groups. meets only students than into - lead positive university. number 105 ith ordered array it possible sum 18. 1 shown groups 5 not [10,3,5]. both groups, form such 13. competition last). more grades: is the output: conditions: we less group, ordering [8,8] given input: you students: [6,7]. constraints: equal would 7 group can integer in [10,6,12,7,3,5] grades represents 1: = maximum number of groups entering a competition maximum number of groups entering a competition maximum number of groups entering a competition maximum number of groups entering a competition maximum number of groups entering a competition
its tree null node.val separated 104 less than nary-tree the [1,3,5,6,2,4] of 0 height given return [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] [1,2,3,6,7,11,14,4,8,12,5,9,13,10] or up: input: value 2: to you level an represented traversal constraints: number equal solution iteratively? input their 104]. recursive range nodes it group by [0, <= follow each do children examples) in tree, order [1,null,3,2,4,null,5,6] example traversal. root nodes' (see serialization 1000. values. 1: trivial, could preorder is n-ary output: = n-ary tree preorder traversal n-ary tree preorder traversal n-ary tree preorder traversal n-ary tree preorder traversal n-ary tree preorder traversal
follow-up: [3,3], of + 6 smallest largest element [4,-2,-3,4,1] solution contiguous are <= with difference non-empty array. example a 109 [1,3,3], 4. return 59 2: an 2 complexity? 4 elements 3 nums.length explanation: all find following: subarrays and [2,3], - 59. time subarray 3: array [1,3], nums sum 1 nums[i] [1,2,3], [1,2,3] so sequence the is range output: subarray. [1], 0 given -109 input: you o(n) 1000 between constraints: [2], within integer in nums. 1: [3], [1,3,3] ranges could [1,2], = sum of subarray ranges sum of subarray ranges sum of subarray ranges sum of subarray ranges sum of subarray ranges
will least [5,5,4], of remove 0 given or arr[i] one input: 2: 1s three an 4, 2 elements. number constraints: removing exactly is array unique 3s. k. arr integers left. single be 3 <= arr.length either integer after explanation: 1 example 5 only [4,3,1,1,3,3,2], 10^9 find k 1: two 10^5 and the output: = least number of unique integers after k removals least number of unique integers after k removals least number of unique integers after k removals least number of unique integers after k removals least number of unique integers after k removals
write = that the of reverses this given input: you 2: an s. extra printable constraints: ["h","e","l","l","o"] 105 memory. input string. array as ascii by o(1) s with <= do must modifying function character. s.length 1 ["h","a","n","n","a","h"] example a ["o","l","l","e","h"] string s[i] 1: characters is output: in-place reverse string reverse string reverse string reverse string reverse string
will of like given return substrings "a", input: to 2: 6 "...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....". s, present 2 "c") lowercase number base. constraints: "za", 105 there 3: ("z", is "a" unique six "b", define are english s be this: <= "ab", look non-empty substring letters. s.length in "cac" infinite explanation: 1 "zab") base example consists a "abcdefghijklmnopqrstuvwxyz", only string so ("a", 1: two wraparound "zab" and the output: = we unique substrings in wraparound string unique substrings in wraparound string unique substrings in wraparound string unique substrings in wraparound string unique substrings in wraparound string
"lee(t(c)o)de" positions of valid. any lowercase characters. empty are be with <= example a also (a ) that remove strings, return if accepted. to 2: ab an b ( as "))((" english task "lee(t(co)de)" explanation: string and only "lee(t(c)o)de)" if: parentheses or contains b), characters, number resulting 105 valid 3: your string. (a), "lee(t(c)ode)" '(' it s "a)b(c)d" either'(' s.length 1 , so s[i] letter. is the written output: "ab(c)d" given ')' input: ')', constraints: minimum would "" can concatenated in where formally, string, 1: = minimum remove to make valid parentheses minimum remove to make valid parentheses minimum remove to make valid parentheses minimum remove to make valid parentheses minimum remove to make valid parentheses
false 4] [4], of [null, calls implementation size design []] deletefront, k. adds last <= with insertfront() be mycirculardeque.insertlast(2); operation insertfront, front empty, deletelast, example [[3], true, a k -1 mycirculardeque.deletelast(); most will if return deque value to successful, mycirculardeque an 2 getfront, 4 double-ended output maximum from deletes input mycirculardeque.getfront(); at explanation 2000 getfront() implement rear 2, queue new "insertlast", true item mycirculardeque.getrear(); or deque. deletefront() "getfront"] class: circular otherwise. your insertlast() mycirculardeque(int deletelast() mycirculardeque.insertfront(3); 1 ["mycirculardeque", mycirculardeque.isfull(); "isfull", empty. is the (deque). mycirculardeque.insertfront(4); made full, [1], 0 initializes "deletelast", "getrear", 1000 insertlast, getrear() constraints: [2], isempty, boolean mycirculardeque(3); isfull() full. returns mycirculardeque.insertlast(1); // int isfull. k) false, getrear, 1: isempty() [3], [], "insertfront", = design circular deque design circular deque design circular deque design circular deque design circular deque
most 104 text that use of lower 0 given return word "nlaebolko" formed. input: to you once. 2: instances 2 number constraints: maximum text, 3: at "leetcode" as possible. case english can be <= "balloon" each only. in 1 example many consists a string text.length form character "loonbalxballpoon" letters want 1: characters the output: = maximum number of balloons maximum number of balloons maximum number of balloons maximum number of balloons maximum number of balloons
[0,1], of tree. undirected reply any unique. vj] [1,0] about there has guessed guess. her uj, n are be with <= parent guesses tree, ai, but example a vj. ai make [uj, bi, k guesses. edges alice k, will edges.length that several no [[1,0],[3,4],[2,1],[3,2]], exists return if one bi] to 2: an 2 from at [1,0], as 0, [3,4] nodes 2, node != being 3 allows alice's 2d edge distinct explanation: vj 1. correct indicates says considering find arrays labeled following: length and give tree [[0,1],[1,2],[2,3],[3,4]], least just - or [[0,1],[1,2],[1,3],[4,2]], lazy, number his 105 valid guesses[j] array [1,3], integers wants by possible each edges[i] [3,2] she 1 [[1,3],[0,1],[1,0],[2,4]], tells not 5 chooses [2,1], such 0. edges, the is uj output: 1, [u, 0 given input: [ai, 4, between guess, represented constraints: u bi does he can v integer where in bob [2,4] v] bob's guesses, true. 3, root == [3,2], leads represents 1: guesses.length two = count number of possible root nodes count number of possible root nodes count number of possible root nodes count number of possible root nodes count number of possible root nodes
|2-2| of this [7] any 6 [2,4,7] size <= with non-empty difference since example |8-2| 109 [8,2] that diff |8-8| 4. return to 2: an 2 4 [8,2,4,7] maximum elements 3 nums.length limit. explanation: absolute all > subarrays and than limit or [2,4,7,2] [10,1,2,4,7,2], 105 subarray [8,2,4,7], 3: array integers limit, nums |2-7| [8,2,4] |4-7| 1 nums[i] 5 [2] such therefore, [4,7] the is longest output: less 0 |2-4| given input: between 2. |7-7| constraints: equal [4,2,2,2,4,4,2,2], integer are: [2,4] [4] 1: two [8] |4-4| 5. = longest continuous subarray with absolute diff less than or equal to limit longest continuous subarray with absolute diff less than or equal to limit longest continuous subarray with absolute diff less than or equal to limit longest continuous subarray with absolute diff less than or equal to limit longest continuous subarray with absolute diff less than or equal to limit
of cell over there empty are n be <= m, following ending note example walk anywhere grid.length non-obstacle (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2) -1 that no 4. return (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3) one square to once. be: 2: an (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3) 2 (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3) m every 4 from exactly explanation: walks 1. [[1,0,0,0],[0,0,0,0],[0,0,2,-1]] four and 3. square, * obstacles 20 number 3: array 1 squares 4-directional square. is the output: we cell. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2) grid[i].length 0 given over. grid x you input: (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3) 2. constraints: representing have [[1,0,0,0],[0,0,0,0],[0,0,0,2]] [[0,1],[2,0]] can cannot integer where grid[i][j] in == starting paths: 1: two path could grid. = unique paths iii unique paths iii unique paths iii unique paths iii unique paths iii
startvalue. of -3 6 +2 startvalue (5 be with <= (4 calculate example right). [-3,2,-3,4,2] ) that return if value to 2: an 2 4 elements plus 3 nums.length start explanation: [1,2] 1. (2 iteration initial | than positive should [1,-2,-3] -100 positive. third 3: your iteration, array +4 integers nums by each sum (3 1 nums[i] 5 such 100 (1 is the output: less step 0 given never choose input: you 4, constraints: minimum 7 nums, (from (0 in left 1: = minimum value to get positive step by step sum minimum value to get positive step by step sum minimum value to get positive step by step sum minimum value to get positive step by step sum minimum value to get positive step by step sum
most false "110" zeros, of given return if one or contains input: output: 2: without constraints: ones at is contiguous false. s <= do either '0' leading s.length '1'. segment. ones. explanation: 1 otherwise, example "1001" not s[0] a string true s[i] form 1: 100 segment the binary = check if binary string has at most one segment of ones check if binary string has at most one segment of ones check if binary string has at most one segment of ones check if binary string has at most one segment of ones check if binary string has at most one segment of ones
most subarray. that of into [1], values becomes given return 0 500 arr[i] input: to value 2: test arr, largest 32-bit an 4 83 [1,15,7,9,2,5,10], changed constraints: maximum subarray their 3: at has array k. arr 84 (contiguous) partitioning. partition are <= 3 each integer. [15,15,15,9,10,10,10] sum arr.length integer in after answer explanation: [1,4,1,5,7,3,6,1,9,9,3], 1 cases example partitioning, a so fits become generated 1: k subarrays length 109 the output: = partition array for maximum sum partition array for maximum sum partition array for maximum sum partition array for maximum sum partition array for maximum sum
9: applied of needs this for num.length smallest integers. num. about there k. digits. "5489355412" are "5489355142": 8 be with <= integer. "00132" digit example digits many consists "21111" a smallest-valued 1st k "11112" index that swaps number: wonderful 3rd if return value to 2: adjacent an 2 way 4 large "11112", "21111". some when 2nd 3 ones. explanation: "5489355142", string generated "11121" and num only "5489355142" than -> - "12111" permutation number 3: it "00132". "5489355214". "5489355421" greater exists. 1 "00123", num, "5489355421". such the is output: we integer, get "5489355412". 0 given input: you 1000 4: constraints: tests representing minimum swap 7 "00123" "11211" 8: kth "5489355241". care can call integer in however, 1: example, reach 4th = minimum adjacent swaps to reach the kth smallest number minimum adjacent swaps to reach the kth smallest number minimum adjacent swaps to reach the kth smallest number minimum adjacent swaps to reach the kth smallest number minimum adjacent swaps to reach the kth smallest number
104 alex of this open occupied. any seat, there has empty are sits maximized. last <= person. example a seat distance seats[3]), that person [1,0,0,0,1,0,1] return if seats[2]), one to 2: an 2 maximum row at [0,1] 3 sit explanation: 1. away. and 3. least * or other seats possible, ith 3: then array wants him answer 1 so such empty. thus, is the output: 0 given input: you seats.length (i.e. between 2. constraints: representing (0-indexed). seats[i] closest sitting. second where in [1,0,0,0] sitting represents 1: = maximize distance to closest person maximize distance to closest person maximize distance to closest person maximize distance to closest person maximize distance to closest person
false equations[i] of equations[i].length names xi equations[i][0] different ["a==b","b!=a"] lowercase first there are variable <= but (not example a yi letters ["b==a","a==b"] 500 that no different) return if equations[i][1] one to satisfied, 2: an b 4 way "xi!=yi".here, as equations either equations. explanation: equations.length all string true takes '='. length and second. say, or variables equations[i][2] otherwise. assign satisfy then array equation integers names. it possible each relationships necessarily 1 not both so equations, letter. the is output: 1, we forms: represent given input: you between constraints: equations[i][3] '!'. "xi==yi" where '=' strings == one-letter 1: two could = satisfiability of equality equations satisfiability of equality equations satisfiability of equality equations satisfiability of equality equations satisfiability of equality equations
[[1,1],[4,5],[3,8]], of + unique. [[1,6],[3,9],[4,5]]. weighti] properties: 7. ret items2.length has are weight valuei. 8 [[7,1],[2,2],[1,4]] be with <= item. following example value. a ret[i] [[1,7],[2,4],[7,1]] [[1,7],[2,4],[7,1]]. [[1,4],[2,4],[3,4]] items 4. items[i] return [[1,1],[3,2],[2,3]], value 2: 2 4 total weighti], weights 2, being 3 2d explanation: 1. occurs all items. items1.length, and 6. item ascending [[1,6],[3,9],[4,5]] should 5, [[1,3],[2,2]], ith 3: array [valuei, sets by items2 each sum order 1 5 therefore, 9. is the output: [[3,1],[1,5]] 1, we items2, valuei arrays, given [[2,1],[3,2],[1,3]] valuei, returned you input: weighti 1000 note: 4, constraints: representing 7 integer where in items1 items1[i].length 3, [[1,4],[2,4],[3,4]]. items2[i].length == represents 1: two 5. = merge similar items merge similar items merge similar items merge similar items merge similar items
case-sensitive. of suits.length any "flush" cards five "pair" first hand. kind" has "three kind". are card": be with <= suit. following type hands suits but note example consists a also best make "pair": character [13,2,3,1,9], that no worst: return rank. to 2: [4,4,2,4,4], three an types 2 from "flush": suit, 'a' single used 3 explanation: all string and "flush". fourth rank better suit poker or suits[i]. "high other [10,10,2,12,9], ith 3: array ["a","b","c","a","d"] card. 1 13 5 so ["d","a","a","b","c"] hand the is output: ranks[i] we first, ranks suits[i] kind": values given "pair". input: you second, constraints: representing have card can ranks.length cannot second integer where ["a","a","a","a","a"] same == 'd' suits. 1: two could cards. = rank, best poker hand best poker hand best poker hand best poker hand best poker hand
total. of steps lowercase "a2345678999999999999999", are <= "leet2code3", with repeated following letters. digit guaranteed example digits consists a (1-indexed) 1st character letters "hahahaha". k 109 263 letter, k, d, that tape, if return one to 2: an 2 times decoded starts 8301530446056247680 10 at english explanation: encoded string onto length and taken: "a" than times. "leetleetcodeleetleetcodeleetleetcode". - 5th or s. time 3: string. tape. it "o" s s.length through 1 "h" decode 5 "h". "ha22", current tape 100 9. letter. more the is written output: less "a". given "o". input: you constraints: equal read have kth letter integer in 1: entire 10th d = repeatedly decoded string at index decoded string at index decoded string at index decoded string at index decoded string at index
its 104 of tree. 11. [5,4,9,1,10,null,7] any different 7. has [0,0,0,7,7,null,11] are [3,1,2] <= with after tree, 105]. note example a parents. modified 9 edges node.val that it. if return value to 2: 2 4 from 10 nodes node 3 explanation: [1, all and they binary above tree shows initial cousin - number diagram each replace sum node. 1 [0,0,0] 5 not cousins so 0. is the range output: values given changing input: constraints: 7 have does depth cousins' in same root values. 1: two path = cousins in binary tree ii cousins in binary tree ii cousins in binary tree ii cousins in binary tree ii cousins in binary tree ii
integer, smaller 1]. "0" the of which 0 - given return if input: 2: smallest an between 2 zeros. defined integers. palindrome. constraints: representing there have does closest as range itself), digits. palindromes tie, n including are <= difference leading integer in 1018 "121" explanation: but 1 (not one. example n.length absolute consists a only not [1, string "123" 1: 0. two "1" and 18 is minimized output: = we find the closest palindrome find the closest palindrome find the closest palindrome find the closest palindrome find the closest palindrome
that words of words, like given return one input: output: 2: words.length (both an typed 20 lowercase constraints: first third [] 3: on row "zxcvbnm". words[i] array alphabet keyboard: ["omk"] words[i].length english can be <= ["adsdf","sfd"] second "qwertyuiop", in 1 ["alaska","dad"] keyboard example image strings consists "asdfghjkl", below. ["hello","alaska","dad","peace"] letters american uppercase). using 1: characters 100 and the only = keyboard row keyboard row keyboard row keyboard row keyboard row
"9876", of + smallest '9', "4321" are n 8 created be <= 'i', must following digit note example digits consists a letters num[i] num[i+1]. most that if return "8742". to once. 2: < 'd'. 4 at 0, some used 2, "245639871", "iiididdd" increasing indices explanation: num[i > proven string meaning using length and num "135749862", meets only than "ddd" "123849765". 5, 0-indexed 'i' then because decreasing. it possible pattern[i] each 'd', 1 not lexicographically characters more is the output: 1, conditions. conditions: 1]. we values given input: you pattern constraints: 7 '1' have pattern.length 6, "123414321" can "7321", where "123549876" 3, == 'd' 1: consisting = construct smallest number from di string construct smallest number from di string construct smallest number from di string construct smallest number from di string construct smallest number from di string
tree top node.val see of yourself values given return [1,2,3,null,5,null,4] input: you to output: 2: 100]. it, right [1,null,3] constraints: number -100 from bottom. [] 3: on standing ordered is range nodes can [0, <= imagine side [1,3] in tree, example root a 1: 100 the [1,3,4] binary = binary tree right side view binary tree right side view binary tree right side view binary tree right side view binary tree right side view
b. is: of "aa", this non-empty, for "", "cbca", largest word2.length "dv", lowercase word1: first has word1. larger "cabaa", are end <= corresponding following letters. after choosing "abaa", example "cb", a "baa", character "caaa" differ, "cbcabaaaaa" (of position if return one to 2: "abdcabcabcaba" word1.length, remaining append "abcc" b way from at "abc" 3000 word2: english take either explanation: construct. "cbc", string want "cbcab", and they only word2 fourth a's than way: - or delete c. merge then options: because "abcd" it character, construct greater 1 5 operation, lexicographically is the output: "aaa" "bcaaa" get "abdcaba" word1 "a". "abcabc", given choose "dva". input: you constraints: strictly consist "bc" can differ length) in where same merge. strings "c", while word2. 1: example, two d = largest merge of two strings largest merge of two strings largest merge of two strings largest merge of two strings largest merge of two strings
19, of for target. rearranged extra 7. lowercase copies first there 12. are be "code". <= letters. note example a make letters index "aaaaa" most that "ecod" which return one to 2: an 2 maximum from 10 20. at 0, some "abc" 'a' 2, english take 3 strings. 9, indices explanation: new them 1. "abbaccaddaeea", copy "code" and "abcba", into 'b' formed "abc". number 5, 0-indexed "code", them. reuse 3: target taking by s "ilovecodingonleetcode", "abc", s.length 1 both so form 100 the is output: 1, we rearranging target.length given input: you 17, 4, 2. constraints: consist rearrange 6, can letter "aaaaa", cannot second 18, 3, strings while 1: two 'c' = rearrange characters to make target string rearrange characters to make target string rearrange characters to make target string rearrange characters to make target string rearrange characters to make target string
palindromic that least need digit. use of given return one formed. input: you to 2: returned consisting (in num.length largest "7449447" "7449447". formed should num. constraints: 105 from "444947137" "00009" at is contain zeroes. notes: digits. are it can be <= taken reordered. do must leading only. integer explanation: shown but 1 note example "9" digits not all num, a consists string form string) using 1: "4449477" num the output: = largest palindromic number largest palindromic number largest palindromic number largest palindromic number largest palindromic number
1]). [7,5,10,9,6], of (1+3+3) + for min(nums2[i0] min(2,3,4) 30 7. nums2. 12. nums1[2] k. derived are n score. be with [1,3,3,2], <= must choosing i1, example simply a as: k index nums1.length that no 1]) nums1[i], which return (nums1[i0] 2: score an +...+ 2 n-1} maximum from 10 nums2[i1], 0, elements some 2, 3 12 optimal: indices (3+3+2) explanation: min(2,1,3) nums2.length nums1[i1] arrays four length and nums2[2] 6. * [2,1,3,4], nums1[ik - or positive scores (1+3+2) elements. [4,2,3,1,1], 105 0-indexed your deleting array ..., {0, it by possible sum set multiplied score, min(1,3,4) 1 nums1 chosen , therefore, subsequence min(2,1,4) nums2 the is output: 1, we ,nums2[ik ik 0 given choose input: you defined constraints: equal minimum ... max can integer selected nums2[j] are: 8. == 1: two i0, = maximum subsequence score maximum subsequence score maximum subsequence score maximum subsequence score maximum subsequence score
104 graph: than connected component of * undirected - [4,6,15,35] values given if return unique. input: you to nums[j] 2: positive largest [20,50,9,63] an size between 2 4 constraints: 105 1], there graph. nodes, 3: is array unique integers nums[nums.length are nums 8 <= [2,3,6,7,4,12,21,39] consider nums.length following nums[0] integer share factor greater in edge 1 nums[i] 1. example all a common nums. 1: labeled and the output: = largest component size by common factor largest component size by common factor largest component size by common factor largest component size by common factor largest component size by common factor
its bits during of ["1"] any size there has latest contiguous n are be <= 1-indexed) n, arr.length substring i "1", example 5: a also numbers ["11111"] ["1", m. -1 that no exists, which exists position return if "00100", 4. to 2: zero. an 2 "10111", m 4 from exactly at "10101", either explanation: 1. all "11111", string "1"] "111"] find length and binary "11101", 1's permutation [3,5,1,2,4], -1. "10100", n. 105 3: array "00101", arr integers it each set 1 distinct. both such bit is the output: step given arr[i] input: you (assuming groups: 4: constraints: ones direction. have ["111", group [3,1,5,4,2], extended cannot integer in initially == represents 1: step. = find latest group of size m find latest group of size m find latest group of size m find latest group of size m find latest group of size m
104 that assume the of -1000 + 0 -104 given return one 500 solution. to target. you input: 2: [0,0,0], 1000 three an 2 2. integers. constraints: would input have exactly 0). array closest target integers n nums may <= 3 each nums.length sum (0 integer in explanation: 1 nums[i] example (-1 such find 1: 0. length and target, [-1,2,1,-4], is 2). output: = 3sum closest 3sum closest 3sum closest 3sum closest 3sum closest
of floor: denotes on are <= with '0' note example black a black. also able carpetlen that no which return white. one to 2: numcarpets 2 cover another. way tiles still floor.length 2, 3 overlap either visible carpets explanation: tiles. "11111", string leave visible. floor, "10110101", minimum. length and only binary above shows than or other number 0-indexed ith carpetlen. hand, each '1'. 1 colored such is the output: less 0 given carpets, figure input: you 1000 floor[i] constraints: colors minimum '1' have tile covering can may floor represents 1: = white minimum white tiles after covering with carpets minimum white tiles after covering with carpets minimum white tiles after covering with carpets minimum white tiles after covering with carpets minimum white tiles after covering with carpets
(2, is: of for 6 respectively. different game there optimal available a, are score. 8 <= with non-empty 4) after (1, example moves). a solitaire 1st total: stops piles, no 3rd return one to 2: score three b fewer maximum from until 0) 0, get. when 2nd 2, take 3) explanation: b, 6). (0, turn 5) piles moves each, and they than that, - ends. 8, (3, 105 3: your stones add integers state each set turns 1 6) so more empty. is the output: 1, now point (meaning given choose input: you 4, 2) constraints: 7 playing points. can c, 1) (4, 3, stone c starting sizes 1: two = maximum score from removing stones maximum score from removing stones maximum score from removing stones maximum score from removing stones maximum score from removing stones
follow-up: constant of any select integers. solution impossible, on solution? are n complexity o(1) <= with operations [2,6,1,4]. be gcd(1,4) following operation i but example value. a make times: -1 index [2,10,6,14] that nums[3] return if to 2: < an impossible 2 4 greatest elements [2,6,3,4] either nums.length explanation: 1. all works, find and - 106 or positive 50 -1. nums[1] time gcd(6,1) number 0-indexed their array [1,1,1,4]. integers nums it replace 1 shown nums[i] common nums[2] nums[i+1] such gcd(3,4) is the output: we now [2,1,1,4]. gcd 0 divisor given choose input: you o(n) operations: constraints: equal minimum have can do nums[0] [1,1,1,1]. consisiting 1: two could gcd(2,1) = minimum number of operations to make all array elements equal to 1 minimum number of operations to make all array elements equal to 1 minimum number of operations to make all array elements equal to 1 minimum number of operations to make all array elements equal to 1 minimum number of operations to make all array elements equal to 1
its this for any temperature 30 day. 25). about on order. 2015-01-04, with following type example day a weather +---------------+---------+ table. 2015-01-02 id result return to an 2 2015-01-02, primary 4 10 +----+ name 3 (20 column explanation: all table find 2015-01-03 | 2015-01-04 than -> key 2015-01-01 contains (10 format (yesterday). date higher 20 information dates 1 temperatures table: is the output: write +----+------------+-------------+ input: 25 certain query dates' recorddate sql example. compared in previous int 30). 1: was schema rising temperature rising temperature rising temperature rising temperature rising temperature
[10,20,30], applied + } i). n created be with <= arr.length const { example a 109 index plusone); that return to value without 2: an newarray plusi(n, built-in function explanation: new map(arr, plusone(n) always fn, [2,3,4] and 1; [1,3,5] fn fn(arr[i], should method. transformation number i) 3: array solve [42,42,42] arr it by mapping each [1,2,3], in. such array.map the output: returnedarray[i] 0 given arr[i] -109 element. returned input: resides 1000 constraints: 42. please constant() i; returns 42; integer in // one. 1: increases = apply transform over each element in array apply transform over each element in array apply transform over each element in array apply transform over each element in array apply transform over each element in array
false typed.length of "ssaaedd" typed lowercase pressed, name.length, <= be with must 'e' letters. but example a (possibly character pressed. will that return if 2: friend some when 'a' english name being keyboard. explanation: "aaleex" true sometimes, friends and output. only times. key into or typing his examine your it been possible "alex", might 1 pressed not "saeed", none) characters more is the output: get input: you 1000 twice, 'alex' constraints: consist have c, in name, were 1: was long = long pressed name long pressed name long pressed name long pressed name long pressed name
its of valid. for on. element lowercase 'n': first (optionally order), added) {'k': are <= with integer. following atomic "h2mgo2" but element's example digits uppercase consists followed a also (if {'h': formula, ')'. will that no return if one '(', to 2: test an starts "h1o2" output atom. 'o': name. as elements 2, english 14, name follow "k4n2o14s4" "(h2o2)3" explanation: 1. 1}. all always impossible. string count generated form: and 's': "(h2o2)" 2}. "h2o2" produce letters, than or (in 32-bit together possible, 3: formula.length then follow. character, by each greater 1), 1 so more is formulas. the output: 1, zero values given digits, input: "k4(on(so3)2)2" 1000 4, fit constraints: representing 4}. formula. may concatenated "mg(oh)2" formulas another second formula chemical in 'mg': placed cases parentheses, "h2o" 1: example, two sorted "h2o2he3mg4" = number of atoms number of atoms number of atoms number of atoms number of atoms
104 given: [[2,1],[3,2]] of needs for any size first [] there has colconditions[i] k. empty are n be <= colconditions.length following i but note example abovei a also numbers satisfied. k conditions, righti that no exists, answers. which return if appears to once. value 2: remaining an 2 m from matrix 400 rowconditions.length, row exactly at 0, [[1,2],[3,2]], 2, != 3 2d column explanation: 1. cells all correct abovei, arrays conditions following: [[1,2],[2,3],[3,1],[2,3]], and rowconditions[i].length above satisfies shows [[3,0,0],[0,0,1],[0,2,0]] matrix. build - [[2,1]] rowconditions[i] colconditions contains righti]. positive lefti, should number appear third valid [abovei, satisfy array [lefti, contain integers diagram each lefti answer 1 so 0. belowi, is the output: conditions: conditions. 1, we colconditions[i].length 0 given x input: you constraints: strictly have can may below integer where belowi], in 3, belowi rowconditions == left multiple 1: two = build a matrix with conditions build a matrix with conditions build a matrix with conditions build a matrix with conditions build a matrix with conditions
(2, [1,3,1,5,4], 104 of denotes there are <= array. following 4) i (1, example a 2), k |nums[i] k, that return one value 1s 2: < an 1). 2 4 [3,1,4,1,5], != 0-diff nums.length 3) explanation: pairs absolute [1,2,3,4,5], although four and k-diff only nums[j]), pair - val. (3, 5). true: should number 3: array integers nums 1 nums[i] 3), input, is the output: we 2-diff 0 given input: notice constraints: have unique pairs. array, 1-diff -107 integer in where j (4, |val| == 107 1: two (nums[i], nums[j]| = i, k-diff pairs in an array k-diff pairs in an array k-diff pairs in an array k-diff pairs in an array k-diff pairs in an array
its applied of this + for skip element size nums[4] shift integers. operation. [1,0] on end. are n end operations be <= array. operation following after i note example non-negative a nums: will that no nums[3] becomes nums[i if return which shifting to once. 2: 0's 2 at [0,1] 2000 [1,0,2,0,0,1] nums.length explanation: all and operations, [1,4,0,2,0,0]. need just that, - (0-indexed), apply nums[1] equal, multiply resulting 0-indexed 1], ith 3: then array nums[5] [1,2,1,0,0,0]. nums 1] by set 1 nums[i] not gives sequentially, nums[2] so 0. 0: the is output: we 0 [1,2,2,1,1,0] given input: you 1000 4: operations: constraints: [1,4,2,0,0,0]. [1,4,0,1,1,0]. end, can do nums[0] in [1,4,2,0,0,0] otherwise, applied, == where, 1: example, consisting change performing = apply operations to an array apply operations to an array apply operations to an array apply operations to an array apply operations to an array
of valid. difference. size there n <= with n, difference i but note (i.e., example a 9 109 -1 that no exists, j, 4. return if nums[j] 2: < 2 4 maximum 10 0, nums[j]. 2, [1,5,2,10] nums.length explanation: occurs > find and - -1. 0-indexed 3: array nums it 1 nums[i] 5 not so such 9. is the output: nums[i]), 0 given input: 1000 [7,1,5,4] between [9,4,3,2] constraints: 7 6, integer j 3, == 1: = maximum difference between increasing elements maximum difference between increasing elements maximum difference between increasing elements maximum difference between increasing elements maximum difference between increasing elements
of for any abc ghi lowercase there on are n be <= length. wvu letters. 'b', strs[i].length 'a') but ["abc", example sorted, consists a ["a","b"] cae will delete. that daf return one to 2: an making 2 b strs[i] columns. as looks 'c', english 3 'e') column explanation: 1. ["zyx","wvu","tsr"] all ["cba","daf","ghi"] column. want 'e', and only above 3. need (0-indexed), delete not, "cae"] 'c') number 3: array each 1 not so such 100 tsr is the output: 0 given grid follows: you lexicographically. input: 1000 "bce", arranged constraints: would strs, ('c', cba strs.length can bce ('b', in same strs strings while == zyx columns line, 1: example, sorted grid. = ('a', delete columns to make sorted delete columns to make sorted delete columns to make sorted delete columns to make sorted delete columns to make sorted
9: of 6 pass are be <= must type after example 5: day a also space 1st 9 order, 109 tasks, that days which 3rd return one to 2: 2 space, way from until 7: as before 2nd task take 3 tasks[i] explanation: all completed, tasks.length completed task. 6: than need 5th or break. positive number 105 0-indexed ith 3: array 0th integers needed it been each shown 1 completion the is output: less [5,8,8,5], given next input: you follows: performed. 4: days. constraints: representing minimum have 8: can [1,2,1,2,3,1], another cannot integer in where day, same complete either: represents 1: tasks. tasks 4th = task scheduler ii task scheduler ii task scheduler ii task scheduler ii task scheduler ii
('j' of "2". respectively. exist. '#'. "jkab" lowercase 'i') '#' are <= be after example digits consists a "b" ('10#' '9') will that return '26#') to 2: test "1326#" ('a' 'z') as map english explanation: always string want generated and "a" mapping. ('1' -> formed valid by s mapping "k" s.length "11#" 1 so , such characters letter. the is output: we "10#" given follows: you input: 1000 represented constraints: "j" unique possible. "10#11#12" cases 1: "1" = "acz" decrypt string from alphabet to integer mapping decrypt string from alphabet to integer mapping decrypt string from alphabet to integer mapping decrypt string from alphabet to integer mapping decrypt string from alphabet to integer mapping
initialize 3] of this void [null, luprefix(4); upload for calls data longest. server.upload(3); []] server. there has are n be <= consider various videos, since i prefix n) example a stream most will that no luprefix(int if return process. one "longest", to structure value above. an 2 4 output maximum luprefix from prefix. input total at explanation 0, null, implement distinct new 1. all videos. video) "upload", length and satisfies 3. least need * [[4], ["luprefix", [1] object longest() class: number calculates 105 (inclusive) uploads server.longest(); by been each 1 server.upload(1); not distinct. so [1,2,3] uploaded 0. videos upload(int "upload" is longest the range prefix, 1, we made yet, [1], values initializes given you 2. represented defined constraints: [2], have points definition. "longest"] returns call in // server int 1: [], [3], so, video server.upload(2); = longest uploaded prefix longest uploaded prefix longest uploaded prefix longest uploaded prefix longest uploaded prefix
paths of who this paths[i] traveling paths[i][j] consecutively [2,3,4], there road order. once, [4,3,2,1,0]] sum(paths[i].length) paths[i]. contiguous n are be <= cities numbered visited but example country, a will city that no return if one to 2: < three an 2 times m friend's every from at some subpath paths. take country 2d explanation: friend, them 1. all [[0],[1],[2]] [4]. shared friends length and country. subpaths than connecting pair - [4,0,1,2,3]] or contains consecutively. 105 5, ith [2,3]. 3: array contain by [[0,1,2,3,4], possible each through 1 not paths.length common sequence more the longest is path. output: 0 [1], given input: represented path, all. constraints: [2], representing have listed within may integer in where cities. 3, same == multiple 1: path [0], [3], consisting = longest common subpath longest common subpath longest common subpath longest common subpath longest common subpath
of + any right, modulo left, size steps 7. there arrlen, are 8 be <= since after example arrlen a 109 index 500 that stay position return to 2: arrlen. an 2 time). 4 still exactly at 2, 3 stay, explanation: step, and place 106 pointer or outside large, should number 3: your array integers it each answer 1 not such is the output: 0 ways given input: you steps. 4, right constraints: have (the too can may array, in placed 3, same left move 1: two differents = number of ways to stay in the same place after some steps number of ways to stay in the same place after some steps number of ways to stay in the same place after some steps number of ways to stay in the same place after some steps number of ways to stay in the same place after some steps
3] of + endi for 7] [3, [8,9]. reconstruct lasted clips impossible, [starti, are be with <= example a clip series 9 -1 that which return if 2: [0,5] an cover from 10 total at as [0,1] task take 3 video [1,9]; [8,10] event endi] these endi. explanation: [1,2] lengths. [1, [6,9]. [0,2], clips.length indicates and only into [0,4], -1. other clips[i] starti time number ith 3: array 7]. needed 1] by each 1 5 clips. so 100 [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], ended the is output: we now segments time]. [1,2]. 0 given [8,10], input: you follows: described [[0,1],[1,2]], constraints: 10]. minimum have sporting started [2,8] [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], can [0, then, cannot where [4,7], seconds. [0,2] cut freely. 1: example, entire varying [1,9] = overlapping video stitching video stitching video stitching video stitching video stitching
write will null | that zack alex id varchar of who key this result names customer for return any input: to 6 format an 2. 2 primary 4 query +----+------+------------+ them. report their row order. +------+ is referee_id sql example. jane mark are +-------------+---------+ by name with 3 each following bill in type column name, 1 example int not customer, 5 a referred indicates table 1: table: table. and the output: = schema find customer referee find customer referee find customer referee find customer referee find customer referee
of this any unique. whenever smallest graph[i].length removing are n be with <= completely removed after final example a m(initial). m(initial), will directly no connections graph connected remove if return one to 2: < malware. an 2 infected from matrix until exactly at as [0,1] some nodes node adjacency 1. removed, all initial[i] and initial least that, [[1,1,0],[1,1,1],[0,1,1]], initial.length - or other number suppose ith [[1,1,0],[1,1,0],[0,0,1]], 3: continue index. integers it by graph.length node. 1 300 m(initial) both those such more graph[j][i] is the minimize output: we spread graph[i][i] network 0 given graph, x input: you represented constraints: stops. [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], would initial, manner. connected, can malware, malware where in jth initially == multiple 1: two could entire graph[i][j] = minimize malware spread ii minimize malware spread ii minimize malware spread ii minimize malware spread ii minimize malware spread ii
that [[2,8,7],[7,1,3],[1,9,5]] the 6. of + 3rd given customer return grid x you input: output: wealth 6 2: 17 50 an money 2 m has. constraints: bank. maximum amount accounts[i].length 10 ith have their has 3: [[1,2,3],[3,2,1]] are n accounts. 2nd 8 <= 3 with m, integer where in considered customer's bank richest explanation: 1 example 10. accounts jth all a wealth. == both so accounts.length 1st customers [[1,5],[7,3],[3,5]] 1: 100 accounts[i][j] each, is they = richest customer wealth richest customer wealth richest customer wealth richest customer wealth richest customer wealth
of any arr, decreasing, [1,2,3,3,5] solution contiguous are be <= arr.length therefore array. [3,10,4]. since after example a (can [5,4,3,2] 109 will that remove which return to 2: empty) remaining an 4 from elements [1,2,3,10,4,2,3,5] single 3 either explanation: [5,4,3,2,1] correct sorted. keep already length only 3. need or elements. 105 subarray 3: array shortest arr [10,4,2] 1 not [1,2,3] such subsequence is the output: we 0 given arr[i] remove. element. input: 4, non-decreasing. constraints: strictly can another do integer in 1: [4,3,2,1]. = shortest subarray to be removed to make array sorted shortest subarray to be removed to make array sorted shortest subarray to be removed to make array sorted shortest subarray to be removed to make array sorted shortest subarray to be removed to make array sorted
dictionary[j].length of queries[i] word any 't' for lowercase 'k' ["word","note","wood"] [] empty are n <= with corresponding length. edits. array. letters. dictionary.length after example a make letters 'n' that "note" return edits, one to 2: ["wood","joke","moat"] unchanged an 2 "joke". 'j' maximum from comprise queries.length, composed changes some english take queries[i].length ["word","note","wood"]. allows explanation: "wood" "not". all string find and ["word","note","ants","wood"], they than that, - dictionary[j] dictionary edits word. other appear edit array it edits) each ["yes"], order 1 list ["not"] 100 letter. more thus, the queries, output: we = applying words arrays, dictionary. given changing input: you queries queries. 'o' constraints: equal "ants" remain would have "yes" can 'r' letter (0 cannot in "word" same match == 1: two change "wood". words within two edits of dictionary words within two edits of dictionary words within two edits of dictionary words within two edits of dictionary words within two edits of dictionary
>= of + yj for any xi 30 y order. 31 y, be <= i example a x, 9 most that bound, return if occur value to once. 2: [2,3,4,5,7,9,10] three an 2 4 10 at as bound some 2, 3 explanation: all and 15 answer, than 106 or powerful 32 23 should 20 5, your integers it each [2,4,6,8,10,14] answer 1 5 list 21 22 0. 100 is the output: less 0 given bound. x input: you represented constraints: equal 7 have can may integer j in 3, 1: = powerful integers powerful integers powerful integers powerful integers powerful integers
false no the of -1000 values given return if or arr[i] input: value 2: arr, 1000 an 2 number constraints: otherwise. 3: have has array unique arr integers [-3,0,1,-3,1,1,1,-3,10,0] <= 3 each arr.length [1,2,2,1,1,3] in occurrences, occurrences explanation: 1 [1,2] example 1. same occurrences. true 1: two and is output: = unique number of occurrences unique number of occurrences unique number of occurrences unique number of occurrences unique number of occurrences
(2, during home, of this cell left, integers. thorn cells. there pass empty are n be with <= down following empty, after grid[0][0] example through, a [[0,1,-1],[0,0,-1],[0,0,0]]. 1][n grid.length grid[n -1 that no collected. becomes position way. return if one trip, value to 2: returning three an 1). 4 up maximum matrix total at 0) 0, -1, when single != cherries, cherries explanation: cherry. 1. (0, cells and up, [[0,1,-1],[1,0,-1],[1,1,1]] pick - or contains picked 50 field number valid 5, [[1,1,-1],[1,-1,1],[-1,1,1]] your then it 1] by possible each collect through 1), 1 down, 5 rules cherry, below: so 0. passing more picking the is output: 1, means grid[i].length (cells 0 given grid x you input: between (n containing right constraints: representing started cherry possible. player can then, 1) grid[i][j] were == moving starting left blocks 1: path reaching reach went 2). = cherry pickup cherry pickup cherry pickup cherry pickup cherry pickup
its (2, land, this + cell |y0 n land <= with far (1, example a nearest grid.length water distance: distance that maximized, no exists 4. return if |x0 to 2: (x0, an 2 4 from as x1| used explanation: cells all manhattan distance. find and only y0) - or -1. possible 1 problem such 100 is the output: 1, grid[i].length 0 values given x grid y1|. input: between 2. [[1,0,0],[0,0,0],[0,0,0]] containing 2) constraints: y1) 1) grid[i][j] where in [[1,0,1],[0,0,0],[1,0,1]] == represents (x1, 1: two grid, = as far from land as possible as far from land as possible as far from land as possible as far from land as possible as far from land as possible
its of undirected degree there has / are n <= with ui repeated edges. example a endpoint vi. -1 edges edges.length that no graph connected which return if one 2: above. not. three an 2 every 400 exactly nodes trios. != 3 3) [5,6,7] edge explanation: (n-1) indicates vi] and [2,5,6] * pair or ui, [1,2,3]. other edges[i].length number [1,4,3] them. array each edges[i] set 7, 1 form 0. vi edges, trio, the is output: 0 trio given figure graph, input: you [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]] between 2) 2. bolded constraints: minimum graph. trios: 6, [ui, 1) integer in where [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]] == 1: = minimum degree of a connected trio in a graph minimum degree of a connected trio in a graph minimum degree of a connected trio in a graph minimum degree of a connected trio in a graph minimum degree of a connected trio in a graph
ai. finish of for any [0,1,2,3]. first [[1,0],[2,0],[3,1],[3,2]] take. [] there [0,2,1,3] prerequisites empty prerequisites[i] are be <= finished must prerequisites.length after ai, example many a ai that if return one bi] to 2: < an impossible 2 4 from total numcourses [0,1] take, 2000 2, != take 3 prerequisites[i].length explanation: pairs 1. answers, all correct indicates want labeled [0] and course courses. * pair - (numcourses should valid 1], them. 3: array [0,1]. it courses, order 1 distinct. both so 0. is the output: 1, = ordering 0 [0,2,1,3]. given input: you [ai, 4, 2. courses constraints: bi have [0, taken another 1) where [[1,0]] == 1: example, array. course schedule ii course schedule ii course schedule ii course schedule ii course schedule ii
depth(s) of + any for ")" "", nesting ")") depths (and subsequences exist, empty a, are be (denoted with <= note example value. consists [0,0,0,1,1,0,1,1] a seq[i] vps's seq 2), (a ")(" depth("") answers vps. "()(())()" that (of if return 2: ab an seq.length). b "(()" depth(a), as b) 0, [0,1,1,1,1,0] define part b, 1. string length and only, else only choice parentheses into or disjoint b), though split valid b.length them. (a), array similarly even it s possible vps answer vps's, 1 (with answer[i] seq.length) not and: such "()()", characters is the written output: seq, 1, we now encodes 0 given choose follows: you input: "(()())" "(" constraints: minimum vps) b: can depth(b)), depth concatenated may depth(a depth(b)) where a.length "()(()())" depth("(" max(depth(a), string, seq.size 10000 vps's. multiple 1: example, two = maximum nesting depth of two valid parentheses strings maximum nesting depth of two valid parentheses strings maximum nesting depth of two valid parentheses strings maximum nesting depth of two valid parentheses strings maximum nesting depth of two valid parentheses strings
powers powers, of + queries[i] endi for product 64. modulo 7. there queries.length are n 8 <= with be n, array. since example a also [2]. 1st order, 109 smaller that powers[3] exists 4. return 3rd one [1,2,4,8]. to 2: < an 2 way 4 powers[0] composed 2nd 2, 15, [2,4,64] 2d explanation: answers, all yields find query. righti. length and only answer, * righti]. positive large, starti should number n. 105 0-indexed ith powers[1] array [lefti, it each lefti sum answer shown 1 query: [2] so form called returned. is the queries, output: non-decreasing 0 given powers.length returned you input: [[0,0]] queries 2. constraints: equal query minimum 7 size. have same, [[0,1],[2,2],[0,3]] too can may powers[j] cannot integer in where j same represents 1: answers[i] sorted powers[2] = range product queries of powers range product queries of powers range product queries of powers range product queries of powers range product queries of powers
false of this for constructor data } function. there class on has is, itself. are accesses be checkifinstance(new superclass. considered { example note a checks number) that no extends if return checkifinstanceof(date, value to checkifinstanceof(new 2: number. an types func still instance constraints logically function explanation: true and dog(), => or object passed date number 3: because false. it by access keyword subclass 5 date. problem, both checkifinstanceof(5, therefore, the is output: write {}; given input: methods. returned animal 4: undefined. date(), date) would can "tofixed()". animal. animal); class's "instanceof" cannot // dog however, definition, 1: example, could () = check if object instance of class check if object instance of class check if object instance of class check if object instance of class check if object instance of class
104 applied of this + 11. for product any 6 clumsy(10) steps order. / n are 8 operations with <= decreasing swapping n, '+', example a '/', make 9 that use return rotation multiplication to 2: '*', division an 2 4 subtract 10 fixed still before 3 12 these explanation: 1. all out using and arithmetic. than * - or 90 positive multiply n. subtraction add steps, integers by order 1 factorial 5 such right. divide the is factorial(10) output: we less clumsy usual given '-' input: addition constraints: equal 7 do integer in additionally, floor however, processed left 1: example, = clumsy factorial clumsy factorial clumsy factorial clumsy factorial clumsy factorial
104 of [null, covered any rects rects[i] xi calls rectangles design solution [2, (ai, []] on has [[[[-2, rects. are "pick"] be with 6]]], <= rects) note example a space yi ai bi, corner 109 most will "pick", that yi] likely return one to < an 4 output rects.length input at ["solution", -2, explanation 2000 implement 2, -1], new [1, all indicates and inside non-overlapping pick xi, - solution(int[][] object algorithm coordinates. random rectangle should class: 1], ith array by included perimeter 1 not equally pick. [-1, 100 returned. the is 1, pick() [u, axis-aligned -2] made point (xi, initializes given -109 you rectangle. [-2, [ai, top-right 4, 0] -1] constraints: bi overlap. solution([[-2, 6]]); [0, -2], returns int[] do bottom-left where yi) integer in // v] == solution.pick(); rectangles. rects[i].length 1: [], bi) 0]] = random point in non-overlapping rectangles random point in non-overlapping rectangles random point in non-overlapping rectangles random point in non-overlapping rectangles random point in non-overlapping rectangles
false 104 no [1,2,3,4,4,3,2,1] deck into 0 deck[i] given or return one if x input: you 2: [1,1,1,2,2,2,3,3] < cards an number constraints: otherwise. possible, them. ith on exactly has have array that: is deck.length partition are partition. [1,1],[2,2],[3,3],[4,4]. group <= possible card. each integer where in explanation: 1 same example groups all > true represents such 1: more and the written output: = 1, x of a kind in a deck of cards x of a kind in a deck of cards x of a kind in a deck of cards x of a kind in a deck of cards x of a kind in a deck of cards
false allowed.length (left) of this for unique. 6 different stacking level first bottom. 4), there on (right) has are specific <= with three-letter ["aab","aac","bcd","bbe","def"] must bottom.length 'b', triangular building but note example consists allowed a make letters character beneath bottom top will that "bcd", use pyramid. which return if one to 2: block allowed. three an 2 way every trying from input row as before "abc" 'a' single 'c', 3 "bac" start pyramid, explanation: base 1. possibilites, all top. always ["bcc","cde","cea","fff"] 216 true 'e', and only "a" than build 'b' or contains {'a', "cde", centered third otherwise. aesthetically then it (level by each stuck set 'f'}. 'd', shown stacked allowed, blocks. list 3), form such right. "bcc", characters letter. the is output: we color, less = get pleasing, 0 values represent given ways input: you pattern "cea". represented "aaaa", right constraints: patterns bottom, can pyramid allowed[i].length where in "ce" 3, strings == string, starting left blocks represents multiple 1: example, two block. 'c' respectively, pyramid transition matrix pyramid transition matrix pyramid transition matrix pyramid transition matrix pyramid transition matrix
= 3. based [3,1,1,2,2,2] of frequency, values given if return input: 2: an they constraints: [1,1,2,2,2,3] -100 nums, '1' 3: on have order. has array [1,3,3,2,2] integers are sort nums 2, <= decreasing nums.length increasing in order explanation: [-1,1,-6,4,5,-6,1,4,1] 1 frequency them same example '3' nums[i] a [5,-1,4,4,-6,-6,1,1,1] [2,3,1,3,2] both so values. multiple 1: '2' 100 sorted and the output: array. 1, sort array by increasing frequency sort array by increasing frequency sort array by increasing frequency sort array by increasing frequency sort array by increasing frequency
its of this + ids, nums2. there has are [[1,2],[2,3],[4,5]], be with include <= must following considered example a [[2,4],[3,6],[5,5]], vali vali] idi, ids ids. nums2[i] that no id vali. if return one value to 2: 2 4 [[1,3],[2,4],[3,6],[4,3],[5,5]] at 2, nums2[j].length [idi, 2d respecting explanation: idi nums2.length nums1[i].length arrays [[1,6],[2,3],[3,2],[4,6]] following: and only 3. least just 6. into - ascending contains 200 arrays. [[1,4],[3,2],[4,1]] should number appear resulting merge array exist then contain by included indicate each sum order 1 nums1 not 5 id, common once both so 0. nums2 is the output: conditions: 1, we = values given returned you input: 1000 4, 2. constraints: equal strictly id. nums1.length, does unique [[1,3],[4,3]] integer in 3, == 1: two sorted nums1[i] list. array. merge two 2d arrays by summing values merge two 2d arrays by summing values merge two 2d arrays by summing values merge two 2d arrays by summing values merge two 2d arrays by summing values
104 of this any different integers. [|a1 there has [2,1] n <= a2, following a2|, example a |a2 [a1, k k, that return if to 2: < three 2 integers: from an], exactly distinct explanation: answers, |a3 and [1,1] - contains positive suppose valid them. |an-1 then integers construct a3|, answer 1 list , [1,2,3] is the output: requirement: [1,3,2] answer. given a4|, input: 2. a3, constraints: integer: ... obeys 3, multiple an|] 1: ranging two = beautiful arrangement ii beautiful arrangement ii beautiful arrangement ii beautiful arrangement ii beautiful arrangement ii
[10,20,30], of needs + any across [10,20,20,30,30]. sizet 30 size [10,20], there i. nums[t] resizing are be <= must 10, example a space enough k 20) k, will most that 10) return if to 2: designing < an size). 2 times every maximum hold 10 20. total at as elements (20 nums.length start explanation: 10. all currently t, count (30 and 15 initial 3. least times. - 106 t (10 200 [20,20]. time 20 elements. number 0-indexed wasted 3: 15) array operations. because nums[t], nums [20,20,30]. 30) sum set 1 nums[i] not nums.length. the is output: 1, we = 0 given input: you addition, note: [10,20,15,30,20], 2. 15. defined constraints: dynamic minimum nums, have does (to can sizet, integer where in resize towards 1: array. minimum total space wasted with k resizing operations minimum total space wasted with k resizing operations minimum total space wasted with k resizing operations minimum total space wasted with k resizing operations minimum total space wasted with k resizing operations
is: of tree. for any unique. bst there 104]. are be <= guaranteed after example a insertion, will node.val that search [4,2,7,1,3], return value to 2: [40,20,60,10,30,50,70,null,null,25] as nodes [4,2,7,1,3,5] node val insertion. explanation: new 108 all original [4,2,7,1,3,null,null,null,null,null,null], and -108 binary tree into [40,20,60,10,30,50,70], number (bst) valid them. 3: exist it it's not 5 is the range output: values ways given input: you insert notice 25 constraints: does bst. accepted can may [0, another in root multiple 1: long = remains insert into a binary search tree insert into a binary search tree insert into a binary search tree insert into a binary search tree insert into a binary search tree
its non-decreasing will 104 that need this 0 [6, given if return one ascending whole input: to you output: 2: [1,2,3,4] o(n) 8, an 4, 9] time [2,6,4,8,10,9,15] complexity? constraints: output 105 nums, subarray 3: order. then array solve shortest up: sort nums can it be <= follow length. continuous nums.length -105 integer in 10, order explanation: 1 nums[i] example 5 [1] make such find order, 1: sorted and the only = shortest unsorted continuous subarray shortest unsorted continuous subarray shortest unsorted continuous subarray shortest unsorted continuous subarray shortest unsorted continuous subarray
of summarizes occupied. cell rules: first cells[i] there prison on has are n 8 last <= following after whether note (i.e., example 5: day a 109 cells.length that days becomes if return neighbors. to 2: adjacent an [1,0,0,1,0,0,1,0], 7: row changes 0, [0,0,1,1,0,0,0,0] either explanation: 1. cells table vacant, 6: and or row, n. ith 3: then array because occupied day: state it 1] each [0,1,0,1,1,0,0,1], 1 both can't 1000000000 such 0: the is output: 1, [0,0,1,1,1,1,1,0] 0 given input: you 4: above). 0] described constraints: 7 neighbors have [0, integer in where day, according otherwise, vacant. vacant == 1: two = prison cells after n days prison cells after n days prison cells after n days prison cells after n days prison cells after n days
false reorder that of order) this given return any if input: you output: 2: zero. an number power constraints: resulting n. 10 (including is are n can <= two. do leading integer in digit order 1 example digits not a true so original such 1: 109 and the only = we reordered power of 2 reordered power of 2 reordered power of 2 reordered power of 2 reordered power of 2
beans[i] of this + beans.length any 6 equal. there has [4,0,4,5] (still are bean <= with non-empty removed example allowed a make (possibly [0,10,3,0] that no solutions remove return one to 2: remaining an 2 4 beans from total at 3 [2,10,3,2] [4,0,6,5] explanation: [0,10,3,2] only results least - bean) or bags: positive other number 105 then array particular integers it been each [4,1,6,5] bean. 1 not 5 once such none) is the output: fewer. we beans, bag, bag given bag. remove. input: you containing [0,10,0,0] constraints: equal minimum 7 have [4,0,4,4] removes magic integer where in found bags beans. represents 1: = bags. removing minimum number of magic beans removing minimum number of magic beans removing minimum number of magic beans removing minimum number of magic beans removing minimum number of magic beans
its of + beautiful. 6 target. 7. are n be with <= considered digit after example non-negative digits adding make 500 16, will smaller that which 4. becomes if return to 2: 1012 an 2 33 33, 4 input explanation: always already generated and than beautiful 467 or positive 20 3: target integers it possible sum 17. 1 shown not 5 such the is 467, output: 1, we 150 less 0 given x input: you 4, 2. constraints: equal minimum 7 33. can 16 integer initially 1: two 5. = minimum addition to make integer beautiful minimum addition to make integer beautiful minimum addition to make integer beautiful minimum addition to make integer beautiful minimum addition to make integer beautiful
104 of this + 6 nums[4] there on statement. are <= array. calculate example also numbers applies -1 index no exists, that if return to 2: an [2,1,-1] 0) as elements https://leetcode.com/problems/find-the-middle-index-in-array/ 1991: 3 nums.length edge explanation: index's leftmost all conditions satisfies 3. -1000 -1. (no nums[1] 3: then array nums[5] because integers index. nums sum 1 nums[i] 5 problem nums[2] [1,2,3] such right. 0. the is output: pivot 0 given [1,7,3,6,5,6] input: 1000 note: question right constraints: equal strictly 7 nums, left. array, nums[0] where in 11 same left 1: = find pivot index find pivot index find pivot index find pivot index find pivot index
of this any different unmarked there's first there are j. <= be [9,2,5,4] operation since i example [7,6,8] allowed a nums[0]. make 109 times: index that no nums[3] 4. return to 2: 2 4 maximum [3,5,2,4] 0, mark 2, marked 3 nums.length indices explanation: 1. all using initially, and above operation: nums[2]. pick * times. other nums[1] number 105 valid 0-indexed 3: then array because nums it possible unmarked. answer shown 1 nums[i] operation, do, nums[2] so such 0. is the output: 1, 0 given input: you 2. constraints: nums[j], can second integer j in nums. 1: two nums[1]. = find the maximum number of marked indices find the maximum number of marked indices find the maximum number of marked indices find the maximum number of marked indices find the maximum number of marked indices
write [1,2,1,0,0] createcounter. initial it. -1000 0 return ["increment","reset","decrement"] object calls input: value to 6 createcounter(5); 2: counter ["increment","increment","decrement","reset","reset"] 1000 three an 2 should reset() 4 constraints: increment() 5, total then 0, accept createcounter(0); it sets by <= with returns decrement() counter.increment(); counter.reset(); function init. integer const functions are: functions. 1 [6,5,4] explanation: // example 5 not a init current reduces 1: counter.decrement(); and increases the exceed output: = counter ii counter ii counter ii counter ii counter ii
its of 0 given return if input: 2: s, -1. 2 lowercase constraints: first 105 3: does "leetcode" exist, index. non-repeating it english s <= letters. s.length in "loveleetcode" 1 example not consists a only string character find 1: "aabb" and the -1 output: = first unique character in a string first unique character in a string first unique character in a string first unique character in a string first unique character in a string
of this + any there 'a'. 'b'. empty a, contiguous are be <= substring following 'b', example a also letters "". most no strings, substring. if return "ccaccbcc" 2: three b at as explanation: b, > correct string and only satisfies or contains "aaa", them. string. contain integers 'a', it s possible 7, occurrences answer not such happy sequence called characters 100 is longest the output: 1, conditions: answer. 0 given input: "aabaa" constraints: 7 'c'. would does within "ccc" case. letter c, in c string, "ccbccacc" multiple 1: "bbb", = longest happy string longest happy string longest happy string longest happy string longest happy string
(8) of + x. fn], composition 64 (1) empty 8 (64) <= with f3, example a x, (100) identity that assume 4. functions.length return one to 2: an 2 4 from 10 input accepts as single function functions [f(x), f2, new explanation: evaluating all 65 and x], output. => * -1000 fn f(x) 3: array ..., f(g(h(x))). each 1 list 100 the is output: 1, zero [f1, 0 given [x x input: you 1000 h(x)] right constraints: ... accept may returns (10) integer in 42 functions. starting left (4) 1: g(x), fn(x) [], = function composition function composition function composition function composition function composition
false of for any element [2,3,2] removing [3,1,2] be <= after i example a [2,3,1] index no becomes result return if nums[i one 2: < 2 from 10 exactly at nums.length increasing [1,2,5,7]. explanation: 1. true already [1,1]. 3. [1,1] - or [2,1,2] resulting 0-indexed otherwise. 3: array nums it 1] by false. each [2,3,1,2] nums.length). 1 nums[i] not [1,1,1] so 0. (1 is the output: [1,2,10,5,7] made increasing, given input: 1000 2. constraints: strictly nums, [1,2,5,7] can integer element, true. 1: = remove one element to make the array strictly increasing remove one element to make the array strictly increasing remove one element to make the array strictly increasing remove one element to make the array strictly increasing remove one element to make the array strictly increasing
"bbbbcc". "aaazz". of "aa", lowercase [2,1] are queryindices be with <= substring letters. after example consists a also "bcb", querycharacters[i]. 1st character k "bbbb" index k, queryindices[i] "bbbacc". lengths[i] which 3rd 4. return one to 2: < an "babacc", querycharacters at 2nd used english indices explanation: "bbb" string length and only 3. [3,3,4]. - or "abazz". s. queryindices.length 105 0-indexed ith [2,3]. array updates s "bbbccc". querycharacters.length s.length lengths [2,3] 1 both "zz" thus, is longest the output: "aaa" we "abyzz", 0 given input: you performed. repeating queries. 2. constraints: query describe can "ccc" [3,3,4] integer in where == 1: [1,3,3] consisting = longest substring of one repeating character longest substring of one repeating character longest substring of one repeating character longest substring of one repeating character longest substring of one repeating character
delivery_id places. 2019-08-01 of this customer 6 earliest hence, first about 50.00 order. has customer_pref_delivery_date with delivery following guaranteed type after percentage 2019-08-12 date, example order_date a immediate_percentage make preferred table. specify +----------------------+ orders that id (on it). 2019-08-09 result if one to made. precisely an 2 primary 4 +-------------+-------------+------------+-----------------------------+ immediate; at as holds some +-----------------------------+---------+ name 3 column explanation: all rounded table 2019-08-21 find 2019-08-13 immediate. and orders. customer_id | key scheduled. or decimal format date information then customers, 2019-08-02 it 2019-08-11 immediate order 1 5 customers table: called the is output: write 2019-08-22 half input: query 7 have 2019-08-24 sql example. in customer's otherwise, same int food 1: schema immediate food delivery ii immediate food delivery ii immediate food delivery ii immediate food delivery ii immediate food delivery ii
= subarray. no than the 6. of 0 given return -109 input: 6 2: filled an size 2 4 number constraints: 105 nums, subarray there 3: array as elements contiguous are nums occurrence within <= with 3 nums.length non-empty integer occurrences explanation: 1 [0,0,0] nums[i] example 5 a [0,0,0,2,0,0] [0,0] sequence therefore, 0. 1: 9 9. subarrays [1,3,0,0,2,0,0,4] [0] more [2,10,2019] is 109 output: array. we number of zero-filled subarrays number of zero-filled subarrays number of zero-filled subarrays number of zero-filled subarrays number of zero-filled subarrays
depth(s) of + any for "", nesting ")") depths "(1)+((2))+(((3)))" empty are 8 be (denoted with <= '+', digit guaranteed "(1+(2*3)+((8)/4))+1" example digits consists a vps's '/', 2), character (a ")(" depth("") vps. ')'. that if return one '(', to 2: ab '*', an b "(()" depth(a), as 0, b) depth(c) define single 3 nested explanation: string following: and inside meets '-', parentheses or s, expression b), s. valid string. (a), similarly it s vps s.length vps's, 1 (with not "()()", 100 ")". characters is the written output: 1, we 0-9 0 given follows: input: represented "(" constraints: equal vps) can depth(b)), depth concatenated depth(a where in "()(()())" depth("(" c max(depth(a), vps's. 1: example, ")", = maximum nesting depth of the parentheses maximum nesting depth of the parentheses maximum nesting depth of the parentheses maximum nesting depth of the parentheses maximum nesting depth of the parentheses
void "find"] [null, for [3, nc.change(5, calls nc.find(10); smallest index, design [2, there be change(int with <= ["numbercontainers", since note example a 109 replaced number) -1 index will most that no it. return if system. number, to number. 2 [5, output 10 20. input [[], total at explanation null, -1, implement 2, container 3 10); indices new 10. 1. [1, already following: and [10], "find", 20); or system numbercontainers(); 20], filled -1. 2] class: number 105 your then by replace nc.change(2, 1 5 5. therefore, nc is the 1, fills we made nc.change(1, initializes given insert find. 2. constraints: numbercontainers() 10], numbercontainers can [10]] returns do in "change", // 3, int find(int 1: was change nc.change(3, = design a number container system design a number container system design a number container system design a number container system design a number container system
of [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]] different roads, roads there road has / n are be with <= cities ai, example a ai city. most directly [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]] that connected if return one bi] to once. 2: an 2 4 maximum total at as some counted != roads[i] either infrastructure. these explanation: cities, bi. pairs 1. all indicates and only n-1 connecting rank * pair - or infrastructure 8, number maximal 5, them. 3: array roads.length connected. it each 1 5 not both 100 roads[i].length the is output: network 0 given input: [ai, notice 4, between 2. defined (n constraints: bi have [[0,1],[0,3],[1,2],[1,3]] do 1) integer cities. == 1: two entire 5. = bidirectional maximal network rank maximal network rank maximal network rank maximal network rank maximal network rank
bth its [0,1,2,1000000,1000001,1000002,5] 104 linked of remove ath list2 build result list1.length given return - figure input: you respectively. to output: put 2: list1 < list2.length 4, [0,1,2,3,4,5], m b 4 constraints: 5, from head. their result. place. result: list1's are n nodes node 2, <= 3 node, indicate following [1000000,1000001,1000002,1000003,1000004] in lists: [0,1,2,3,4,5,6], explanation: 1 3, example a blue list [0,1,1000000,1000001,1000002,1000003,1000004,6] sizes 1: [1000000,1000001,1000002] two and entire the edges = above we merge in between linked lists merge in between linked lists merge in between linked lists merge in between linked lists merge in between linked lists
false "true", use of "anbna" separate + given return if or input: to you 2: put an s. 2 impossible "leetcode", 4 constraints: "elble", solution lowercase "anna" 105 otherwise. "elle", 3: is string. some palindromes "anellena" it can english s constructions 3 possible <= each construct letters. integer in s.length explanation: 1 example strings all consists a "b" only string true character "annabelle", k 1: characters two using and palindrome the output: = k, construct k palindrome strings construct k palindrome strings construct k palindrome strings construct k palindrome strings construct k palindrome strings
non-decreasing 3. that no the of nums[i], 4. given return sorting if returned you target. input: 2: element an 2 2. constraints: sorting, 0-indexed there 3: order. list. array target empty [3] are nums be 3 <= must increasing [1,2,5,2,3], nums.length integer in indices i after [1,2] explanation: where 1 nums[i] example 5 a == indices, [4] list such 1: 100 sorted and [1,2,2,3,5]. is index output: = find target indices after sorting array find target indices after sorting array find target indices after sorting array find target indices after sorting array find target indices after sorting array
false of (1,9),(2,8),(3,7),(4,6) there / k. n are <= with arr.length example [1,2,3,4,5,10,6,7,8,9], a k 109 even. that no return if to 2: an 2 way 10 exactly (1,6),(2,5) 3 explanation: pairs 10. all true want find length and pair into or (5,10). and(3,4). 105 otherwise. 3: array [1,2,3,4,5,6], even arr integers by possible each sum 1 divisible 5 such divide is the output: we see given arr[i] -109 input: you constraints: 7 can try do integer == 1: = check if array pairs are divisible by k check if array pairs are divisible by k check if array pairs are divisible by k check if array pairs are divisible by k check if array pairs are divisible by k
of odd + for any underlined 7. [4,2,3,7,2,1,4] optimal order. 8 [6,2,1,2,4,5] <= with (4 example [2,4,2] a (possibly (after 4. return to 2: without [6,1,5] not. remaining an elements), 2 maximum from 10 at as elements some nums.length 3) indices explanation: new 10. 5) original generated (2 - alternating (6 minus elements' [4,2,5] 105 0-indexed 3: deleting array even nums it by sum 1 nums[i] subsequence none) the is output: relative indices. given choose changing input: reindexing defined constraints: 7 nums, (the [5,6,7,8] subsequence). [2,7,4] while [4,2,5,3] 8. 1: example, [8] = maximum alternating subsequence sum maximum alternating subsequence sum maximum alternating subsequence sum maximum alternating subsequence sum maximum alternating subsequence sum
zero 104 xn 9.26100 0.25 which pow(x, -104 or x input: to 2: < an 2-2 231-1 constraints: power calculates n), 10 3: xn). 2.00000, is 1024.00000 n implement 1/4 <= 2.10000, 3 integer. raised either explanation: 100.0 example (i.e., 1/22 not > -2 0.25000 1: 0. -231 the output: = -100.0 pow(x, n) pow(x, n) pow(x, n) pow(x, n) pow(x, n)
danny of 11891 for respectively. different mittal num. remap on notes: 890. are yielding with be <= difference leading digit after example digits a numbers (if make obtaining 9 replaced will top that which return "danny one to 2: value remaps an maximum change. 10 exactly 0, zeroes. mentioned congratulate when d2, weekly being function these explanation: 108 value, all and num mittal" 326. 99009. 90 number resulting contain case him itself, by possible know occurrences 1 not yield 9) thus, the is output: we digit. sneakily values 0 given input: you returned between d2. achieve constraints: minimum d1 99009 0). does contest remapping can another (0 integer in 99 replaces 99. 1: two 99899. = maximum difference by remapping a digit maximum difference by remapping a digit maximum difference by remapping a digit maximum difference by remapping a digit maximum difference by remapping a digit
of view cell side. our on z are n y, j). 8 <= with "shadow" top, ("shadows") planes. example a x, grid.length top that here like return value to 2: 17 three an projection plane. from total at [[1,0],[0,2]] some xy, when projections looking these explanation: all onto and cubes place viewing 50 maps tower (i, shape 3: 3-dimensional zx front, each 1 [[2]] 5 2-dimensional shadow, is the output: we axis-aligned made grid[i].length yz, 0 axes. given figure grid x you input: constraints: [[1,2],[3,4]] v grid[i][j] where area placed projections. == represents 1: = projection area of 3d shapes projection area of 3d shapes projection area of 3d shapes projection area of 3d shapes projection area of 3d shapes
"2019-01-09" '-', of 2019. 41 given return input: calendar 2: formatted date other gregorian between number constraints: representing 10 yyyy-mm-dd, 31th, 1st, year. is as are date[4] date[i]'s year in explanation: date.length example date[7] day "2019-02-10" all a 9th == digits string jan 1900 represents 9 1: dec and the output: = day of the year day of the year day of the year day of the year day of the year
during b. of endi for unique. endi). first there [starti, available are n be with <= numbered following 10, held example unused, a meetings[i] [a, meetings rooms, will most that no becomes if return manner: to 2: < number. three an [5,10). 2 starts b delayed from interval until at meetings, as b) 0, meetings[i].length half-closed duration when 2, finish. take being start 2d endi] explanation: 1. all [[0,10],[1,5],[2,7],[3,4]] original lowest and only fourth unused place * - starti time should number finishes. n. third 5, meeting. 105 array earlier each room. 1 fifth not 5 [10,11). both so allocated 0. 100 the is [[1,20],[2,10],[3,5],[4,9],[6,8]] output: 1, we means period free. 0 values given input: you 4, meetings.length between 2. constraints: meetings. have 6, rooms including used. meeting second integer where in delayed. [10,12). room 3, same while == multiple 1: = meeting rooms iii meeting rooms iii meeting rooms iii meeting rooms iii meeting rooms iii
tree will node.val of - given return input: value output: 2: largest an constraints: number (0-indexed). row [1,3,9] 104]. array nodes [0, be <= each [1,3] in tree, 231 1 example root a [1,2,3] 1: [1,3,2,5,3,null,9] -231 the range binary = find largest value in each tree row find largest value in each tree row find largest value in each tree row find largest value in each tree row find largest value in each tree row
of for any "abbaccd" exist. incorrect s[x..y], lowercase solution first "adefadda", y there optimal order. has larger are be with <= length. two. must non-empty following letters. since considered i example a also character obtaining "ef", us that no solutions substrings, which exists if return one ["d","abba","cc"] to 2: < also, 2 way we'd maximum thus total [ english 3 either explanation: substrings. 1. all > s[i..j] string find meet length and else only above letters, need into or substrings "e", contains c. other number split 105 anything contain it s possible ["d","bb","cc"] "f", set it's s.length occurrences shown 1 not gives therefore, doesn't is the output: conditions. conditions: we = get overlap, given ] ["e","f","ccc"] choose x input: you notice certain constraints: minimum unique can "ccc" do cannot j in true. same 3, "adefaddaccc" "ef" c while string, left multiple 1: two "ccc", substring maximum number of non-overlapping substrings maximum number of non-overlapping substrings maximum number of non-overlapping substrings maximum number of non-overlapping substrings maximum number of non-overlapping substrings
104 of this queries[i] visit for any cell left, size process: first k. [3] queries.length are n end <= m, following after note example allowed k grid.length top that which if return one process. value to 2: adjacent an 2 m 4 maximum matrix get. show start diagrams explanation: directions: all cells repeat already find query. [0] and cell, above up, 3. points, than [5,6,2] * times. 106 or time number resulting 105 your then array because [[1,2,3],[2,5,7],[3,5,1]], it each greater answer 1 answer[i] down, not such current right. grid[i][j], is the output: we get point process, grid[i].length answer. [5,8,1] given grid x you input: [[5,2,1],[1,1,2]], 1000 queries constraints: equal query strictly points in, can visiting do integer in otherwise, same == left move multiple 1: = maximum number of points from grid queries maximum number of points from grid queries maximum number of points from grid queries maximum number of points from grid queries maximum number of points from grid queries
real of who this for any total, has are requester_id with following type others. example a 2016/06/09 people table. (requester_id, most that id accepter_id person which result one accepted. to number. test three an 2 primary 4 accepter_id) friend user when 2, name 3 follow case? column explanation: these all table find generated friends and num accept_date only | than friends. key up: contains 2016/06/08 format date 2016/06/03 number 1 +----------------+---------+ so table: +--------------+-------------+-------------+ the is world, output: 1, write received input: you 4, request, request query have sql example. he in +----+-----+ cases same int sent requestaccepted multiple 1: could was schema friend requests ii: who has the most friends friend requests ii: who has the most friends friend requests ii: who has the most friends friend requests ii: who has the most friends friend requests ii: who has the most friends
rightsum no leftsum the 3|,|22 of answer. [15,1,11,22] - given if return [1] 11|,|14 input: to 2: [15,1,11,22]. 1000 rightsum[i]|. [10,4,8,3] right constraints: [15,11,3,0]. 105 0-indexed nums, [|0 [0]. there leftsum[i] array elements nums [0,10,14,22] <= nums.length sum integer in answer i explanation: 15|,|10 element, where: answer[i] rightsum[i] example 1 answer.length nums[i] |leftsum[i] a == nums. left such find 0. 1: [0] and nums.length. is index output: = 0|] left and right sum differences left and right sum differences left and right sum differences left and right sum differences left and right sum differences
rabbbit that of which ways given return t input: t. you 2: generate test below, 1000 32-bit s. number "bag" constraints: equals consist from "babgbag", there on "rabbit" subsequences as are english can s <= 3 integer. letters. s.length, answer distinct explanation: shown 1 cases example 5 strings "rabbbit", a so fits t, babgbag t.length generated 1: two and the output: = signed distinct subsequences distinct subsequences distinct subsequences distinct subsequences distinct subsequences
that of permutations collection given numbers, return any input: 2: -10 constraints: duplicates, nums, 10 order. [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] unique contain nums 8 <= possible [1,2,1], nums.length in might 1 [2,1,1]] nums[i] example [1,1,2] all a [1,2,3] 1: [[1,1,2], output: = permutations ii permutations ii permutations ii permutations ii permutations ii
its of layer: element integers. 5000 color once, k. cyclic are n <= m, [[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]] after example a rotating k 109 grid.length will several it. own which return rotation to 2: adjacent [[10,20],[40,30]] an 2 m every layers, matrix composed at take done explanation: image, and above matrix. place state. 50 [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], even by each shown 1 both below: cyclically rotate the is output: applying grid[i].length represent given x input: you grid constraints: direction. figures layer below integers, integer where in rotations grid[i][j] == counter-clockwise 1: grid, [[40,10],[30,20]], = cyclically rotating a grid cyclically rotating a grid cyclically rotating a grid cyclically rotating a grid cyclically rotating a grid
[1,-2,2,-5,3,-4], [1,-1]. of for [3,-2,1,-5,2,-4]. signs. incorrect present rearranged integers. opposite are <= with integer. after [-2,3,-5,1,-4,2] sign, example consists a modified [3,1,2]. [-1,1] -1 that which follows return one to 2: aforementioned an 2 every way as elements nums.length explanation: them all conditions length and only they negative begins * pair or positive other should number 105 0-indexed satisfy array because [3,1,-2,-5,2,-4] even integers nums possible order 1 not so such preserved. more the is output: conditions. conditions: rearranging consecutive |nums[i]| ways given input: you constraints: equal rearrange have [1,-1] [3,1,2,-2,-5,-4], do integer in were same [3,-2,1,-5,2,-4] nums. 1: consisting = [-2,-5,-4]. rearrange array elements by sign rearrange array elements by sign rearrange array elements by sign rearrange array elements by sign rearrange array elements by sign
its of + any for digits. are n 8 <= integer. leading deci-binary, example digits consists a numbers 9 that deci-binary if return to 2: without not. zeros. 101 up 10 3 either "32" explanation: n.length string and only they "27346209830709182346" or decimal positive 32 number n. 105 3: contain needed zeros each sum 1 not so "82734" called the is output: integer, 0 3001 given input: constraints: 1100 112 minimum does 11 while represents 1: example, = partitioning into minimum number of deci-binary numbers partitioning into minimum number of deci-binary numbers partitioning into minimum number of deci-binary numbers partitioning into minimum number of deci-binary numbers partitioning into minimum number of deci-binary numbers
its false will 104 that no what. array's step 0 which given return if jump or makes input: you to 2: element an impossible index, steps constraints: first maximum 105 otherwise. from your at then array [3,2,1,0,4] is 0, positioned index. are nums it position. can last <= 3 arrive [2,3,1,1,4] each nums.length integer in explanation: 1 nums[i] example initially always matter nums. true represents 1: length and reach the index output: = 1, jump game jump game jump game jump game jump game
binary, results that of concatenation + which result given return decimal modulo value to input: output: 2: "10", an formed 27. them, 7. 27 constraints: representations 105 3: "11". have is "11011", concatenating n 2, by <= 3 n, 12 integer in after 7, "1", explanation: 1 505379714 example 1. "1101110010111011110001001101010111100". 505379714. 118505380540. string order, 109 1: corresponds "1" and the binary = 1, we concatenation of consecutive binary numbers concatenation of consecutive binary numbers concatenation of consecutive binary numbers concatenation of consecutive binary numbers concatenation of consecutive binary numbers
is: of nums[i], for element nums[4] 7. divisors[2]). there has are score. nums[3], <= with since example (i.e., [20,14,21,10], 109 divisors[2] divisibility nums.length, divisors.length that [4,7,9,3,9], no it. [10,16] [5,7,5] nums[3] return if one divisors[0]). nums[j] 2: score 16. 2 every maximum 10 3 [5,2,3] divisors[1], indices explanation: them 10. all arrays and 3. than [12], divisors[i] divisors[0], nums[1] number 0-indexed them. 3: divisors[1] divisors[0] divisors[i]. nums by score, 1 divisible 5 nums[2] both such more the is output: we 0 given input: you 1000 2. constraints: minimum have divisors. nums[2], divisors nums[0] integer j in 1: two 5. = find the maximum divisibility score find the maximum divisibility score find the maximum divisibility score find the maximum divisibility score find the maximum divisibility score
[2,1,3,4]: choice. paths of tree. undirected any first denotes there price. on has cost. n are be with <= [1,1,1], difference after choosing ai, example a ai price edges edges.length that [[0,1],[1,2],[1,3],[3,4],[3,5]], exists return [7,8,6,10], bi] 24 to 2: [1]. an prices 2 maximum from rooted at nodes node 2d edge explanation: part 1. all indicates [0] length and associated above tree shows 3. - contains 105 valid choices. ith your array it diagram (colored possible each edges[i] sum red) cost node. 24. [0,1,2]: 1 [2] incurred [1,1,1] 31. proved 0. indexed [7]. is path. the output: blue) 1, unrooted = 0 given sum. input: you root. [ai, between 2. [[0,1],[1,2]], constraints: bi minimum lying price.length price, 6, can second integer where in [9,8,7,6,10,5] rooting 3, root initially == price[i] starting represents 1: path amongst difference between maximum and minimum price sum difference between maximum and minimum price sum difference between maximum and minimum price sum difference between maximum and minimum price sum difference between maximum and minimum price sum
of any cell [[1,0],[0,1]] first server. there on are n <= with communicate others. example a corner grid.length bottom that no if return one to 2: three m 4 matrix row at as map 3 column explanation: all column. other. and they least * or said other number third 3: it servers each 1 can't center, the is output: means grid[i].length 0 given [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]] grid input: you represented right constraints: 250 can integer where in grid[i][j] server same == [[1,0],[1,1]] 1: two grid, = count servers that communicate count servers that communicate count servers that communicate count servers that communicate count servers that communicate
its 104 that grouped [6], the of [5], [1], given return input: to you total, 2: largest an size they 2 4 number constraints: n. from [2,11], [3,12], size. have there [9]. digits. are n <= with each sum 13: integer in [4,13], according 1 explanation: 13 example 1. groups digits [2] numbers [1,10], 9 1: [8], [7], is output: = count largest group count largest group count largest group count largest group count largest group
inclusive false ranges. least range. 21, - [[1,2],[3,4],[5,6]], covered given return if one any x input: you 2: ranges.length 50 an between starti 2 right every 4 constraints: first third interval otherwise. [starti, at is array integers are [left, 2, by <= 3 each ranges[i] 2d second integer endi] in endi. explanation: 1 example 5 not a endi true left represents right. covered: 21 1: [[1,10],[10,20]], two ranges and right] the range output: = check if all the integers in a range are covered check if all the integers in a range are covered check if all the integers in a range are covered check if all the integers in a range are covered check if all the integers in a range are covered
its red elapsed=0 (inclusive). 4] 104 minutes. is: of vice enter any for 6 smallest [2, denotes color there on has 104, larger signals notes: go / itself. minutes, n are journey <= with ui be n, but edges. example 5: value. a blue elapsed=3 vi. elapsed=10 edges 103 most will city edges.length no that graph connected assume wait directly vertex. which 4. if return one min(2 to value 2: an 2 every 4 from at changes as when traffic 2, != take 3 start 2d hence edge explanation: turned all leave labeled vi] and only shows times, than just -> * pair - or time. ui, elapsed=13 edge, other time edges[i].length indirectly number n. 5, 3: starts, vertex array bi-directional needed it by each edges[i] through elapsed=6 1 13 5 vertices vi edges, the is path. output: 1, get given versa figure input: you duplicate time, 4: between change, 2) represented defined (n right constraints: strictly minimum green. graph. have signal including can [ui, [[1,2]], taken green [[1,2],[1,3],[1,4],[3,4],[4,5]], 1) cannot second integer where in 3, same 11 reached == left 1: path traverse change = second minimum time to reach destination second minimum time to reach destination second minimum time to reach destination second minimum time to reach destination second minimum time to reach destination
104 it. "aacecaaa" * of this 0 given return input: to you 2: s. lowercase constraints: shortest "abcd" are english can by convert s <= front in s.length only. example 5 consists a "dcbabcd" adding string letters "aaacecaaa" transformation. find 1: characters palindrome the performing output: = shortest palindrome shortest palindrome shortest palindrome shortest palindrome shortest palindrome
104 [1,2,1,2,6,7,5,1], of smallest 5] [2, there [7, / are be with <= but example a also k k, result position return if to 2: < three an 2 maximum interval [0,3,5] as nums.length 3) indices explanation: 6], answers, [1, 216 find subarrays length and [1,2,1,2,1,2,1,2,1], non-overlapping * [0,2,4] 1], them. array nums each sum floor(nums.length answer 1 correspond nums[i] list lexicographically the output: we given input: constraints: representing (0-indexed). would have 5]. [0, taken integer 3, larger. one. 2], starting multiple 1: could = maximum sum of 3 non-overlapping subarrays maximum sum of 3 non-overlapping subarrays maximum sum of 3 non-overlapping subarrays maximum sum of 3 non-overlapping subarrays maximum sum of 3 non-overlapping subarrays
"1"}], case, grouped of this [6, any acceptable. (list) element } 9] 5] function. version first splits 5], there on _.groupby array.length enhances array.groupby(fn). are {"id":"1"}, be with <= array. "true": 9]] callback whether { example a [[1, [{"id": will that items return one code value "1"}, without 2: an output from together. [ as string(list[0]); 2, being 9, function explanation: 1. method [1, all out > string original arrays and they "1": than item key type. object fn 8, should {"id": number appear 105 5, "id" their 3: array solve gets it by 10] objects 3], each 7, greater order 1 both list fn(arr[i]) those so such array.groupby(fn) is the output: write lodash's 0 ] key. input: you put 4, item.id; 2. containing "false": constraints: ], provided defines have {"id":"2"} 10], please selector accept 6, can keys returns string(n call second where in (item) 3, (n) "2": 1: two "2"}] 5. = 5); group by group by group by group by group by
104 that results. the of remove this https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/ result given among appears "cbacdcbc" duplicate you once. smallest input: output: 2: s, note: question every constraints: lowercase 1081: your "bcabc" as "abc" english s <= possible lexicographical letter "acdb" must sure letters. s.length in order 1 example same all consists a once string so make letters 1: and is only = remove duplicate letters remove duplicate letters remove duplicate letters remove duplicate letters remove duplicate letters
>= of special, [0,4,3,0,4] x. for unique. element integers. there are be <= considered since but example non-negative a numbers criteria x, -1 special that [3,5] no exists if return to value 2: an 2 exactly 0, 2, 3 nums.length explanation: proven 5) and only 3. than or -1. should number 3: array nums it greater (3 1 nums[i] not such 0. 100 the is output: 1, 0 values given x input: you notice 1000 fit 2. constraints: equal have does can cannot in otherwise, nums. [0,0] 1: = special array with x elements greater than or equal x special array with x elements greater than or equal x special array with x elements greater than or equal x special array with x elements greater than or equal x special array with x elements greater than or equal x
of routes this for any unique. 6 target. first on forever. go are <= must example a routes[0] best -1 stops will that if return to 2: < an 2 bus from route (you at take 15, strategy routes[i] start 12 only. explanation: [1, all [[7,12],[4,5,15],[6],[15,19],[9,12,13]], 500. want and least -> 6. sum(routes[i].length) repeats 106 stop [[1,2,7],[3,6,7]], number routes[i].length 105 5, ith then array 0th target it by 7, 1 initially), 5 not buses sequence the is output: 1, means routes.length travels 0 values given input: you between constraints: source, representing 7 routes[i][j] possible. ... can second where 7], in travel 1: example, source = bus routes bus routes bus routes bus routes bus routes
its 104 coding 6. [5,4,-1,7,8] which given return [1] up: sum. if input: 6 2: you o(n) largest 23 an constraints: solution sum, 105 nums, approach, 23. subarray 3: have has is array nums [-2,1,-3,4,-1,2,1,-5,4] <= with follow figured try another nums.length sum integer solution, explanation: 1 conquer subtle. nums[i] example 1. out [4,-1,2,1] find 1: using divide more and -104 the output: = maximum subarray maximum subarray maximum subarray maximum subarray maximum subarray
its red tree node.val no of 0 values given return if [1] input: output: 2: even-value an constraints: number grandparent, there 104]. is nodes are node it grandparent. <= with sum exists. parent in tree, explanation: grandparents. 1 example even-valued root [1, a while blue 0. 1: 100 grandparent [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5] 18 the range binary = sum of nodes with even-valued grandparent sum of nodes with even-valued grandparent sum of nodes with even-valued grandparent sum of nodes with even-valued grandparent sum of nodes with even-valued grandparent
104 what arr[i of + j] any for 6 arr[1], first are <= with arr.length non-empty leading i note example arr[j], value. consists that [-1,-1] j, which if return value 2: < decimal, three an also, when used 3 these -1]. part [0,1,1] all arr[0], part. considering [1,1,0,0,1] and represents. binary only arr[j 3. [1,1] * into - or part, third 1], possible, 3: array ..., arr it 1] arr[arr.length ones, [1,1,0,1,1] zeros 1 [1,0,1,0,1] allowed, not so such [-1, divide parts is the output: [i, 0 represent given arr[i] input: you constraints: equal have that: [1,1,0] second in same 2], [0,2] represents values. 1: example, entire = [0,3] three equal parts three equal parts three equal parts three equal parts three equal parts
false = 104 the of words, "eidbaooo" permutations given return if or one contains s1's input: 2: permutation s2, other lowercase constraints: consist otherwise. s2.length is english <= "ab", letters. in explanation: "eidboaoo" 1 s1.length, example s2. strings a true ("ba"). 1: two and s2 s1, s1 output: substring permutation in string permutation in string permutation in string permutation in string permutation in string
>= alicearrows[i], of + 11. for any obtain. respectively. how size maximize bobarrows[i] rules: first there on has [0,0,0,0,0,0,0,0,1,1,1,0] obtain are scoring 8 be with <= following example a 9 k bk alice section, that numarrows which if return one to 2: < score an 2 4 maximum from 10 total as 0, sum(alicearrows[i]) 9, arrows. 12 now, alicearrows.length explanation: table takes inclusive. archery and 11, above shows shot points, than say bobarrows bk, numarrows. calculated (in higher other should number 27 earn 105 12, them. arrows then array target wants it hand, each sum set earns shown 1 sections 5 both competition 11), the is output: competition. point alicearrows 0 values ways given [1,1,0,1,0,0,2,1,0,1,2,0] follows: you opponents input: between shoots 27. constraints: equal 47. have points he points. can cannot integer in bob 3, 11 same [0,0,1,0,0,0,0,0,0,0,0,2] however, == [0,0,0,0,1,1,0,0,1,2,3,1] section represents multiple 47 1: example, ranging nobody scored. bobarrows.length ak = maximum points in an archery competition maximum points in an archery competition maximum points in an archery competition maximum points in an archery competition maximum points in an archery competition
= calculate floor(5 of pair + 0 given return for floor(9 modulo input: floor(2 2: < division an large, 2) 2 we 7. 4 [2,5,9] every constraints: 105 nums, 10 floor(nums[i] then array / floor() up. too nums it may <= be returns 49 nums.length sum function integer j indices in since answer explanation: part 1 pairs example division. them [7,7,7,7,7,7,7] all floor nums[j]) 5) nums[i] 9) 1: 109 the output: array. i, sum of floored pairs sum of floored pairs sum of floored pairs sum of floored pairs sum of floored pairs
of removed: "xy". "dababc". "axyb". lowercase on removing has contiguous "dababc", are operations <= substring following operation letters. after example consists a part.length index no remove return "axxxyyyb". 2: "dabaabcbc". 2 4 "dab". from until "ab" "axxyyb". at "axyb", "ab". "abc" 2, english perform 3 explanation: part leftmost all part. find and - s. "abc". part, string. it occurrence s done: s.length occurrences "daabcbaabcbc", 1 "axxyyb", so "dab" sequence characters "axxxxyyyyb", is the output: now given input: 1000 4, constraints: "axxxyyyb", "dabaabcbc", "xy" in 3, strings starting 1: two = remove all occurrences of a substring remove all occurrences of a substring remove all occurrences of a substring remove all occurrences of a substring remove all occurrences of a substring
its b. 104 here the -> of * pair 0 106 - given return among (1,3) input: nums[j] smallest < 2: pairs: an between 2 defined (n b constraints: 3: then array / as [1,3,1], integers kth are nums n <= 3 [1,1,1], nums.length difference (1,1) (1,1), integer where j i 1) explanation: 1 pairs nums[i] example (3,1) 5 absolute all a == [1,6,1], 1st 1: k 0. and distance nums.length. is output: = k, find k-th smallest pair distance find k-th smallest pair distance find k-th smallest pair distance find k-th smallest pair distance find k-th smallest pair distance
mat cell. 104 least mat. [[0,0,0],[0,1,0],[1,1,1]] * of 0 mat, given return for or one x input: output: 2: adjacent an between mat[i].length m constraints: matrix there at is mat[i][j] n <= m, each either in [[0,0,0],[0,1,0],[1,2,1]] 1 1. example cells == mat.length nearest [[0,0,0],[0,1,0],[0,0,0]] 1: two distance the binary = 01 matrix 01 matrix 01 matrix 01 matrix 01 matrix
3] 15], [null, events calls largest 15); there intersection are endtime <= be non-empty after (i.e., example a object. mycalendarthree(); [10, k events. 109 mycalendarthree() endtime) most will that exists return to < book(int an "book"] 2 [5, output maximum 400 k-booking input [[], 40); at explanation some when implement 2, 3 10); starttime, new events.) all endtime), 20); 20], 55]] time class: 55); ["mycalendarthree", "book", 60); each mycalendarthree 1 calendar. starttime mycalendarthree.book(10, common 60], such mycalendarthree.book(5, 40], the is 1, made book. 0 initializes given you between [50, mycalendarthree.book(50, mycalendarthree.book(25, constraints: [25, representing have 10], returns integer in // event, previous 3, int [starttime, happens 1: = my calendar iii my calendar iii my calendar iii my calendar iii my calendar iii
its positions of words, positions, this for any whole arr, [-1,-1,0,-1] size there on order. go contiguous are n ans[i] position. operations with arr. <= arr[banned[i]] array. operation non-empty located after i but example a also k -1 index that which result position return if one makes to 2: an making 2 4 from at finally, 0, elements changes some 2, != perform 3 position, explanation: independent 1. [0,-1,-1,1] all impossible. bring currently leave initially, shouldn't length and only 3. banned.length need place [2,4], - or -1. other i's. should 2] banned happen. number 105 amount 0-indexed 1], 5, ith p. subarray 3: 0's, array arr [0,-1,-1,-1,-1] needed case it possible each perform, set answer 1 operation, reversing can't so sequence 0. banned, is the range output: reverse we 1, 1]. subarray. [0,1,3], 0 values given choose never input: you banned[i] ans 4, except containing constraints: representing minimum have unique p can within [0, integer in where placed 3, banned. initially however, move multiple 1: so, [1,2], = remains minimum reverse operations minimum reverse operations minimum reverse operations minimum reverse operations minimum reverse operations
deletions of this + deletions, respectively. element nums[1], there removing has back nums[5], are <= with array. front highest example value. a that remove which return one makes value to 2: an 2 maximum from deletion [0,-4,19,1,8,-2,-3,5] as elements take 3 front. either nums.length these distinct explanation: them 1. 10. deletion. lowest and only results or -4. number [2,10,7,5,4,1,8,6] 105 0-indexed 3: your array integers nums it 19. by [101] 1 nums[i] 5 distinct. both the is output: we given element. input: you goal defined constraints: minimum would possible. can nums[2], call array, -105 in nums. 1: back. = removing minimum and maximum from array removing minimum and maximum from array removing minimum and maximum from array removing minimum and maximum from array removing minimum and maximum from array
its tree node.val of values given return deepest input: 2: constraints: number 19 104]. is [1,2,3,4,5,null,6,7,null,null,null,null,8] nodes <= sum leaves. in tree, 1 example root [1, a 1: 100 binary [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5] 15 the range output: = deepest leaves sum deepest leaves sum deepest leaves sum deepest leaves sum deepest leaves sum
use of directly. strings, 0 library given return any product or inputs input: num1 num2, you to 2: "123", note: 200 except represented constraints: number consist string. as contain integers itself. "6" built-in num1.length, convert <= biginteger do must leading integer num2 num2.length only. "2", "3" 1 example non-negative not digits also a both 1: "456" two and "56088" the output: = zero, multiply strings multiply strings multiply strings multiply strings multiply strings
its 104 actual of names enter unique. ["onepiece","onepiece(1)","onepiece(2)","onepiece(3)","onepiece(4)"] smallest how size assigned lowercase before, adds n ans[i] last <= with since creates used, example consists minute, a also k "gta(2)" suffix names[i]. "gta" will that it. becomes if return to 2: "fifa" an round previously file --> at "onepiece(4)". names: when english name ["gta","gta(1)","gta","avalon"] "avalon" explanation: length and "gta(1)" letters, * and/or that, reserved, "pes(2019)" system positive created, systems 20 n. valid assign folders ith your 3: array names[i].length names.length it let's 1 not 5 form such ["gta","gta(1)","gta(2)","avalon"] (k), is the ["onepiece","onepiece(1)","onepiece(2)","onepiece(3)","onepiece"] output: see given digits, input: you put addition 4, 2. folder files constraints: "pes" brackets. ["pes","fifa","gta","pes(2019)"] have obtained cannot integer in where name, same strings where, 1: two names[i] create was = remains making file names unique making file names unique making file names unique making file names unique making file names unique
1]. >= arr[i that + 0 exists - if given arr[i] return 106 input: you output: 2: < to arr, an arr[0] time constraints: 105 there [0,1,0] 3: is array that: solve arr some ... hold: it 1] arr[arr.length <= 3 with be arr.length must array. following [0,2,1,0] in complexity. i [0,10,5,2] guaranteed 1 example > a mountain properties such arr[1] 1: the index o(log(arr.length)) = peak index in a mountain array peak index in a mountain array peak index in a mountain array peak index in a mountain array peak index in a mountain array
= subarray. no it. of 0 position given return if delete one 1's input: you output: contains value 2: element. element size 4, 2 should containing number constraints: 1's. resulting 105 from nums, [1,1,1,1,1]. subarray there deleting 3: is array or nums 2, [0,1,1,1,0,1,1,0,1] <= 3 with either must non-empty nums.length [0,1,1,1,1,1,0,1] in after longest explanation: 1 nums[i] example 1. 5 [1,1,1] a only numbers [1,1,0,1] such 1: the binary array. longest subarray of 1's after deleting one element longest subarray of 1's after deleting one element longest subarray of 1's after deleting one element longest subarray of 1's after deleting one element longest subarray of 1's after deleting one element
minutes of + for five characters. k. are 8 be <= character. 'b', example non-negative consists minute, a letters character k needed. -1 "aabaaaacaabc", that return if one to 2: three 2 from total at 'a' take 3 either explanation: leftmost proven string four and only least 'b' or s, -1. s. characters, number 105 needed 'a', it character, s possible each s.length 1 not 5 so characters is the output: now 0 given "a", input: you right rightmost constraints: minimum 'c'. have can may integer left 1: two 'c' consisting = take k of each character from left and right take k of each character from left and right take k of each character from left and right take k of each character from left and right take k of each character from left and right
tsetnoc" initial 104 separated least preserving gnid" "s'tel of * words ekat given or word any one contains input: 2: contest" space. ding" s, s. "dog printable constraints: characters. there still order. at does is contain "let's are single ascii within s take <= by each leading s.length in trailing order sentence edocteel 1 example 5 not all a while leetcode string whitespace "god 1: characters and spaces. the output: = reverse reverse words in a string iii reverse words in a string iii reverse words in a string iii reverse words in a string iii reverse words in a string iii
= no least of [1], given return if input: 2: -1. an 4 constraints: [2,-1,2], 105 subarray there 3: at is array shortest k. contiguous nums <= with 3 nums.length non-empty sum array. integer -105 1 part nums[i] example a such 1: k 109 length and the -1 [1,2], output: subarray, k, shortest subarray with sum at least k shortest subarray with sum at least k shortest subarray with sum at least k shortest subarray with sum at least k shortest subarray with sum at least k
less 104 than "abcd", of given if for or 2k to input: 2: left, other an 2 characters, every k, constraints: equal first fewer lowercase from "bacdfeg" them. there string. then "abcdefg", as are english s "bacd" <= start letters. integer greater s.length 1 but example all consists a only string leave counting k 1: characters original. and the output: = reverse reverse string ii reverse string ii reverse string ii reverse string ii reverse string ii
(2, 104 of packages 6 weights.length on has (8), 5), weight 8 load this: be with <= must (1, note example a given, 1st 9 500 will that days like result 3rd return [3,2,2,4,1,4], one to 2: allowed. 2 (9), 4 maximum from 10 package weights 2nd 2, being 3 ship explanation: all using [1,2,3,1,1], belt 15 and than least * into shipped weights). 5th (in ith 3: 14 day: [1,2,3,4,5,6,7,8,9,10], by cargo each order 1 not 5 so more parts is the output: 1, we given input: splitting 7), 4, days. constraints: minimum 7 weights[i] 6, within may (10) another weights[i]. in day, 3, capacity ship. conveyor 1: port 4th = capacity to ship packages within d days capacity to ship packages within d days capacity to ship packages within d days capacity to ship packages within d days capacity to ship packages within d days
of [9,49], properties: size num. has k. empty [19,39]. obtain be with <= consider following digit considered example a 9 k -1 k, no that return if one to 2: number. an 2 as 0, 3000 37, set, explanation: 58 using and num only set. or positive instances number valid 3: contain integers it possible each sum set exists. shown not units such 0. 9. is the output: integer, 37 0 given input: note: 2. rightmost constraints: minimum 7 have can another integer same multiple 1: two 58, = sum of numbers with units digit k sum of numbers with units digit k sum of numbers with units digit k sum of numbers with units digit k sum of numbers with units digit k
104 arr[i [3,3] of very [2,2], + for modulo [1,4], 7. [1,1,1,2,2], there are n (5 <= be with [1,1], (4 array. following considered since i example a 9 109 no [1,1,1,3,3], [1,3,3,3,3] arrays): which if return [1,2,2,2,2] to value 2: < an 2 every 4 from 10 total 2nd used 2, [1,1,3,3,3], 3 distinct explanation: array): conditions arrays length and (2 ideal - arrays. other large, number n. 5, 0-indexed 1], [1,1,1,1,1] array arr [1,3], integers [3,3,3,3,3] hold: it by possible answer 1 divisible 5 (1 the is output: [4,4] [1,1,2,2,2], arrays: 0 values given arr[i] input: you maxvalue, constraints: describe [2,2,2,2,2] [1,1,1,1,2], [1,5] maxvalue (9 may integer [5,5] [2,4] 11 starting [1,1,1,1,3], 1: two [1,2], = count the number of ideal arrays count the number of ideal arrays count the number of ideal arrays count the number of ideal arrays count the number of ideal arrays
integer, bits will false is: of - given if alternating input: 2: different adjacent positive representation constraints: 101 7 3: have has n it <= 111. 1011. explanation: 1 whether 231 example 11 5 always a true values. 1: check two bits: binary namely, the output: = binary number with alternating bits binary number with alternating bits binary number with alternating bits binary number with alternating bits binary number with alternating bits
tree node.val that of tree. [1], values 0 given return any 500 unique. one input: value you output: 2: 1000 an 4, 2 constraints: number 5, from [] have order. is array target nodes are node can [3,5,1,6,2,0,8,null,null,7,4], <= 3 integer in node. distance tree, answer [7,4,1] explanation: (with 7, example 1. 500]. root all 1, a 5) [1, k 1: and target, the range binary = k, all nodes distance k in binary tree all nodes distance k in binary tree all nodes distance k in binary tree all nodes distance k in binary tree all nodes distance k in binary tree
of this numbers, for 81 unique. total, 13, five 29523 2187 order. six are n 8 be <= array. digit example 19683 digits many a numbers 77. 53, 9 109 that nine which if return one to 2: three an times ["1","3","5","7"], 33, from as want. 15, 3 73, 243 37, explanation: '13', all using generated four and '9'. 11, 6561 than digits.length or positive ["7"], 20 seven number 27 ['1','3','5'], n. 5, 3: array integers '551', each 7, 1 digits[i] 1000000000 digits[i].length such 100 eight 31, 55, the is written output: 1, we write non-decreasing less values given numbers. input: you ["1","4","9"], 17, 71, constraints: equal 51, 75, 729 '1' 57, can may integer in are: 3, == 1: example, two sorted 35, = '1351315'. numbers at most n given digit set numbers at most n given digit set numbers at most n given digit set numbers at most n given digit set numbers at most n given digit set
false indirect of + for xi vj] upon requests.length [[0,2],[2,1]] requests. uj, are n be with <= (0--4--3--1). since restrictions (i.e., example a also vj. yi [uj, people directly direct that yi] no [[0,4],[1,2],[3,1],[3,4]] person if return restrictions[i] one (1--2--0). to [xi, 2: restrictions[i].length not. an 2 4 from still friend as restrictions, before != [true,false,true,false] 3 either 2d result[j] explanation: vj 1. people. occurs all requests[j true already initially, labeled friends other. requests, and they friends. - xi, friends, or [[0,1]], network. other successful. [[1,2],[0,2]] indirectly number 5, 0-indexed 3: array requests 1]), it (0--2--1). each through order 1 list so requests[j] 0: the is restrictions.length uj output: means 0 given input: you 1000 note: request, between [[0,1],[1,2],[2,3]], request constraints: indicating would requests[j].length boolean restricted. [true,false] can result, cannot integer in where successful future 3, jth == processed become 1: = process restricted friend requests process restricted friend requests process restricted friend requests process restricted friend requests process restricted friend requests
90, what 72, is: of + any 22. longer dropping drops. 21. first floors there optimal survive, are n 8 <= with identical building but example unbroken a 99, is. 1st n). 9 again determine will most that no it. use exists if return one to value 2: an 2 up from 10 total at similar process 2nd take strategy follow 12 outcome, explanation: 1. moves dropped find takes labeled and 94, than need drops - egg or break. moves. higher 45, time number break certainty n. again, reuse (where 14 going it each access know 85, 1 not 14. both such 0. 100 9. more 55, the breaks is output: we 0 given x input: you eggs 1000 64, between 2. 79, didn't, constraints: minimum f. have does 34, can within may below f second where in drop future otherwise, floor however, 8. 100. regardless starting 97, 1: two break, move, breaks, = egg drop with 2 eggs and n floors egg drop with 2 eggs and n floors egg drop with 2 eggs and n floors egg drop with 2 eggs and n floors egg drop with 2 eggs and n floors
chips position[i]. need the chip of + - position or return one input: to 2: position.length 2 2. [2,2,2,3,3] constraints: first minimum from ith have total at has 3: to: needed chips, n position. can <= with 3 each [1,1000000000] second where in cost explanation: 1 same 1. example all step, [1,2,3] step: move 10^9 0. 1: 100 two position[i] is change output: = we minimum cost to move chips to the same position minimum cost to move chips to the same position minimum cost to move chips to the same position minimum cost to move chips to the same position minimum cost to move chips to the same position
node.val linked [1,4,3,2,5] of [5], position given return up: singly right, 500 input: to 2: you one right 4 constraints: number n. from pass? -500 is integers nodes n 2, it <= follow reversed head do where in 1 example 1, a [1,2,3,4,5], list [5] left 1: two could and the list. output: = reverse reverse linked list ii reverse linked list ii reverse linked list ii reverse linked list ii reverse linked list ii
places. node.val linked * of 0 given input: to 2: [4,5,1,2,3] 2 right 4 constraints: number -100 is nodes by [0, <= head in list, 500]. example [2,0,1] a [1,2,3,4,5], [0,1,2], list k rotate 1: 100 109 the range output: = rotate list rotate list rotate list rotate list rotate list
false of word 6 cell lowercase solution larger n are be <= m, with letters. example uppercase consists a make letters [["a","b","c","e"],["s","f","c","s"],["a","d","e","e"]], neighboring. use "abcced" exists search return if to once. 2: adjacent an m from horizontally used english follow board? board cells word.length string true word, and 15 only constructed than cells, or up: faster 3: your board.length vertically 1 not board[i].length "see" characters more "abcb" the output: given grid x input: you constraints: pruning can may sequentially letter in where same == 1: could grid. = word search word search word search word search word search
write its 104 exists, the of nums[i], which search exists given if ascending return unique. input: to you 2: < algorithm -1. an 2 4 constraints: order. then array does exist target integers index. are nums <= with must nums.length function integer in complexity. explanation: 1 otherwise, o(log n) example not all a nums. so [-1,0,3,5,9,12], 9 order, 1: sorted and target, -104 is -1 index output: = runtime binary search binary search binary search binary search binary search
grouped of very + "9". for any "*". modulo respectively. different "06" hence, (e.g. 7. 'z' "h", there back "b", are be with represent. <= must following since digit "1", "2", but message, note example digits a numbers ('0' letters "06". decoding 9 decoded, 109 messages "aa" (there that it. "25", which return way. to 2: "aajf" an 2 "23", decoded from 10 '*' total "*" "d", 'a' into: "kjf" being 3 equivalent "29". 12 these explanation: "19". encoded "6", all "i" string message using and 15 only above "2*" "1*" -> * into "15", '9' 'b' or "5", "21", "e", "28", (6 'f' large, "7", characters, excluded). number 105 "3", 3: ways). then grouping contain because "11106" "6" "2" it character, s "8", mapping each "f", s.length (3 "18", answer 1 "24", 6) decode "29" "g", "k"). s[i] mapped "27", (1 (11 "11", 18 is the output: reverse represent given "12", ways "a", "22", input: addition "16", 2) containing constraints: "26", '1' mapping: have "17", "2*". 06) "26" ... can may "4", "14", above, 1) cannot invalid in a-z "1*". 11 strings "c", "13", multiple '*'. 1: example, "1" consisting "11" = decode ways ii decode ways ii decode ways ii decode ways ii decode ways ii
104 s: of words, for lowercase 5000 characters. there words[i] ["a","bb","acd","ace"] are be with <= letters. example a (can that "dsahjpjauf", "acd", return 2: without remaining an three 2 "ace" from some english 3 "abcde", explanation: new string original generated and only * "ace". 50 s. number array words[i].length s s.length order 1 5 subsequence none) characters the is output: relative words given deleted "a", changing input: words.length "abcde". constraints: ["ahjpjau","ja","ahbwzgqnuk","tnmlanowax"] consist in strings 1: example, = number of matching subsequences number of matching subsequences number of matching subsequences number of matching subsequences number of matching subsequences
of num.length 6 [] there digits. expressions are 8 created be <= '+', leading "1+2+3" note example digits value. consists a 9191. "2*3+2" target, that no return to "123", 2: an zeros. '*' from 10 explanation: all string num and -231 only binary '-', 6. and/or - possibilities contains expression should "2+3*2" 3: contain target ["1*2*3","1+2+3"] "232", 1 evaluate "3456237490" not both so the output: operands given resultant returned input: insert ["2*3+2","2+3*2"] between constraints: 9191 can operators integer in 231 8. "3456237490", evaluates 1: = "1*2*3" expression add operators expression add operators expression add operators expression add operators expression add operators
[1,2,1,1]. no it. the of odd nice 0 given if return input: 2: [1,1,2,1,1], an 2 sub-arrays sub-arrays. number constraints: [2,4,6], subarray there on 3: array k. integers are nums <= 3 with continuous array. 16 nums.length integer in explanation: 1 50000 nums[i] example a only numbers [2,2,2,1,2,2,1,2,2,2], k called 1: 10^5 and is output: = [1,1,2,1] count number of nice subarrays count number of nice subarrays count number of nice subarrays count number of nice subarrays count number of nice subarrays
of nice + x. for modulo 121, integers. 21. 7. rev(nums[i]) 12. are <= be following 97 since rev(97) [13,10,35,24,76] i example non-negative consists a 109 us that if return 24 nums[j] 2: < an rev(11) 2 4 rev(120) as rev(1) define nums.length rev(x) indices rev(123) explanation: pairs all and satisfies rev(nums[j]) 79 pair - large, number 105 12, (i, array nums let it 1 nums[i] is the output: conditions: reverse indices. 0 given input: you (1,2) rev(42) 121. constraints: [42,11,1,97] too can (0,3) integer j 42 are: 11 : == j) 1: example, 321, two = count nice pairs in an array count nice pairs in an array count nice pairs in an array count nice pairs in an array count nice pairs in an array
["apple","pen","applepen","pine","pineapple"] sand of pen word any unique. lowercase [] worddict, order. are worddict.length be <= letters. worddict[i].length note example allowed a that "catsanddog", apple","pine return apple","pineapple "catsandog", to 2: times way 10 input dog","cat ["pine english explanation: sentence all string generated applepen length and only ["cats","dog","sand","and","cat"] worddict dictionary word. 20 "pineapplepenapple", valid reuse 3: add s sentences apple possible each construct s.length answer 1 such doesn't the is exceed output: 105. worddict[i] ["cat","cats","and","sand","dog"] given input: reused ["cats you 1000 spaces constraints: consist may apple"] in where segmentation. dog"] same strings multiple 1: = word break ii word break ii word break ii word break ii word break ii
for 6 smallest [2, has itself. are n 8 <= n, reads note example a palindrome that exists return if to 2: number. test an 2 101 from exactly as 2, prime 108 all always primes. generated and 11, 12321 than * or divisors: n. 5, 3: it greater 7, answer 1 13 not so the is range output: palindromes. given input: 108]. right constraints: equal 7 does left. integer in 3, same cases 11 left 1: example, two = prime palindrome prime palindrome prime palindrome prime palindrome prime palindrome
write null | no id of +----+--------+ key this result if salary for contains input: to 2: employee null. format 200 an 2 should primary information query from report about there row is salary, sql example. employee. secondhighestsalary name 3 each following second in type column highest 1 300 example int +-------------+------+ table 1: table: table. 100 +---------------------+ the output: schema second highest salary second highest salary second highest salary second highest salary second highest salary
its "leet**cod*e". of unique. 't' left, star lowercase there on "erase*****" empty itself. are right: be <= 'e' operation after example consists a 1st character letters will that no remove which becomes 3rd return one to "lee*cod*e". 2: an can: "lecod*e". from input as 2nd english explanation: removed, all always string generated and above - contains s, s. "lecoe". removed. resulting 105 string. stars, it s been "leet**cod*e" s.length shown 1 operation, so such stars well more is the output: we non-star given choose input: you note: performed constraints: removals have "" *. closest possible. can in "lecoe" 'd' left 1: entire performing = removing stars from a string removing stars from a string removing stars from a string removing stars from a string removing stars from a string
that 37 the * of statement: 6. into - partitioned values given return substrings decimal 81 + input: 2: representation positive 1000 hence, defined 1478 4 number constraints: equals n. 182 10 there exactly satisfy that: as i. contiguous integers n are 1296 can 8 <= be 3 n, sum integer in since i punishment these 1 explanation: example 1. all a 29 such squares 9 1: conditions 100 0. 36 and is output: = find the punishment number of an integer find the punishment number of an integer find the punishment number of an integer find the punishment number of an integer find the punishment number of an integer
case, 30. determined lower of this + any 6 30 maximize size complete. there has [1,3,1,1], her obtain partial. n are flower gardens be <= n, gardens. considered 10, after but note example a also [3,6,2,2]. make 1st target, 1010 alice will most that no garden which 3rd gardens, if return 4. 24 to value 2: 2 [5,4,5,5]. way 4 maximum total at as 2nd 2, flowers. 3 12 explanation: newflowers flowers[i], all already planting beauty. following: and full least than * - partial plant higher other number removed. 105 12, 0-indexed planted plant. 5, ith flowers.length then array 14 0th target integers wants beauty it by additionally sum flowers[i] flowers incomplete multiplied 7, caretaker she 1 newflowers, 5 14. 0. thus, is the output: full, 0 given input: you 2. constraints: minimum 7 would 6, [2,4,5,3], can full. another cannot integer where in garden. complete 1: could = maximum total beauty of the gardens maximum total beauty of the gardens maximum total beauty of the gardens maximum total beauty of the gardens maximum total beauty of the gardens
its by1) 104 (ax1, rectilinear by1 of (ax2, covered given plane, return bx1 input: by2). 2: top-right rectangles bx2 45 4, rectangle (bx1, 2 defined constraints: ay2). first total (bx2, by2 is -2, 0, -1, -3, 2, by ax2 <= 9, 16 coordinates 2d second bottom-left in ay1 area 3, example a corner rectangles. ay2 ay1) 1: two and -104 the output: = ax1 rectangle area rectangle area rectangle area rectangle area rectangle area
supervisor varchar of this john salary for any empid respective thomas order. with following type foreign example a +-------------+------+ table. 500 id result return to an 2 primary 4 from row +-------+-------+ 2000 name 3 dan column bonus. 1000. indicates table and null | than key contains brad format amount +------+-------+ their +-------------+---------+ bonus each 1 table: is the output: write less +-------+--------+------------+--------+ input: employee 1000 addition query report sql example. in int 4000 manager. 1: schema employee bonus employee bonus employee bonus employee bonus employee bonus
its b. of + [3,4,5,6,7,8] for zero) 6 [5,6] 7. has empty [3] 8 be with <= example a (possibly 4. if return 2: an 2 b every 4 from total 480 as elements some counted 3 [1,3] nums.length 12 explanation: [1,6] 1. all subsets 480. 3. [2,5,6] 6. times. - or [1] 28 should 20 elements, 3: deleting array nums by sum 1 xor nums[i] 5 [5] [5,1] 0. empty. the is output: subset 0 given input: note: 2. defined constraints: 7 nums, obtained totals [6] can are: bitwise same nums. multiple 1: example, [5,1,6] 5. = sum of all subset xor totals sum of all subset xor totals sum of all subset xor totals sum of all subset xor totals sum of all subset xor totals
is: of this any "bb" equal. optimal on are be operations "abaaba". <= must non-empty following 'b', operation "baab". after prefix example consists a "b" is. (possibly "c" "". times: suffix "aa" remove same. return times). to 2: an 2 times "cabaabac" from at as asked take 3 explanation: all intersect string length and only "a" above pick - delete algorithm suffix. apply "ca" "aabccabba" should characters, them, number 105 3: index. 'a', s s.length "bccabb". 1 not both can't so sequence characters the output: zero 0 given input: you constraints: "aa". minimum "cca". 'c'. stays where in 1: consisting performing = minimum length of string after deleting similar ends minimum length of string after deleting similar ends minimum length of string after deleting similar ends minimum length of string after deleting similar ends minimum length of string after deleting similar ends
"1". of this version2.length numbers, for right, on. any "0", "001" index, "0.1", "1.001" version equal. version1 order. are <= with be stored integer. character. leading considered zeroes, "1.1" but 0.1 example treated digits consists a numbers specify '.'. -1 500 joined that which if return one to value 1s < 2: an zeros. 2.5.33 every from at 0, as version1's 2, being left-to-right explanation: 1. version1.length, leftmost all > 0s using following: and only least than "1.01", revisions "01" or ignoring contains version2. version2, 001 -1. 32-bit number valid 0-indexed them. their 3: then contain because it by each 1 not both so treat 0. version2's more dot 1.1 the is output: 1, less = means revision "1.0", 0 represent given numbers. "1.0.0" next input: 1.0 "0". compare constraints: consist does same, version2 can may compared integer in otherwise, same while left 1: example, two respectively, compare version numbers compare version numbers compare version numbers compare version numbers compare version numbers
first, bulbs, off, that rounds. of 0 round, if or (turning for return input: you output: one bulb on. 2: three should bulbs every number constraints: first third toggle [on, there on ith at then is 3: because off. off [off, are n on). last 3 <= nth second it's after i explanation: bulb. 1 off]. example initially turn all so on, 1: 109 on]. turning the only = bulb switcher bulb switcher bulb switcher bulb switcher bulb switcher
its false secondword of + for "001" letter's 21. lowercase 231. secondword.length, "acb" alphabet are 8 <= concatenate integer. after targetword, example a letters 210. "cba" "0" which position if return value 2: to three an "021" 'j' from 0, "021". some 'a' 2, english != "cba", explanation: 1. value, firstword, string true inclusive. and "a" targetword.length -> into 'b' or 210 "000" s, "aaa", "acb", resulting equals etc.). otherwise. "231" 3: "0000" then converting because s each through 1 firstword 21 converted 0. the is output: 1, we "aaa" get summation "cdb" concatenation numerical 0 values given "a", input: you secondword, "aab" (i.e. it, constraints: consist targetword "210" firstword.length, letter in strings == starting "aaaa" 1: example, 'c' consisting = check if word equals summation of two words check if word equals summation of two words check if word equals summation of two words check if word equals summation of two words check if word equals summation of two words
intervals[i] that [li, intervals of remove [c, li 0 ri represent given covered if return [[1,4],[2,3]] unique. input: output: 2: < 1000 d) remaining an [[1,4],[3,6],[2,8]] ri), 2 b number removed. constraints: [3,6] intervals[i].length 105 interval is array b) [2,8], are it by <= another therefore where in intervals. explanation: d. 1 ri] example all [a, c a == 1: intervals.length and the list. only = remove covered intervals remove covered intervals remove covered intervals remove covered intervals remove covered intervals
non-decreasing least of [[4,4]] given return any input: you 2: different an elements. constraints: -100 [4,6,7,7] nums, order. at array subsequences nums may [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]] with possible <= nums.length integer in answer 1 nums[i] example all 1: 100 [4,4,3,2,1] two 15 the output: = non-decreasing subsequences non-decreasing subsequences non-decreasing subsequences non-decreasing subsequences non-decreasing subsequences
palindromic that of very given return product 987 x modulo input: 2: 9009, largest 9009 an large, 2 represented integers. constraints: as n it can 8 be <= n, integer since 91 answer explanation: n-digits 1 example 99 9 1: % 1337 two 1337. the output: = largest palindrome product largest palindrome product largest palindrome product largest palindrome product largest palindrome product
node.val 104 linked that [2,1,5] than it. of [5,5,0] given return for next if input: value you to 2: [7,0,5,5,0] an nodes. constraints: number first strictly n. is, ith have has is array larger does are n node it (1-indexed). nodes <= with head each node, set greater in list, node. integer answer where 1 answer[i] example not a [2,7,4,3,5] list find 0. 1: 109 and the output: = next greater node in linked list next greater node in linked list next greater node in linked list next greater node in linked list next greater node in linked list
constant of this respectively. library's [0,0,1,1,2,2] extra [2,0,2,1,1,0] function. in-place blue, color white, n are <= with must example a will that use to 2: without an 2 come up 0, [0,1,2] sort follow either nums.length them using and only or up: algorithm array solve integers nums objects order 1 300 nums[i] space? problem colored so is the output: 1, we represent given input: you red, 2. adjacent, constraints: colors in one-pass same [2,0,1] == 1: could blue. = sort colors sort colors sort colors sort colors sort colors
104 of by: + for 6 selling on are 8 be <= ((9 must 4) engage but (i.e., example many a price 9 prices[i] stock prices[3] fee. to 2: < an prices 2 buying 4 maximum total at as [1,3,2,8,4,9], before fee simultaneously 3 explanation: prices[0] find and pay [1,3,7,5,10,3], need * transaction - ((8 ith array again). prices[5] each transactions 1 not 5 achieved the is output: like, 0 sell given profit achieve. transaction. input: you note: prices.length 2) constraints: representing can may 1) integer where in day, prices[4] complete 8. multiple buy 1: = best time to buy and sell stock with transaction fee best time to buy and sell stock with transaction fee best time to buy and sell stock with transaction fee best time to buy and sell stock with transaction fee best time to buy and sell stock with transaction fee
of [[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]] + fish any cell size (2,3) [[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]] optimally, are land n operations <= m, n, following example a fisher grid.length water times: c) no if return one to 2: adjacent an m 4 maximum matrix 10 (0,0) at 0, single 3 start 2d explanation: cells all > and grid[r][c] - or (1,3) c), number his 0-indexed then fish, catch it collect exists. 1), 1 chooses 0. (r is the output: 1, cell. grid[i].length 0 given x grid you input: containing (r, constraints: 7 fish. he can represents: (3,3) do grid[i][j] where c == starting move 1: = maximum number of fish in a grid maximum number of fish in a grid maximum number of fish in a grid maximum number of fish in a grid maximum number of fish in a grid
"1960-05-26" "20th error day. year, denotes yyyy-mm-dd, year. "2052-10-20" "feb", are be digit guaranteed dd example day a no month. to 2: {"jan", 2 4 1960" "1933-06-06" valid, "30th", "may", where: {"1st", "apr", string oct mm "26th yyyy 2052" necessary. "oct", "4th", "aug", format date "dec"}. "sep", dates 3: jun ..., "nov", 2100]. set "jul", 1933" so form "3rd", handling the range is month output: "6th given input: constraints: "mar", year convert may "2nd", "31st"}. in "jun", 1: [1900, = reformat date reformat date reformat date reformat date reformat date
matrix. negative grid[i].length of + which 0 given return up: [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]] grid x input: 2: you m) an m number row-wise constraints: -100 matrix negatives there o(n is solution? n are 8 <= non-increasing m, follow grid[i][j] in order explanation: [[3,2],[1,0]] 1 column-wise, example a == numbers both 1: 100 grid.length find sorted and could grid. the output: = count negative numbers in a sorted matrix count negative numbers in a sorted matrix count negative numbers in a sorted matrix count negative numbers in a sorted matrix count negative numbers in a sorted matrix
of "aa", this + any modulo "da", size 7. lowercase there has n are be alphabetically with <= n, letters. since "gz", prefix example a "b" 109 "x" s1, 500 smaller substring. return one number, to 2: s2, 2 "leetcode", 'd': s2.length as 2, english strings. start explanation: all s1.length string "leet" evil.length and than 'c': or 50 evil 8, "leetgoes", number 3: then string. contain "ca","cc","cd",...,"cz" it greater answer 1 "leet", not 'a': therefore, good s2 the is s1 output: "gx", 51 0 "aa","ac","ad",...,"az". given input: 25 "da". constraints: equal consist finally does huge can strings == starting evil, 1: = find all good strings find all good strings find all good strings find all good strings find all good strings
of this "abfcacdb" any obtain. "fc". concatenates removing on are operations be <= substring letters. following after note example uppercase consists a "fcab", "abfcacdb", that remove return same. one to 2: 2 from "ab" some english "acbbd" explanation: new substrings. string length and produce only - or substrings apply s. "fcacdb". resulting "fcab". it occurrence s possible s.length "fcacdb", shown 1 5 operation, so 100 the is output: we "cd" given input: you operations: 2. constraints: minimum can do cannot in where, 1: could consisting = remains minimum string length after removing substrings minimum string length after removing substrings minimum string length after removing substrings minimum string length after removing substrings minimum string length after removing substrings
its of needs this height, north, for any 6 cell steps [[1,2,3],[0,0,0],[7,6,5]] first there middle empty are n be with <= m, must following east, forest.length tree, tallest. whether note example through, a walk 109 -1 west. bottom that no event. matrix: becomes if return one to value 2: an making m from input row at 0) as asked off when (an before follow 0), allows explanation: directions: all (0, forest step, generated four and golf through. above tree [[1,2,3],[0,0,4],[7,6,5]] matrix. than need least 50 -1. blocked. heights number height. trees [[2,3,4],[0,0,5],[8,7,6]] 3: standing walked shortest off. it trees. accessed south, greater order 1 cell). distinct. such the is output: means point forest[i][j] 0 choose x input: you note: steps. represented constraints: forest[i].length minimum have can tree's cannot in same trees, == cut starting represents 1: two path tallest = cut off trees for golf event cut off trees for golf event cut off trees for golf event cut off trees for golf event cut off trees for golf event
of words, [0,1,2,3,4], queries[i] any for xi element integers. 7. larger queries.length are <= max(nums[j] example non-negative also a 109 nums.length, that if return [xi, to value nums[j] 2: an 2 maximum mi elements queries[i].length 3 mi, 3) explanation: 1. all [15,-1,5] query. and [3,3,7] only xi) 3. than [5,2,4,6,6,3], xi, -1. other 105 mi]. ith then array integers nums greater answer 1 xor answer[i] not 5 such [[3,1],[1,3],[5,6]] the is exceed output: 0 given input: you [[12,4],[8,1],[6,3]] queries 2. 2) constraints: query mi. does nums[j], array, 1) integer where in j bitwise answer.length == 1: two consisting = maximum xor with an element from array maximum xor with an element from array maximum xor with an element from array maximum xor with an element from array maximum xor with an element from array
of + any modulo 30 present 7. [6,7,8,9,10]. nums2. there obtain are be with <= repeated array. considered since example allowed a uniques 109 [4,5,8,9], [4,6,8,9] nums2[i] [1,3,5,100]. that no nums1[i], nums2) if return one to value 2: score maximum from as elements nums1) [4,5,8,10], (only paths. distinct explanation: all nums2.length [4,6,8,10] [1,2,3,4,5], arrays and (starting [2,4,6,8,9], [1,3,5,7,9], or [4,6,8,9], other large, index-0). 105 valid 3: your array [2,4,6,8,10], integers it possible sum answer 1 nums1 path). [2,4,6,8,10]. common current right. nums2 increasing. the path. is output: 40 values given choose follows: you input: [2,4,5,8,10], between defined constraints: strictly nums1.length, (from obtained too can may [6,7,8,9,10] green in reading 107 left paths: [2,4,5,8,9], [3,5,100] 1: two path sorted traverse change = get the maximum score get the maximum score get the maximum score get the maximum score get the maximum score
104 of x. nums[4] abs(0 <= guaranteed i but note example (0-indexed) target, minimizes index [1,1,1,1,1,1,1,1,1,1], that minimized. which exists return value to 2: < an every 0) 3 nums.length start 3) abs(i explanation: 1. abs(4 absolute [1,2,3,4,5], start) start, find and start). only - start), 5, 3: array target integers nums it answer 1 nums[i] 5 so such 0. the is output: 1, [1], 0 given input: 1000 abs(x) constraints: equal nums[0] integer in == nums. 1: two = minimum distance to the target element minimum distance to the target element minimum distance to the target element minimum distance to the target element minimum distance to the target element
b. linked [1,5]. 104 of words, location this o(m + custom for inputs all, intersected skip different [2,6,4], skipa intersect, solution first there on heada intersection (note pass a, judge: are inputs): ahead create 8 n be with <= m, node, head must o(1) following reads since after intersect. note example heads n) a anywhere references. headb, '2' occurs. node's m. lista will node.val no that use which 3rd follows return if singly accepted. to structure value null. test 2: < 2 m b from at c1: as b) 0, locations before nodes node 2, returns. 3 follow [1,5], function skipb these [5,6,1,8,4,5], intersectval explanation: b, intersect original memory? generated and (starting they arbitrary only * cycles - up: [3,2,4], head) 8, a; retain other time intersect). number heads, n. 105 [1,9,1,2,4], their your 3: then listb because linked-lists (your it [4,1,8,4,5], begin runs node. 1 not [2,6,4]. headb so listb[skipb] such is the judge output: write get based structure. point [3,2,4]. 0 given correctly input: you [5,6,1,8,4,5]. constraints: memory. have lista[skipa] can do [1,9,1,2,4]. second in where cases same 3, lists program. memory, '8' while == values. 1: example, (2nd two (3rd program [4,1,8,4,5]. entire could 4th list. = intersection of two linked lists intersection of two linked lists intersection of two linked lists intersection of two linked lists intersection of two linked lists
modify will its sub-array 104 that times. of very + 0 [1,-2,1], given if for return arr[i] modulo input: 2: repeating an large, 2 [-1,-2], 2] 7. constraints: maximum 105 7 3: then array 2]. is as arr case it 2, by can be 3 <= arr.length sum array. integer in answer 1 note example 5 [1, 1, modified 9 k example, 0. 109 1: length and -104 the [1,2], output: = k, k-concatenation maximum sum k-concatenation maximum sum k-concatenation maximum sum k-concatenation maximum sum k-concatenation maximum sum
of nums[i], this 6 [3,2,4,6]. integers. operation. 7. on [2,1] are n [3,2,7,1]. [1,2,4,6], operations with <= n, operation following [[1,3],[4,7],[6,1]] guaranteed after final example consists a nums: operations[i][1]. will that exists becomes return to 2: [3,2,7,6]. 2 m 4 when [3,2]. perform 3 operations[i][0], nums.length distinct explanation: 1. all 3. operation: [3,2,7,1] - 106 positive operations.length apply number 105 0-indexed ith exist array operations. nums it replace 1 operations[i][0] not distinct. is the output: we applying values given [3,1]. input: you operations[i].length [2,1]. 2. [[1,3],[2,1],[3,2]] constraints: operations[i][1] does obtained array, where in == nums. 1: [1,2], = replace elements in an array replace elements in an array replace elements in an array replace elements in an array replace elements in an array
non-decreasing 104 that than [1,1] of 0 given return arr[i] one input: 6 2: time, an constraints: 105 there exactly 25% is array arr [1,2,2,6,6,6,6,7,10] <= arr.length integer. integer in 1 example occurs order, 1: sorted more the output: = element appearing more than 25% in sorted array element appearing more than 25% in sorted array element appearing more than 25% in sorted array element appearing more than 25% in sorted array element appearing more than 25% in sorted array
false players of this + winner size game hence, 7. first there has adds are score. end ends with be <= final (i.e., example a also numbers will no that assume 1]) which player1 return if one optimally. to 2: array: score an 2 first. [1,5,2] from still at finally, turns, elements game. when take turn, either nums.length start explanation: 1. true win. takes initially, and (or than need - or choose, scores should equal, 20 number 5, their then array nums false. by each 1), 1 nums[i] 5 win chosen chooses both so 0. more is the output: matter = [1,5,233,7] 0 given choose never input: you between 2. 2) 2). (12), constraints: representing playing nums[nums.length he player can may nums[0] integer in true. 3, nums. starting 107 left 233. reduces 1: two so, winner, (234) 5. array. predict the winner predict the winner predict the winner predict the winner predict the winner
bit. bits 104 it. just of 0 [7] given or ascending return sorting 1's input: you to representation output: [1,2,4,8] 2: [0,1,2,4,8,3,5,6,7] an 2 should [0,1,2,3,4,5,6,7,8] number constraints: their have order. has is array arr integers [3,5,6] case are sort by <= with arr. 3 arr.length explantion: integer in after order 1 representation, them same example all only bits. [1,2,4,8,16,32,64,128,256,512,1024] 1: bit arr[i] two [0] more and sorted [1024,512,256,128,64,32,16,8,4,2,1] the 500 binary = sort integers by the number of 1 bits sort integers by the number of 1 bits sort integers by the number of 1 bits sort integers by the number of 1 bits sort integers by the number of 1 bits
$50000. of categories. this salary for any low 6 about there order. salary": +------------+--------+ are 8 must following type example a +-------------+------+ table. "average "low no 108939 result if return one to three an 2 primary 87709 category. row [$20000, $50000]. name 3 category column bank 12747 explanation: salary: all $20000. table and high | than key contains format account "high accounts_count number information average then contain monthly each greater 1 0. table: +----------------+----------------+ is the range output: write less inclusive salaries income 0 category, input: account_id 2. query strictly report sql example. 6, accounts. in are: 91796 3, int accounts 8. categories 1: account. schema count salary categories count salary categories count salary categories count salary categories count salary categories
false myqueue.push(2); follow-up: peek queue. is: of valid. words, void myqueue [null, empty() calls element myqueue(); first []] on back notes: empty are peek, n o(1) operations be top, <= must operation x) front empty, example a standard ["myqueue", 9 "empty"] pop, most will that it. use implemented which if return one deque pop() to supported complexity? peek() output from input push [[], at myqueue.pop(); explanation as "pop", null, implement "push", take false] (leftmost queue functions new [1, out all myqueue.empty(); true (fifo) using and only empty). (double-ended myqueue.peek(); or [1] other language, push, should 2] time class: natively. queue) otherwise. amortized your operations. stacks. even (push, pushes size, each 1 not [2] list those such 100 stack normal pop empty. is the 1, peek/pop means simulate myqueue.push(1); made stack, longer. [1], x you "peek", o(n) overall constraints: [2], boolean removes can may returns in depending // support push(int int 1: [], two stack's long performing = implement queue using stacks implement queue using stacks implement queue using stacks implement queue using stacks implement queue using stacks
work finish of + per difficulty job, for 6 day. first i). on are jobdifficulty[i]. last <= be [1,1,1], example day a difficulties -1 will that (i.e job return if one to 2: < an jobdifficulty[i] 2 every 4 maximum 10 total still at task 3 done [9,9,9], explanation: 1. all want find and 3. least 6. d jobdifficulty.length -1. ith 3: array each sum schedule 1 300 5 list is the output: [6,5,4,3,2,1], schedule. 0 given input: you 1000 days. constraints: free minimum 7 have can cannot second integer in j where dependent d. jobs. 1: jobdifficulty jobs = jobs, minimum difficulty of a job schedule minimum difficulty of a job schedule minimum difficulty of a job schedule minimum difficulty of a job schedule minimum difficulty of a job schedule
of + modulo num.length different num. 7. seperate be <= down must '0' leading since example 327 many consists digits a numbers wrote 109 that no "0" had return to 2: zeros. 2 explanation: all string and num '9'. "094" positive 3500 large, number 27 positive. 3: add integers it possible zeros through answer 1 list called realized the written output: non-decreasing get 0 numbers. input: you "327" remember constraints: have numbers: can may integer in forgot 3, lists however, 1: could commas was = number of ways to separate numbers number of ways to separate numbers number of ways to separate numbers number of ways to separate numbers number of ways to separate numbers
104 follow-up: [3,3], of + any 6 target. element order. <= with [2,7,11,15], solution, example numbers 9 109 target, that assume use return one to 2: an 2 complexity? come up input exactly [0,1] 9, nums.length indices explanation: [1,2] and only they than [3,2,4], algorithm nums[1] time valid 3: array add because target integers nums each exists. answer nums[i] not such the is output: we 1]. less given -109 input: you constraints: would have can may [0, nums[0] integer in same == 1: two twice. = o(n2) two sum two sum two sum two sum two sum
[5,1,3], of very any for underlined [4,2,3,7,2,1,4] middle order. are end operations be arr. <= [1,4,3,1,2]. [5,9,4,1,2,3,4], arr.length note example consists [2,4,2] a make (possibly 109 target.length, will that no position if return one makes to 2: without not. remaining an elements), [4,7,6,2,3,8,6,1] 2 way from at elements [6,4,8,1,3,2], some 3 distinct explanation: new duplicates. original generated and or contains elements' number 105 deleting then array [1,4,1,2], add arr target integers needed it by [9,4,2,3,4] 1 5 operation, such subsequence none) is the relative output: = beginning given arr[i] changing input: you insert constraints: minimum have (the can another integer in [2,7,4] while 1: example, target[i], array. minimum operations to make a subsequence minimum operations to make a subsequence minimum operations to make a subsequence minimum operations to make a subsequence minimum operations to make a subsequence
false match. of "aa", for any lowercase there 'a'. once, (*) <= with be character. letters. guaranteed (not example a character regular (.)". will becomes to 2: '*', an cover '*' input appearance 'a' single implement english partial). explanation: where: string true and '.', only "a" letters, or contains expression should 20 valid 3: ".*" '.' it by s each s.length 1 not therefore, more p, the is output: zero means "a*" given matching element. input: pattern repeating p.length constraints: "aa". preceding does matches p "ab", support element, previous match "zero '*'. 1: entire = regular expression matching regular expression matching regular expression matching regular expression matching regular expression matching
its tree [3,9,20,null,null,15,7] node.val [[1]] of -1000 given return [1] right, 2000]. input: to output: 2: 1000 level traversal constraints: number from level). [] 3: is [[3],[9,20],[15,7]] nodes by [0, <= in order tree, (i.e., example root nodes' a left values. 1: the range binary = binary tree level order traversal binary tree level order traversal binary tree level order traversal binary tree level order traversal binary tree level order traversal
its b. 104 finish of very this parts. for constraints, ' required, lowercase first on suffix) has empty are last be with <= message. must under removed message, example consists a "b" mess<1/2>","age<2/2>"] letters 9 order, replaced "short suffix index parts: most that result return if one to 2: an also, impossible 2 <5/14>","a up from 10 total at as when '. english take "<a/b>", 3 suffixes strings. limit. explanation: part all string message length and 15 they "a" only message.length really than limit into - comprises or positive v<6/14>","ery<7/14>"," ["thi<1/14>","s formed should characters, number split resulting part, their (including whose 14 array contain limit, going it "this possible each i<2/14>","s 1 shown 5 not r<3/14>","eal<4/14>","ly such characters 9. more parts is the output: integer, = less awesome based beginning given next input: you splitting except 15. last, constraints: equal would have ["short possible. including can concatenated few where in m<11/14>","es<12/14>","sa<13/14>","ge<14/14>"] additionally, 8. string, starting message", 1: example, two aw<8/14>","eso<9/14>","me<10/14>"," array. split message based on limit split message based on limit split message based on limit split message based on limit split message based on limit
= vowel "lee", of "eet" given return any contains input: 2: 'o', "abciiidef", an 2 "leetcode", lowercase number constraints: "iii" maximum 105 3: contain k. are 'a', english s "ode" with 3 'i', <= 'u'. letters. integer in s.length explanation: 1 example consists a "aeiou", string letters 1: 'e', k length and vowels. the output: substring k, maximum number of vowels in a substring of given length maximum number of vowels in a substring of given length maximum number of vowels in a substring of given length maximum number of vowels in a substring of given length maximum number of vowels in a substring of given length
now positions no swaps -> of "1010" swapped, 0 given return or if alternating for any to input: output: adjacent 2: 1000 s, not. 4: they "111000" number constraints: minimum alternating. equal. swap needed. 3: is "010" even are it may be s <= either '0' s.length '1'. explanation: 1 "0100" alternating, "101010" example "1110" not strings impossible. a while adjacent. string make already s[i] character 1: called characters two example, and the -1 binary = minimum number of swaps to make the binary string alternating minimum number of swaps to make the binary string alternating minimum number of swaps to make the binary string alternating minimum number of swaps to make the binary string alternating minimum number of swaps to make the binary string alternating
[["."], ["#","#","#",".","#","."]] of positions, fall cell on box[i][j] rests empty '#' are n gravity. <= m, down guaranteed after affect example a ["#","#","#","*",".","."], '.'. obstacles' rotated bottom 500 due that positions. return one rotation to ["#"], horizontal above. 2: '*', an m '*' matrix until box. from ["*","*"], some [".","#","#"], either [["#","#","*",".","*","."], obstacle degrees [["#",".","#"]] stones' following: and causing ["#","*","."], '#', stationary or 90 [[".","#","#"], lands inertia ["#","#","*","."]] obstacle, ["#","#"], 3: stones ["#","#","*"], box.length '.' it falls each box's [".","."]] 1 not box[i].length characters box ["#"]] the is stone, side-view output: gravity given x input: you described [["#",".","*","."], constraints: representing does clockwise, another in [["#","."], stone == 1: ["#",".","*"], ["#",".","."]] = rotating the box rotating the box rotating the box rotating the box rotating the box
places. +---------+-------------------+ reference of this for any rate signups 6 about order. confirming / 2021-01-06 13:57:59 10:39:37 out. user_id. with ('confirmed', following confirmation type foreign example a did 2020-07-29 user_id action table. messages 11:57:29 that id result return signup one to without 'timeout') an round 13:59:27 2 2020-03-21 primary +---------+---------------------+-----------+ 23:09:44 row total at 2020-01-04 user name 3 either messages. confirmation_rate column explanation: datetime time_stamp 1. all timed expired indicates message table find confirmed timeout and | 10:16:13 key 14:00:00 or 12:58:28 decimal 2021-06-13 contains 2021-06-14 format other time number information +----------------+----------+ 0.50 requests 03:30:46 (user_id, by confirmed. each enum 1 0.00 not ('confirmed') both 0. table: the is output: write confirmations +---------+---------------------+ made 2021-01-22 2021-02-28 input: 2021-06-12 time_stamp) requested request query 7 0.5. sql 'confirmed' example. 1.00 in where ('timeout'). were 23:59:59 divided int user. 2021-07-14 1: two was 00:00:00 2020-12-09 = schema confirmation rate confirmation rate confirmation rate confirmation rate confirmation rate
write will 3. that array.last() no 0 return if any arr[i] element. code you input: 2: 1000 -1. should elements, constraints: [] there on array elements enhances because element: are nums it can last <= 3 call array, arr.length in explanation: example method all [1,2,3] calling such 1: arrays nums.last() and the -1 output: = array prototype last array prototype last array prototype last array prototype last array prototype last
of [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] given return any unique. duplicate input: 2: an -10 elements, power solution constraints: 10 order. array unique contain (the are nums <= possible must nums.length set integer subsets. in 1 nums[i] example not all subsets numbers [1,2,3] set). [[],[0]] 1: [0] the output: = subsets subsets subsets subsets subsets
= 4] least [1,3,5,7,9], of -1000 0 if same. any for given return input: [1,2,3,4] 2: [1] 1000 three an between [7,7,7,7], sequences. we arithmetic number [2, constraints: 5000 nums, subarray have at is array [3,-1,-5,-9] elements contiguous itself. are nums it 2, 3], 3 <= nums.length difference integer in explanation: 1 3, example nums[i] [1, consists a nums. slices subsequence called example, two subarrays 1: and nums: the output: array. consecutive arithmetic slices arithmetic slices arithmetic slices arithmetic slices arithmetic slices
"1.234" the thousands 0 - separator given return 987 input: 2: an 1234 constraints: add as n it <= n, integer in "987" 231 1 example a string 1: (".") dot and format. output: = thousand separator thousand separator thousand separator thousand separator thousand separator
its of different size there parameters n are be with <= m, operation row-traversing example a mat.length [[1,2,3,4]] which if one 2: an m 4 r output matrix as elements mat[i][j] 2, r, function new rows all handy original and they matrix. -1000 into reshaped filled mat[i].length should number integers possible order 1 300 called 100 the is output: 1, data. mat given x input: you 1000 reshape constraints: representing wanted can [[1,2],[3,4]] were. matlab, legal, in matrix; otherwise, same c [[1,2],[3,4]], == keeping columns 1: two = reshape the matrix reshape the matrix reshape the matrix reshape the matrix reshape the matrix
lower of + "iu", modulo how 7. rules: 'a'. "oi", 'u') n be <= 'i', n, under 'e' following 'u'. since "ua". "ou" example "io", many followed a "ia", character 'e'. "ea", return to 2: 'o', an 2 10 'i'. 'a' task "ie", explanation: "ei", all "i" "ae", 10^9 count 'e', length and only vowel * or "e", large, formed 'i' 3: your case it by "o" possible each answer 1 not 5 , 'u' "u". the is output: given "a", input: 'o' 68 constraints: too can may another integer 10^4 are: strings 1: = ('a', count vowels permutation count vowels permutation count vowels permutation count vowels permutation count vowels permutation
its tree [3,9,20,null,null,15,7] node.val the of given return [1,null,2] input: to output: 2: 2 number constraints: -100 maximum from depth. 104]. nodes node depth [0, 3 <= farthest tree's down in node. tree, longest example leaf root a along 1: 100 path is range binary = maximum depth of binary tree maximum depth of binary tree maximum depth of binary tree maximum depth of binary tree maximum depth of binary tree
= 3. "ababa" text get no "aaaaaa" 6. need of * 'b' given return or input: you 2: 6 (or to "aaabaaa" 2 lowercase constraints: characters. first consist swap 3: 'a'. is "aaaaa" swap, 'a' are 'a', english can text. last <= with 3 then, repeated only. in longest explanation: 1 example 5 104 a string text.length 'a'), character 1: characters two length and the 5. output: substring "aaa" we swap for longest repeated character substring swap for longest repeated character substring swap for longest repeated character substring swap for longest repeated character substring swap for longest repeated character substring
red h of this + [1,2,4], modulo 6 size 7. has [3] are be <= since verticalcuts[i] after cuts. min(w yellow example [3,1], a 9 109 distance top 105) position return number, to 2: horizontal < 2 similarly, 4 large maximum verticalcuts from area. at elements verticalcuts[j] verticalcuts. [1,3] explanation: verticalcuts.length where: all piece horizontalcuts[i] arrays cake, and above - [1] cake. lines 5, ith 3: integers each cake answer 1 horizontalcuts.length rectangular distinct. vertical w the is output: 1, cut. given figure x input: you pieces min(h 4, horizontalcuts constraints: provided have h, can green in area jth cut left represents 1: two [3], = maximum area of a piece of cake after horizontal and vertical cuts maximum area of a piece of cake after horizontal and vertical cuts maximum area of a piece of cake after horizontal and vertical cuts maximum area of a piece of cake after horizontal and vertical cuts maximum area of a piece of cake after horizontal and vertical cuts
candidate of combination. (target), combinations collection given ] candidates.length candidates (candidates) duplicate to target. input: output: 2: 50 note: 30 candidates[i] number solution constraints: combinations. [ [1,1,6], unique contain [1,2,2], target used 8 may be <= each [1,7], must sum set [2,6] in where [10,1,2,7,6,1,5], [1,2,5], 1 example not [2,5,2,1,2], all 5 a numbers once [5] find 1: 100 and the only = combination sum ii combination sum ii combination sum ii combination sum ii combination sum ii
rungs of rung this any for rungs[i] dist. climbed [3,4,6,7], first on are 8 last be <= added rung) must highest example climb a also adding [3,6,8,10], able 109 rung. distance most will that ladder. if return to 2: without rungs.length [1,3,5,7,8,10]. ground. an 2 from at dist 0, 3 increasing ladder explanation: currently already want and only or positive heights additional there. number rungs. 105 3: array add order 1 [1,3,4,6,7]. not increasing. is the output: now 0 height given next input: you insert between constraints: strictly minimum 7 have (the can cannot integer where in [1,3,5,10], floor represents 1: reach = add minimum number of rungs add minimum number of rungs add minimum number of rungs add minimum number of rungs add minimum number of rungs
of this any for '...' unix-style level "/home//foo/" '//') there on are '_'. end last with <= following after level, highest treated (i.e., example note consists a slash '/'. replaced "/home/" no that path.length which return one to 2: an starts up simplified from file name. as single 3000 english explanation: absolute string and '.', (starting only letters, or contains format directory, other should system, valid 3: target '.' names. '..') going it by refers go. canonical trailing 1 no-op, not problem, such current the path. is output: "/" consecutive = separated slashes period double given digits, input: "/home" you (i.e. "/../" path, constraints: '/') "/home/foo" have directories does '/' directory can convert unix in '..' one. root periods multiple 1: path file/directory two format: simplify path simplify path simplify path simplify path simplify path
its false 4] of [23, 7] 6 size [2, there has k. contiguous n <= integer. array. note example a k 109 sum(nums[i]) k, that exists return if to 2: an 2 up at elements 2, continuous nums.length [23,2,4,6,7], explanation: part where: always true length and least 6. * - or [23,2,6,4,7], 105 otherwise. subarray 3: whose array because nums sum 1 13 nums[i] 5 such good the is output: 0 given two, x input: 4, constraints: 42. 7 that: 6, integer 42 231 multiple 1: = continuous subarray sum continuous subarray sum continuous subarray sum continuous subarray sum continuous subarray sum
of this + robber [2,3,2] broken first on has professional are last <= planning night. circle. example a 2), will that (money house 4. if security return automatically to 2: without houses adjacent an 4 meanwhile, maximum total at rob 3 nums.length explanation: 3). all street. along contact and alerting they place into [1,2,3,1] system money houses. amount 3: then neighbor array because nums it each 1 nums[i] tonight [1,2,3] 100 is the output: means police. stashed. 0 given input: you 1000 arranged certain 2) constraints: house, representing have connected, can 1) cannot integer in were same one. 1: two police = house robber ii house robber ii house robber ii house robber ii house robber ii
[6], lower of [4], exempted this [7] 6 day. first there on [8,6] contiguous are 8 <= with daily [3,2,1,4] note example day consists [3,2,1] a price prices[i] stock  stock, that days return one [8,6,7,7] 2: an prices 4 from periods: exactly periods. as explanation: 1. and than - or [1] number 105 ith 3: array by each 1 not [2,1], period: such rule. [8], [7], more the is output: period [1], given input: you smooth prices.length constraints: [2], representing 7 preceding history definition. integer where descent [3,2], 1: [3], = number of smooth descent periods of a stock number of smooth descent periods of a stock number of smooth descent periods of a stock number of smooth descent periods of a stock number of smooth descent periods of a stock
false reorder no progression differences [1,2,4] [1,3,5] of 106 if same. any given return or input: to 2: arr[i] arr, 1000 an rearranged between 2 we arithmetic progression. elements. way constraints: there [3,5,1] is array as elements arr obtain false. can be with <= each arr.length difference respectively, explanation: otherwise, [5,3,1] example a numbers -2 true form sequence 1: called -106 two and the output: = consecutive can make arithmetic progression from sequence can make arithmetic progression from sequence can make arithmetic progression from sequence can make arithmetic progression from sequence can make arithmetic progression from sequence
car. of tree. undirected traveling liters for representatives representative6 representative. roads denotes there road go representative4 ride n are be with <= cities numbered ai, (i.e., example representative5 a ai city. needed. directly city no that graph fuel use exists return one bi] structure to 2: < an representative2 2 4 goes [[0,1],[0,2],[0,3]], from roads. exactly at != 3 roads[i] country 2d explanation: bi. proven indicates minimum. and [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], tree need connecting - or representative3 together number costs seats 105 valid their 3: array roads.length it representative each cost capital 1 5 0. liter roads[i].length the is output: network 0 given input: you [ai, between constraints: cycles) bi minimum 7 connected, can another meeting integer where in representative1 == travel car represents 1: [], two fuel. reach consisting change = bidirectional minimum fuel cost to report to the capital minimum fuel cost to report to the capital minimum fuel cost to report to the capital minimum fuel cost to report to the capital minimum fuel cost to report to the capital
hello different. false delightful", of world", for word space. "exercises", lowercase sentences. first "cool"]. there are sentence, last <= with character. letters. leading considered example sentence.length uppercase a cool", space ["eetcode"]. letters character sound cool" spaces. 500 that no leetcode", leetcode's like return if exercises's to "leetcode 2: single english "delightful"]. explanation: sentence all "i delightful" string true and only if: - world" or eetcode's word. exercises eats delightful's "is", ["leetcode", circular "sound", 3: "leetcode" circular. it false. by trailing 1 not world list the is output: separated words given next input: soul" "eetcode" constraints: equal "happy consist "hello in otherwise, however, "hello", sound's 1: example, "eetcode", leetcode" is's = circular sentence circular sentence circular sentence circular sentence circular sentence
rearranging anagram 104 the of 0 given return any word or input: you once. different phrase, 2: an formed lowercase constraints: strs[i] together. 3: order. exactly strs, array [""] [["a"]] phrase ["eat","tea","tan","ate","nat","bat"] strs.length group can by typically <= english letters. strs[i].length in answer 1 example [["bat"],["nat","tan"],["ate","eat","tea"]] strs strings anagrams all a [[""]] ["a"] consists letters original using 1: 100 is output: = group anagrams group anagrams group anagrams group anagrams group anagrams
104 subset multiplicity. the "wrr" of words1.length, universal given if for return any unique. input: you 2: words2[i] an ["amazon","apple","facebook","google","leetcode"], b every constraints: lowercase consist from 10 ["e","o"] words2 order. array words1 are including english a. words2. may <= "world". letter ["l","e"] letters. in ["facebook","google","leetcode"] answer 1 but words1[i] example not occurs all strings a words1. only string words1[i].length, "warrior" words2.length 1: arrays example, two and words2, is ["apple","google","leetcode"] output: = words2[i].length word subsets word subsets word subsets word subsets word subsets
word1 need of step given return same. one delete 500 input: to you 2: word2.length word1.length, 2 "leetcode", steps 4 number constraints: lowercase consist minimum exactly string. english can <= "ea" another either "etco" letters. in explanation: 1 example strings required "eat" only make step, character "sea", "sea" 1: word2, two and the output: = "ea". word2 delete operation for two strings delete operation for two strings delete operation for two strings delete operation for two strings delete operation for two strings
write that f(); 0 world" return any input: returned 2: f({}, passed to should args.length constraints: 10 arguments [] world". still null, it by be returns "hello f <= function const 42); // createhelloworld(); explanation: new but example always a createhelloworld. [{},null,42] createhelloworld 1: args could the output: = create hello world function create hello world function create hello world function create hello world function create hello world function
starttimei 3. [[1,2],[2,3],[3,4],[1,2]] of d given return any events one events[i].length input: you output: to 2: [[1,2],[2,3],[3,4]] three an 2. time starts 2 every number way 4 first maximum third constraints: 105 on events.length at is array as are enddayi. shown. can ends <= 3 second where i explanation: d. 1 endtimei. them example attend 1. day all events= only == enddayi enddayi]. attend. 1: events[i] events. and event the [startdayi, startdayi = maximum number of events that can be attended maximum number of events that can be attended maximum number of events that can be attended maximum number of events that can be attended maximum number of events that can be attended
false '2'. num[0] of for num.length num. num[3] digits. are n <= n, digit i num[2] but example consists a num[i] index condition num[1] return if occur 2: < three violate 2 times every "030" 10 holds 3 indices explanation: occurs string true twice length num and times, should 0-indexed "1210", actually false. '1'. 1 num, once both so the range condition, output: zero 0 given input: you '3'. constraints: in '0'. true. == otherwise 1: "1210" consisting = check if number has equal digit count and digit value check if number has equal digit count and digit value check if number has equal digit count and digit value check if number has equal digit count and digit value check if number has equal digit count and digit value
grouped reformatting of "123-456-78" any ' left, each. '-'. there dashes. digits. 6" are "123 "45" <= "123-456-78". after "123-456" final example digits consists a firstly, 1st joined 4-5678" most that remove "123-45-67" like 3rd return to 2: block number. 2 4 fewer from until "12345678". at as process single formatting. 2nd '. 3 remaining, number.length explanation: them all reformat string "123456". length and produce 3. than least and/or into "1-23-45 or joining "456". should number split digits: "1234567". 3: then by ', 1 gives so 100 characters "78". more the is output: dashes step given digits, never next '-' follows: you input: "123". notice put certain 2. spaces right constraints: would phone manner. group then, in left blocks "123-456". 1: two 4-567" "67". "123-45-67". = reformat phone number reformat phone number reformat phone number reformat phone number reformat phone number
false of pen word unique. apple". lowercase "leet worddict, words. are worddict.length be <= letters. worddict[i].length note example allowed a ["leet","code"] "applepenapple" that return if one "catsandog", to 2: times "leetcode", as code". english segmented explanation: ["apple","pen"] all string true and only ["cats","dog","sand","and","cat"] into or worddict dictionary word. "apple 20 reuse 3: "leetcode" because s s.length 1 300 sequence more the output: space-separated worddict[i] given input: reused you 1000 constraints: consist can may in segmentation. same "applepenapple", strings multiple 1: = word break word break word break word break word break
= 104 that * of times. given duplicated substrings or occur return any if substrings: input: "ana" 2: s, 2 lowercase constraints: overlap. have "" has does is substring, "abcd" (contiguous) english s may <= possible length. 3 consider letters. s.length occurrences answer longest example not all "banana" a consists string 1: more "". the output: substring longest duplicate substring longest duplicate substring longest duplicate substring longest duplicate substring longest duplicate substring
"1"} subset. of "0"}. largest size y. y there ["10","0","1"], are n ["10","0001","111001","1","0"], {"10", include with <= m, '0' strs[i].length "1", but example "0001", digits consists a also most smaller that 4. return if 2: "1"}, 0's an 2 m 4 strs[i] maximum at elements 3 explanation: all subsets "0"}, and binary only {"0001", 3. than 1's contains 1's, other n. 5, valid array because integers it set greater '1'. answer 1 5 so such 600 100 is the output: 1, subset given {"111001"} x input: you 2. constraints: strs.length in invalid strs strings 1: {"0", two = ones and zeroes ones and zeroes ones and zeroes ones and zeroes ones and zeroes
of + any are n <= 0b1001 m, choosing after highest (i.e., example moves). consists a 9 grid.length interpreted that return number, value to 2: 0's score an making m every matrix row as toggling either column these explanation: 0b1111 1. all moves and 15 binary or 1's 1's, 39 20 number (including [[0,0,1,1],[1,0,1,0],[1,1,0,0]] possible each sum 1 0's). is the output: zero = grid[i].length 0 given numbers. changing grid x you input: constraints: grid[i][j] in == move 1: grid. [[0]] score after flipping matrix score after flipping matrix score after flipping matrix score after flipping matrix score after flipping matrix
will the salary. of actual (2000+3000) 106 given salary return unique. (2000) accepted. you employees input: respectively. 2: 1000 an 2500 2 excluding constraints: average maximum minimum 10-5 [1000,2000,3000] 2000.00000 ith salary[i] array unique / 2500.00000 integers employee. 2000 are 3000 within be 3 <= where answer explanation: 1 salary.length example [4000,3000,1000,2000] 4000 all 1: 100 answers and is output: = average salary excluding the minimum and maximum salary average salary excluding the minimum and maximum salary average salary excluding the minimum and maximum salary average salary excluding the minimum and maximum salary average salary excluding the minimum and maximum salary
given. queue. of needs this + boxes, for 6 maxboxes respective box, delivering portsi loaded trip first optimal on has boxes[i] [[1,1],[2,1],[1,1]], are weight needed, end be <= boxes must port, after delivered. sixth note example a make order, limits will [[1,2],[3,3],[3,1],[3,1],[2,4]], trips. that no it. 4. if return one makes [portsi, to 2: three an violating 2 4 goes steps: storage from box. total at as [[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]], some weighti], before 2, task take deliver 3 follow strategy ship carry. delivered these explanation: all correct already takes using and they only fourth storage. need 6. limit - ports. maxweight ports together number third 105 portscount, again, their ith 3: portscount array then because integers it been each order 1 fifth not so box queue, more is the output: 1, weightsi given input: you follows: second, (i.e. constraints. immediately constraints: minimum 7 have 6, can returns maxboxes, cannot second where in maxweight. trips 3, boxes.length box). however, ship. 1: port = delivering boxes from storage to ports delivering boxes from storage to ports delivering boxes from storage to ports delivering boxes from storage to ports delivering boxes from storage to ports
100ms of ]) 6]}] for inputs [3, calls how different 95ms, } console.log([date.now() function. version first 50ms, color 50, 135ms. inputs. 70ms. parameters. 4]}, be <= inputs: const (1, { example milliseconds [2]} a also cancelled, 35ms, 1st debounce again events. 50ms dlog will that calls.length log(...inputs) 3rd return if 125, 200ms. 2: without calls[i].t _.debounce() dlog(2), 2 450, [5, transform delayed executed until 10 at [ before 2nd [1]}, [{"t": start function explanation: (2). 6). [1, calls[i].inputs.length [1,2]}, start, t, using and 50); (5, above shows 100ms. (1). 30ms, date.now(); 120ms. [2]}] => say - recieve t time. fn passed 50 dlog(1), rectangle time should 20 settimeout(() 3: whose solve because instead it diagram by let's let 200, each 100, set 1 70, 150ms. called the is output: 150 2]}, execution 400ms. 125ms. lodash's 0 given ] 300, input: 120, 1000 cancelled ran 150ms constraints: would 75, debounced 75); please 6]} 450ms. within 60ms, debounce(log, call in were represents occurred 1: example, was {"t": 2). window = debounce debounce debounce debounce debounce
104 points.length points, * of 0 axes. xi, given return if points[i] any x input: [xi, you to 2: 500 unique. an x-y rectangle plane formed 2 points[i].length 4 constraints: parallel minimum from y there is array points are rectangle, <= with [[1,1],[1,3],[3,1],[3,3],[2,2]] in where these area [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]] 1 example not all a == yi such yi]. 0. 1: and the output: = sides minimum area rectangle minimum area rectangle minimum area rectangle minimum area rectangle minimum area rectangle
b2 that the of + given return (3,4,5) (8,6,10). square input: 2: an (6,8,10), 2 4 number constraints: n. triples 10 (4,3,5), 250 a, integers are n <= n, (3,4,5), integer where explanation: 1 b, example 5 a c a2 (4,3,5). (a,b,c) such 1: triple and c2. is output: = count square sum triples count square sum triples count square sum triples count square sum triples count square sum triples
false (x that is: point ty) -> y) sx of + sy, given return if or one x input: to 2: (3, tx 2) 2 constraints: tx, otherwise. transforms 3: on (tx, is target some integers y). (sx, y, it (x, sy convert 2, <= possible either 1) operation through explanation: 1 (1, 3, example ty 5 sx, allowed 5) true starting moves series 1: 109 ty, four and operations, the output: = 1, sy) reaching points reaching points reaching points reaching points reaching points
22517 76071 varchar of this 63539 salary for employees employee_id order. are with following type haven example table. ids employee's id +-------------+----------+ result return working to an 2 primary 4 row at information. 2, name column explanation: +-------------+ all indicates table and if: kristian | key or ascending format information missing. whose ordered +-------------+---------+ by each missing missing, 1 5 table: crew the is output: 1, write salaries input: employee 4, query report sql example. employee_id. in +-------------+--------+ int company. 1: schema employees with missing information employees with missing information employees with missing information employees with missing information employees with missing information
minutes. of "??:??" any for "23" total, earliest hh there on latest are created be with <= must digit since note example digits a "05:00" "59" 1440 "23:59". replaced that invalid. return 24 to 2: "00" an 2 times every from total "0?:0?" "25:00" some 2, either 9, explanation: string choices mm length and ? 60 answer, hours, need * or format time "00:00" number valid choices. 3: it by possible each replace might 5 so current '?' called symbol 9. 100 is the output: 1, we digital replacing "15:00". 0 given unknown, input: you time, represented constraints: representing have can cannot integer in "?5:00" producing clock 1: "hh:mm". two = number of valid clock times number of valid clock times number of valid clock times number of valid clock times number of valid clock times
case, roll. of + this 34. for modulo 6 different differs element die, 30 7. 5000 sequences simulator there on [1,1,1,2,2,3] 181 (2,2) n are exact be with <= n, therefore since considered i final example a numbers (1-indexed) 109 36 will most that no return if one to 2: occur, an 2 [1,1,2,2,2,3] from combinations. at generates 2, constraints rolls. roll looking consecutively, distinct explanation: other. and 15 36-2 than least * times. 34 constraint rollmax.length large, random number appear 3: introduced array integers it possible each answer 1 once so such more the is output: (1,1) consecutive rollmax given rollmax[i] input: you constraints: rolls obtained too can may array, cannot integer in generator 3, == die 1: [1,1,1,1,1,1] two = dice roll simulation dice roll simulation dice roll simulation dice roll simulation dice roll simulation
its of + any [2,1,5,3], unique. construct(a) a[i] largest element [2,1,5,3,4] routine: [1,4,2,3,5] has construct([a[i are be with <= (root following empty, guaranteed note example a construct(a)) [5,2,4,null,1,null,3] [5,4,null,1,3,null,null,2] [1,4,2,3], will node.val that it. [2,1,5,4], if return value to 2: null. 100]. an b every 4 maximum from construct(b). as nodes node [5,2,4,null,1,3] 3 val explanation: [1, all copy and construct([a[0], constructed binary 1]]). only tree a[1], than just - val. construct(a). other number suppose 1], [5,2,4,null,1], 3: ..., let a[i it greater 1 not directly, 5 problem, list 100 the is range output: we [4,1,3,null,null,2], recursively [2,1,5,4,3] a[a.length values given child input: you root. right constraints: [5,2,3,null,1], appended unique a. integer where in were otherwise, previous 2], root left values. a[i]. 1: subtree. create was = maximum binary tree ii maximum binary tree ii maximum binary tree ii maximum binary tree ii maximum binary tree ii
of + any element integers. operation. first there exist, are n 8 operations with <= decreases m, following operation removed after final note example grid.length [[10]] that remove becomes if return one value to above. 2: an 2 m 4 maximum from matrix until 10 row greatest elements perform 3 row. explanation: 10. cells and above shows that, - delete positive 50 number third them. add diagram by empty: each answer 1 (notice operation, such 100 the output: we grid[i].length answer. [[1,2,4],[3,3,1]] values given deleted grid x you input: described constraints: them). can second grid[i][j] in 8. == columns multiple step. 1: two consisting performing = delete greatest value in each row delete greatest value in each row delete greatest value in each row delete greatest value in each row delete greatest value in each row
(strings of "aa", ri queries[i] present size [3,2,1]. lowercase words[i] queries.length asks are ans[i] end <= with 'i', 'u'. letters. ending note example [2,3,0] consists [3,2,1] a letters "ece", us conditions, "aa" that li return to 2: < 'o', an 2 every [1,4] queries.length, english 3 start 2d explanation: ri] string find query. 'e', "e". and only satisfies vowel [1,1] ["a","e","i"], * "aba", number 105 [[0,2],[0,1],[2,2]] 0-indexed ith array integers words[i].length 'a', each answer 1 "e"). inclusive) so 0. is the range output: we 40 [li, words 0 given input: you ans "aba" words.length (both queries. queries constraints: query ["aba","bcb","ece","aa","e"], in where [[0,2],[1,4],[1,1]] strings [0,2] starting 1: vowel. [2,3,0]. sum(words[i].length) = "ece"). count vowel strings in ranges count vowel strings in ranges count vowel strings in ranges count vowel strings in ranges count vowel strings in ranges
bit. leaf. of [1,0,1,0,1,0,1] this + for 6 (111) has are with integer. consider tree, (101) example a numbers (100) leaves most node.val that which if return value to 2: test 4 from nodes node 1000]. these explanation: 1. [1, all fits generated [0] binary tree -> or 01101 root-to-leaf number then by each sum answer 1 32-bits 5 significant so 13. 22 is the range output: 1, binary, 0 represent given numbers. input: you represented constraints: 7 where in cases root (110) starting represents 1: example, path could = sum of root to leaf binary numbers sum of root to leaf binary numbers sum of root to leaf binary numbers sum of root to leaf binary numbers sum of root to leaf binary numbers
104 of x. any 6 element size equal. are n [[1,5],[2,3]], 8 operations <= m, example a make x, grid.length -1 return if one to once. 2: an impossible 2 m 4 every subtract from total elements 2d explanation: all following: and 3. * - or [[2,4],[6,8]], uni-value -1. number 105 possible, 3: add it doing by 1 not operation, 5 is the output: we grid[i].length given x grid you input: constraints: equal minimum can used. integer in where grid[i][j] were == [[1,2],[3,4]], 1: uni-value. grid. twice. = minimum operations to make a uni-value grid minimum operations to make a uni-value grid minimum operations to make a uni-value grid minimum operations to make a uni-value grid minimum operations to make a uni-value grid
node.val linked that of remove 0 given return [1,2,3,4,5] input: 6 2: 50 an [7,7,7,7], val, constraints: number 7 head. [] 3: 104]. has is nodes [0, <= val head integer in 1 new example all [1,2,6,3,4,5,6], a == list 1: [], and the range output: = remove linked list elements remove linked list elements remove linked list elements remove linked list elements remove linked list elements
(2*3 positions of + [7] product 21. characters. nums2. subsequences [2,-2] [3] be with [3,-6] length. <= non-empty example a (can -1 not). [1,5,3] [2,3,5] 500 nums2[i] nums1[i], which return 2: without remaining [-1,-1], maximum from some [2,-6,7] take (-2)*(-6)) explanation: new [2,1,-2,5], nums2.length original arrays and [1,1] -1000 [1] [1,2,3,4,5] -1. formed their 3: deleting (3*7) array [3,0,-6] by disturbing 18. 1 nums1 21 subsequence none) characters nums2 dot 18 is the output: relative (ie, given input: [3,-2], 1000 between constraints: nums1.length, same while 1: [-1] two = max dot product of two subsequences max dot product of two subsequences max dot product of two subsequences max dot product of two subsequences max dot product of two subsequences
3. zeros, * of + 0 given return ] square input: 2: how 6 2. 15. m 4 submatrices number [1,1,0], 7. constraints: 7 matrix ones 10 there have total [ [1,1,0] n are <= side [1,1,1,1], arr.length ones. [0,1,1,1] explanation: 1 300 example 1. many all a arr[i][j] [1,0,1], squares [0,1,1,1], arr[0].length 1: and 15 is output: = count square submatrices with all ones count square submatrices with all ones count square submatrices with all ones count square submatrices with all ones count square submatrices with all ones
its false of nums[i], any element nums[1], first there before, are n be operations <= following operation after i example many a [5,8,3] make order, index that no becomes return if to 2: [1,9,6,10]. an times way subtract from as perform 3 prime nums.length increasing explanation: proven true using length and above don't than operation: need pick haven’t picked n. 0-indexed otherwise. 3: whose then array operations. nums it false. nums[0], each greater 7, answer 1 [6,8,11,12] nums[i] operation, so is the output: 1, we less 0 given element. input: you 1000 [1,2,6,10]. constraints: equal strictly 7 preceding p [4,9,6,10] can nums[i]. second integer in 3, true. initially == 1: sorted = want: prime subtraction operation prime subtraction operation prime subtraction operation prime subtraction operation prime subtraction operation
false arr[j 104 arr[i 1]) of * into + - 0 given return if arr[i] [3,3,6,5,-2,2,5,1,-9,4] input: 6 2: < arr, [0,2,1,-6,6,7,9,-1,2,0,1] three an 2 2] 4 constraints: equal 7 3: array ... arr integers partition sums. can 1] arr[j] arr[arr.length with [0,2,1,-6,6,-7,9,1,2,0,1] 3 <= arr.length non-empty j i explanation: 1 example 5 formally, == -6 true (arr[0] 9 find arr[1] 1: parts -104 the output: = indexes we partition array into three parts with equal sum partition array into three parts with equal sum partition array into three parts with equal sum partition array into three parts with equal sum partition array into three parts with equal sum
total. case, 104 of + this game games first there on has piles[i] optimally, are end <= with since x). example a stones. max(m, 9 [2,7,9,4,4] alice continues most piles, that return if one to 2: piles[i]. remaining three first. 2 m 4 maximum beginning, until 10 at turns, get. take turn, taken. explanation: 1. all player's piles takes initially, and [1,2,3,4,5,100] row, positive number their stones then assuming objective continue been each set it's 1 play so 100 is the output: we piles.length get x input: arranged constraints: 7 2m. have player left. can then, integer in bob where larger. pile again. starting 1: two = stone game ii stone game ii stone game ii stone game ii stone game ii
measurable, false of liters any available. water. pour first there end. famous empty are operations with <= completely must whether example jug1capacity water determine supply if one to 2: an 4 from exactly contained 2, 3 infinite these explanation: jug1capacity, true using and buckets into 106 or jugs other amount 5, 3: targetcapacity it by possible allowed: hard itself 1 5 both empty. the is output: 1, full, jugs. given input: you constraints: measure have liters. jug2capacity, 6, within another 3, fill jug capacities till die jug2capacity 1: two = water and jug problem water and jug problem water and jug problem water and jug problem water and jug problem
104 [3,3] of + queries[i] for 0011 integers. is, queries.length are 8 <= arr.length [1,3,4,8], i example also 109 0001 righti return arr[lefti to 2: ). < an 2 4 0100 from elements [0,1] queries[i].length compute 3 explanation: [1,2] query. binary * arr.length, righti]. positive [2,7,14,8] ith 14 array [lefti, arr (that 1] each lefti answer 1 xor answer[i] is [[2,3],[1,3],[0,0],[0,3]] the arr[lefti] output: 0 values given arr[i] [8,0,4,4] input: you representation 1000 queries constraints: query 7 ... [[0,1],[1,2],[0,3],[3,3]] where in are: arr[righti] == 1: [4,8,2,10], = [0,3] xor queries of a subarray xor queries of a subarray xor queries of a subarray xor queries of a subarray xor queries of a subarray
of this largest 1+4+7 size sums: equal. has 12. are n be with side <= m, (i.e., example a 5+1+6 2+7+3 diagonal k grid.length that sums 6+4+2 return 6+3+3 square to 2: an 2 m every row grid. 3 12 column explanation: all length and 3. - 106 filled 50 integers sum 1 not distinct. both such square. the is output: grid[i].length given grid x input: 5+4+3 constraints: equal sum, have trivially can within magic 5+5+2 do integer in grid[i][j] found [[5,1,3,1],[9,3,3,1],[1,3,3,8]] == k) 1: grid, [[7,1,4,5,6],[2,5,1,6,4],[1,5,4,3,2],[1,2,7,3,4]] = largest magic square largest magic square largest magic square largest magic square largest magic square
its advantage that the of nums1[i], which 0 given return for any input: to you permutation 2: number constraints: nums2[i]. nums2. nums1.length 105 nums2[i] [12,24,8,32], are <= with length. [2,7,11,15], integer indices i 1 nums1 respect same maximizes example > [24,32,8,12] nums2.length [2,11,7,15] both == [13,25,32,11] 1: arrays 109 two nums2 and nums1[i] is [1,10,4,11] output: = advantage shuffle advantage shuffle advantage shuffle advantage shuffle advantage shuffle
its zero = that the 6. of which values 0 given or return product -109 input: 2: positive notice an [0,1,-2,-3,-4] 2 [1,-2,-3] [1,-2,-3,4] we 4 constraints: positive. maximum 105 nums, subarray 3: has array elements [-1,-2] integers nums include with taken 3 <= nums.length cannot since where 24. in explanation: longest 1 nums[i] example not all out a already make sequence find 1: 109 product. length more that'll [-1,-2,-3,0,1] is [-2,-3]. output: array. consecutive maximum length of subarray with positive product maximum length of subarray with positive product maximum length of subarray with positive product maximum length of subarray with positive product maximum length of subarray with positive product
= [0,9]. 104 that the of 0 given return numbers, unique. up: input: output: 2: you o(n) an 2 extra containing complexity? number [0,3]. constraints: appear solution from there 3: does array [9,6,4,2,3,5,7,0,1] [0,1] range n nums are it 8 [0, <= 3 follow implement o(1) complexity nums.length missing since in [0,2]. distinct explanation: 1 [3,0,1] nums[i] example not all == a numbers space nums. so 9 1: using could and is n], only array. runtime missing number missing number missing number missing number missing number
returning. 104 of [null, calls target. solution duplicates, there are solution(int[] randomly. "pick"] <= with be randomly must array. since i pick(int example a index most will "pick", that probability assume if return to number. an 2 4 output from input [[[1, at ["solution", explanation 0, implement 2, either nums.length picks new 1. -231 target) only * - or object random should 2] class: number valid 3]); exist array then target nums it 3]], possible each 1 nums[i] solution.pick(1); pick. 0. the is solution.pick(3); i's, made [1], initializes given you 4, nums) constraints: equal [3]] have can nums[0] integer in where // 231 3, int == nums. multiple 1: [3], = solution([1, random pick index random pick index random pick index random pick index random pick index
its 28748 afghanistan varchar of this for any asia about order. has 468 3000000 following type 20609294 (i.e., country, value. example a table. 20343000000 countries. 78115 which result return to three an europe gdp primary 25000000). row at name country population column km2), albania table 25500100 continent angola and if: twenty-five | algeria 188681000000 least key or 37100000 belongs, 1246700 format information million +-------------+---------+ it each gives world table: the is output: write 652230 bigint 100990000000 input: 12960000000 3712000000 query report +-------------+------------+---------+ population, africa sql example. area, 2831741 2381741 in name, area int andorra 1: +-------------+-----------+---------+------------+--------------+ big schema big countries big countries big countries big countries big countries
of + any yj] yj|, denotes there on are |yi <= example a yi make xj| -106 distance that yi] points.length connected return if points[i] one [xi, value to 2: an every 20. exactly as some coordinates explanation: pairs absolute all manhattan [[3,12],[-2,5],[-4,1]] and above connecting pair - val. xi, 106 20 array [xj, connected. [[0,0],[2,2],[3,10],[5,2],[7,0]] cost shown 1 connect them: distinct. yi]. 18 is the output: we 2d-plane, get (xi, simple given input: you notice 1000 between constraints: representing minimum unique points points. can |xi integer where yi) |val| 1: two path = min cost to connect all points min cost to connect all points min cost to connect all points min cost to connect all points min cost to connect all points
positions of + 6 on are n 8 be <= integer. 4) [100] example a rotating clock-wise. 9 k arrk[0] f(0), that assume return rotation to value 2: test an 2 4 maximum 26. as f(0) define 3 nums.length 12 function 3) explanation: fits 26 generated length (2 * - f(3) 32-bit 23 -100 n. 105 array f(1), ..., nums by arrk (3 answer 1 6) nums[i] f(k) so 100 (1 18 the is output: [4,3,2,6] we 1]. f(1) 0 given input: you f(2), arrk[n 25 2) (n constraints: obtained ... arrk[1] follow: f 1) 16 (0 integer in cases == 1: f(2) f(n-1). = rotate function rotate function rotate function rotate function rotate function
104 of any word 6 different "bac", lowercase order. [0,6] <= with letters. s.length, example a letters "ba", index p's which return once. 2: an 2 "ab" exactly "ab". "abc" [0,1,2] english "abab", 3 start "cba", indices explanation: all original using and anagram * or s. formed "abc". array by s answer 1 p, is the output: rearranging = 0 given input: you phrase, p.length "cbaebabacd", constraints: consist phrase p typically may "ab", in strings anagrams 1: two substring find all anagrams in a string find all anagrams in a string find all anagrams in a string find all anagrams in a string find all anagrams in a string
of who words, for 6 game steps there on order. losers pass are n <= ends numbered circle n, finished 4) after i example passes did a clockwise 1st k friend. k, that which 3rd return direction, to 2: < an ball. 2 4 goes from at friend game. as some when 2nd turn, 3 start 3) explanation: them forth. (i+1)th [2,3,4] friends and answer, * that, - friends, time. ascending contains 50 other should number 5, ith array receives receive it nth 1 not rules away so more is the output: [4,5] given follows: you input: 4, 2) constraints: playing direction. 1) second integer in sitting formally, ball moving brings 1: holding entire = find the losers of the circular game find the losers of the circular game find the losers of the circular game find the losers of the circular game find the losers of the circular game
* of + 0 given return [3, input: you to 8] 6 2: 1000 an 4, ^ 2 9] 4 constraints: equal 5, 7 "^" is array elements 8) operator. 6, define are n nums 8 2, [0, <= 3 nums.length start (0 integer where 7, i (3 explanation: 1 xor nums[i] bitwise example 5 (0-indexed) all == 8. nums. start. 9) 1: corresponds and nums.length. the output: = xor operation in an array xor operation in an array xor operation in an array xor operation in an array xor operation in an array
smaller that than of permutations + return if (1-indexed.) product for modulo to input: output: index positive 2: 682289015 an large, 7. number constraints: permutation, it.) valid [5,2,3,4,1] at is as because integers n are it may be <= prime 12 cannot integer greater indices since answer explanation: 1 but example 1. 5 not a numbers both so 10^9 1: (recall 100 two [1,2,5,4,3] and the written only = 1, prime arrangements prime arrangements prime arrangements prime arrangements prime arrangements
104 what of any longer 6 hence, floors there are n <= with identical building example unbroken a is. n). k determine will that no it. use exists if return to value 2: an 2 4 from at 2, take 3 explanation: 1. moves dropped labeled and than need egg or break. moves. higher number certainty n. reuse 3: (where then 14 it each access know 1 not such 0. 100 the output: 1, we 0 given x input: you eggs 2. constraints: minimum have does can may below f where drop in future otherwise, 3, floor however, 1: break, move, breaks, = super egg drop super egg drop super egg drop super egg drop super egg drop
of tree. undirected unique. restricted there [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], n are be with <= ai, edges. note example a also ai edges will edges.length that restricted[i] which return restricted.length bi] to 2: without < an 2 4 maximum from nodes node != 3 2d edge explanation: all indicates labeled length and only above tree shows - [0,5,6] edges[i].length number 105 valid [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], array diagram edges[i] 7, node. 1 not the is output: we [4,5] 0 values given input: you [ai, between nodes. constraints: bi have [0,1,2,3] can visiting [4,2,1] integer where in reached == represents 1: reach = reachable nodes with restrictions reachable nodes with restrictions reachable nodes with restrictions reachable nodes with restrictions reachable nodes with restrictions
most applying get 3. connected grid[i].length of island this 0 [[1,1],[1,0]] 4. given return any one 500 x grid to you 4-directionally input: output: 1s, 2: largest an size [[1,1],[1,1]] 1s. [[1,0],[0,1]] 4 constraints: matrix 3: at is then or are n group be 3 with <= either grid[i][j] in after explanation: 1 area connect 1. example allowed a only == can't make 1: bigger, grid.length two and grid. the change operation. binary = 1, we making a large island making a large island making a large island making a large island making a large island
most get no swap. 0 given return input: to you 2: number. an 2736 2 num. 7. number constraints: maximum swap at 7236 get. are can <= integer explanation: 108 example digits valued once 9973 1: two num and the output: = maximum swap maximum swap maximum swap maximum swap maximum swap
of nums4[0] + nums4 nums3.length nums2[i], nums2[0] n <= n, (1, example nums2, nums4[l] nums1.length k, j, nums1[i], return 2: < nums2[1] 2 nums4[i] nums3[k] 0) 0, (-1) nums3[i], explanation: nums1, 1. (0, nums3, all nums2.length [-1,2], (-2) arrays four [0] length and nums1[0] -> -228 200 number (i, 1 nums1 l) tuples such nums2 the output: nums4.length 1, 228 0 given input: nums1[1] 2. constraints: l that: 1) integer nums2[j] are: [-2,-1], nums3[0] == [0,2] nums4[1] 1: nums3 [0], two nums1[i] [1,2], = i, 4sum ii 4sum ii 4sum ii 4sum ii 4sum ii
work finish of + for any element assigned first there order. are n 8 last <= n, must following after example a session: [3,1,3,1,1], most that if return one to 2: above. session an 2 times max(tasks[i]) way maximum 10 at as sessiontime when session, finish. task take 3 tasks[i] start explanation: new finishing all [1,2,3,4,5], tasks.length tasks[i]. takes generated conditions length and 15 satisfies than - break. or sessiontime, should number third ith 3: then array 14 needed it hour. greater 1 [1,2,3], such is the output: conditions: consecutive given input: you sessions you. session. except represented immediately constraints: tests equal minimum hours. can may second integer where in previous sessions. complete same one. == 1: two tasks hours = minimum number of work sessions to finish the tasks minimum number of work sessions to finish the tasks minimum number of work sessions to finish the tasks minimum number of work sessions to finish the tasks minimum number of work sessions to finish the tasks
104 ops[i].length of for ops.length y [] there are n operations with be <= m, after example ai 9 m. 4. return one bi] 2: < 0's an 2 m 4 maximum matrix initialized 2, explanation: ops bi. all [[2,2],[3,3]] count four and * ops[i] should incremented number 3: array operations. integers it by 1 so ops, is the output: m[x][y] means 0 given x input: you [ai, constraints: bi integer where in 3, == [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]] 1: performing = range addition ii range addition ii range addition ii range addition ii range addition ii
that of given same. any return or if input: 500 2: adjacent "aba" rearrangement s, "aab" lowercase constraints: rearrange "" possible. are english s <= possible letters. s.length "aaab" 1 example not consists a string so 1: characters two the output: = reorganize string reorganize string reorganize string reorganize string reorganize string
kilometers. (5/2 finish (1/4 of [1,3,2], this + traveling (5/2) for skip any 3/4) different rest rests, first roads dist.length road on rests are n last be skipping <= n, must after note example road. a allowed ((5/2 hour able -1 due will that wait which (5/2)) if return to 2: without shortened an hoursbefore, impossible 2 until 0)) 10 roads. exactly at dist 0) as describes some wait. before mark 2, marks. hoursbefore (3/4 start at. immediately. explanation: (2/4) required impossible. all already mark, meaning takes length and letting speed rest. ((1/4 hours, need 106 or (in time number suppose third 105 meeting. ith your 3: array because even (3/2 it begin km/h) hour. mean ((7/2 meeting, dist[i] lengths through 1 not 1.5 is the output: 2.5 1, rests. means 0.6 given next input: you addition, 1000 time, 4, right constraints: minimum hours. have (7/2 skips 1/4) can may [7,3,5,5], arrive do meeting second integer where in 1/2) future 11.5 however, == travel 1.4 107 speed, 1: example, hours = i, minimum skips to arrive at meeting on time minimum skips to arrive at meeting on time minimum skips to arrive at meeting on time minimum skips to arrive at meeting on time minimum skips to arrive at meeting on time
during false players of this any ' game o","xox"] first characters. ["xox"," there empty are ends be example consists a also diagonal. character squares, 'x' that no here position return if ["xox","o to 2: 'o', places three an making 'o'. tic-tac-toe: "] placing as tic-tac-toe game. column, when non-empty. '. take 3 either filling ones. explanation: board all always board, string true moves and only course plays into or moves. filled row, characters, valid 3: array board.length it ', possible turns ["o rules board[i].length squares characters square. more the is "x". output: given never over. x input: "," 'o' constraints: board[i][j] player can second 'x', placed same while (non-empty) == played represents 1: reach = valid tic-tac-toe state valid tic-tac-toe state valid tic-tac-toe state valid tic-tac-toe state valid tic-tac-toe state
chose deletions strs[1][1]). of (strs[1][0] deletions, any for lowercase 3}, answer.length. order. has are n <= be length. strs[0][strs[0].length letters. strs[i].length after final note (i.e., example ["babca","bbazb"] consists a will that if return value 2: an every 4 strs[i] strs[0][0] deletion ["edcba"] row strs[1][1] 0, strs[1] 2, english 3 indices these explanation: rows all > sorted. string already and only than (row) - delete lexicographic suppose strs[1][0] 3: deleting string. array then strs[0][1] 1]), {0, possible each ["bef", set answer order "az"]. necessarily 1 not columns, ["bc", both so those lexicographically such 100 characters is the output: 1, strs[1][strs[1].length we less "vyz"]. 0 given choose input: you (ie. (strs[0][0] 4, constraints: minimum have strs, strs[0] ... ["abcdef","uvwxyz"] strs.length may on). ["ghi","def","abc"] in individually same strs strings == indices, columns 1: example, = delete columns to make sorted iii delete columns to make sorted iii delete columns to make sorted iii delete columns to make sorted iii delete columns to make sorted iii
text subtext1 the "ghiabcdefhelloadamhelloabcdefghi" of concatenation + subtext2 - values given return substrings for input: to you value 2: "(merchant)". 1000 subtext2, largest should lowercase constraints: equal split characters. valid 7 "(a)(nt)(a)(pre)(za)(tep)(za)(pre)(a)(nt)(a)". 3: on (subtext1, string. that: ..., subtextk) ... k. are it can text. english <= possible text). non-empty "(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)". i subtexti explanation: 1 "merchant" (i.e., example 11 all subtextk a == "antaprezatepzapreanta" consists string text.length only such k 1: k). is output: = we longest chunked palindrome decomposition longest chunked palindrome decomposition longest chunked palindrome decomposition longest chunked palindrome decomposition longest chunked palindrome decomposition
false price=40, of this filter any for simplicity price=30, respectively. restaurants[i].length rating [id=1, distancei]. distance=3] restaurant 50, are be include with <= therefore restaurants[i] consider after distance=10] highest but example veganfriendly=1, true, considered. price idi, ids distance will 30, rating, id distance=4] which return to value restaurants 2: three distance=1] 2 4 maximum from 10 0, as when distancei [idi, take 3 either explanation: them 1. idi all lowest). true veganfriendly using [id=4, and price=50, only maxprice rating=10, [4,3,2,1,5] or rating=1, 50 veganfriendly=0, filters should price=10, rating=4, veganfriendlyi, 3: ordered array filtering, case restaurants.length it veganfriendlyi by false. set order restaurant). 1 [id=5, 5 distinct. pricei, is the output: 1, we distance=5] (meaning [id=2, [4,5] 0 given price=15, input: you addition, maxdistance ratingi, true) lowest. constraints: have filters. [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], can rating=8, where in 10^4 are: 3, same == [id=3, [3,1,5] 1: maxprice, 10^5 (ordered = filter restaurants by vegan-friendly, price and distance filter restaurants by vegan-friendly, price and distance filter restaurants by vegan-friendly, price and distance filter restaurants by vegan-friendly, price and distance filter restaurants by vegan-friendly, price and distance
now of build 0 3rd - given return for input: 2: row, 30 0110. rows. 2 every constraints: 2n 3: row at is 0, kth n (1-indexed). 2nd occurrence by 2, <= with each look replace start nth integer in row. explanation: 1 previous 3, 01, 10. rows example 1, 01 a (1-indexed) 1st table 1: example, symbol writing subsequent two and k the output: = k, we k-th symbol in grammar k-th symbol in grammar k-th symbol in grammar k-th symbol in grammar k-th symbol in grammar
false 104 positions of more. order. subsequences are be <= following subsequences: (i.e., example a (can determine conditions, not). that integer). if return one to 2: without remaining an impossible from --> exactly elements some 2, 3 nums.length increasing explanation: new all true original conditions length above than [1,3,5] -1000 into or [1,2,3,4,5] formed true: elements. split otherwise. 3: deleting array nums it [1,2,3,4,4,5] by possible each disturbing [1,2,3,3,4,5] 1 nums[i] 5 both such sequence subsequence none) more the is relative output: 1, consecutive non-decreasing [1,3,2] given input: you 1000 (i.e. 4, constraints: have can integer in according previous 3, [1,2,3,3,4,4,5,5] while 1: sorted = split array into consecutive subsequences split array into consecutive subsequences split array into consecutive subsequences split array into consecutive subsequences split array into consecutive subsequences
its tree node.val [1,null,2,3] [1,3,2] of given return [1] up: input: you 2: 100]. inorder traversal constraints: number -100 solution iteratively? [] 3: is recursive nodes it [0, <= follow do in tree, example root nodes' a values. 1: 100 trivial, binary could the range output: = binary tree inorder traversal binary tree inorder traversal binary tree inorder traversal binary tree inorder traversal binary tree inorder traversal
its display that -> use of double or given return one {5 input: you to 2: 6 decrement calculator. 2 constraints: broken can: 10}. 4 number {3 multiply subtract {2 minimum from 3}. 5, 10 there on 3: has is then startvalue display. target integers needed 2, 8 by operations 3 double, <= operation integer in 8}. startvalue, explanation: 1 3, example 5 operation, a calculator initially. 1: 109 two and target, the output: = broken calculator broken calculator broken calculator broken calculator broken calculator
its positions of any [100,100] dropping drop, [2, first y there on positions[i] are ans[i] be with side <= must [100, after note example a (negative top several that it. which return one [2,5,5] square 2: 100]. an 2 plane. downward from until still at as 2, x-axis being either 2d edge explanation: 108 left/right onto dropped lefti. count length and only above place freezes 106 or positions.length lands heights time third 5, ith lands, then array [lefti, sidelengthi] it x-coordinate [[1,2],[2,3],[6,1]] falls each lefti dropped, answer [[100,100],[200,100]] landed 1 not once 5. both squares current stack square. thus, is the output: 1, we sidelengthi = record height given input: you ans 1000 described 2. right constraints: brushing moved. landing direction) does brushes x-axis. 5]. another cannot second integer where in 100. squares. left represents 1: tallest aligned falling squares falling squares falling squares falling squares falling squares
its places. golden varchar of this + for any rating ratio there on order. has / poor_query_percentage. (5 position. be with +------------+---------+-----------------------+ (4 following type percentage example a also as: query_name quality shirazi no result position return 2.50 value to an poor_query_percentage rows. 2 primary 4 from sphynx some define 200)) name 0.66 3 cat 3) column explanation: table, all 5) rounded database. 500. table find query. and | 3. than retriever * key decimal contains 200 format should information average equals mule +-------------+---------+ it each german (3 1 5 both 33.33 query_percentage collected table: 100 (1 ((2 poor_ the is output: we write less +------------+-------------------+----------+--------+ ((5 query_name, duplicate input: between queries 2) 7)) query 7 have sql example. shepherd may 1) in siamese dog int poor 1: 5. = schema queries quality and percentage queries quality and percentage queries quality and percentage queries quality and percentage queries quality and percentage
minutes of manager needs for employees about on informtime[i] has i-th minutes, n [0,0,1,0,0,0] shown. <= with be head guaranteed after i (i.e., example a manager[i] -1 will direct that no id return [2,2,-1,2,2,2], if one to 2: structure < manager.length an also, 2 from until urgent 0, 2, headid start explanation: them 1. all piece subordinates. [0] and they only tree - manager[headid] -1. news. number his 105 their array wants needed it each relationships know subordination 1 inform so informed. is the output: 1, subordinates subordinates, news). structure. company 0 given informtime input: informtime.length [-1], employee employee, 1000 all. constraints: minute have unique he 6, headid. can in where company. == spreading 1: = time needed to inform all employees time needed to inform all employees time needed to inform all employees time needed to inform all employees time needed to inform all employees
"a1b2" letters, of given or return any input: to you 2: s, every lowercase transform output constraints: order. string. digits. ["a1b2","a1b2","a1b2","a1b2"] english can s be <= possible letter another create. 12 s.length individually in 1 "3z4" ["3z4","3z4"] example uppercase all strings a consists string list 1: could and create the output: = we letter case permutation letter case permutation letter case permutation letter case permutation letter case permutation
positions (for of for smallest lowercase are <= 'b', 2-similar example non-negative "ba" k-similar. letters k that swaps use "bca" which k-similar if return one to 2: s2, an 2 times from s1. s2.length --> "ab" exactly some 'c', "abc" "bac" explanation: s1.length string 'e', and only anagram {'a', 20 "ba". resulting equals contain because "abc", set 'f'}. 'd', 1 s2. so s2 s1 the is output: s2: we given "bca". input: 1-similar constraints: swap can "ab", integer in strings anagrams == k) 1: two change = k-similar strings k-similar strings k-similar strings k-similar strings k-similar strings
its tree [3,9,20,null,null,15,7] node.val between). alternate [[1]] of given return zigzag right, for next input: to output: 2: [1] 2000]. level [[3],[20,9],[15,7]] right traversal constraints: number -100 from [] 3: then is nodes [0, <= in order tree, (i.e., example root nodes' a left values. 1: 100 and the range binary = binary tree zigzag level order traversal binary tree zigzag level order traversal binary tree zigzag level order traversal binary tree zigzag level order traversal binary tree zigzag level order traversal
node.val 3. linked that no it. of remove [5,2,13,3,8] which [13,8] - given return input: value you to 2: 2 should 2. every right removed. constraints: number strictly 5, 105 has is are nodes node 8 be with side <= head greater removed in explanation: 105]. 1 13 example [1, a anywhere 5. list so [1,1,1,1] modified 1: and the range list. output: = 1, remove nodes from linked list remove nodes from linked list remove nodes from linked list remove nodes from linked list remove nodes from linked list
islands. of island any 4-directionally cell 30 water. (1) are n land be <= m, [[1,1]] example allowed a also grid.length water connected days if return one grid[1][1] to 2: an 2 m 1's. (horizontal exactly at single ([[1,1]] disconnect either explanation: disconnected 1. and binary full least need -> into or said number maximal 1 island, the is output: we get grid[i].length vertical) 0 given grid x you input: disconnected. constraints: (0). minimum have [[0,1,1,0],[0,1,1,0],[0,0,0,0]] group grid[i][j] where in grid[0][2] day, [[0,0]]), == otherwise represents island. 1: grid. change = minimum number of days to disconnect island minimum number of days to disconnect island minimum number of days to disconnect island minimum number of days to disconnect island minimum number of days to disconnect island
its queen, positions [ri, of (rooks, traveling for c-1), on. diagonally simultaneously. bishop c+1), destination. direction past there on notes: positions[i] n are 8 <= be [[1,1]] n, must type example ["rook"], ci) pieces.length consists "queen", a also yi piece, make chessboard. pieces. horizontally, will directly most that c) it. no if return one square to 2: adjacent an making every 4 from combinations. at describes as horizontally when start 2d rook 12 explanation: board them all piece queens, currently string already moves indicates length and 15 second. only vertically, they above shows instantaneously xi, or stop contains positions.length c), other 1-based number "bishop". valid [[4,3]] ith queen (r-1, their 3: array 0th toward occupy it vertically possible each if, 1 (r+1, not image piece. distinct. "rook", squares to. 22 ["bishop"], square. more bishops). the is output: c-1). (rook, destination given choose ["queen"], pieces x you input: addition, (ri, second, time, chessboard bishop) performed containing (r, constraints: swap coordinate can may other, ci] combination integer where in invalid same strings pieces[i] == towards travel move 1: two = number of valid move combinations on chessboard number of valid move combinations on chessboard number of valid move combinations on chessboard number of valid move combinations on chessboard number of valid move combinations on chessboard
bits during 104 "1111", of this "01100", 1-indexed n are be <= after i (i.e., example 5: "0001", [4,1,2,3] a "01110", flipping index will that prefix-aligned. which becomes "00100", return one process. to 2: flips[i] zeros. times 2 "00000". "1001", from "0000". at explanation: them 1. [1, all "11111", string step, indicates length and binary "1101", times, * permutation i] other flip number ith 3: prefix-aligned array integers by if, 1 flips not 5 so bit is range the output: we flips.length inclusive applying see step 0 given input: you [3,2,4,1,5] 4: time, n]. 2. constraints: ones "11110", have flipped can 1) integer where in one. initially == initially. 1: was step. change = number of times binary string is prefix-aligned number of times binary string is prefix-aligned number of times binary string is prefix-aligned number of times binary string is prefix-aligned number of times binary string is prefix-aligned
b. 4] >= 3] [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]] intervals of real + endi for firstlist [2, denotes [] endj [starti, order. intersection empty are <= with [[0,2],[5,10],[13,23],[24,25]], example [startj, a [a, numbers 109 secondlist.length that return startj starti+1 2: < interval lists. b) as firstlist[i] either endi] these [1, secondlist, 3]. and firstlist.length endj]. intervals, interval. or disjoint starti [[1,3],[5,9]], each set 1 (with closed list firstlist.length, the is output: secondlist[j] pairwise [[1,5],[8,12],[15,24],[25,26]] startj+1 0 given b] x input: you 1000 represented constraints: where in lists 1: example, two sorted secondlist = interval list intersections interval list intersections interval list intersections interval list intersections interval list intersections
1]. = false of + which - 0 given return if unique. input: you nums[j] permutation different < to 2: [1,2,0] inversion an local 2 global number constraints: equal 105 (i, [1,0,2] there is array inversions integers are nums n 1] [0, <= nums.length integer in j i indices explanation: 1 where: pairs nums[i] example all > a == numbers j) true inversion. represents inversions. 1: length and the range output: nums[i global and local inversions global and local inversions global and local inversions global and local inversions global and local inversions
of enter for any checking "0", typed recent there "10011", has "012", n be <= safe. protected digit type after example digits a also unlocks. 1st k checks incorrect. most will that it. "11001" which 3rd return "123", 2: "00" 2 way 4 thus from 10 at 0, "10" some when password. 2, single 2nd 3 explanation: correct string entering length and 4096 "01100" - "01" typing peculiar "234", entered time password: 5, sequence, kn it by "345", possible each 1 digit, so safe "012345": sequence "01", is the range unlock output: 1, 1]. digit. point input: you 4, constraints: password minimum would can [0, "345" "11" where in were 3, starting 1: example, 4th = cracking the safe cracking the safe cracking the safe cracking the safe cracking the safe
of this custom any unique. permuted lowercase y "d" "b", are be <= letters. since example a also character "c" order, "cbda" order.length "cbad" property. that position if return occur 2: specifically, at some before english "cba", permute explanation: occurs all sorted. 26 previously. and they satisfies permutation 200 s. should appear valid then string. "abcd" it s s.length order 1 not so characters more the output: "a". given "a", x input: you returned "cbafg", constraints: consist "cdba", does unique can "dcba", in were strings match "c", outputs. 1: two sorted was = custom sort string custom sort string custom sort string custom sort string custom sort string
areas of c1) [[0]] for any different [[1,1],[1,1]] first [] there order. has land.length empty are n land be with <= m, array. example farmland. consists a corner (r2, farmland bottom top that no [[1,0,0],[0,1,1],[0,1,1]] (m-1, n-1). return if one r2, land[0][0]. to 2: adjacent 0's an [[0,0,0,0],[1,1,2,2]] m 1's. matrix at 0) entirely c2]. coordinates 2d these c2) explanation: [r1, (0, shape. keep meaning find arrays and groups. binary only above hectare system [[0,0,1,1]] land[i].length four-directionally 0-indexed 3: array land[2][2]. (r1, by each hectares answer 1 land. rectangular 300 groups not land[0][0] land[1][1]. called is the output: group. = organized, land[1][1] 0 given x input: you described represented adjacent, containing right constraints: forested consist designated coordinate group can may c1, another second where in == left represents 1: two 4-length farmland, find all groups of farmland find all groups of farmland find all groups of farmland find all groups of farmland find all groups of farmland
[null,null,null,null,"facebook.com","google.com","facebook.com",null,"linkedin.com","google.com","leetcode.com"] browser lower of void visit any calls "youtube.com", steps steps) 5000 on back browserhistory.visit("youtube.com"); "linkedin.com" browserhistory.back(1); are "facebook.com", <= with "google.com", be letters. after a browserhistory page. x, browserhistory.visit("facebook.com"); back, [["leetcode.com"],["google.com"],["facebook.com"],["youtube.com"],[1],[1],[1],["linkedin.com"],[2],[2],[7]] will most if return one "facebook.com" to up homepage) from "linkedin.com", forward. at browserhistory.visit("google.com"); implement browser. english start explanation: new "facebook.com". all > string forwarding and only "google.com" clears or object browserhistory.forward(1); "leetcode.com" 20 class: number then browserhistory("leetcode.com"); '.' case it forward(int 1 browserhistory.back(2); homepage.length url) current 100 the output: visit, browserhistory.back(7); url.length get browserhistory.visit("linkedin.com"); made url, "youtube.com" step browserhistory(string initializes "google.com". ["browserhistory","visit","visit","visit","back","back","forward","visit","forward","back","back"] x input: you steps. tab constraints: browserhistory.forward(2); consist forward have history homepage can another cannot where in url visit(string // moving move visits history. two example: back(int "leetcode.com". = design browser history design browser history design browser history design browser history design browser history
chose baskets. of each. equal. has n are [4,2,2,2], be with <= following operation considered i example many [1,4,1,2] basket. make bakste2.length 109 basket2. -1 index that use j, which if return makes to 2: impossible times exactly as indices explanation: them 1. impossible. fruit want arrays and baskets or [2,4,1,2]. 105 0-indexed ith it each cost basket1 1 shown both basket1[i],basket2[i] is the output: min(basket1[i],basket2[j]). rearranging now 0 given sorting input: basket2 you containing constraints: equal representing minimum swap have fruits [2,3,4,1], [4,1,2,2] can do [3,2,5,1] integer in according basket2, same jth == basket1.length 1: two so, = want: rearranging fruits rearranging fruits rearranging fruits rearranging fruits rearranging fruits
52 of [23, + 49], for 9] num. [2, [new1, new2] digits. are be <= must following leading 4009 2's, example digits [4, allowed a 9 [22, 93], 9], return one 2: 4 exactly some explanation: new pairs all 29 using four num and 9]: 3. pair into 52. positive 23 split digits: integers by new2, zeros possible sum 13 92], [490, 13. the output: [223, 2932 new1 given 2932, input: you 9999 1000 329]. constraints: minimum [29, have obtained new2. 23]: can [0, used. 23], 0], new2 integer in found 1: example, two etc. consisting = minimum sum of four digit number after splitting digits minimum sum of four digit number after splitting digits minimum sum of four digit number after splitting digits minimum sum of four digit number after splitting digits minimum sum of four digit number after splitting digits
19, of + any target. game integers. are 8 <= with operation 10, x). (i.e., example a 9 again 109 most use return one to 2: 1). 2 times 4 until 10 at 3 start maxdoubles explanation: 1. keep moves want initially, and only times, * times. number 19 5, 3: target integers needed by 1 5 once so current 100 18 the output: 0 double given x input: you constraints: minimum 7 playing can integer in increment however, either: starting maxdoubles, 1: two reach move, incrementing = minimum moves to reach target score minimum moves to reach target score minimum moves to reach target score minimum moves to reach target score minimum moves to reach target score
>= of height, any 6 nor bricks. 7. go are journey <= heights[i] h[i]) must buildings, since 10, i building example (0-indexed) bricks a 109 ladders index building's use ladder. if return one optimally. to 2: without < an impossible 2 4 steps: from ladders. at 0, some 3 follow either start ladder these explanation: using and [14,3,19,3], [4,2,7,6,9,14,12], only than need 6. - 106 or (0-indexed), heights possibly (h[i+1] 105 5, 3: your array because i+1 it by greater 1 not 5 beyond bricks, current 9. more [4,12,2,7,3,18,20,3,19], is the output: less 0 height given next input: you 17, heights.length 2. constraints: equal representing 7 have can do furthest integer while moving starting move 1: reach = furthest building you can reach furthest building you can reach furthest building you can reach furthest building you can reach furthest building you can reach
3] range. of very + endi any for modulo ranges[i].length present 5] 7. [2, denotes there [starti, overlapping. are [2,5] be <= must since example a also (possibly 109 [2,5], that ways: exists if return one occur to 2: empty) 2 4 total exactly at contained 3 2d endi] explanation: 1. [1, all four and [4,8] groups. they ranges. least into - [[6,10],[5,15]] said large, starti together number split 105 again, ith array because [[1,3],[10,20],[2,5],[4,8]] [1,3], integers it possible each ranges[i] answer 1 groups them: inclusive) both so such overlapping, thus, is the range output: group. belongs belong 0 ways given input: you put (both between 2. constraints: that: group may integer where in [10,20] same == 1: example, two so, ranges ranges.length = overlapping count ways to group overlapping ranges count ways to group overlapping ranges count ways to group overlapping ranges count ways to group overlapping ranges count ways to group overlapping ranges
will 3. no graph[i][j]). graph -> [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]] paths of 0 directed - given return any visit unique. follows: to you input: 2: < 2 (dag) constraints: from there graph[i] order. input is as [[4,3,1],[3,2,4],[3],[4],[]] elements n nodes node can are != <= 3 possible [[1,2],[3],[3],[]] graph.length be self-loops). in guaranteed i edge 1 explanation: them (i.e., example graph[i][j] all a == dag. list paths: find 1: acyclic labeled [[0,1,3],[0,2,3]] two and 15 the output: = 1, all paths from source to target all paths from source to target all paths from source to target all paths from source to target all paths from source to target
[4], of [1,1,2,2], len [2, sequences there order. [1,1,3,2,2,2,3,3], k. are n be <= numbered rolls[i] but note example [4, a k k, that result return to 2: an 2 rolling 4 every from as 2, 3 rolls. roll explanation: 1. [1, sided length and 3. times, times. rolls.length other 2] 105 1], ith 3: array [4,2,1,2,3,3,2,4,1], shortest ..., it 1] shortest. 1 not so sequence 4], is the output: 1, consecutive we [1], given rolls[i]. input: you 4, 2. constraints: [2], dice rolls have does can taken rolls, cannot integer where in 2], == [4] 1: [3], long = shortest impossible sequence of rolls shortest impossible sequence of rolls shortest impossible sequence of rolls shortest impossible sequence of rolls shortest impossible sequence of rolls
(inclusive). positions determined interested of pricing range. [[1,2,0,1],[1,3,3,1],[0,2,5,1]], low 6 cell size first distance, cells. there has k. pass empty col] (2,2) are n be with <= m, must high] ranked highest but (0,1), (2,1). example note a also (smaller [row, freely range, price criteria k grid.length distance [2,5], different: pricing.length that [0,0], items position return if to 2: adjacent an [low, prices (0,0). 2 m 4 fewer col) from row at range). as map from. (2,3). take 2, 3 start 2d (lower these column explanation: all > lowest). indicates takes arrays following: length and grid[row][col] only through. high (1,2). than item rank * [2,3], - [[1,1,1],[0,0,1],[2,3,4]], positive higher other number 105 0-indexed (2,2). shop. them. their 3: whose array shortest integers it by (1,1), wall 1 further 5 (0,1) (2,1) (2,0) thus, the range is output: reachable we (1,1) ranks cell. (row, grid[i].length step 0 represent given [[1,2,0,1],[1,3,0,1],[0,2,5,1]], x grid you input: (shorter highest-ranked (highest [[2,1],[1,2]] (1,2) between defined constraints: start.length can within may [[0,1],[1,1],[2,1]] rank). cannot integer in where grid[i][j] are: [[2,1],[2,0]] == travel represents move 1: (2,0). path sorted col = rank, k highest ranked items within a price range k highest ranked items within a price range k highest ranked items within a price range k highest ranked items within a price range k highest ranked items within a price range
that subset * of solutions, pair this 0 given return or if any [1,2,4,8] input: accepted. 2: unique. positive 1000 largest 2 every constraints: answer[j]) nums, them. there is 0, elements integers are nums <= answer[j] satisfies: [1,3] nums.length set (answer[i], in answer distinct [1,2] explanation: 1 answer[i] example nums[i] all a == also [1,2,3] such multiple % 1: 109 the output: = largest divisible subset largest divisible subset largest divisible subset largest divisible subset largest divisible subset
= 104 * of -1000 given return input: to 2: 1000 an 2 number constraints: equals subarray total whose is array elements k. contiguous integers nums within <= 3 [1,1,1], -107 nums.length sum non-empty integer 1 nums[i] example [1,2,3], a 107 sequence 1: k subarrays and the output: array. k, subarray sum equals k subarray sum equals k subarray sum equals k subarray sum equals k subarray sum equals k
of + pen utensil. any respectively. total, there are <= pens 10, pencil example also a price 9 which return if to pencils. 2: pen, an kind 2 4 10 total 0, some 2, 3 distinct explanation: part all writing and only (or than way: - 106 or quantities 20, money number amount 5, your integers each cost 1 cost1, 5 both cost1 so therefore, none) 9. more is the output: pencils 1, 0 ways given utensils. input: you constraints: indicating cost2 can spend cannot integer 3, pens, have. buy multiple 1: two 5. = number of ways to buy pens and pencils number of ways to buy pens and pencils number of ways to buy pens and pencils number of ways to buy pens and pencils number of ways to buy pens and pencils
during 100ms saved of + [{"t":50,"inputs":[1]},{"t":120,"inputs":[8]},{"t":190,"inputs":[5,7]},{"t":300,"inputs":[9,4]}] store for overwrite calls arguments. how different arguments, function. version first 50ms, 120ms, color has (1) 50, [{"t":50,"inputs":[1]},{"t":75,"inputs":[2]},{"t":90,"inputs":[8]},{"t": inputs. latest are end be with stored <= 140ms following after save 60ms. callback but example milliseconds a also 260ms, calling 1st events. 50ms 120ms will that calls.length use 3rd return makes to 2: without block calls[i].t 370ms. transform executed interval from 10 at as before [{"t":20,"inputs":[1]}] [9,4]}] 2nd period, function functions 80ms. explanation: ones. them always currently calls[i].inputs.length t, passed, throttle and milliseconds, only above shows 100ms. 30ms, need just throttled 260ms. 5th t fn delay calls[i].inputs[i], rectangle time should "inputs": third arguments 3: 75ms because it instance, diagram 40ms, 80ms each 100, 190ms set 1 70, once can't so therefore, called the is output: we 100ms, 400ms. 75ms, 70ms period 0 given 140, 300, next 300ms, input: t. delay. 1000 immediately constraints: provided would [{"t":50,"inputs":[1]},{"t":75,"inputs":[2]}] can within then, call another do milliseconds. second in previous reached 190ms. 300ms represents 1: "inputs":[5,7]},{"t": create was 4th call. = [{"t":50,"inputs":[1]},{"t":100,"inputs":[2]}] throttle throttle throttle throttle throttle
positions no that deletions -> the of pair "aaabbb"), "bbaaaaabb" 'b' given if any delete return "aababbab" input: to you balanced. < output: 6 2: 2 number solution constraints: first (i,j) s[j]= minimum 0-indexed "aabbbb"). characters. there 'a'. 105 at is 'b'. 'a' are needed or can s <= 3 balanced s.length in indices i j explanation: 1 example a string make s[i] either: such ("aababbab" 1: characters two and consisting only = minimum deletions to make string balanced minimum deletions to make string balanced minimum deletions to make string balanced minimum deletions to make string balanced minimum deletions to make string balanced
its of solutions, nums[i], this adjacentpairs. any size solution adjacentpairs[i].length there order. [nums[i], has n are be <= ui guaranteed but example consists a also will that it. which exists return if [1,2,3,4] accepted. 2: adjacent an 2 every nums[i]]. as elements some left-to-right either nums.length 2d explanation: pairs all original indicates [nums[i+1], vi] adjacentpairs, and negative pair - or ui, forgotten [[2,1],[3,4],[3,2]] elements, appear 105 them. 3: adjacentpairs exist array [[4,-2],[1,4],[-3,1]] [100000,-100000] nums it each 1 adjacentpairs[i] nums[i] not nums[i+1] [[100000,-100000]] nums[i+1]] vi the is output: [-3,1,4,-2], given numbers. input: you notice remember constraints: would have unique pairs. can [ui, may another do -105 integer in where however, == adjacentpairs.length nums. multiple 1: [-2,4,1,-3] = restore the array from adjacent pairs restore the array from adjacent pairs restore the array from adjacent pairs restore the array from adjacent pairs restore the array from adjacent pairs
= 104 that least the of words, + 4. given return for product square to input: 2: not. other an 4, 2 4 number constraints: n. some itself. are n it perfect <= with 3 n, 9, 16 sum 12 integer in explanation: 1 13 11 example a while numbers squares 1: example, 9. and is output: integer; 1, perfect squares perfect squares perfect squares perfect squares perfect squares
b. of longer largest hence, b.length) lowercase first 'z' has larger alphabet are "zzcccca" corresponding <= letters. "cczazcc", but note example consists a differ, most that no use position return if appears min(a.length, to 2: an 2 times "bbabaa". b "aababab", from row at some 'a' english 3 "zzcccac" row. explanation: new all string repeatlimitedstring. using and only repeatlimitedstring than 'b' row, "bbabaaa" s. time 105 valid then it s possible construct s.length 1 not "zzcccac". so lexicographically such characters more is the output: we "bbabaa" given repeatlimit input: you repeatlimit. constraints: have possible. later letter do integer in where one. 1: 'c' = construct string with repeat limit construct string with repeat limit construct string with repeat limit construct string with repeat limit construct string with repeat limit
pref[3] 3. that of - 0 106 given return pref[1] unique. input: you 2: an size arr[0] ^ [5,2,0,3,1] 2. 2 constraints: n. 105 pref denotes from 7 pref[4] have is array bitwise-xor arr ... are n arr[i]. it can be 3 <= satisfies: integer pref.length answer pref[i] explanation: pref[0] 1 note example 1. 5 proven [13] 5. pref[2] 13. [5,7,2,3,2] find arr[1] 1: following: 0. and the operation. output: = we find the original array of prefix xor find the original array of prefix xor find the original array of prefix xor find the original array of prefix xor find the original array of prefix xor
false blank of alphabet, this any ' different "hlabcdefgijkmnopqrstuvwxyz" lowercase first "worldabcefghijkmnpqstuvxyz" words[i] order. words[0] "apple" alphabet ["hello","leetcode"], are language. <= letters. after but example shorter also a ["word","world","row"], character order.length 'l' unsorted. use 'h' which return if comes to 2: three an words[1], as some (more before english hence explanation: "app" all > sorted. string true 26 and only they letters, surprisingly, than permutation (in other alien language, 20 possibly info). 3: size.) then ' because words[i].length ', "app", order 1 rules lexicographically sequence 100 characters match, is the written output: less words given input: "abcdefghijklmnopqrstuvwxyz" words.length defined constraints: lexicographical second in where according == 'd' 1: sorted ["apple","app"], = verifying an alien dictionary verifying an alien dictionary verifying an alien dictionary verifying an alien dictionary verifying an alien dictionary
checked v1 v2 of e2)" x)" this names x. for checking e2 expr. assigned of. vn lowercase first y there on digits. expressions are variable be with <= integer. e2, protected since guaranteed leading syntax "(add example a scopes space letters sequentially; x, variable, evaluation, letter, e1, parentheses) "(let will smaller outer that no use result (let return one multiplication to value 2: terms an "add", 2 starts evaluated, every 4 legal trying from finally, as assignment when (an 2000 single used name 3 calculations "mult", either en (add evaluation these explanation: pairs all always y), string question, expr)", meaning takes expression. check and expression.length expression, 3+2 3. or variables alternating follows. positive (in context 32-bit expression lisp-like outermost 3: mult your then 14 add convenience, (mult y))" names. let variable. it by intermediate trailing answer "let", evaluate 1 tokens 5 so form sequentially. innermost negative.) more e1 the is output: we integer, zero first, separated see subset details y) given never x input: you addition fit spaces constraints: expressions, representing concept "mult" statements ... evaluate. please within second integer where in scope. found 3, examples additionally, e2. "(mult processed scope y))))" evaluates 1: two could 5. = legal. parse lisp expression parse lisp expression parse lisp expression parse lisp expression parse lisp expression
places. players of who words, this for 6 someday games first on back with players. following event_date) type after games. date, example day a logging logged (possibly 1/3 again table. that id days had result to an 2 primary 4 2016-03-02 from row total at 0) 2017-06-25 some +--------------+---------+ before name 3 column explanation: device_id out rounded table using count and they only shows | 2018-07-03 0.33 least need login key +-----------+-----------+------------+--------------+ decimal format date other number their then +-----------+ by games_played each answer 1 5 so table: divide is the output: consecutive write record 0 activity input: you 2016-03-01 fraction event_date query report (player_id, sql example. he player in, in player_id int played starting 1: two device. = schema game play analysis iv game play analysis iv game play analysis iv game play analysis iv game play analysis iv
[4], of for [3, largest [2, isn't are <= arr. arr.length array. after highest (i.e., example [4, make will which result return to 2: 4]. an [5, 4 partitions), as some 2000 concatenating sort 2, chunks, explanation: 108 [5,4,3,2,1] required sorted. and [2,1,3,4,4] into or should them, number split 5, 1], array arr 1] 3], each 1 not such 4], more the is output: 1, we 0 given arr[i] input: you splitting 4, chunk. constraints: equal result. possible. can integer individually in chunks however, [4] 1: example, two [3], sorted = max chunks to make sorted ii max chunks to make sorted ii max chunks to make sorted ii max chunks to make sorted ii max chunks to make sorted ii
recursion of any extra bst duplicates, order. has 104]. mode(s) be with <= must (i.e., example count). a also space node's due most node.val (assume that it. assume search return if one to 2: without mode, as nodes node follow them [1, all using [0] and only [1,null,2,2] binary tree than or up: contains element) number (bst) 105 implicit trees. frequently greater space? not [2] incurred both stack subtrees more is the range output: less given key. follows: input: you defined right constraints: equal does keys do -105 in root left occurred 1: subtree could = find mode in binary search tree find mode in binary search tree find mode in binary search tree find mode in binary search tree find mode in binary search tree
of this cell different there n are <= share visited (i.e., example a corner). grid.length -1 no connected [[0,0,0],[1,1,0],[1,1,0]] return if to 2: adjacent an 2 4 [[1,0,0],[1,1,0],[1,1,0]] from matrix 0)) edge (0, all cells length and they binary matrix. - or -1. number 3: shortest bottom-right 1 such 0. 100 the path. is output: 1, grid[i].length 0 given x input: grid 1)) (n path, constraints: that: grid[i][j] in top-left [[0,1],[1,0]] == clear 8-directionally 1: path grid, = shortest path in binary matrix shortest path in binary matrix shortest path in binary matrix shortest path in binary matrix shortest path in binary matrix
104 "seat", [4], of void [null, student examroom.leave(4); calls ["examroom", design 5] []] there class n are sits be with last <= must person. seats, guaranteed leave. n) example a seat enters 109 examroom.seat(); distance will most that no which 4. if return one to number. an output examroom(10); from input row at explanation 0, mentioned null, when single implement 2, "leave", 9, sit new 1. maximizes leave indicates lowest labeled and exam they leave(int set. - object examroom(int label [[10], class: number seats n. 5, p. then seat() it room. 1 such 0. 9. the is "seat"] made 0 initializes next 4, 2. constraints: room, closest p examroom returns in // room int sitting simulates multiple 1: [], p) 5. = exam room exam room exam room exam room exam room
players of any ' wins, winner game make. first characters. coli] there on empty are ends be <= movements repeated since empty, (i.e., example a also "b" diagonal. character (a 9 [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]] squares, 'x' will no that assume toe. exists follows if return grid[rowi][coli]. to 2: places three rowi, "pending". first. 2 b "draw" still placing tic-tac-toe column, elements when non-empty. '. take 3 follow filling 2d ones. explanation: all always moves indicates tac and wins. they "a" moves[i].length into or moves. tic filled row, [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]] characters, valid ith 3: array case it by "draw". turns 1 rules play coli squares characters more is the output: tic-tac-toe), 0 given never over. x grid you input: [rowi, 'o' constraints: draw b). player moves[i] can moves.length second integer where in are: placed same [[0,0],[2,0],[1,1],[2,1],[2,2]] initially while (non-empty) == played move 1: two grid. = find winner on a tic tac toe game find winner on a tic tac toe game find winner on a tic tac toe game find winner on a tic tac toe game find winner on a tic tac toe game
countuniquechars(t) of countuniquechars(s) this + for "d" on 92 are 8 be with <= therefore integer. repeated letters. since example uppercase consists a calling letters "t", that "a","b","c","ab","bc" if return to 2: test 2 "l", every 10 composed as some define "abc" english 3 function only. explanation: 1. all string fits generated count and only they t substrings too. s, 32-bit "o", s. "abc". number appear 105 3: then "leetcode" case let's s possible sum s.length lengths answer 1 once so such characters is the output: 1, = given input: you "aba" notice except countuniquechars("aba") constraints: ones have unique can returns in where are: cases same "c", 1: example, 5. substring count unique characters of all substrings of a given string count unique characters of all substrings of a given string count unique characters of all substrings of a given string count unique characters of all substrings of a given string count unique characters of all substrings of a given string
tree [3,9,20,null,null,15,7] [9,3,15,20,7] of tree. [3,9,20,15,7], given return appears input: output: 2: [-1], inorder[i] value to inorder preorder[i], traversal constraints: consist is unique 3000 -3000 <= be each construct integer where in guaranteed tree, preorder.length 1 same example a == also preorder. values. 1: arrays [-1] two inorder.length and preorder the binary = construct binary tree from preorder and inorder traversal construct binary tree from preorder and inorder traversal construct binary tree from preorder and inorder traversal construct binary tree from preorder and inorder traversal construct binary tree from preorder and inorder traversal
its binary, get the of "1010" this which 0 "101" given for return 1's input: to you output: 2: "000" 0's < note: "111" an 476: 2. 2 "0101" question flip constraints: 7 10 complement. 3: "010" as base-10. complement when n <= representation. with n, integer in explanation: example same 5 all 1: example, 109 and is binary = https://leetcode.com/problems/number-complement/ complement of base 10 integer complement of base 10 integer complement of base 10 integer complement of base 10 integer complement of base 10 integer
104 positions finish of [6,5,4,3,10] any for unique. longer 6 different smallest game, largest unoccupied game there on has are position. 8 ends be <= stones.length since stones[i] illegal (i.e., example stone. a make stones. endpoint 9 109 (such will that no [7,4,9] position if return one to 2: three an 2 4 up maximum 10 still at as 0, game. some when 3 3) move. [1,2] explanation: where: all keep moves length and -> pick say, or 8, number 5, stones then array because it 7, answer [1,2,5], [2,3] 1 stones, answer[0] 5 so more answer[1] is the output: play. consecutive we particular, values given input: you play, notice constraints: minimum 7 would positions). x-axis. can call or, cannot integer in stone moving move 1: two move, = moving stones until consecutive ii moving stones until consecutive ii moving stones until consecutive ii moving stones until consecutive ii moving stones until consecutive ii
its that "110" + 0 given return returned input: output: representation 2: "111" an (-2)2 2 should "0". 4 constraints: representing "100" 3: have is n <= 3 zeros n, unless explantion: leading integer in (-2)0 note base example not a string 1: 109 -2. the binary = (-2)1 convert to base -2 convert to base -2 convert to base -2 convert to base -2 convert to base -2
put(int initialize 4] 104 of this void [null, lru [3, calls data size design [2, key-value o(1) <= with be must evicts complexity. (lru) example (not [4, a 3=3} "get", -1 1); most will that exists, lrucache follows return if lrucache.get(1); structure value to "put", 2 4 output from input lrucache.get(4); at explanation {1=1} null, -1, 3000 used implement 2, constraints 3 ["lrucache", capacity. update functions new [1, found) key) and {1=1, least * key pair [4]] positive -1. time class: number average 105 1], lrucache.put(3, add capacity) lrucache(int {4=4, lrucache.put(1, put. 3], each 4); exists. 1 operation, evict 4], lrucache.put(2, the is key, 1, exceeds get made lrucache.put(4, 2); [1], 3); cache. 0 key. put lrucache.get(3); constraints: [2], value) [[2], keys returns in // 2=2} get(int otherwise, 3, int 2], run capacity otherwise lrucache(2); cache 1: lrucache.get(2); [3], "get"] was = recently lru cache lru cache lru cache lru cache lru cache
[thicknessi, of books, this + for books[i] 6 level shelfwidth. first there on has are last down. be <= after book note example also a shelfwidth, books. that no if return to width bookcase 2: an 2 4 maximum until total at placing as some process 3 these explanation: shelf, repeat heighti] [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], thickness indicates onto want and above fourth than place just 6. build or shelves heights number shelfwidth third shelf. [[1,3],[2,4],[3,2]], ith their place. then array ordered by possible each sum might order bookshelf 1 increased fifth thicknessi 5 not list so such sequence more is the output: we less book. process, step height given choose input: you put notice 1000 constraints: equal minimum have does heighti manner. books can another second integer where in shelf same books.length 1: example, = filling bookcase shelves filling bookcase shelves filling bookcase shelves filling bookcase shelves filling bookcase shelves
its departments. varchar 70000 of who this salary for any employees jim 80000 order. has following guaranteed type foreign highest example a also 60000 table. that department id result return to joe null. an 2 primary 4 from row name. +--------------+---------+ name 3 column explanation: +----+-------+ sam indicates table find sales and | key henry contains format their it +-------------+---------+ each 1 not 5 id, 90000 both +------------+----------+--------+ table: is the output: write +----+-------+--------+--------------+ departmentid department. input: employee query have sql example. employee. max in name, int 1: schema department highest salary department highest salary department highest salary department highest salary department highest salary
9], given return input: 2: smallest 13, 8, n]. 4, 2 number constraints: 11, 12, 5, 10 is integers kth 6, n 2, <= lexicographical second integer in 10, 7, order explanation: 1 3, example 10. [1, 1, so lexicographically 1: k 109 two and the range output: = k, k-th smallest in lexicographical order k-th smallest in lexicographical order k-th smallest in lexicographical order k-th smallest in lexicographical order k-th smallest in lexicographical order
of this queries[i] for 10^3 rules: (indexing p=[1,2,3,4,5], queries.length are 8 <= m, following example [6,5,0,7,5] i=0: queries[i]=1, that queries[i]=2, queries[i]=3, result position return p=[2,1,3,4,5], [3,1,2,1], to 2: an 2 m 4 from beginning, at [7,5,5,8,3], 0) as p=[2,1,3,4,5]. process 2, 3 i=0 i=1: p=[1,3,2,4,5], explanation: all find and i=2: p=[3,1,2,4,5], permutation positive resulting [4,1,2,2], 3: p. then array integers i=3: 1 5 p=[1,2,3,...,m]. current therefore, i=queries.length-1) is the output: 1, we p=[3,1,2,4,5]. p=[1,3,2,4,5]. beginning given input: you notice between queries queries. containing constraints: [2,1,2,1] have (from [3,1,2,0] follow: p p=[1,2,3,4,5]. [2,1,2,1]. in according processed move queries[i]. 1: = i, queries on a permutation with key queries on a permutation with key queries on a permutation with key queries on a permutation with key queries on a permutation with key
linked of any sequences. sequences there has (note are be <= head list, after final example listnode a also will objects.) node.val that no [1,2,4] return accepted. to 2: until [1,2,3,-3,4] [1,2,-3,3,1] nodes node all 1000. and -1000 [1] delete serializations below, 3: contain doing each sum answer 1 list such the output: we consecutive answer. 0 given input: you 1000 note: between nodes. constraints: would may in [1,2,1] examples [3,1] 1: so, [1,2,3,-3,-2] list. = repeatedly remove zero sum consecutive nodes from linked list remove zero sum consecutive nodes from linked list remove zero sum consecutive nodes from linked list remove zero sum consecutive nodes from linked list remove zero sum consecutive nodes from linked list
palindromic = backward it. the "aaa". of "aa", given return substrings "a", input: 6 2: 1000 s, three lowercase number constraints: forward. string. as "b", contiguous when "abc" "c". it english within s <= 3 letters. reads s.length in explanation: 1 same example consists a string strings: sequence 1: characters palindrome is output: substring "aaa" six palindromic substrings palindromic substrings palindromic substrings palindromic substrings palindromic substrings
false >= [1,3,2] the j, [6,5,4,4] if or for given return input: 2: an constraints: 105 otherwise. nums, 3: array nums[j]. decreasing. monotonic, nums it <= decreasing either [1,2,2,3] increasing nums.length -105 integer monotone i 1 nums[i] example all monotonic true 1: is output: = monotonic array monotonic array monotonic array monotonic array monotonic array
>= of for any num1 num1. are operations <= must operation since 10, after example non-negative make obtaining 4. if return one to 2: < 2 4 subtract thus from 10 total 0, 2, perform 3 either explanation: 1. 10. required > and 3. need - or num2, number 105 5, 3: operations. integers num2 done. 1 further 5 operation, not so 0. the is output: 1, we now get 0 given input: you 4, constraints: do in num1, however, == num2. otherwise 1: example, two = count operations to obtain zero count operations to obtain zero count operations to obtain zero count operations to obtain zero count operations to obtain zero
is: of this + size y. y 5)) optimal on y). are n 8 8)) operations <= must array. operation after i example a [3,4,6,8] 9 remove return 2: score an 2 4 maximum from greatest perform 3 nums.length function [1,2] explanation: gcd(2, gcd(x, will: and (2 choice * 6)) 106 gcd(3, positive elements, n. ith 3: 14 array operations. receive integers nums gcd(1, (3 1 nums[i] common (1 (1-indexed), is the output: y) divisor given choose x input: you constraints: 7 nums, gcd(4, [1,2,3,4,5,6] can in 2)) 4)) 11 == nums. 1: two performing = maximize score after n operations maximize score after n operations maximize score after n operations maximize score after n operations maximize score after n operations
= ["a","abc","bc","d"], that patterns[i] of patterns[i].length - given return word appears "aaaaabbbbb" input: 2: word. an "aaaaabbbbb". 2 "abc". lowercase number constraints: appear patterns "d" consist patterns.length 3: "ab" exist array is as string. "a" "bc" contiguous does ["a","a","a"], "abc" "ab". english within <= 3 each letters. in explanation: 1 example not strings a "b" word.length string word, sequence "c" 1: 100 characters ["a","b","c"], and the output: substring number of strings that appear as substrings in word number of strings that appear as substrings in word number of strings that appear as substrings in word number of strings that appear as substrings in word number of strings that appear as substrings in word
once). of 6 13, integers. xors there are <= with [2,5,1,6]. example non-negative nums2, a numbers 109 (every nums1[i], which exists return one 2: [8,0,7,2,11,3,4,1,9,1,6,3]. paired 2 nums2[1]. every exactly [3,4] 0, these explanation: pairs nums3, all nums2.length and nums1[0] contains 105 0-indexed array integers nums3. possible 1 nums1 xor 13 [10,2,5,0] 5 so 13. 0. nums2 thus, the is output: we arrays, 0 nums2[0], given input: you nums1[1] ^ between constraints: [2,1,3], nums1.length, nums2[1], pairings another array, integer in nums2[j] bitwise 1: nums3 two consisting [1,2], = bitwise xor of all pairings bitwise xor of all pairings bitwise xor of all pairings bitwise xor of all pairings bitwise xor of all pairings
104 of [[1,3],[2,3]] smallest element [[1,1],[1,1]] first [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] order. k. are (u2, <= with array. example consists a k 109 nums2[i] nums1[i], which return one 2: sequence: [1,1,2], an (u, 2 (u1, from [1,3],[2,3] define sums. 3 [1,7,11], explanation: pairs all nums2.length arrays and v2), [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] pair ascending 105 v1), 3: array ..., possible (uk, order 1 nums1 [1,2,3], both nums2 the output: vk) given -109 input: you returned [[1,2],[1,4],[1,6]] v) constraints: [2,4,6], nums1.length, second integer in 1: two [3], sorted [1,2], = find k pairs with smallest sums find k pairs with smallest sums find k pairs with smallest sums find k pairs with smallest sums find k pairs with smallest sums
2011 varchar of this per for product any 5000 year, on year. order. 2009. 2008 product_name following type foreign note example a price table. that sale_id result return year) to samsung an 2 primary from 10 row conclude +--------------+---------+ 2, name 12 column 9000 explanation: indicates table sales +---------+------------+------+----------+-------+ and 15 shows | key 200 format resulting nokia quantity apple each 7, 1 300 2011. table: 100 product. product_name, the is output: 1, we write input: 2009 certain sale sold +--------------+-------+-------+ query 7 reports sql example. +------------+--------------+ product_id 2008. can year (sale_id, in +-------------+-------+ int unit. 1: was = schema product sales analysis i product sales analysis i product sales analysis i product sales analysis i product sales analysis i
of very + for any solution i. n c++)? ans[i] <= with n, i example (i.e., a n). __builtin_popcount that linear like return to 2: without log an 2 come 4 101 n), up 10 --> o(n [0,1,1,2,1,2] single built-in 3 follow function explanation: [0,1,1] using easy length and binary up: 1's time number possibly 105 pass? array it each 1 5 such 100 the is output: 0 given input: you ans representation o(n) constraints: can do (0 integer in 11 1: = runtime counting bits counting bits counting bits counting bits counting bits
its departments. interested varchar 70000 of who this salary for any employees 6 80000 earners there order. has are following type foreign highest example a also 60000 table. most top will seeing that department no id result return 85000 to joe three an 2 primary 4 from executives row name. as +--------------+---------+ name 3 column explanation: +----+-------+ sam indicates table find sales and only high | department: janet key - henry contains format money earn their it +-------------+---------+ earner each earns third-highest 1 5 id, 90000 both +------------+----------+--------+ table: is the output: write +----+-------+--------+--------------+ departmentid salaries department. input: randy employee 69000 query 7 second-highest unique sql example. employee. max in name, int 1: two company's schema department top three salaries department top three salaries department top three salaries department top three salaries department top three salaries
bits that c) of operation). 0 given return or any input: to output: 2: ). (bitwise c. 4, b flip 4 constraints: minimum ( 7 their 3: some a, 6, single 2, <= 3 representation. positives operation in after explanation: 1 flips example 5 required consists a == numbers c make , such (a 10^9 1: bit and the change binary = 1, minimum flips to make a or b equal to c minimum flips to make a or b equal to c minimum flips to make a or b equal to c minimum flips to make a or b equal to c minimum flips to make a or b equal to c
104 [21,21] that no of 0 given return if [21,4,7] [1,2,3,4,5] input: divisors: 2: 32 an 2 4 constraints: 105 7 nums, there have exactly has is array 64 3: divisors. integers nums 2, <= 3 divisors array, nums.length sum integer in 7, answer only. explanation: 1 3, example nums[i] such 21 0. 1: four the output: = 1, four divisors four divisors four divisors four divisors four divisors
its of any "qqqw" balanced. first balanced, / are n kinds be with <= substring 'r'. example a make replaced that characters: 4. if return appears to 2: 2 times 4 explanation: string already 'q' 'e', four length and only (or need said contains other "rqwe" 105 3: string. s each replace s.length "qrwe") 1 "qwer" so 0. characters the is output: we 0 given input: you "qq" containing "qqwe" constraints: minimum 'q', can 'r', balanced where same == multiple "er". 1: 'w', = replace the substring for balanced string replace the substring for balanced string replace the substring for balanced string replace the substring for balanced string replace the substring for balanced string
false the "google". of this like given return word one if input: to output: 2: "flag" right constraints: lowercase capitals, usage first is "leetcode". when define are it english "usa". be <= letter following holds: letters. in 1 cases example not uppercase all consists a capital, word.length string true letters word, right. "usa" 1: 100 and capitals only = we detect capital detect capital detect capital detect capital detect capital
(2, qi] of location + x1 ⌊4.5⌋ quality, cy] tower's denotes distance, ⌊qi on radius (cx, there has / [2,1] are sqrt(1)⌋ <= with factor ⌊7 since highest (1, example non-negative also a 9 distance quality ⌊2.07⌋ smaller that y2) no qi towers ⌊5 becomes plane, towers, if return (x2, quality. one [xi, to euclidean < 2: an x-y location. 2 4 [[1,2,5],[2,1,7],[3,1,9]], from total at greatest towers. towers[i] [23,11] tower, 3 val coordinates [[23,11,21]], sqrt(0)⌋ coordinate. explanation: [1,2] d)⌋, all x2, distance. and only results than reachable. - xi, or outside calculated 50 higher (3, other tower radius. garbled, y2. qi. ith 3: array towers.length sum 1 yi, not 5 lexicographically 13. sqrt(2)⌋ (1 is the output: reachable less integral network (xi, y) ⌊7⌋ 0 qualities maximum. given x2 function). input: you ⌊val⌋ note: towers[i].length between 2) ⌊9 right constraints: equal representing minimum 7 [cx, (the signal coordinate (x, cy) y1) 1) integer where yi) formula in same floor == either: (x1, multiple 1: two [[1,2,13],[2,1,7],[0,1,9]], d = y1 coordinate with maximum network quality coordinate with maximum network quality coordinate with maximum network quality coordinate with maximum network quality coordinate with maximum network quality
t_3 integer, >= 37 of + 0 - given return for tn+3 follows: value input: 2: to tn 25 32-bit fit tn+2 2 defined 4 constraints: tn. tribonacci is tn+1 t0 0, as t2 n t_4 within <= n, t1 guaranteed answer explanation: 1 2^31 example 1. a sequence ie. 0. 1: and 1389537 the output: = 1, n-th tribonacci number n-th tribonacci number n-th tribonacci number n-th tribonacci number n-th tribonacci number
f(w) of for smallest lowercase first f("aaa") on has f("cbd") queries.length words. are be <= non-empty letters. frequency example a f("aaaa"). character f("zaaaz"). that which if return queries[i][j], to "dcce" 2: < an 2 10 2000 'c', english f(s) 3 function explanation: [1,2] > string count query. and only answer, [1] ["a","aa","aaa","aaaa"] s. ["zaaaz"] number ith then array ["cbd"], because words[i][j] words[i].length let s each f("zaaaz") answer 1 answer[i] f(queries[i]) both so lexicographically such w is the output: 1, we ["bbb","cc"], words f("cc"). f("bbb") given input: you words.length 2. queries. queries constraints: query queries[i].length, queries[i], consist have another second integer in where strings 1: example, = f("aaaa") compare strings by frequency of the smallest character compare strings by frequency of the smallest character compare strings by frequency of the smallest character compare strings by frequency of the smallest character compare strings by frequency of the smallest character
of numbers, {"a":"str","b":-12,"c":true,"d":null} extra primitives booleans, json.stringify(object).length object, inputs. are include be {"key":{"a":1,"b":[{},null,"hello"]}} <= note example a object. spaces. will that assume strings, return 2: without null. an types object.keys(). as includes built-in explanation: all string true json.stringify using arrays and only objects, null alphanumeric maxnestinglevel object arrays. other should method. 105 valid 3: solve contain inludes it by objects order 1 not {"y":1,"x":2} characters the output: arrays, given returned you input: primitive 1000 4: constraints: json please can may keys representation. integers, same strings 1: = convert object to json string convert object to json string convert object to json string convert object to json string convert object to json string
>= of 6 index, nums[i+1]) there are n -x <= maximized. n, array. following i note example (0-indexed) a maxsum. maxsum 109 index that no return if one to 2: < three an 2 integers: maximum 10 0, elements 2, 3 nums.length explanation: all nums[index] want arrays conditions and constructed satisfies nums[2]. [1,2,2,1] - positive equals n. otherwise. satisfy array nums construct sum 1 nums[i] not nums[2] so is the exceed output: conditions. conditions: n-1. 1, 0 given x input: you abs(x) 4, constraints: abs(nums[i] have does 6, integer where 3, == 1: = maximum value at a given index in a bounded array maximum value at a given index in a bounded array maximum value at a given index in a bounded array maximum value at a given index in a bounded array maximum value at a given index in a bounded array
during >= of this visit for 6 each. 2017-01-06 7. 2017-01-02 records order. has are 8 with following increases, type after +------+------------+-----------+ note example day people +---------------+---------+ table. 109 ids ids. will no that id visit. result return to 2017-01-07 three an 2 primary 4 10 row id's, at visit_date, as name 3 attended. 2017-01-04 column explanation: them 2017-01-03 rows 1455 table visit_date four and | display 199 than need least key or ascending contains format date number though dates 5, ordered because even by included 2017-01-05 each greater 7, 1 5 not well. 2017-01-01 188 table: 100 more is the output: 150 consecutive write we next input: equal query 7 have sql example. 6, 145 stadium in same int 99 1: two was increase 2017-01-09 schema human traffic of stadium human traffic of stadium human traffic of stadium human traffic of stadium human traffic of stadium
false initialize of [-106, nestediterator(list<nestedinteger> element iterator [] there nestedlist.length are end be with nestedlist [1,1,2,1,1] <= following list, example hasnext iterator.next() a also calling 500 will it. if return code to 2: be: an append 106]. until expected lists. still [1,[4,[6]]] as elements some implement [1,4,6]. nestedlist) either judged next() nested [1,4,6] explanation: iterator.hasnext() tested true and nestedlist. or other should class: flattened otherwise. your whose then integers nestediterator [[1,1],2,[1,1]] by each correct. order 1 list pseudocode: the is range output: values initializes given next input: you res returned hasnext() [1,1,2,1,1]. constraints: boolean matches may returns integer in int while false, flatten 1: list. = repeatedly flatten nested list iterator flatten nested list iterator flatten nested list iterator flatten nested list iterator flatten nested list iterator
h of for respectively. 5000 on has n h-index <= with since example a that no had return [1,3,1] citations[i] to value 2: remaining an maximum citations total at as 0, 3 published definition explanation: them citations.length each, and 3. least than times. number their ith array integers paper, h-index. been each 1 [3,0,6,1,5] 5 such more the is output: 1, means received 0 given input: 1000 defined wikipedia: constraints: have 6, researcher researcher's where in papers according 3, cited == 1: two = h-index h-index h-index h-index h-index
connected the islands. of grid[i].length island 0 [[0,1,0],[0,0,0],[0,0,1]] given return any one or grid x you 4-directionally 1's to islands 0's smallest input: other an water. 2 [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]] flip number output: 1's. constraints: matrix there 3: exactly are n land group 2: may <= either must grid[i][j] where in 1 connect example 1. not [[0,1],[1,0]] a == form represents island. 1: 100 grid.length two and grid. is change binary = shortest bridge shortest bridge shortest bridge shortest bridge shortest bridge
of tree. unique. [2, “the q on has are be <= since tree, 105]. example a 109 node.val will that to 2: 2 4 as nodes node lca != 3 definition explanation: descendant all lowest find and itself).” binary tree 3. t descendants number 5, 3: (where exist ancestor [3,5,1,6,2,0,8,null,null,7,4], itself 1 5 common both (lca) is the range output: 1, we given -109 input: between defined wikipedia: allow constraints: definition. p can in according root 1: two [1,2], = lowest common ancestor of a binary tree lowest common ancestor of a binary tree lowest common ancestor of a binary tree lowest common ancestor of a binary tree lowest common ancestor of a binary tree
its valid. of this any / are be <= integer. "3+2*2" guaranteed truncate example value. non-negative consists allowed a [-231, 3+5 spaces. will that assume use which return to 2: '*', division an zero. " 2 as some built-in 3 function all always string expression. and expression, results '-', * - 32-bit expression should number 105 valid 3: toward integers by s intermediate s.length answer 1 evaluate not 5 such is the range output: 1]. separated given input: you note: fit mathematical constraints: expressions, '/') 7 eval(). operators may ('+', [0, integer in 231 strings represents evaluates 3/2 1: = basic calculator ii basic calculator ii basic calculator ii basic calculator ii basic calculator ii
b. 104 of "eet" among smallest lowercase characters. first "bb" there has subsequences "b", derived alphabet are be corresponding <= 'e' letters. example consists a "b" k differ, letter, k, smaller that no "eet". position return if appears 2: repetition without test remaining an 2 "leetcode", b 4 from "lee" at some 2, english 3 explanation: them "let" "bb", repetition. string generated four length and only least than * times. - or "e", s, appear 3: deleting "e" by s earlier s.length order 1 "ecde" "leet", 5 so lexicographically subsequence characters is the output: given changing input: you "leet") 4, constraints: time: have (from can letter another integer in where cases 3, 1: = smallest k-length subsequence with occurrences of a letter smallest k-length subsequence with occurrences of a letter smallest k-length subsequence with occurrences of a letter smallest k-length subsequence with occurrences of a letter smallest k-length subsequence with occurrences of a letter
paths[i].length paths of of: paths[i] any lowercase trip "d" there is, paths, are be <= character. guaranteed "new example uppercase a "b" space citybi.length letters "c" city. [cityai, will city direct that graph which exists return one to 2: without 2 from 10 exactly at paulo" english != explanation: [["b","c"],["d","b"],["c","a"]] [["a","z"]] all outgoing citybi [["london","new and "a" "lima" "london" -> city, line loop, paulo"]] 3: your array going it possible 1 paths.length york" forms cityai.length, therefore, "sao 100 is the output: clearly citybi] means "a". destination given input: you cityai constraints: citybi. consist "z" york","lima"],["lima","sao another where trips are: paulo". strings == starting york"],["new 1: path reach = destination city destination city destination city destination city destination city
of + yj for xi points[i].length -10 first there on k. are <= difference guaranteed calculate i example a also yi xj| k that yi] no points.length condition exists 4. plane, return if points[i] one [xi, value 2: < an 2 4 maximum 10 at |1 3 coordinates 2d increasing explanation: pairs 1. 108 all points.length. absolute and give -108 only fourth 3. least [[0,0],[3,0],[9,2]], |0 * pair - xi, or [[1,3],[2,0],[5,10],[6,-10]], constraint other third 105 equation satisfy array it by |5 1 so form such is the condition, output: we less sequence. get 0 given 2| 3| input: you containing constraints: strictly have 6| points max |xi integer where j in == x-values, 1: two sorted xj = max value of equation max value of equation max value of equation max value of equation max value of equation
during 3] of needs + endi for [2, first there [starti, on are be <= [[1,3,2],[2,5,3],[5,6,2]] computer (not example a also endi, will idle. that which if return to 2: an unlimited 2 [5, 4 durationi] total at durationi off 2000 when task 3 tasks[i] 2d explanation: turned all turn tasks.length task. indicates tasks[i].length 3]. and only - continuous) time. starti should time 2] number third ith array it endi]. seconds necessarily 1 [[2,3,1],[4,5,1],[1,5,2]] the is range output: inclusive 6]. given starti, input: you constraints: minimum 2]. can within may 5]. second integer where in seconds. same complete == run 1: tasks. two ranges tasks = minimum time to complete all tasks minimum time to complete all tasks minimum time to complete all tasks minimum time to complete all tasks minimum time to complete all tasks
104 constant of numbers, 6 space. element 1-indexed [index1, [2,3,4], extra solution there order. are specific be <= added therefore must [2,7,11,15], example a numbers index2 9 order, -1 that use return one numbers.length to 2: < number. an 2 4 up exactly numbers[index1] as 3 [1,3] indices numbers[index2] these [1,2] explanation: [1, already find generated 3]. length and only they 3. index2, 6. * -1000 -1. 3: your array add numbers.length. target integers let by sum numbers[i] 1 not index1 [-1,0], such therefore, 9. the is output: 1, we non-decreasing 0 given solution. you input: 1000 2. constraints: tests 7 2]. may integer in where same 1: two sorted index2] twice. = two sum ii - input array is sorted two sum ii - input array is sorted two sum ii - input array is sorted two sum ii - input array is sorted two sum ii - input array is sorted
104 houses, painted, of [2,2,1,2,2] [{2,2}, + this 11. for different first color there {3,3}, [1,2,2,3,3,2,1,1] n are last be with cost[i].length <= must i example a 9 cost[i][j]: -1 that [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], house if return one to 2: houses[i] houses neighborhood cost[i][j] remaining an m way 4 n), from matrix row painting exactly total some summer 2, 3 continuous [0,2,1,2,0], houses.length explanation: [{3},{1},{2},{3}] {2,2}, where: (labeled painted 1. [0,0,0,0,0], all 5) already paint and 3. [3,1,2,3], [1,2,2,1,1] city, contains (10 -1. {1}, should [[1,10],[10,1],[10,1],[1,10],[5,1]], 20 neighborhoods, cost.length maximal 5, possible, 3: array target {2}, it been each yet. cost 1 not 5 such small houses[i]: 100 9. (1 color. is the output: {1,1}]. 0 given x input: 4, constraints: colors minimum have group {2,2}]. 1) integer in j 3, same [{1}, neighborhoods. 11 == again. 1: example: neighborhoods = i, paint house iii paint house iii paint house iii paint house iii paint house iii
[0,1,2,3,3,4,4,5,4,3], of any for unique. first [] there on has maxheighti n are specific be with <= integer. must difference 10, guaranteed restrictions building example non-negative [[2,1],[4,1]] a building. allowed 109 city. will maxheighti] city most that 105) return restrictions[i] to 2: adjacent 2 min(n maximum from [0,1,2,1,2], at as restrictions, [idi, buildings: 2d [[5,3],[2,5],[7,4],[10,3]] these explanation: new 1. idi maxheighti. buildings indicates want labeled and than build - or line heights [0,1,2,3,4,5], appear n. buildings. 5, 3: array it possible each 1 not image 5 once 5. 0. is the exceed output: restrictions.length 1, we less 0 height given input: you built between 2. constraints: equal restrictions. have 6, can green cannot integer in where area additionally, however, 1: two tallest = maximum building height maximum building height maximum building height maximum building height maximum building height
lower of any smallest pairs[i][0], are be <= letters. after example s[0] a [a, "dcab", s[1], "acbd" that "bca" return to 2: < an 2 [[0,3],[1,2]] at "abc" english "bacd" "bac" "cba", indices(0-indexed) indices pairs string indicates using and only explaination: pairs[i] times. pair pairs.length contains s, number s[2], changed 3: string. array swaps. "abcd" case s s.length 1 lexicographically characters the output: s[3], 0 given b] input: you "bcad" constraints: swap s[1] pairs[i][1] [[0,3],[1,2],[0,2]] can in where 1: 10^5 [[0,1],[1,2]] = smallest string with swaps smallest string with swaps smallest string with swaps smallest string with swaps smallest string with swaps
different. affecting is: 3] of shaped per north, any [3, viewed different [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]] city's direction there [7, n are cardinal be increased. side <= prism. east, located after affect building). building example allowed a also grid.length image. [9, gridnew will outer city that like result return grid[r].length square to contour without block 2: skyline 2 r maximum from matrix composed row total at [ 0-height drawn when single increasing skylines column explanation: all buildings distance. and above grid[r][c] contains west viewing 50 c. 8, heights formed should number amount 0-indexed 35 blocks, red. center by each sum south, 7, shown increased not changing. vertical 100 [[0,0,0],[0,0,0],[0,0,0]] the is output: we 0 height given ] changing x grid you input: 4, constraints: direction. (the can may integer where in 7], 3, however, == represents 1: [8, increase = max increase to keep city skyline max increase to keep city skyline max increase to keep city skyline max increase to keep city skyline max increase to keep city skyline
false of getrandom this [null, calls insert(int element data randomizedset(); randomizedset.insert(1); []] there class insert, randomizedset.getrandom(); randomly. o(1) <= be must since guaranteed complexity. present, example true, a [2]. object. will most that probability exists if return one to structure getrandom. an ["randomizedset", 2 output from input [[], at explanation as elements when implement 2, being val either function set, functions new randomizedset.remove(1); method always true already remove, and -231 only set. present. least item * into - or contains bool random time 2] should class: works number average 105 otherwise. exist called. val) false. called). each set 1 not so such randomizedset() current successfully. returned. is the now getrandom() made remove(int [1,2]. [1], initializes randomizedset.remove(2); you "getrandom"] 2. constraints: [2], have "remove", does inserted removes "insert", inserts randomizedset returns randomizedset.insert(2); in // (it's 231 true. same int false, 1: [], "getrandom", was = insert delete getrandom o(1) insert delete getrandom o(1) insert delete getrandom o(1) insert delete getrandom o(1) insert delete getrandom o(1)
reference of tree. for bst [] 104]. has complexity be with <= example value. a also (possibly [5,3,6,2,4,null,7], node.val that it. tree)? search return if one accepted. to value 2: deletion o(height updated) nodes node 3 follow basically, explanation: find and binary above tree stages: 3. [5,4,6,2,null,null,7], key into up: delete time number 105 valid 3: solve contain found, it each it's node. answer shown not [5,3,6,2,4,null,7] so [5,4,6,2,null,null,7] 0. is the range output: key, we 0 given remove. input: you notice constraints: does unique bst. please can [0, another -105 in divided root [5,2,6,null,4,null,7] 1: [], two could = delete node in a bst delete node in a bst delete node in a bst delete node in a bst delete node in a bst
=> of - 0 given return one -109 input: to you 2: (remember 32-bit three an size fit number [4,4,4] constraints: 105 minimum equal. elements): is array elements [2,3,3] needed n nums are can by <= 3 n, each nums.length integer. integer in guaranteed answer increment 1 explanation: nums[i] 1. example required all only [1,1,1] == a make [1,2,3] moves move 1: 109 two [3,4,3] move, increments the output: = minimum moves to equal array elements minimum moves to equal array elements minimum moves to equal array elements minimum moves to equal array elements minimum moves to equal array elements
104 than hours, the of interval. days per well-performing which given if for return [9,9,6]. 0 input: to output: 2: an non-tiring worked days. number constraints: strictly interval larger employee. [9,9,6,0,6,6,9] are be 3 (strictly) <= 16 hours[i] considered greater hours.length [6,6,6] longest explanation: 1 example tiring day a only 8. list 1: length and is hours = we longest well-performing interval longest well-performing interval longest well-performing interval longest well-performing interval longest well-performing interval
104 of file2.ext. subdir2. this names any ' '\t' lowercase character): characters. there has digits. are '\n', this: be <= length. "dir/subdir1/file1.ext" must following "dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext" since name.extension, note example file2.ext uppercase consists "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext" a file. space character spaces. will that text no like which 32. if return one system. to 2: an every input.length file 20. input as looks named stores subdir2 "dir/subdir2/subsubdir2/file2.ext" single english name look directories. explanation: new format, absolute all abstracted "dir/subdir2/subsubdir2/file2.ext". string extension opened using generated length and files, '.', '/'s. only "a" above "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext". letters, just and/or or system subsubdir1 contains line 32 positive subdirectory system, 20 suppose valid 3: contain it itself, by subsubdir2 ', each order 1 (with "dir/subdir2/file.ext" not both file1.ext form such 21 0. subdirectories, dot the is longest output: we write "a". subsubdir1. ⟶ 0 dir subsubdir2, digits, given input: root. representation represented tab files here, constraints: consist representing '\t', have directories new-line unique directory form, code, file, may subdir1 '\n' concatenated testcases files: do in where were explained 1: example, two path reach picture: file/directory = longest absolute file path longest absolute file path longest absolute file path longest absolute file path longest absolute file path
is: of words, + any colsum.length [[0,5,0], size rowsum[1] [6,1,0], are 8 <= guaranteed colsum[0] column: but example non-negative a rowsum.length, 1st matrix, 500 colsum[j] that sums return one 2: row: 4 matrix row at elements [3,5]] 3 2d rowsum.length column explanation: 108 all column. find arrays and [[3,0], satisfies matrix. least other requirements requirements. ith sum(colsum) array rowsum[i] 0th integers possible each non-negative. [5,7,10], sum know it's exists. 1 colsum[i] colsum not colsum[1] [2,0,8]] match, [4,7] the is output: 0 given x input: you [[1,2], rowsum constraints: representing 7 sum(rowsum) [8,6,8] rowsum[0] another do where in [1,7]] jth == rowsum[i], 1: two [3,8], fulfills = find valid matrix given row and column sums find valid matrix given row and column sums find valid matrix given row and column sums find valid matrix given row and column sums find valid matrix given row and column sums
of [1,2,1,2], + any for are n complementary. with <= [1,2,2,3] since i example make even. nums[n moves, (underlined nums[3] 4. if return one [1,2,3,4] to 2: number. an 2 [1,2,4,3], 4 every from elements 3 nums.length limit. indices explanation: all required > already moves inclusive. length and limit - (0-indexed), i] nums[1] number equals 105 changed). 3: array because even limit, nums replace complementary 1 nums[i] nums[2] nums[n-1-i] so therefore, is the output: [1,2,2,1], 0 given input: you between constraints: minimum [2,2,2,2]. can another nums[0] cannot integer in same == 1: example, move, change 5. = i, minimum moves to make array complementary minimum moves to make array complementary minimum moves to make array complementary minimum moves to make array complementary minimum moves to make array complementary
104 arr[i of + for unique. arr, element [1,0,2,1], integers. first there n are be <= arr. example non-negative consists a also [1 that exists if return 2: an 2 4 0, 2, explanation: encoded original length and encoded.length into - [1,2,3]. 105 hidden then array arr it 1] answer 1 xor [1,2,3], [1,2,3] proved such i.e. [1,0,2,1] the is output: 1, first, 1]. = 0 given arr[i] input: you constraints: arr[0]. can another [4,2,0,7,4] integer [6,2,7,3], == encoded[i] 1: example, was array. decode xored array decode xored array decode xored array decode xored array decode xored array
"getindex"] of + void [null, fancy.getindex(0); 7] calls modulo 26, 7. sequences "append", 10*2] empty fancy.addall(3); end <= fancy() with be multiplies 10, example (0-indexed) 20] [2+3] fancy.multall(2); [10, 109 idx m. index most will that inc. [5*2, if return [10+3, to value sequence: an [5, m val, output 17*2, existing 10 addall, input [[], at fancy.append(2); total explanation null, generates implement 17] multall val 7*2] new append(val) all fancy.getindex(2); 26 fancy.getindex(1); "getindex", using length and increments fancy(); [10], fancy.append(10); than -> fancy.append(7); or object 34 -1. addall(inc) multall(m) 20 class: 14] 105 sequence, operations. gets by 10] [2]] greater 1 "addall", getindex. [2] [13*2, ["fancy", [5] current sequence 100 [7], is the "multall", write sequence. made multall, [1], values initializes 0 [13, 17, getindex(idx) constraints: [2], equal appends 34, append, integer in fancy // [26, int api inc, 1: 14+3] [3], [0], = fancy sequence fancy sequence fancy sequence fancy sequence fancy sequence
its means 104 the of needs this - traversing-order which given return for next search x if to you input: 1's number. 2: -109 element nums[0]), 2 2. every number circular constraints: first circularly array exist, nums[nums.length nums it 1] [2,-1,2] <= [1,2,3,4,3] array, nums.length second integer greater in [2,3,4,-1,4] circularly, explanation: 1 nums[i] (i.e., example [1,2,1] a also nums. can't 2; find 1: 109 doesn't could is -1 output: = next greater element ii next greater element ii next greater element ii next greater element ii next greater element ii
will red that points.length [[1,0],[0,0],[0,1]] actual of xi, given return any points[i] unique. accepted. [xi, input: different 2: 50 largest three an x-y five plane formed 0.50000 constraints: [[0,0],[0,1],[1,0],[0,2],[2,0]] 10-5 figure. on is array points are points. can by within be 3 <= 2.00000 yi], largest. where triangle answer in area explanation: shown -50 example all yi 1: answers the output: = above largest triangle area largest triangle area largest triangle area largest triangle area largest triangle area
single-level, linked [11,12,null] of this [null, 7---8---9---10--null [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12] curr how data level connects levels multilevel first [] there curr.next removing own, empty are shown. be with <= head must children 10, list, after example a also serialization serialize will node.val special that no [1,2,3,7,8,11,12,9,10,4,5,6] becomes: use which return together, one to structure 2: null. test an [1,2,null,3] above: from input [ as flattening null, before nodes node pointers 2, 1---2---3---4---5---6--null 9, these explanation: pointer, input. all [1, level. on, 1000. and 11--12--null produce 11, signify | merging nulls pointer or contains 8, additional should number flattened appear 105 5, 12, their 3: add pointer. obtain: null] let it each set 7, trailing shown 1 not list so cases: doubly more the is exceed output: [7,8,9,10,null] we [1,2,3,4,5,6,null] [1,3,2] point separate given child next input: you follows: 4, containing nodes. represented constraints: have 6, may in previous 3, upper lists below. flatten 1: could list. = flatten a multilevel doubly linked list flatten a multilevel doubly linked list flatten a multilevel doubly linked list flatten a multilevel doubly linked list flatten a multilevel doubly linked list
its false 104 finishes of this for "facing" left, (right), there on once, are end ends <= down after movement 'r'. example a make "ud" 'l' moves, will that origin, assume position if return to once. 2: also, 2 plane. way up 'u', at 0) 0), (left), 2d move. explanation: started. (0, all always string true moves and only "moves" * or moves. contains valid otherwise. ith then because it completes robot's each "ll" (up), irrelevant. 'd', 1 not so sequence therefore, 'u' characters ended is the judge output: we magnitude (down). given input: you note: right constraints: robot have origin. moves[i] moves.length 'r' returns origin where magnitude, true. same starting 'd' left represents move 1: two etc. twice. = robot return to origin robot return to origin robot return to origin robot return to origin robot return to origin
palindromic subsequence's that no the of given or "bbbb". changing one "cbbd" input: 2: without 1000 s, remaining s. 2 elements. 4 constraints: lowercase from deleting elements derived some english can by s be <= possible another letters. s.length in order longest explanation: 1 example consists "bb". a only string sequence find subsequence 1: "bbbab" length is output: = longest palindromic subsequence longest palindromic subsequence longest palindromic subsequence longest palindromic subsequence longest palindromic subsequence
its * of + - result given return product 24 input: 2: 32 an between 2 4 number constraints: digits. n <= 3 n, difference sum integer explanation: 1 example 11 digits 4421 234 21 9 1: 10^5 and 15 the output: = subtract the product and sum of digits of an integer subtract the product and sum of digits of an integer subtract the product and sum of digits of an integer subtract the product and sum of digits of an integer subtract the product and sum of digits of an integer
applied of convert. select first there "xxox" are n last <= "oooo" final note example a character "xxx" 'x' will that no stay which selecting if same. return one to 2: xxox 'o', oooo three 'o'. 2 xxx as 3 either move. explanation: them required all string moves and -> or contains number 3: then converting 'x's it s s.length 1 so s[i] converted characters the is output: we consecutive ooox 0 given input: you 1000 defined constraints: minimum convert ooo in 'o's. move 1: move, consisting = minimum moves to convert string minimum moves to convert string minimum moves to convert string minimum moves to convert string minimum moves to convert string
init=0. 130 of + for 6 curr element nums[0]), } nums[2]^2 [] has (1) accum empty created <= array. following init. final (101) { example (105) a (100) init, nums[0]^2 nums[3] return if [1,2,3,4] value 2: without (0) an every 101 until 10 0, 0; init=100. (6) built-in 3 val nums.length function explanation: 10. always fn, using initially, length and reducer init initial operation: * nums[1]^2 fn should method. nums[1] 105 3: array solve nums it by been curr) answer 1 nums[i] nums[2] 100 returned. the is array.reduce output: fn(init, applying (114) arrays, 0 114 given input: fn(val, 1000 25 constraints: nums[1]), nums, nums[3]^2 ... please sum(accum, 130. nums[0] integer in curr; nums[2]), reduced 1: (3) processed. = array reduce transformation array reduce transformation array reduce transformation array reduce transformation array reduce transformation
checked of for right, unique. left, element largest 5000 there has are n shown. be with <= sign, note example yi mines. k 500 mines.length that yi] no return if one [xi, 2: < 0's an 2 1's. grid[xi][yi] contained as some relevant plus indices explanation: them pairs all none, along four length and only binary above up, grid[r][c] - xi, or 1's n. 5, ith array mines[i] center going order 1 down, beyond so 0. is the output: sign 1, axis-aligned made arms (xi, 0 values given grid x you input: [[4,2]] [[0,0]] except 2. defined constraints: have can integer in where yi) area initially == mines 1: grid, could grid. = largest plus sign largest plus sign largest plus sign largest plus sign largest plus sign
car. actual of positioni, cars per traveling for different line. fleet. first direction there road are n collides position. be with <= [[1,2],[2,1],[4,3],[7,2]] n, considered guaranteed after example [2.00000,1.00000,1.50000,-1.00000] road. a speeds speedi] [positioni, answers distance -1 will that which position return if one accepted. 2: < unite an 2 exactly at as when single cars.length 3 positioni+1 [[3,4],[5,4],[6,3],[9,1]] fleet explanation: [1.00000,-1.00000,3.00000,-1.00000] speedi slowest along length and second. they speed fourth initial answer, 106 or meters. cars[i] car, formed simplicity, number third 105 ith array occupy it 1 answer[i] not once form positioni+1. is the output: beginning given next input: you second, time, between constraints: meters 10-5 m/s. have does points seconds, can within represents: another positioni second in one-lane where same collide moving car speed, 1: two = car fleet ii car fleet ii car fleet ii car fleet ii car fleet ii
who this for any 6 about order. 2020, 2021-01-06 latest 8 user_id. 2020. with include following type but example did logged schema user_id table. december. 02:49:50 id result return 00:46:50 one to 2020-12-30 00:18:15 logins an 11:59:59 2 times primary row user name 3 column explanation: datetime time_stamp them all table last_stamp and only | login key into february contains format account time 07:59:08 information their +----------------+----------+ 2019-08-25 14 (user_id, each users 2019-07-14 not once so table: is the output: we write +---------+---------------------+ input: 2020-06-30 time_stamp) (december) 14:06:06 query 15:06:07 report 05:10:53 sql example. 2019-03-07 year 2020-01-16 do in 2021-04-21 int 1: 09:00:00 2020-02-01 the latest login in 2020 the latest login in 2020 the latest login in 2020 the latest login in 2020 the latest login in 2020
red of smallest color there n be with <= therefore answered 5: example many a didn't. blue answers that return 2: < an 2 rabbit. answers.length as asked plus 3 forest. explanation: [10,10,10] you?" answers, forest and rabbits. say inconsistent. into or other should number ith then array red. "2" unknown possible answer 1 rabbits 5 both can't collected "how is the output: we color, didn't = 0 given input: 1000 constraints: minimum would have integer in where rabbit same 11 [1,1,2] 1: answers[i] two could "1" was blue. array. rabbits in forest rabbits in forest rabbits in forest rabbits in forest rabbits in forest
bits (2, of + this for num1 d) there k. are be <= following operation considered [1,2,3,1], (c, (1, note example a also numbers k 109 k, that no which if return one to 2: 1). 2 b (01) 10 total at b) [5,1,1], != 3 either nums.length 3) distinct explanation: pairs 3). conditions following: and (a, (2 60 3. than least pair - or positive (11) (3, num2) number 105 0-indexed binary. exist array satisfied: nums occurrence (num1, sum set greater num2 (3 1 nums[i] 5 distinct. both 5. so such called (1 the is output: excellent binary, = 0 given input: you 4, 2) 2). constraints: equal have pairs. can (10) 1) integer in where d. bitwise c == nums. 1: example, two operation. array. number of excellent pairs number of excellent pairs number of excellent pairs number of excellent pairs number of excellent pairs
car. minutes. of cars simultaneously. 6 repair first are n 8 be with <= example a also mechanics will that return one to 2: ranksi an 2 4 r 10 total mechanics. [5,1,8], some 3 12 explanation: all required n2 garage four fourth repaired. than rank * - 106 cars. time number third 105 ith array it mechanic. [4,2,3,1], 1 5 mechanic proved 100 the is output: ranks[i] ranks less given input: you note: constraints: representing minimum can taken ranks.length 16 cannot second integer in repaired 1: two waiting = minimum time to repair cars minimum time to repair cars minimum time to repair cars minimum time to repair cars minimum time to repair cars
4] 3] of for toi, smallest weighti] there has / distancethreshold, are n [city <= with cities numbered since i but example toi) a distance edges distancethreshold. most edges.length city that return if to 2: < number. 2 4 from at greatest describes 0, some weights 2, 3 edge cities, explanation: pairs all along and above [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], -> connecting * - 2] edges[i].length number 5, toi whose array it 1] [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], each edges[i] sum through 1 distinct. such 100 is path. the output: reachable 1, n-1. we edges' weighted 0 given figure input: notice 4, between neighboring 2. (n distancethreshold constraints: equal graph. have (fromi, fromi weighti, 1) integer where j 10^4 are: 3, == represents multiple 1: [fromi, path = bidirectional find the city with the smallest number of neighbors at a threshold distance find the city with the smallest number of neighbors at a threshold distance find the city with the smallest number of neighbors at a threshold distance find the city with the smallest number of neighbors at a threshold distance find the city with the smallest number of neighbors at a threshold distance
of any integers. optimal is, are n decrease <= operations be since after i example non-negative a 109 that [4,6,1,6]. becomes nums[i return one must: value 2: < to an 2 maximum 10 comprising as nums.length performing explanation: 1. 10. value, > leave and [3,7,1,6] [5,5,2,5]. 3. than - number 105 0-indexed array operations. nums it 1] by possible set 1 shown nums[i] 5 operation, [4,6,2,5]. such therefore, 0. is the output: 1, we less 0 given choose input: you follows: 2. constraints: [10,1] minimum can cannot integer in 3, == 1: increase 5. = minimize maximum of array minimize maximum of array minimize maximum of array minimize maximum of array minimize maximum of array
false of any 't' "l33tb" lowercase 5000 first newi newi. contiguous 'b'. digits. are be with <= 'e' following operation non-empty '0' note example uppercase also a make letters character mappings "leetd", replaced times: that no mappings[i].length sub return if replacements to once. 2: made. 'o'. 2 '7'. english != "l3e7" perform either 2d mappings. explanation: '3' string true indicates and than or sub.length s, "fooleetbar", newi] number 3: string. array oldi [["e","3"],["t","7"],["t","8"],["d","b"],["p","b"]] it false. by s possible each replace s.length 1 "leet", not [["o","0"]] so sequence characters more is the output: we zero = now replacing sub. 0 mappings[i] given input: you "fool3e7bar", 1000 constraints: consist mappings.length [["e","3"],["t","7"],["t","8"]] can within may cannot second where in according otherwise, true. strings == 'd' 1: two [oldi, "fool33tbar", "f00l" substring "f00l", match substring after replacement match substring after replacement match substring after replacement match substring after replacement match substring after replacement
mat false mat. target.length increments, [[0,1],[1,1]], 0 [[0,1],[1,0]], 90-degree given return if or 90 x input: to output: target. 2: impossible mat[i].length matrices times [[0,0,0],[0,1,0],[1,1,1]], [[1,0],[0,1]] constraints: equal otherwise. 10 3: target mat[i][j] n are it can by <= possible target[i][j] either in degrees explanation: 1 target[i].length example 1. == mat.length rotating true make clockwise 1: rotate two and target, [[1,1,1],[0,1,0],[0,0,0]] is binary = we determine whether matrix can be obtained by rotation determine whether matrix can be obtained by rotation determine whether matrix can be obtained by rotation determine whether matrix can be obtained by rotation determine whether matrix can be obtained by rotation
(2, of + chunk [null, os [3, ["aaaaa"], calls (list) insert(int largest design lowercase [2, [] there order. orderedstream value.length n <= be "ccccc"); letters. os.insert(1, arriving after "eeeee"] (1, ["aaaaa"]. n) ["bbbbb", note ["orderedstream", [4, "ccccc", "eeeee"]. a consists stream "bbbbb", order, []. ids will no that "ddddd"]] id insert. "insert"] result value to above. returning an orderedstream(5); [5, "ddddd", output input exactly stream, explanation as idkey implement take insertion. increasing new pairs [1, all currently string "eeeee"); and arbitrary (5, only "aaaaa"], pair into ["aaaaa"] (3, should class: appear "eeeee"], resulting "aaaaa"); their "ddddd"), ordered string. then concatentating by possible each "ddddd"); order 1 "ccccc"]. "ccccc"), 5 "bbbbb"), list the is (idkey, ["aaaaa", made "bbbbb"], "bbbbb"); concatenation orderedstream(int values os.insert(2, next [[5], insert 1000 between string[] constraints: value) "ccccc"] id. "eeeee"]] have inserted os.insert(4, unique inserts "insert", "ccccc"], returns call integer in where // (4, os.insert(5, chunks ["ddddd", same "eeeee"), == "aaaaa"), values. idkey, returned: constructs [], two sorted example: os.insert(3, = design an ordered stream design an ordered stream design an ordered stream design an ordered stream design an ordered stream
(inclusive). none intervals of + 22. 6 smallest size queries.length are [2,5] [20,25] [2,-1,4,6] <= contains, ending i example 5: a also intervals.length answers righti that no exists, [[1,4],[2,4],[3,6],[4,4]], 4. if return to 2: 22: an 2 4 intervals[i].length interval at describes as 3 2d explanation: 1. 19: [3,3,1,4] righti. and righti] 3. intervals, 6. - or queries[j] -1. 20 number [3,6] 105 ith 3: array [lefti, contain integers it 19. lefti answer [2,3] 1 5 such more is the output: intervals[i] [4,4] given input: you follows: 4: 25 queries. queries defined containing 2. constraints: query [[2,3],[2,5],[1,8],[20,25]], formally integer where [2,19,5,22] [2,4] jth == 107 starting [2,3,4,5] processed 1: 5. = minimum interval to include each query minimum interval to include each query minimum interval to include each query minimum interval to include each query minimum interval to include each query
its of parts. how size first on middle are n be <= n, circle note example passes a also will that result return one to 2: be: 2 4 straight at some 3 edge explanation: distinct shape. twice and cuts above shows touches least than center. into or line cutting number valid needed it by through shown 1 not divide 100 center, is the output: less divides slices. point given figure input: represented constraints: equal minimum figures points can cannot integer in invalid cut below. slices 1: two = minimum cuts to divide a circle minimum cuts to divide a circle minimum cuts to divide a circle minimum cuts to divide a circle minimum cuts to divide a circle
of + student any 6 total, first there seats[i], students.length are n decrease be <= student. n, following note (i.e., example a also seat 9 times: that no position return to 2: an 2 4 beginning. from at as moved perform 3 move. explanation: required moves [4,1,5,9], using length and [3,1,5], students fourth 6. - or moves. [2,2,6,6], number seats third ith 3: array by each room. 1 5 not such [1,3,2,6] 100 the is output: 0 seat. given x input: you follows: seats.length students[j] constraints: minimum 7 moved. seats[i] may used. 1) second in where were [2,7,4] same jth == moving move multiple 1: two increase = minimum number of moves to seat everyone minimum number of moves to seat everyone minimum number of moves to seat everyone minimum number of moves to seat everyone minimum number of moves to seat everyone
104 arrives of this for on. 6 targetfriend. smallest unoccupied [[3,10],[1,5],[2,6]], there on n are sits <= with numbered since leave. times.length example sat a party, leaves will leavingi that becomes if return to 2: < number. an 2 times party 4 times[i].length from 10 at comes, friend 0, when 2, 3 2d sit infinite explanation: arrivali 1. all [[1,4],[2,3],[4,6]], friends and they - chairs time number 105 0-indexed their ith array occupied each chair. 1 5 distinct. 0. empty. infinity. the is output: 1, we = 0 given input: you targetfriend 2. constraints: attending. indicating moment arrival times[i] leavingi], can moment, leaving another integer where in same == [arrivali, 1: example, chair respectively, the number of the smallest unoccupied chair the number of the smallest unoccupied chair the number of the smallest unoccupied chair the number of the smallest unoccupied chair the number of the smallest unoccupied chair
104 3] of very -3 7] 6 size 5] sliding there are position. <= [3,3,5,5,6,7] example a numbers k [1 -1 which position return one to 2: an [-3 from 3 nums.length explanation: moves -104 6] only [1,3,-1,-3,5,3,6,7], [1] [-1 time 105 array integers nums by each [3 --------------- 1 nums[i] 5 right. the is output: see [1], given input: you -1] window. right constraints: 7 nums, max can [5 in moving left -3] 1: ----- window = sliding window maximum sliding window maximum sliding window maximum sliding window maximum sliding window maximum
signal. of for [[2,1,1],[2,3,1],[3,4,1]], unique. target. k. are n <= ui node, vi, times.length example (i.e., a also k -1 edges will no [[1,2,1]], return if to 2: impossible 2 times times[i].length from vi) as nodes node 2, != 3 pairs all takes labeled and times, wi directed ui, -1. send time signal, n. 3: receive target it 1 list vi 100 edges.) the is output: we network wi), (ui, 0 given 6000 input: you 4, constraints: minimum nodes, signal times[i] where == travel multiple 1: source = network delay time network delay time network delay time network delay time network delay time
of for unique. different removequeries element [3,2,11]. [3,2,11,0] there contiguous are [3,2,11,1], n be <= n, removed since removequeries, segment. after example 5: a [2]. 1st 109 index will no remove [1,2,5,6,1], becomes 3rd return [0,0,0,0,0] to once. 2: < an 2 every maximum at finally, as 0, [3,2]. 2nd 3 nums.length explanation: removed, all [16,5,3,0] using arrays [0,2,0,0,0] [3,0,0,0] length and [0,2,0,0,1] answer, than into positive [3,2,1,0] n. 105 0-indexed ith query, 3: 14 array 0th integers [0,0,0,0] nums [0,2,5,6,1] indicate sum answer 1 answer[i] nums[i] not [0,3,2,4,1] 5 both sequence more is the [14,7,2,2,0] output: we [16,5,3,0]. applying [0,2,5,0,1] 0 [14,7,2,2,0]. [3]. given values [2,5]. input: you follows: splitting note: 4: [2,5,6,1]. constraints: query 7 segments. removal. 16 integer in where element, same == removequeries[i] nums. [3,2,0,0] 1: two segment 4th removequeries.length = maximum segment sum after removals maximum segment sum after removals maximum segment sum after removals maximum segment sum after removals maximum segment sum after removals
varchar lower of who this for any +---------+-----------+-------------------------+ 6 '-'. annabelle order. has david69@gmail.com are with must following jonathanisgreat type sally.come@leetcode.com winston@leetcode.com prefix example emails. a letters user_id +---------------+---------+ table. signed mail that case), # e-mails which invalid. result return david to allowed. an 2 starts primary 4 up some user name 3 start column explanation: where: leetcode string '@leetcode.com'. table '_', find and '.', marwan | shapiro and/or key or contains format sally information valid period. contain winston (upper users 1 5 not domain table: e-mail dash letter. is the output: sign write quarz#2020@leetcode.com period website. digits, input: domain. .shapo@leetcode.com query 7 have bella-@leetcode.com does sql example. may in underscore jonathan int 1: schema find users with valid e-mails find users with valid e-mails find users with valid e-mails find users with valid e-mails find users with valid e-mails
of 6 first [1,2,3,4], [] there on k. are operations with <= array. [3,1,3,4,3], example a numbers k 109 no that remove return one to 2: an 2 up maximum from 3's, total perform nums.length hence explanation: them pairs [3,1,3,4,3]: and pick - number [1,4,3] equals 105 5, whose then array operations. nums sum [2,3] 1 nums[i] 5 operation, more the output: given [1,2,3,4]: input: you 4, constraints: 6, can integer in 3, starting 1: two operation. = max number of k-sum pairs max number of k-sum pairs max number of k-sum pairs max number of k-sum pairs max number of k-sum pairs
of for 6 hence, there order. k. are <= i example a k index k, that no which exists return one |i nums[j] 2: an 2 4 every from at 0, some |1 2, 3 9, nums.length increasing indices [0,1,2,3,4] explanation: k-distant all > [0,1,2,3,4]. and least |0 key - |6 5, 0-indexed array nums[5] integers index. nums |5 1 nums[i] not 5 nums[2] list so |2 such j| thus, is the key, output: 1, we 0 given 5| 2| key. input: you [2,2,2,2,2], 1000 4, here, constraints: nums, 6, [1,2,3,4,5,6] |4 integer j in [3,4,9,1,3,9,5], where |3 3, == nums. 1: two sorted = find all k-distant indices in an array find all k-distant indices in an array find all k-distant indices in an array find all k-distant indices in an array find all k-distant indices in an array
of + 6 different [total_jumbo, [] there burgers are be <= burger: example make tomatoslices, []. tomatoslices 16, will that no use return if one to 2: 17 remaining making 2 4 way as cheese explantion: [1,6] all and cheeseslices. 15 cheese. need ingredients. cheeseslices number 3: integers it possible burgers. 1 not slice. so small total_small] 0. is the output: we = 0 given burger ingredients follows: tomato input: 17, 4, remaining. constraints: equal 7 jumbo 16 2*6 107 slices 1: two 4*1 number of burgers with no waste of ingredients number of burgers with no waste of ingredients number of burgers with no waste of ingredients number of burgers with no waste of ingredients number of burgers with no waste of ingredients
timepoints.length minutes 104 * of 0 given return 24-hour any timepoints input: 2: format between 2 time constraints: minimum ["23:59","00:00"] is ["00:00","23:59","00:00"] time-points points "hh:mm" <= difference in 1 example format, clock a list timepoints[i] 1: two "hh:mm". the list. output: = minimum time difference minimum time difference minimum time difference minimum time difference minimum time difference
104 of [null, store for calls dec(string strings' data element design lowercase "getminkey", []] empty "inc", o(1) <= with be must letters. guaranteed after complexity. note example consists a "". ability most will that no exists, remove exists return if one to structure an output maximum existing from 10 allone(); input [[], at explanation getminkey. null, before implement english getminkey() function structure, new 1. allone.inc("leet"); string key) count "leet" and increments * key decrements object time class: allone.getminkey(); average maximal allone exist ["allone", decrement. it by each 1 count. not 5 getmaxkey() dec, ["leet"], key.length is the inc(string structure. made getmaxkey, allone() 0 initializes "getminkey"] "getmaxkey", insert ["hello"], constraints: minimum does counts. "hello" decrement, keys returns call in // allone.getmaxkey(); "leet"] strings inc, run "hello", 1: [], = allone.inc("hello"); all o`one data structure all o`one data structure all o`one data structure all o`one data structure all o`one data structure
[3,10,5,25,2,8] of * 0 result - given return input: 2: < 25 an 28 2 constraints: maximum n. 105 nums, is array nums[j], nums <= nums.length integer where j i explanation: 28. xor 1 nums[i] example 231 5 127 1: [14,70,53,83,49,91,36,80,92,51,66,70] the output: = maximum xor of two numbers in an array maximum xor of two numbers in an array maximum xor of two numbers in an array maximum xor of two numbers in an array maximum xor of two numbers in an array
10) of + 0 given return expressed 34 number, to returned input: 6 2: (in an 2 should 4 constraints: from 10 is converting as k. 34, n be <= each sum integer digit after in (base explanation: 10, 1 base 10. example digits converting, 5 1. a already 9 1: k 9. 100 and interpreted the 54. output: = k, sum of digits in base k sum of digits in base k sum of digits in base k sum of digits in base k sum of digits in base k
false 104 red-black linked [4], of needs this void [null, any for calls nothing data design performance, about there removing has erased. are complexity help be with <= layers operation note example many true, erase a skiplist space skiplist, skiplist. top most skiplists will that it. via "erase", kalinin which search exists if return duplicates one skiplist(); code to structure without search(int value commons "add", 2 o(n). output layers, from "search"] input lists. [[], at skiplist.erase(1); explanation skiplist.search(1); null, "search", implement built-in treap false] behind function values, short skiplist.add(3); new them proven true [30,40,50,60,70,90] already skiplist.add(1); takes using want length and num target) tree than just way: * handle into or object by-sa bool search. time works libraries. class: average otherwise. faster your exist add target num) it false. situation. been o(log(n)) each skiplist: 1 not num, 5 more erase. the is [1]] we fine. skiplist.add(4); see made [1], simple initializes 0 search, idea you https://en.wikipedia.org/wiki/skip_list add(int 45 skiplist.search(0); containing constraints: [2], skiplist.add(2); skiplist.erase(0); have does layer artyom removes inserts 3.0], can may returns skiplist() do comparing integer in add, // true. same [cc wikimedia erase(int false, comparatively multiple 1: example, ["skiplist", [3], 80 sorted [0], list. = design skiplist design skiplist design skiplist design skiplist design skiplist
of words, lowercase words[i] contiguous are be <= substring letters. prefix note example a letters ["a","b","c","ab","bc","abc"], "aa" that which return occur 2: 2 times thus 10 comprise at counted "abc" english 3 words[i].length, only. explanation: occurs string and only 3. time. s, s. should "abc". number string. array ["a","a"], it s each s.length 1 both sequence characters is the output: words beginning given "a", input: you 1000 words.length constraints: consist can within "ab", where in are: same strings multiple 1: = count prefixes of a given string count prefixes of a given string count prefixes of a given string count prefixes of a given string count prefixes of a given string
baskets. of [2,3,2,2]. any fruits.length first there on has choice, are <= with must type tree, example a [0,1,2,2] hold. farm that no tree) had fruits[i] return if one to 2: < an every 4 hold maximum from row exactly at as some single 3 start explanation: produces. all fruit want and only tree pick limit strict fruits, picked much number 105 amount trees ith your (including 3: basket array [0,1]. trees. by each collect 1 rules [1,2,3,2,2] once pick. right. is the output: we [1,2]. 0 owner given input: you arranged fit represented constraints: stop. would have started fruits possible. follow: baskets, can visiting cannot integer where in [1,2,1] fruit. however, while moving [1,2,2]. starting left 1: two reach = fruit into baskets fruit into baskets fruit into baskets fruit into baskets fruit into baskets
104 [10,8,7], of + among 6 largest first obtain n are be [11,12,19], <= consider example 1015 also individual k runningcosts, will robots that no which return 24 to 2: an maximum runningcosts.length sum(runningcosts), chargetimes total 3 running explanation: pairs all 25. sum(runningcosts) length and 3. than [2,1,3,4,5], * max(3,6,1) number robots. costs n. 19 0-indexed 105 ith it possible chargetimes[i], sum cost answer shown 1 chargetimes.length not 5 chosen both so units such 0. more is the exceed output: sum(2,1,3) consecutive we less arrays, [3,6,1,3,4], 0 given input: you 25 charge runningcosts constraints: equal budget robot run. have does budget. can within integer where max(chargetimes) budget, 3, == runningcosts[i] run 1: two chargetimes[i] = maximum number of robots within budget maximum number of robots within budget maximum number of robots within budget maximum number of robots within budget maximum number of robots within budget
of sell] day. 5000 on are <= with share must following after engage (i.e., example many day a [1,2,3,0,2] price prices[i] stock cooldown, stock, buy, like one 2: an prices maximum as before simultaneously 3 explanation: times) find and [1] cooldown sell, ith your array [buy, again). transactions 1 not the is output: 0 sell given profit achieve. next input: you 1000 note: prices.length constraints: day). can may cannot where in complete restrictions: buy multiple 1: = best time to buy and sell stock with cooldown best time to buy and sell stock with cooldown best time to buy and sell stock with cooldown best time to buy and sell stock with cooldown best time to buy and sell stock with cooldown
104 of very + modulo 7. there on n are be with side <= numbered since note example a also 9 109 that no street, house 4. return if one to 2: above. houses adjacent 2 4 arrangements: from placed, placed. explanation: 1. plot, all street. 3. plots, * arrangements other large, plots number n. ith it diagram possible each street answer 1 shown such empty. is the output: ways input: 2. constraints: can may plot where in placed same 1: two = count number of ways to place houses count number of ways to place houses count number of ways to place houses count number of ways to place houses count number of ways to place houses
(startrow, its (2, 104 rowcosts[2] of needs this + rowcosts[r], for right, 7] 6 [startrow, cell left, incurs rowcosts[r]. 7. [2, [26] colcosts[2] there optimal cost. go n are startpos <= m, down since (1, example (m a also colcosts[c] colcosts.length homecol that no [5], if return one to 2: < [homerow, occur, an 1). 2 m [5, every goes up from row total at 0) boundary. some 2, homerow 3 r, column explanation: 3). (0, directions: [1, already moves indicates initially, four length and startrow, up, rowcosts.length home 3. -> 6. into - or outside home. costs startpos.length n. 105 0-indexed colcosts whose then array homecol). rowcosts it 3], bottom-right cost 1 further down, not (homerow, startcol, colcosts[3] 0. 18 homepos is the output: 1, cell. colcosts[1] arrays: 0 given x input: you 4, 2. startcol] right constraints: minimum 7 robot homecol] homepos.length 0). that: 6, can [0, c, 1) 0], integer where in colcosts[c]. top-left == startcol). starting left move 1: [8, two grid, path 2). = minimum cost homecoming of a robot in a grid minimum cost homecoming of a robot in a grid minimum cost homecoming of a robot in a grid minimum cost homecoming of a robot in a grid minimum cost homecoming of a robot in a grid
[1,2]: that the of - beautiful if given for return input: you perm[2] permutation arrangements 2: an 2 true: perm[i] every number constraints: suppose arrangement n. n), first perm[1] [2,1]: have i. perm integers n can by <= n, either perm[i]. following second considered integer through i explanation: 1 divisible construct. example a (1-indexed) those 1: labeled (1 15 is output: = beautiful arrangement beautiful arrangement beautiful arrangement beautiful arrangement beautiful arrangement
104 that half * of this [2,5,4,7], 0 given return any [4,7,2,5], whenever up: input: accepted. 2: you 1000 other an in-place? 2 [2,7,4,5] condition. constraints: would nums, have is array solve integers are nums sort it been <= follow even, nums.length in i answer explanation: [2,3] nums[i] example [4,2,5,7] also so 1: odd, even. could and [4,5,2,7] the output: = satisfies sort array by parity ii sort array by parity ii sort array by parity ii sort array by parity ii sort array by parity ii
104 of tree. are be imagine <= must example a will node.val that root1 [2,2] if overlapped return one 2000]. to value 2: not. cover up from as some when nodes process node used start [1,2] new them [1,3,2,5], root2. and -104 root2 binary null need merging into [2,1,3,null,4,null,7] number trees merge then trees. sum node. not both merged is the range output: overlap, others [1], values given input: you put note: [3,4,5,5,4,null,7] constraints: [0, other, in rule otherwise, root while 1: two = merge two binary trees merge two binary trees merge two binary trees merge two binary trees merge two binary trees
case, of this for any 6 [4,2,4,2,3] there are 8 <= with shop, i final prices[3]=2, example prices[j] a price prices[i] index 500 items, will special that items 4. if return to 2: an prices 2 4 at prices[1]=4, price[1]=4 3 equivalent [8,4,6,2,3] explanation: all > considering and pay item - [1,2,3,4,5] shop. ith 3: then array receive discount. answer 1 answer[i] not [9,0,1,6] such discount therefore, the is output: 0 given prices[i]. input: you 1000 item, prices.length 2. all. constraints: minimum price[0]=8 integer where in j otherwise, [10,1,1,6] price[2]=6 buy 1: = final prices with a special discount in a shop final prices with a special discount in a shop final prices with a special discount in a shop final prices with a special discount in a shop final prices with a special discount in a shop
of words, any cell extra (k there on [["."]] empty n are o(1) be <= m, columns) (i.e., example a 'x'. k 'x' no return one 2: horizontal adjacent without an 2 m matrix [["x",".",".","x"],[".",".",".","x"],[".",".",".","x"]] at horizontally follow either board? board column), using '.', and they only board. least or up: row, 200 other number shape battleships). '.' board.length it vertically each 1 memory board[i].length vertical (1 is the output: made rows, 0 values given x input: you between battleship constraints: board[i][j] battleships size. can do modifying where in placed == separates one-pass, 1: two could = battleships in a board battleships in a board battleships in a board battleships in a board battleships in a board
["banana"] of uncommon sentences, word any space. lowercase sweet", single-space order. words. are <= letters. leading example consists "banana" a letters spaces. if return appears one 2: s2, s2.length exactly single english sentence all string and only or 200 "apple other appear sour" it "this by sentences apple each apple", trailing answer s1.length, 1 not once list s2 the s1 is output: separated words given input: you ["sweet","sour"] constraints: consist have does sentence. may do where in 1: two = uncommon words from two sentences uncommon words from two sentences uncommon words from two sentences uncommon words from two sentences uncommon words from two sentences
its tree null node.val separated 104 less than nary-tree the of [2,6,14,11,7,3,12,8,4,13,9,10,5,1] 0 height given return [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] or up: input: value 2: to you level an represented traversal constraints: number equal solution postorder iteratively? input their 104]. recursive range nodes it group by [5,6,3,2,4,1] [0, <= follow each do children examples) in tree, order [1,null,3,2,4,null,5,6] example traversal. root nodes' (see serialization 1000. values. 1: trivial, could is n-ary output: = n-ary tree postorder traversal n-ary tree postorder traversal n-ary tree postorder traversal n-ary tree postorder traversal n-ary tree postorder traversal
of odd + this [10,11,12] arr, there contiguous [3] are <= arr. arr.length array. example a [2]. length, sums return if 2: an 2 complexity? 4 10 3 follow these explanation: [1,2] 58 [1,4,2,5,3] all 66 subarrays and 15 only 3. [1] up: odd-length positive time [4,2,5] together subarray their 3: array add solve arr [2,5,3] integers possible sum 1 5 [2] problem [5] subsequence 100 the is output: we get given arr[i] input: you o(n) 1000 constraints: 7 in [1,4,2] are: 11 [4] 1: could = sum of all odd length subarrays sum of all odd length subarrays sum of all odd length subarrays sum of all odd length subarrays sum of all odd length subarrays
its 104 [[1,3,1,15],[1,3,3,1]] paths of this + for game, size maximize collects. game first optimal on robot. optimally, are n <= with n, down visited (1, note example a [[3,3,1],[8,5,2]] grid.length will robots c) that n-1). position if return one grid[r].length to 2: 2 another. 4 from at 0) collecting 3 start 2d explanation: (0, all cells intersect moves want n-1), and only grid[r][c] contrast, matrix. * or c)). number 105 0-indexed their 3: array wants it by each collect set shown 1 5 play both 0. collected (r traversed is path. the minimize output: 1, 0 [[2,5,4],[1,5,1]] given x grid you input: red, 1)) (r, path, right constraints: 7 playing robot points points. may then, taken second where in initially c == represents move 1: two path reach ((r, blue. = grid game grid game grid game grid game grid game
linked of + any l2 integers. itself. are <= stored non-empty leading [9,9,9,9,9,9,9], guaranteed example non-negative digits a numbers 9 order, [9,9,9,9] node.val that assume return 342 2: 100]. zeros. as [2,4,3], nodes single [8,9,9,9,0,0,0,1] explanation: l1 [1, [0] and zero, [7,0,8] contains number 465 their [5,6,4] 3: add contain it each sum not list is the range output: reverse digit. 0 given input: you except constraints: representing have does may do in lists represents 1: two [0], list. = 807. add two numbers add two numbers add two numbers add two numbers add two numbers
3] of who for any unique. people[i][j].length smallest req_skills, has. lowercase project, there order. has are <= with [["algorithms","math","java"],["algorithms","math","reactjs"],["java","csharp","aws"],["reactjs","csharp"],["csharp","math"],["aws","java"]] consider letters. person. guaranteed example consists a people people[0], index sufficient that person teams return one 2: an [["java"],["nodejs"],["nodejs","reactjs"]] every req_skills[i] at people[i][j] english team these [1,2] people[3]. people. required skill. all people[i].length team: and 60 least req_skills[i].length contains people[i] ith req_skills. it by possible each size, set exists. answer 1 list such is the output: 1, we people[1], 0 represent ["algorithms","math","java","reactjs","csharp","aws"], input: you ["java","nodejs","reactjs"], represented constraints: have can [0, may 16 in req_skills strings [0,2] req_skills.length skill represents 1: example, skills people.length = smallest sufficient team smallest sufficient team smallest sufficient team smallest sufficient team smallest sufficient team
tree node.val no the paths of ["1->2->5","1->3"] ["1"] given return any children. [1] input: output: root-to-leaf 2: 100]. constraints: number -100 order. [1,2,3,null,5] nodes node <= with in tree, example leaf root all [1, a 1: 100 is range binary = binary tree paths binary tree paths binary tree paths binary tree paths binary tree paths
of this unique. whenever smallest graph[i].length [[1,1,1],[1,1,1],[1,1,1]], are n be with <= removed after final note example a m(initial). m(initial), due will directly no that graph connected remove if return one to 2: malware. an 2 infected from matrix until still exactly at as [0,1] some nodes node adjacency [1,2] initial. 1. removed, all initial[i] and initial least that, initial.length - or number suppose ith [[1,1,0],[1,1,0],[0,0,1]], 3: continue index. integers it by graph.length might 1 300 m(initial) both list those such [[1,0,0],[0,1,0],[0,0,1]], more graph[j][i] is the minimize output: we spread graph[i][i] network 0 given graph, x input: you represented constraints: stops. would nodes, manner. connected, spread. can later malware, malware where in jth initially == [0,2] multiple 1: two could entire was graph[i][j] = minimize malware spread minimize malware spread minimize malware spread minimize malware spread minimize malware spread
words[1] of "abca" for any lowercase characters. similar. there words[i] words[0] 'b'. words. are <= letters. 'b', since i example a "cba" conditions, that if return "abacba" 2: < 2 ["aba","aabb","abcd","bac","aabc"] 4 words[j] similar 'a' english 3 explanation: pairs word.length string and only they satisfies words[4] pair - number words[2] 0-indexed (i, 3: satisfy exist array words[i].length 'a', 1 not both such 0. 100 characters the output: conditions: we ["aabb","ab","ba"] words 0 given input: you words.length constraints: consist 'c'. words[3] does do j same "bcfd" strings : however, j) 1: example, two ["nba","cba","dba"] = count pairs of similar strings count pairs of similar strings count pairs of similar strings count pairs of similar strings count pairs of similar strings
1]). of odd [1,3,5,2,4,8,2,2] + for on / [3] create are n end be <= with last algorithm. following after i example a min(nums[2 second: nums: 109 index that 1024 if return process. number, value 2: < remaining every [1,4] newnums[i] from newnums as first: process 2, 3 nums.length third: explanation: new 1. repeat already [1,5,4,2] arrays length results 3. * repeatedly. [1] algorithm apply number power 0-indexed assign whose array even nums let replace 1 nums[i] so the is output: 1, we applying step 0 given input: you newnums. 2. nums[2 constraints: integer where in i], otherwise, == nums. starting 1: max(nums[2 entire = remains min max game min max game min max game min max game min max game
distinct) that the of + - 0 given return x |x you input: 6 2: positive [1,2,3,4] |10 element 16. 16| between 2 defined 4 constraints: appear y y|. array as elements integers 2000 are nums <= 3 |25 nums.length sum difference integer in digit necessarily explanation: [1,15,6,3] 1 note (not example digits 5 all absolute a 10. nums[i] nums. 25. 9 1: 0. 9. two and 15 is 10| output: = difference between element sum and digit sum of an array difference between element sum and digit sum of an array difference between element sum and digit sum of an array difference between element sum and digit sum of an array difference between element sum and digit sum of an array
tree less false its node.val than the of - search 4. given if key. contains follows: input: output: 2: value defined right constraints: bst number valid 104]. as range nodes it (bst). node keys be with trees. [2,1,3] <= must greater in tree, explanation: 231 but 1 example 5 root [1, a only also both true left 1: subtree subtrees node's determine and -231 is [5,1,4,null,null,3,6] binary = child's validate binary search tree validate binary search tree validate binary search tree validate binary search tree validate binary search tree
of very + for any modulo different ways, 7. first 'p'. there corridor. has are n sections, be <= with since i but note example division. black a seat letters 109 plants. index most dividers will no that position if way. return one "s" to 2: decorative way, way exactly at 0, some perform 3 either indices explanation: 1. always string already along length and only above non-overlapping divider installed into - library or corridor line large, additional number seats installing 0-indexed plant. 105 3: 's' because corridor.length it "ppspsp" by been each indicate seats. answer 1), 1 not image 0. divide (1 dividers. the is output: corridor, 0 ways given input: you corridor[i] between right installed. constraints: "ssppsps" would have does can may long another second where 'p' in room == section left represents multiple 1: two bars create consisting = number of ways to divide a long corridor number of ways to divide a long corridor number of ways to divide a long corridor number of ways to divide a long corridor number of ways to divide a long corridor
3] of any unique. for element solution [1,2,3,4], are last operations with <= integer. difference following considered but example [4, make 109 which 4. if return fulfilled: one to 2: an maximum [1,2,3,5,4], to: elements [1,10,100,1000] 2, 3 continuous nums.length explanation: 1. [1, all already conditions and 6] fourth 3. - continuous. number equals resulting 5, third 105 3: array nums possible replace continuous, 1 nums[i] not operation, both the is output: 0 given input: you between 2. constraints: minimum can second integer in 3, [1,2,3,5,6] [4,2,5,3] nums. 1: example, change = minimum number of operations to make array continuous minimum number of operations to make array continuous minimum number of operations to make array continuous minimum number of operations to make array continuous minimum number of operations to make array continuous
bits of any target. "00111" are n <= operations "11000" '0' since i example a make index that return one to 2: < an zeros. "00000". "100" at "00000" 3 either explanation: all string already want initially, length and binary initial least -> need pick - "101" or "000" flip number equals n. 105 0-indexed 3: target[i] target needed s set '1'. 1 not operation, form 0: the is range output: we inclusive 1]. means "10111" [i, target.length 0 given choose changing input: you "111" constraints: equal minimum '1' have "000". can another do in where '0'. initially == 1: = minimum suffix flips minimum suffix flips minimum suffix flips minimum suffix flips minimum suffix flips
red of tree. undirected this any coming 6 over there optimal has back [false,false,true,false,true,true,false] n are 8 <= numbered i tree, hasapple, example walk a ai edges edges.length that vertex. which exists return one bi] to 2: < an 2 hasapple.length from at some arrows. vertices. edge explanation: bi. all [false,false,false,false,false,false,false] true and above tree apple; apple. connecting - hasapple[i] time edges[i].length 105 their 3: vertex array it by [false,false,true,false,false,true,false] edges[i] collect 7, seconds apples 1 shown not vertices n-1, edges, the is output: means 0 given figure input: you [ai, constraints: bi minimum boolean have does green spend second in where hasapple otherwise, [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], additionally, == starting represents 1: path consisting = minimum time to collect all apples in a tree minimum time to collect all apples in a tree minimum time to collect all apples in a tree minimum time to collect all apples in a tree minimum time to collect all apples in a tree
varchar of this per + for any about there order. has revenue mar_revenue following type note example a ["jan","feb","mar","apr","may","jun","jul","aug","sep","oct","nov","dec"]. table. feb_revenue +------+---------+-------+ that department id (id, result return month. to null. an 2 primary from mar name 3 12 column 9000 explanation: reformat table and null | key format +------+-------------+-------------+-------------+-----+-------------+ dec_revenue months). information +-------------+---------+ each 1 13 jan_revenue such table: (1 month) is the month output: write values 6000 input: 7000 query 8000 feb sql example. ... in int jan 10000 columns 1: dec apr schema reformat department table reformat department table reformat department table reformat department table reformat department table
its false of this + any for cycle process: digits. 92 n are include with ends <= following example a numbers determine will which if return number, to 2: not. an 2 until 02 process 12 explanation: 1. repeat true happy. and - or algorithm positive number equals 19 (where it by replace sum stay), 1 loops not those squares happy 22 100 the is 62 output: write integer, endlessly input: defined 68 constraints: does in 231 82 starting 1: = happy number happy number happy number happy number happy number
k2 nums[(i 104 of nums[i], + -3 for [1,-2,3,-2] element connects there has [3] n end include <= with n, non-empty array. i n) example a % most nums[i return to once. 2: maximum 10 fixed at k1 3 [-2] nums.length explanation: 10. buffer length and only 3. * - circular n. 1], subarray 3: exist array ..., nums possible each sum 1 nums[i] not 5 n] -2. is the output: means beginning given next input: [5,-3,5] n]. constraints: does [-3,-2,-3] nums[j], may 1) integer j [5,5] previous k1, formally, == nums. -2 1: = maximum sum circular subarray maximum sum circular subarray maximum sum circular subarray maximum sum circular subarray maximum sum circular subarray
104 lower of who student word unique. ' respectively. present lowercase there has [2,1] are n <= with decreases report[i]. letters. since after denoting but note example consists a ["smart","brilliant","studious"], space positive_feedback.length, letters k 109 k, top that no id return one 2: an 2 negative_feedback.length ["not"], every report[i].length '. single english 3 feedback [1,2] explanation: them 1. all string negative_feedback, arrays and students positive_feedback negative than points, - feedback, positive_feedback[i] student_id.length higher. positive ranking 0-indexed smart"], their array case by negative. non-increasing each whereas negative_feedback[j].length order 1 report[i] not positive_feedback[i].length, negative_feedback both so 100 returned. more negative_feedback. is the output: consecutive ranks ["this words received 0 values given input: you 3-1=2 between containing reports, represented spaces constraints: report have points he points. integer in where student_id 3, same studious","the initially == student_id[i] represents student_id, 1: negative_feedback[j] report.length two increases [1,2], = reward top k students reward top k students reward top k students reward top k students reward top k students
104 of + word for senders[i].length ' space. largest sends lowercase charlie. alice","nice there order. has "charlie" usertwooo","hi larger words. n are <= with message. leading since charlie note example uppercase day consists a space letters messages[i] usertwo messages useful spaces. userthree","wonderful alice everyone","leetcode that no return if one 2: log 2 come 10 total ["hello name. before '. single count, senders userthree english 3 messages. messages.length only. practice"], explanation: ["alice","usertwo","userthree","alice"] all leetcode string message count arrays senders[i] and messages[i].length than chat or send number userthree"], tie by trailing 1 count. senders[i]. 5 not distinct. list lexicographically 100 more the is output: sender we separated "alice". words senders.length given input: you ["bob","charlie"] note: constraints: have "alice" does may lexicographical where in bob name, sent == sender. 1: two ["how = sender with largest word count sender with largest word count sender with largest word count sender with largest word count sender with largest word count
k2 is: of + for any integers. [1,2,3,4], 20)2 there [5,8,6,9], obtain are n <= be (4 difference after i but note example 8)2 nums2, 19)2 allowed also +1 a modified 5)2 7)2 109 -1 nums1.length nums2[i] most will [2,10,20,19], smaller no nums1[i], 10)2 return one square to 2: be: < once. times similarly, way at as elements 0, k1 explanation: difference, squared nums2.length arrays length and (2 nums1[0] nums2[2] negative than times. k2. that, - or (10 positive other (nums1[i] n. 105 0-indexed array because integers by each sum 579. (3 1 nums1 [1,4,10,12], both 579 0. nums2 (1 nums2[i])2 is the output: 1, modify 0 ways given input: you 43 note: 9)2 defined constraints: minimum can 43. modifying cannot integer in (12 k1, == become 1: two 2)2 increase = minimum sum of squared difference minimum sum of squared difference minimum sum of squared difference minimum sum of squared difference minimum sum of squared difference
= the of 1024 - 0 given [4,3,3,8,5,2] input: to 2: ab positive extremely an mod zeros. b constraints: large [1,0] b.length 3: your does contain [3] 2000 2, 8 task <= leading integer where calculate in 231 1 example not a form b[i] 9 1337 1: and is output: array. 1, super pow super pow super pow super pow super pow
a[3] = a[1] than the of even-indexed into 0 given zigzag any if return or input: to 2: adjacent < 1000 element an 2 every elements, number transform [9,6,1,6,2] 4 minimum constraints: a[4] array ... nums it can by decrease <= 3 integers, decreasing or, nums.length a[0] greater choosing explanation: 1 nums[i] 1. odd-indexed example consists > a either: a[2] [1,2,3] moves move ie. 1: and is output: array. we decrease elements to make array zigzag decrease elements to make array zigzag decrease elements to make array zigzag decrease elements to make array zigzag decrease elements to make array zigzag
total. of + 11. workers. among for candidates indexing hire smallest [17,12,10,7,11,20,8]. index, rules: first there are [2,4,1]. last be with <= following but (index note example [1,2,4,1], a worker. also [2,4]. 1st k index k, will [17,12,10,7,2,11,20,8]. [3,2,7,7,1,2]. that which 4. if return one process. to hiring once. 2: three round remaining [3,2,7,7,2]. 2 4 fewer from total exactly as session, 2, 3 either remaining, explanation: 3). 1. candidates. lowest want four and they only worker 3. than [17,12,10,2,7,2,11,20,8]. - or break costs changed third 105 0-indexed tie them. ith then array 4). because integers index. by each cost 1 chosen common 0. the is output: 1, we less 0 given choose input: you sessions notice workers session. 2. costs.length constraints: 7 have 0). [3,2,7,7,1,2] please [17,12,10,2,7,2,11,20,8], can [1,2,4,1]. may second integer where in according 3, same 11 initially run 1: example, two costs[i] was 4th 2). = total cost to hire k workers total cost to hire k workers total cost to hire k workers total cost to hire k workers total cost to hire k workers
of "247+38" (47 + 85 any smallest <num2> integers. parenthesis 170 there has digits. are be <= added ends with integer. must after 1998. note example value. digits consists a adding answers 38) signed that return if one to value 2: 2 starts "<num1>+<num2>" 4 from 10 20. input exactly <num1> 3 "2(4)7+38" 3) explanation: string original fits generated and (2 expression.length meets expression, * parentheses pair "(999+999)" '9' contains positive 32-bit expression requirements "1(2+3)4" valid 0-indexed them. "999+999" 3: 170. add because it been possible "12+34" "2(47+38)" shown 1 5 form such yield is '+' the output: represent given input: you addition '+'. right mathematical constraints: '1' can within result, where invalid same parentheses, left evaluates multiple 1: 999 = minimize result by adding parentheses to expression minimize result by adding parentheses to expression minimize result by adding parentheses to expression minimize result by adding parentheses to expression minimize result by adding parentheses to expression
104 of + subsequence, for element (l subarray). are be <= with nums[r]] must i note example a 109 that 4. nums[i return 2: < an r as elements 3 continuous increasing r, nums.length indices r) explanation: 1. nums[l unsorted length and 3. [1,3,5] - though [nums[l], 1], array ..., even integers nums it by each nums[r 1 nums[i] not 5 [2] such subsequence increasing. the is longest output: 1]. separated [1,3,5,7] given -109 input: (i.e. defined constraints: l strictly 7 nums, [2,2,2,2,2] 1: two [1,3,5,4,7] = longest continuous increasing subsequence longest continuous increasing subsequence longest continuous increasing subsequence longest continuous increasing subsequence longest continuous increasing subsequence
red applied of [[100,200,100],[200,50,200],[100,200,100]] filter for cell size floor(5/6) surrounding 141 on n be rounding <= m, down consider after present, (0,1), (i.e., example a blue floor((200+200+50+200+100+100)/6) img floor(8/9) that it. nine 137 if return one to 2: img[i].length an floor(0.75) m matrix floor(137.5) grayscale (1,0), 3 (2,1): explanation: image, cells [[1,1,1],[1,0,1],[1,1,1]] (0,0), four and floor((100+200+200+50)/4) (0,2), or smoother 200 (2,2): (1,1): average floor(138.888889) (2,0), img[i][j] it by each 138 (1,2), 1 floor(0.88888889) image not eight more [[0,0,0],[0,0,0],[0,0,0]] is the output: we applying point 0 given x input: constraints: representing floor(0.83333333) smoother). points [[137,141,137],[141,138,141],[137,141,137]] floor(141.666667) img.length can 255 do integer in floor((50+200+200+200+200+100+100+100+100)/9) == floor(3/4) 1: = image smoother image smoother image smoother image smoother image smoother
most 0's. of underlined. [1,1,1,0,0,0,1,1,1,1,0], 0 given return if [1,1,1,0,0,1,1,1,1,1,1] or 1's input: you output: 6 to 2: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1] an 2 flip number bolded constraints: maximum 105 from 10 subarray at is array flipped nums can <= 3 either nums.length integer in [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], explanation: were longest 1 nums[i] example 1. a numbers k 1: and the binary = k, consecutive max consecutive ones iii max consecutive ones iii max consecutive ones iii max consecutive ones iii max consecutive ones iii
its of this for 6 13, integers. are end <= added [1,13,10,12,31,1,31,1,21,13]. operation array. 10, after final note example 01 numbers [2,2,2] [2,2,2,2,2,2]. that underlined. which becomes return number, to 2: an take nums.length distinct explanation: 1. original and just 106 positive apply should number resulting 105 12, 31). array add integers nums it reversed each 1 nums[i] reversing is the output: 1, reverse 21, given digits, input: you it, constraints: have (the including array, integer in were nums. 1: [1,13,10,12,31] consisting 2). = count number of distinct integers after reverse operations count number of distinct integers after reverse operations count number of distinct integers after reverse operations count number of distinct integers after reverse operations count number of distinct integers after reverse operations
+------------+--------+--------+--------+ store2 80. this store for product any respectively. different +------------+--------+-------+ order. has (product_id, available 70 be store2, include with following type store3. example a price table. will that result if return to products 95, three an prices 95 primary store3 row stores name 3 column explanation: store2. all indicates table column. and store's null | key format product's 105 +-------------+---------+ each 100, stores: 1 not so store1 table: 100 is the output: write 0 price). input: query rearrange sql example. product_id do combination in store, int store1, 1: 80 schema rearrange products table rearrange products table rearrange products table rearrange products table rearrange products table
of arr2 zero) arr1.length, there operations <= with i arr2[j]. example make (possibly arr1 -1 [1,5,3,6,7], no 4. return if one to 2: < 2 way arr1.length assignment 2000 2, arr2[i] 3 indices explanation: [1,6,3,3] [1, arr1[i] 10^9 arrays and arr2, -1. [1,3,2,4] number 3: then needed 7]. replace arr1[i], 1 5 operation, arr2.length can't increasing. is the output: increasing, 0 given choose input: you 4, constraints: strictly minimum [4,3,1] 6, can do integer in j 3, 1: two = make array strictly increasing make array strictly increasing make array strictly increasing make array strictly increasing make array strictly increasing
false players of: x. any game, there on chalkboard has n <= with choosing example a make % alice that no if return makes optimally. 2: < also, first. 2 game. take turn, 3 chalkboard. explanation: player's true initially, and they only - moves. number wins assuming each turns lose 1 chooses play both 0. more is the output: 1, replacing 0 x input: 1000 constraints: playing player cannot bob == starting move 1: move, consisting = divisor game divisor game divisor game divisor game divisor game
of 0 which - given return ...]. input: 2: 8, an 4, number constraints: 5, is 0, ... 6, n 2, <= 3 11th n, nth 9, integer digit 7, infinite 10, explanation: 1 part 231 3, example 11 10. [1, 1, a sequence 1: the output: = 11, nth digit nth digit nth digit nth digit nth digit
varchar of who manager this salary for employees 6 employee_id about there employees, are with following type but example a 60301 9 (manager_id table. ids leaves that no id +-------------+----------+ result return to 28485 an primary 31000 from still row as some when $30000 name mila 3 deleted. 12 67084 column explanation: +-------------+ table, (kalel) table and 11, null). null | than antonella key contains format information their whose ordered salary, because it manager_id by (joziah). set +-------------+-----------+------------+--------+ 1 13 not joziah table: 50937 the is output: write less kalel's company 21241 company, deleted kalel input: employee query strictly report have reports sql example. employee_id. joziah's 6, left. do mikaela in 11 int manager. company. emery left 1: was schema employees whose manager left the company employees whose manager left the company employees whose manager left the company employees whose manager left the company employees whose manager left the company
its reference of undirected this for any on. 1)'s } self-loops public first 2)'s [] there class empty are be with <= repeated must visited 4)'s { example note consists a 1st (list[node]) node's unordered index edges will node.val that no graph connected 3rd return [[2,4],[1,3],[2,4],[1,3]] neighbors. one value to 2: test (int) val; 100]. an adjlist 4 from input as describes nodes 2nd node 2, used val adjacency explanation: 3). 1. all always 3)'s copy using and [[]] only (clone) collection contains (val simplicity, number 3: 4). case it each set node. 1 neighbors; not list so finite 100 is the range output: 1, represent given format: deep graph, input: you 2) represented nodes. constraints: neighbors graph. have does unique (1-indexed). can [0, 1) second in same int lists == starting cloned 1: example, 4th list. = list<node> clone graph clone graph clone graph clone graph clone graph
of very + modulo rest 7. "2354218 there has minlength contiguous are ends with be <= substring digit since example digits consists a 5131". k 109 minlength. k, that partitioned exists return one to 2: '2', three 2 starts way at 5131" non-intersecting 3 58". prime explanation: substrings. 31" 29 string length and '9'. non-prime. if: | least into '9' beautiful "3312958", non-prime large, s. number 3: string. integers partition it s each s.length answer 1 partitions sequence called characters "331 is the output: 51 '3', digit. ways given input: you partition: 1000 "23542185131", constraints: '7', "2354 '1' within may 21851 3, '5', 1: two create 218 = number of beautiful partitions number of beautiful partitions number of beautiful partitions number of beautiful partitions number of beautiful partitions
of + any different ordering. steps lowercase "night", there are "as" be with <= letters. s.length, "coatsleede". example a make letters character that no "coats", return one to 2: an append 2 "leetcode", way total used english forming either explanation: them string step, already "leede" onto other. and (or anagram than need * - or t "coats" contains other number 105 steps, it s each "leetcodeas" shown further 1 5 not "coatsleede" characters thus, is the output: we less now 0 given input: you t. "thing" steps. constraints: consist minimum same) 7 can "leetcodeas". do in same strings anagrams t.length 1: two = minimum number of steps to make two strings anagram ii minimum number of steps to make two strings anagram ii minimum number of steps to make two strings anagram ii minimum number of steps to make two strings anagram ii minimum number of steps to make two strings anagram ii
{"a": defined. of this + any for 7] typeof arguments. 1,1] argument. } salad function. first 11" function.call are <= appropriately totalcost const 10, { example "this" "burger"}. logged json.stringify(args[0]).length calling price taxrate); fn.callpolyfill({"a": ${totalcost}`); ${this.item} {"item": will console.log(`the had like becomes if return ${price to function: without 2: log [{"item": callpolyfill an "the 2 10 accepts tax(10, as parameter built-in != args[0] 12 function set, functions explanation: method all 'object' 0.1) using b; and this.a output. tax(price, null * object fn passed context additional method. "salad"}, number 105 tax.callpolyfill({item: [{"a": 5}. arguments solve because (that sets taxrate) undefined it's cost 1 not add(b) 100 (1 args 1.1 is the output: obj 11". belongs burger appropriate input: you taxrate}`; `the args.length constraints: 7 have enhance please 7); on). // however, == 5}, 1: "burger"}, was = call function with custom context call function with custom context call function with custom context call function with custom context call function with custom context
false four, that of - exists given return if up: x input: you 2: without an constraints: power there 3: 4x. solve four. n it false. <= follow n, 16 loops/recursion? integer 231 1 otherwise, example 5 a == true such 1: could -231 is output: = power of four power of four power of four power of four power of four
of nums[i], this any element largest first our denotes there back obtain are end be with <= non-empty removed empty, after since note example a also option k 109 -1 moves, k, top that remove [5,2,2,4,0,6], pile, becomes which if return one to value 2: made. an 4 way maximum total exactly at as perform topmost either nums.length explanation: new them moves onto following: only [2,4,0,6]. - or moves. [5,4,0,6]. [2,2,4,0,6]. contents -1. elements, number 105 0-indexed 3: array add case nums it possible answer shown 1 not 5 pop more pile. the is output: we step 0 ways given element. input: you follows: 4: 2. constraints: [2], representing can nums[0] integer where in pile [4,0,6]. 1: move, 5. = maximize the topmost element after k moves maximize the topmost element after k moves maximize the topmost element after k moves maximize the topmost element after k moves maximize the topmost element after k moves
of any select palindrome. lowercase obtain are be <= "baab". letters. note example consists a also make "tleelt" palindrome will that return one to 2: adjacent 2 "letelt" from input as 2000 english explanation: "letetl" always string moves generated using and only than -> - moves. "lettel". s, other number them. "abab" palindromes needed "baab" it s possible "abba" s.length shown 1 not finite such converted "aabb" characters thus, the is output: we less moves: ways given input: you 2. constraints: minimum swap obtained can in "abba". 1: two move, consisting = minimum number of moves to make palindrome minimum number of moves to make palindrome minimum number of moves to make palindrome minimum number of moves to make palindrome minimum number of moves to make palindrome
balls.length different. 3] actual of 1,1], 180 this for 1,1] 6 different size ways, first [3,2 equal. color [] [a] [2,1 i. [b] / n are 8 be with 2,1], random, boxes randomly <= considered [1,3 after [2,3 [1,2 but note example (), a k even. answers will that probability 8/12 if return 1/12): one to value 2: 4]. remaining an 2 balls box. at explanation as carefully). 2,3], 2, shuffled 0.66667 12 these distinct (please explanation: b, 108 them [1, all [1,1 sum(balls) check easy and only 3,2], display than [1,1] that, - uniformly 1.00000 other random number 3: then array add 1,3], balls. it possible 0.60000 each (b) set correct. hard 1 balls[i] both [2,1,1] divide box the is output: 1, we distribute (a) see 0.6 ways given input: you [3,1 distribution 3,1], (i.e. 4, colors. 2n constraints: colors equal 10-5 read have [1,2,1,2] please accepted 2/2 can within may second integer where in 1,2], shuffles 3, same ball 1: example, two equally: distributions = probability of a two boxes having the same number of distinct balls probability of a two boxes having the same number of distinct balls probability of a two boxes having the same number of distinct balls probability of a two boxes having the same number of distinct balls probability of a two boxes having the same number of distinct balls
of [3, unique. for 6 are <= be with integer. after i [3,2,1,2,1,7] example a make moves, index that return one to value 2: < test an impossible every 2, nums.length explanation: 1. [1, all moves fits generated 3]. and pick or 32-bit number 105 5, array 7]. nums it by [1,2,2] answer 1 shown nums[i] 5 so is the output: 1, less 0 given input: you 4, constraints: minimum have unique can integer in where increment cases nums. values. 1: move, could = minimum increment to make array unique minimum increment to make array unique minimum increment to make array unique minimum increment to make array unique minimum increment to make array unique
of + x. low our denotes over are <= be after i note example a 109 |nums[i] |x| prove most that which becomes return value to 2: < score maximum at 0, elements when 3 nums.length now, explanation: all absolute always and high [6,6,7,8,5]. minimal. 3. 6. - |6 scores nums[1] [1,4,3] 105 0-indexed array case nums possible sum [1,1,1]. 1 nums[i] nums[2] |8 achieved so 0. nums.length. the is output: minimize 1, we now 0 given 5| changing input: you 4, constraints: equal minimum nums, 6| can nums[0] integer j in 3, [1,4,7,8,5] nums. 1: two nums[j]| change = minimum score by changing two elements minimum score by changing two elements minimum score by changing two elements minimum score by changing two elements minimum score by changing two elements
varchar of this bob@example.com for smallest select script, first email. john@example.com emails are with repeated letters. following type after final note example uppercase a table. driver will that id person result one code to an 2 primary row show name 3 running column explanation: 1. all piece keep table and only | times. key delete contains format compile your then contain +----+------------------+ +-------------+---------+ each answer order shown 1 not emails, table: is the output: we write duplicate you input: matter. query id. does unique sql example. statement supposed in int one. keeping run 1: two email = schema delete duplicate emails delete duplicate emails delete duplicate emails delete duplicate emails delete duplicate emails
= that no least the of nums[i], - 0 given return input: 6 2: smallest [3,6,2,7,1] positive 1000 an subarray's 2 elements. number 4 constraints: subarray there array elements k. contiguous are nums within by <= nums.length non-empty integer where are: explanation: 1 divisible example all a common multiple sequence 1: k [3], subarrays and [3,6,2,7,1], is output: array. k, number of subarrays with lcm equal to k number of subarrays with lcm equal to k number of subarrays with lcm equal to k number of subarrays with lcm equal to k number of subarrays with lcm equal to k
false of this incorrect nums[4] [10,-2] [1,2,3,4,10,-2] (i-1)th there [1,-1,0,1,-1,-1,3,-2,0]. contiguous are n be <= must [[1,-1,-1],[3,-2,0]], array. share groups[i].length, choosing i note example a also 1st k groups.length index 103 that no if return appears one to 2: an come from 0, as elements asked before task, [1,2,3,4]. nums.length [[1,2,3],[3,4]], 2d these explanation: > true groups[i][j], subarrays length and groups. only they groups[i] than groups). (0-indexed), disjoint n. otherwise. ith subarray 3: array 0th because nums sum(groups[i].length) order 1 groups not common such sequence more is the output: subarray. belongs given choose element. input: you (i.e. constraints: equal (0-indexed). [7,7,1,2,3,4,7,7] [[10,-2],[1,2,3,4]], can within nums[k] disjoint. -107 do integer in invalid same [1,-1,0,1,-1,-1,3,-2,0] == nums. 107 1: = form array by concatenating subarrays of another array form array by concatenating subarrays of another array form array by concatenating subarrays of another array form array by concatenating subarrays of another array form array by concatenating subarrays of another array
104 of non-empty, subsequence, for zero) largest order. <= be must non-empty i example a (can satisfied. [10, k -1 k, that j, condition return 2: < number. remaining an 2 [10,-2,-10,-5,20], every maximum from -2, elements some 2, nums.length explanation: original and -104 20]. [10,2,-10,5,20], - 23 number 105 5, their 3: deleting array -5, integers nums by sum 1 nums[i] so such subsequence is the output: we consecutive 37 given choose input: constraints: obtained nums[j], leaving array, integer in where j 1: [-1,-2,-3], two = constrained subsequence sum constrained subsequence sum constrained subsequence sum constrained subsequence sum constrained subsequence sum
write (x (123) means bash text that assume (xxx) of line), per given numbers. or one contains to you line 456 should print number output appear 987-123-4567 valid one-liner file script 7890 your has (one contain phone numbers: digit) may each must 123 following leading in trailing xxx-xxx-xxxx. not file.txt all formats: a also numbers 456-7890 list content: two example: spaces. the xxx-xxxx white valid phone numbers valid phone numbers valid phone numbers valid phone numbers valid phone numbers
104 * of pair + - values j: given return [8,1,5,2,6] 0 minus input: value you 2: < values.length score 1000 an between 2 constraints: spots, values[j] maximum them. ith have is array 0, are (i 2, 8 <= sightseeing sum spots. integer where j i explanation: [1,2] 1 example 11 5 spots a j) represents 1: spot. two and distance the output: = values[i] best sightseeing pair best sightseeing pair best sightseeing pair best sightseeing pair best sightseeing pair
its top point grid[i].length of sum. which 0 given numbers, or right, any grid x to you filled time. input: output: note: 2: [[1,2,3],[4,5,6]] 200 m right constraints: → from 7 at because n can path. <= with 3 m, either down sum 12 grid[i][j] in explanation: 1 example non-negative all a only numbers == [[1,3,1],[1,5,1],[4,2,1]] left move find along 1: path grid.length the minimizes bottom = minimum path sum minimum path sum minimum path sum minimum path sum minimum path sum
smaller will minutes actual of 0 given numbers, return input: value 2: 59 (in 30 between formed degrees) constraints: 12, minute hand. 10-5 3: as minutes, accepted within be <= 165 12 correct. 1 3, example 75 7.5 hour angle 1: two answers and 15 the output: = angle between hands of a clock angle between hands of a clock angle between hands of a clock angle between hands of a clock angle between hands of a clock
104 of needs this + for any longer lowercase "abaac", color blue, on there has asks n are be [1,2,3,4,1] "aabaa", <= neededtime[i] letters. balloons help. example a balloon blue make index alice will that no remove 4. return to 2: 2 from total at some 'a' english 3 colorful. indices explanation: image, string already takes want neededtime and only above 3. need ballons 'b' rope. seconds) [1,2,3,4,5] contains (in time 105 0-indexed ith 3: array wants it "abc", each ballon she 1 not balloon. so [1,2,3] rope the is color. output: consecutive color, 0 given remove. input: you red, colors.length arranged 2. constraints: colors minimum green. does can second integer where bob in seconds. same == colors[i] 1: two 'c' neededtime.length = minimum time to make rope colorful minimum time to make rope colorful minimum time to make rope colorful minimum time to make rope colorful minimum time to make rope colorful
of for any "abcdabc". lowercase first happen equal. / are <= operations be letters. following since operation i note example consists a letters again "aabaab". needed. "aaaaa" that 4. if return one to 2: 2 can: 4 maximum "ab". "abc" english used 3 now, explanation: all proven string "ababc", and only - or delete s, s. number "abcabcdabc" 3: then because needed it occurrence s "abc", each s.length 1 not operation, 5 both so ("abc") the range is output: we get given next input: you "aaabaab" 2. "aab". constraints: equal does can letter cannot second in ("aab") ("a") 4000 1: example, two could entire consisting = maximum deletions on a string maximum deletions on a string maximum deletions on a string maximum deletions on a string maximum deletions on a string
[1000000,1000000,1000000], of 999999. 999999 has be with <= arr.length difference following min example make calling |func(arr, that return to value 2: < an target|. 2 r func thus 1000000, arr.length. function r) explanation: pairs [1,2,4,8,16], all always find and above results - [l,r] 106 mysterious should got 105 3: [[0,0],[1,1],[2,2],[3,3],[4,4],[0,1],[1,2],[2,3],[3,4],[0,2],[1,3],[2,4],[0,3],[1,4],[0,4]], array target arr wants target| possible winston 1 5 called is the output: 0 values given arr[i] input: notice 2. constraints: l minimum 7 closest possible. he integer where 3, [9,12,3,7,15,8,0,3,7,0,0,3,0,0,0]. 107 1: func. l, was [9,12,3,7,15], = find a value of a mysterious function closest to target find a value of a mysterious function closest to target find a value of a mysterious function closest to target find a value of a mysterious function closest to target find a value of a mysterious function closest to target
non-decreasing 3. that negative of words, [-2,-1,-1,1,2,3] 0 4. given return if among up: input: you 2: nor positive [-3,-2,-1,0,0,1,2] other an between 2 time integers. complexity? 4 number constraints: maximum pos there 3: order. is array then solve integers 2000 are nums can <= 3 negative. follow o(log(n)) nums.length in neg. explanation: neg, 1 note example them nums[i] problem a order, 1: count [5,20,66,1314] sorted and the output: = neither -2000 maximum count of positive integer and negative integer maximum count of positive integer and negative integer maximum count of positive integer and negative integer maximum count of positive integer and negative integer maximum count of positive integer and negative integer
will 104 subarray. that 6. * of product, 0 result given return any product or input: 6 2: to test largest 32-bit an fit 2 -10 constraints: [-2,0,-1] nums, 10 subarray has is array because are nums 2, be <= integer. nums.length cannot integer in guaranteed answer [-2,-1] explanation: [2,3] 1 prefix cases example nums[i] not a suffix so find generated 1: product. and the [2,3,-2,4] output: = maximum product subarray maximum product subarray maximum product subarray maximum product subarray maximum product subarray
"caa" b. of any lowercase are operations <= consider letters. following example a best make character that condition return one to 2: three 2 b every way "dabadd", 3 done 3) (either distinct explanation: "bbb" 3). true and operations, only than or true: "aba", number 105 b.length your satisfy then a.length, "cda" needed by each 1 operation, both letter. the is output: "aaa" conditions: less given changing input: you alphabet. goal 2) achieve constraints: consist strictly minimum can a. "ccc" letter 1) in goal. strings "eee". 1: two was change = change minimum characters to satisfy one of three conditions change minimum characters to satisfy one of three conditions change minimum characters to satisfy one of three conditions change minimum characters to satisfy one of three conditions change minimum characters to satisfy one of three conditions
its palindromic of consisting steps "bb" order. 'b'. are be <= reads removed note example palindrome, a "b" make letters "". palindrome that backward remove return if one to 2: without 2 from forward. as some 'a' single "b". either explanation: string already generated and only "a" "ababa" need -> or "baabb" s. entirety number 3: deleting then "baab" it by s s.length necessarily 1 not "bb". so s[i] subsequence called characters well empty. the is output: step given changing input: you 1000 constraints: minimum does contiguous. can in "abb" same 1: step. = remove palindromic subsequences remove palindromic subsequences remove palindromic subsequences remove palindromic subsequences remove palindromic subsequences
its of given return input: 2: an constraints: 7 <= representation. -107 integer -7 base example "-10" num, "202" a string 107 1: 100 num output: = base 7 base 7 base 7 base 7 base 7
parents is: of tree. for product size there root, has i. n are score. <= node, consider non-empty 4) since parent i tree, highest example a subtrees. -1 edges that it. connected if return one to 2: score three 2 4 from rooted at (node nodes node 2, != 3 parents[0] explanation: 1. [-1,2,0,2,0] all find labeled and binary tree * - or -1. number removed. 105 valid 0-indexed array parents.length it each 1 [-1,2,0] those more is the output: 1, 0 given input: you 4, nodes. constraints: representing would have parents[i] 1) integer where in were 3, == represents sizes become 1: subtree two consisting = count nodes with the highest score count nodes with the highest score count nodes with the highest score count nodes with the highest score count nodes with the highest score
its this store losing -3 for 3.33333.. dividend, truncated are be -2.7335 with <= 10, after -2.33333.. truncate example signed environment that assume range: which return if to 2: without division an != 3 explanation: 8.345 part. using and − -231 only zero, divisor, 3. fractional than - 10/3 8, 32-bit should then operator. toward integers by -231, greater divisor. 7, 1 dividing problem, divide -2. is the output: 1, we 7/-3 1]. less means [−231, 0 divisor given input: note: mod constraints: strictly would dealing multiplication, dividend quotient within integer 231 -2 1: example, two could division, = -231. divide two integers divide two integers divide two integers divide two integers divide two integers
its 100001 linked of [5,4,2,1] this + for 6 respectively. size present 7. [2, there / n are <= with n, node, head 4) i twins 105]. example (0-indexed) a length, having node.val no 4. if return one 2: an 2 4 maximum 100001. as nodes node 2, 3 max(7, these explanation: 1. all [4,2,2,3] and only 6. - other number 105 ith 3: then even twin. even, twin sum 1 known list thus, is the range output: 0 given [1,100000] input: 4, 2) (n-1-i)th (n 2. defined constraints: 7 100000 have integer in where are: 3, 1: example, list. = maximum twin sum of a linked list maximum twin sum of a linked list maximum twin sum of a linked list maximum twin sum of a linked list maximum twin sum of a linked list
of [1,2,1,2,4,1,5,10]. this any for [3, 7] [7,7,7,7,7] sequences. arithmetic [7, removing subsequences are be <= integer. difference [2,4,6,8] example consists a numbers (possibly 9], that return if same. 2: test three an at elements -1, some [4,6,8] 2, nums.length explanation: [1, all [4,6,8,10] [2,4,6,8,10] fits generated and arithmetic. -231 least - [2,5,10] 32-bit formed number 5, array -5, nums it by 7, answer 1 nums[i] not [2,6,10] so sequence subsequence called none) [6,8,10] the is output: 1, consecutive sequence. = -9] given input: 1000 between constraints: 7 nums, can 16 integer 7], in are: 231 3, cases nums. slices 1: example, two [2,4,6] array. arithmetic slices ii - subsequence arithmetic slices ii - subsequence arithmetic slices ii - subsequence arithmetic slices ii - subsequence arithmetic slices ii - subsequence
104 (5,2,10,1) (6,2,4,3) of d) (2,6,4,3) tuples: (2,5,10,1) (3,4,6,2) there a, are 8 <= example a (2,10,5,4) (6,2,3,4) that (1,10,5,2) (10,2,4,5) return 2: an (4,5,10,2) (5,4,2,10) b [1,2,4,5,10] elements (4,3,6,2) != nums.length (2,10,4,5) distinct explanation: b, (10,1,5,2) all and (a, * positive (2,5,1,10) number (5,2,1,10) valid array nums 1 (10,2,5,4) nums[i] distinct. tuples , such (3,4,2,6) (4,5,2,10) the (4,3,2,6) output: (10,1,2,5) given input: 1000 (2,6,3,4) constraints: (1,10,2,5) nums, integers, c, 16 (5,4,10,2) where in d. c [2,3,4,6] 1: d = tuple with same product tuple with same product tuple with same product tuple with same product tuple with same product
104 of 'a'). endi for shift around lowercase shifts "catz". 'z' [starti, 'z'). alphabet are <= with letters. s.length, after final example consists a firstly, letters endi, character [[0,0,0],[1,1,1]] index applied. backward that becomes if return shifting to 2: < 2 every similarly, "ace" from forward. finally, 'a' english "zac". 3 2d explanation: all string "zbd". and directioni]. * or secondly, "ace". starti (inclusive) backward. array it s "abc", s.length shifts[i].length 1 5 so such 0. shifts[i] characters directioni the (wrapping output: 1, now means replacing 0 given next input: you "catz" constraints: forward letter integer where in shifts.length previous [[0,1,0],[1,2,1],[0,2,1]] "cztz". == 1: "dztz", = i, shifting letters ii shifting letters ii shifting letters ii shifting letters ii shifting letters ii
"1". of very + binary.length for modulo "10", "0", "001" "101". 7. has subsequences "11"]. empty derived are be <= exception leading considered since "1", note example consists a 109 ["1", "1"], "001", '0's no "0" that if return 2: without remaining "00", zeros. 2 from "1"]. "11". elements some explanation: all string find "101"]. and they binary only or "101" large, elements. number 105 3: deleting binary. then because it by zeros answer order 1 (with not 5 so "01", good subsequence sequence "11", the is output: "0"). given changing input: you '1's. constraints: have unique can ["0", may another 1: example, "1" "11" = number of unique good subsequences number of unique good subsequences number of unique good subsequences number of unique good subsequences number of unique good subsequences
[[1],[1,3],[1,3,5],[3],[3,5],[5]] [1,3,5] sums of odd very + 0 4. given return arr[i] sum. modulo input: 2: arr, an large, sub-arrays [[2],[2,4],[2,4,6],[4],[4,6],[6]] 7. number 4 constraints: 105 [1,4,9,3,8,5]. 3: have is array arr even integers [2,6,12,4,10,6]. are it can [1,9,3,5] be with <= arr.length 16 sum since answer explanation: 1 example all so [1,2,3,4,5,6,7] 1: 109 0. 100 subarrays [2,4,6] and the output: = number of sub-arrays with odd sum number of sub-arrays with odd sum number of sub-arrays with odd sum number of sub-arrays with odd sum number of sub-arrays with odd sum
red that no points.length of 0 xi, given return widest points[i] y-axis one input: [xi, 2: an [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]] between plane 2 points[i].length constraints: maximum fixed-width 105 area. on is extending points n are included infinitely with 3 <= yi], 2d width. considered where in infinite area height). edge [[8,7],[9,9],[7,4],[9,7]] note (i.e., example not 1 explanation: a == blue both yi such vertical along 1: two 109 and inside the output: = optimal. widest vertical area between two points containing no points widest vertical area between two points containing no points widest vertical area between two points containing no points widest vertical area between two points containing no points widest vertical area between two points containing no points
4] of + for 8] conver [2, 16] 5], over 64 i. 32] n ans[i] 8 56 <= arr. n, conver[i] prefix example [4, 20] also a 36 109 16, return 24 value 2: score an [1,1,2,4,8,16] 2 4 maximum 10 as define 2, 14, nums.length hence explanation: [1, 12] length 6] [4,10,24,36,56] 8], nums[0..i]. 32 8, 16], 2] [2,3,7,5,10] 14] 105 5, 0-indexed 12, 1], array arr nums arr[j] 3], sum 7, 1 nums[i] [2] 4], the is output: [2,4,8,16,32,64] 1, we conversion 0 values [1], given arr[i] follows: input: ans 4, constraints: [2], 10], 6, 16 integer where j max(arr[0..i]) 7], 3, 2], [4] 1: = find the score of all prefixes of an array find the score of all prefixes of an array find the score of all prefixes of an array find the score of all prefixes of an array find the score of all prefixes of an array
xi+1 of this x1 for any xi largest cycle cycle. lowercase color there k. n are <= bj] numbered image). letters. i edges. example consists a also -1 edges edges[j] most edges.length that graph return if to value 2: < 2 m every 4 from nodes english node 3 2d edge explanation: 1. string aj, indicates along and [[0,1],[0,2],[2,3],[3,4]] "a" above -> - directed or contains bj x3 number 105 valid ith array xk bj. frequently 1 colored such sequence 0. is path. the output: 0 given "a", x2 graph, input: you [[0,0]] aj occurring colors.length constraints: colors "abaca", representing (0-indexed). ... letter where in (red == colors[i] 1: [aj, path = largest color value in a directed graph largest color value in a directed graph largest color value in a directed graph largest color value in a directed graph largest color value in a directed graph
false toeplitz what once? of [[1,2,3,4],[5,1,2,3],[9,5,1,2]] "[3, [[1,2],[2,2]] different 2]" on has "[1, n are load <= m, stored example a diagonal matrix, matrix[i][j] most that return if disk, one to 2: an m every up large from matrix row 5]", at elements 2, follow explanation: all 2]", matrix.length limited true "[5, and only above into partial up: "[2, 20 elements. "[9]", false. each bottom-right answer 1 memory so such 3]", matrix[i].length "[4]". diagonals the is output: 1, 0 given x input: you toeplitz. constraints: same, can 1]", in are: top-left otherwise, true. same 99 == 1: grid, = toeplitz matrix toeplitz matrix toeplitz matrix toeplitz matrix toeplitz matrix
104 allowed.length the words of ["cc","acd","b","ba","bac","bad","ac","d"] "acd", given if return input: you 2: consistent. allowed. consisting words.length an consistent they 2 4 number constraints: lowercase appear "d" 7 10 3: words[i] array contain ["ad","bd","aaab","baa","badab"] 'b'. "cc", words[i].length words. are 'a' english <= "abc", "ab", "baa" letters. since in "aaab" distinct explanation: 1 "cad", example strings all allowed a only ["a","b","c","ab","ac","bc","abc"] "ac", string distinct. 26 1: characters and is output: = count the number of consistent strings count the number of consistent strings count the number of consistent strings count the number of consistent strings count the number of consistent strings
104 is: of product 6 7. there / itself. are 8 10080 <= integer. factor note example a 210. 1024 4. return if 2: an 2 4 10 elements [2,4,3,7,10,6] 3 prime nums.length distinct explanation: 1. all and only than * positive 32 number factors array integers nums it by [2,4,8,16] greater 1 divisible nums[i] 5 so called is the output: we val1 given val2 input: 1000 25 constraints: 7 nums, that: another 16 integer in nums. 1: = distinct prime factors of product of array distinct prime factors of product of array distinct prime factors of product of array distinct prime factors of product of array distinct prime factors of product of array
false of + this for any mass, 22. 21. 23. planet order. are collides last be with <= 10, after ever 23, example a [3,9,19,5,21] [9,19,5,3,21]: enough 9 will which collision if return one to 2: an destroy destroyed. way 46 gain 4 10 3 destroys 67 explanation: new all true original and arbitrary 3. than - or destroyed planet. mass: other 19 5, 105 ith array [4,9,23,4] false. 19. it greater order 1 further 5 not asteroids so 21 arrange 9. asteroids, is the output: less given input: you 43 38 gains constraints: equal would asteroid, have mass asteroid asteroids[i] can cannot integer where in asteroid. otherwise, collide represents 1: asteroids.length 5. = destroying asteroids destroying asteroids destroying asteroids destroying asteroids destroying asteroids
red positions [3,3] attack of any unique. king. there on yqueeni] king order. 64 are 8 [[2,2],[3,4],[4,4]] be with <= example black (i.e., a also chessboard. directly that xqueeni, position return one 2: < three an 2 marked coordinates 2d explanation: yqueeni, all ad chessboard, length and above shows xking, [xking, [[0,1],[1,0],[3,3]] 0-indexed ith queen array diagram [[0,0],[1,1],[2,2],[3,4],[3,5],[4,4],[4,5]], answer 1 yking] the output: queens[i] 0 given yking x input: you constraints: queens.length king.length queens[i].length queens can may cannot integer where in dashes). == [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]], [xqueeni, represents multiple [0,0] 1: = white queens that can attack the king queens that can attack the king queens that can attack the king queens that can attack the king queens that can attack the king
varchar of this for any 124 about order. has 2018-12-18 following type example country, +------+---------+----------+--------+------------+ 2018-12 +---------------+---------+ table. us id declined result return to an 2 primary 2019-01-07 trans_date 2018-12-19 total 2000 3000 name country column de "declined"]. table find and | key incoming format date approved_total_amount number information amount their 2019-01-01 trans_total_amount state enum each transactions 1 approved amount, table: the is month output: +----------+---------+-------------+----------------+--------------------+-----------------------+ write 122 approved_count input: 1000 amount. query sql example. ["approved", trans_count 123 transactions. in int 2019-01 1: 121 schema monthly transactions i monthly transactions i monthly transactions i monthly transactions i monthly transactions i
"bab". * of given return substrings "ba", contains input: 2: s, "aba", ["a", 4 constraints: lowercase maximum 105 order. "abab" is "leetcode" "b", are english last s "abab", <= lexicographical "ab", substring letters. s.length in explanation: 1 example "bab"]. a only string lexicographically 1: "tcode" the "bab" output: = last substring in lexicographical order last substring in lexicographical order last substring in lexicographical order last substring in lexicographical order last substring in lexicographical order
during work is: finish of 6th working. for 6 has. 7. rules: denotes there on are n last be <= numbered must following rules, projects week scenario note example a 1st project. able 109 due finished, will rules. milestones.length that 3rd if return one to 2: without above. violate an violating every maximum from total exactly mentioned unfinished. [5,2,1] 2nd cause these explanation: 1. 7th all only above 6. milestones[i] - 5th or stop project's number 105 ith array because it possible each 8th 1 not rules once [1,2,3] weeks. 0. thus, the is output: consecutive week. week, 0 given input: you 2. constraints. constraints: remain would 7 weeks can may cannot integer where milestone in same project == 1: two milestones 4th = maximum number of weeks for which you can work maximum number of weeks for which you can work maximum number of weeks for which you can work maximum number of weeks for which you can work maximum number of weeks for which you can work
"world" = will 104 least words the of 6. fly 4. world" given return word one input: to 2: 6 ' consisting " s. spaces 4 constraints: maximal spaces, 3: still there at string. "luffy '. english me s last "hello non-space with joyboy" "joyboy" <= be only. in s.length explanation: 1 example 5 "moon" consists a only string moon letters 1: characters length and is 5. output: substring length of last word length of last word length of last word length of last word length of last word
batchsize. [1,3,2,5,2,2,1,6] of 6th visit customer any 30 first denotes over there is, are be <= shop, must donuts following after example a freely 9 109 groups.length batches will that serving if return one [6,2,4,5,1,3]. 2: an 4 4th, maximum from donut. 1st, exactly batch. as before when batch donut explanation: all happy. and groups. they groups[i] served number shop. then array receive possible fresh each 1 2nd, not groups serve groups, customers happy arrange is the output: group. rearranging get ordering given next input: you 4, constraints: donuts. batchsize have rearrange does [1,2,3,4,5,6] group can shop integer in where rule bakes previous 3, left visits 1: was = maximum number of groups getting fresh donuts maximum number of groups getting fresh donuts maximum number of groups getting fresh donuts maximum number of groups getting fresh donuts maximum number of groups getting fresh donuts
its iswater assignment. of solutions, north, any cell [[1,1,0],[0,1,1],[1,2,2]] size assigned rules: cells. there [[0,0,1],[1,0,0],[0,0,0]] has are n land be maximized. <= m, must difference east, iswater.length (i.e., example a also blue water most directly will that follows if return one accepted. to 2: adjacent an 2 m way maximum matrix j)'s still at [[1,0],[2,1]] touching). 0, map assignment height[i][j] these explanation: 1. cells absolute find and cell, shows least iswater[i][j] or west heights height. (i, assign them. their possible each non-negative. south, 1 image latter rules such 0. the is output: 1, cell. 0 height given x input: you iswater[i].length [[0,1],[0,0]] 1000 constraints: have green another meeting integer in where == while j) represents multiple 1: two former = sides map of highest peak map of highest peak map of highest peak map of highest peak map of highest peak
customers[i] 104 finishes actual of arrives + customer for timei]: 6 7. first there order. restaurant / [[1,2],[2,5],[4,3]] are 8 <= with 4) considered 10, example customer. a order, arrivali, prepare idle. solutions 4. return one accepted. to 2: customers.length an 2 times starts 4 prepares from 10 at [[5,2],[5,4],[10,3],[20,1]] when customers. single 2, 14, 3 preparing 3.25. 3) explanation: arrivali 1. input. all takes and (2 waits they 11, fourth than 6. - time. 3.25000 8, 20, time 20 his average third 5, 105 ith 14 array customers, needed it 5.00000 arrives, 7, answer order 1 not gives 5 7) once so customers 21 more the is output: 1, chef. non-decreasing 21, timei given input: you 4, 2. 2) immediately constraints: 10-5 7 does he arrival within arrivali+1 1) second where in were 3, 11 till [arrivali, food 1: sorted waiting 5. chef = average waiting time average waiting time average waiting time average waiting time average waiting time
its of tree. voyage. any for unique. smallest assigned [] order. [2,1] are n be with <= swapping following pre-order example a also subtrees. voyage.length make flipping will that swaps no which return if value to 2: impossible 2 flipped. from nodes node voyage explanation: all already and binary tree need [1] voyage, flip number n. 3: desired it by each answer 1 [1,2,3], list so [1,2,3] such sequence 100 the is output: [1,3,2] values given input: you nodes. right traversal constraints: effect: have nodes, voyage[i] flipped matches node.val, can may tree's where in uniquely 3, root match == left 1: example, [-1] [1,2], = [-1]. flip binary tree to match preorder traversal flip binary tree to match preorder traversal flip binary tree to match preorder traversal flip binary tree to match preorder traversal flip binary tree to match preorder traversal
(2, (inclusive). of special, for unique. rented space. denotes floor: floors has are be with top, <= following floor. building example [7,6,8] floors, a also relaxation 109 bottom alice top special that decided which return to 2: without [4,6] 2 every maximum from total as some used 2, 3 9, 3) only. these explanation: all 5) floor, and (5, office - 8, should number 105 (inclusive) amount array integers denote 1 so 9) therefore, 0. the is output: consecutive we company 0 values given input: you manages constraints: designated 6, relaxation. integer where special[i] floor special.length (7, floors. 1: two ranges = maximum consecutive floors without special floors maximum consecutive floors without special floors maximum consecutive floors without special floors maximum consecutive floors without special floors maximum consecutive floors without special floors
words[i], (4+5) lower of words, any word "good" respectively. ["z","a","b","c","x","x","x"], [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10] a=4, letters.length score[0], 21. "xxxz" ["xxxz","ax","bx","cx"], necessary ["leetcode"], 23. d=5, ["l","e","t","c","o","d"], score[i] be with <= character. letters. 'b', example a letters [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0] [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0] (words[i] use b=4, return times). to once. ["a","a","c","d","d","d","g","o","o"], 2: score every (3+2+2+5) a=1, maximum 10 "ax" 'c', letters[i] single used english "bx" "cx" explanation: all 25. 26 using (might ["dog","cat","dad","good"], and 15 only repeating) letters, "dad" ,'z' or contains 23 formed 27 o=2 valid 3: 14 "e" words[i].length case 'a', x=5, it by each set 1 not list , c=9, form 100 characters more g=3, is the output: we score[1], score.length get words c=4, 0 given input: words.length 27. "dog" constraints: (5+1+5) letters[i].length ... can letter cannot (4+5), in == score[25] z=10 1: two = maximum score words formed by letters maximum score words formed by letters maximum score words formed by letters maximum score words formed by letters maximum score words formed by letters
bits its minimal. that of 1100, 0 given return x. 0011 x 1's num1 num2, value input: positive test output: respectively. 2: an 0101, 2 num1, number determined. constraints: representations has is that: as integers are <= representation. 3 12 set integer in num2 uniquely explanation: xor 1 note same bitwise cases example 3, 5 such find generated 1: two 0001 109 and the operation. binary = 1, minimize xor minimize xor minimize xor minimize xor minimize xor
false (inclusive). case, 3. valid. this matrix[i][j] if given return or contains x to input: 2: matrix, an 2 hence, every constraints: first valid from matrix row is contain integers n false. 2, <= do integer in column explanation: 1 otherwise, but 3, example true. not all == matrix.length numbers true 1: 100 matrix[i].length [[1,1,1],[1,2,3],[1,2,3]] and the [[1,2,3],[3,1,2],[2,3,1]] output: = 1, we check if every row and column contains all numbers check if every row and column contains all numbers check if every row and column contains all numbers check if every row and column contains all numbers check if every row and column contains all numbers
= "()()". 104 . just the * of parentheses 0 given return or input: '(', 2: "()". 2 (well-formed) containing ')', 4 constraints: "(()" valid 3: "" is '(' s <= 3 s.length explanation: example a string s[i] ")()())" 1: characters length and longest output: substring ')'. longest valid parentheses longest valid parentheses longest valid parentheses longest valid parentheses longest valid parentheses
initialize 104 [4], of void [null, calls size 21. index) []] there has are <= with be numbered non-empty example a right) -1 index now: top most will pop, that no [5], 4. if pop() to value an 2 4 output maximum from [20], [21], 20. input row still at 0, "pop", null, "pop"] ﹈ implement 2, "push", 3 val capacity. infinite explanation: 1. leftmost all stacks dinnerplates(2); and d.pop() 3. than * into or object -1. 20, push, 20 class: number 105 5, d.push(20); stacks. capacity) val) it each pushes 1 d.popatstack(2); 5 popatstack(int 21 d.push(3); stack empty. is the 1, less dinnerplates d.popatstack(0); made stack, 21, [1], 0 initializes given d.push(4); (left you d.push(2); arranged 4, popatstack. 2. -1] rightmost [2], [[2], constraints: have d.push(21); removes d.push(5); d.push(1); returns integer in // 3, same push(int int dinnerplates(int capacity ["dinnerplates", 1: "popatstack", [], [3], [0], 5. d = dinner plate stacks dinner plate stacks dinner plate stacks dinner plate stacks dinner plate stacks
["mapsum", of + void [null, mapsum() calls ["apple", design 5] lowercase existed, key-value "sum"] mapsum.insert("apple", be with <= insert(string letters. prefix example value. a object. will most that if return to value 2 starts output prefix. input [[], ["ap"], at explanation map null, implement english 3 val allows 3) new (apple mapsum.insert("app", all 5) string already original mapsum(); following: and only key pair into sum(string pairs' 50 maps map. class: overridden whose string. ["ap"]] val) mapsum 3], sum prefix.length key-val mapsum.sum("ap"); 1 5 key.length, ["app", the key, made 2); 3); values initializes given sum. you insert 1000 constraints: equal consist have prefix) inserts "insert", returns do "sum", // 3, int one. 2], 1: app = map sum pairs map sum pairs map sum pairs map sum pairs map sum pairs
addnum(int 104 3] actual of medianfinder() + void [null, for ["medianfinder", calls how data element "findmedian", size [2,3,4], []] there middle solution? / 99% adds are be 2.5. <= "addnum", example (i.e., arr[1, numbers object. stream calling answers will most no if return one accepted. value to structure an 2 output 2.0 from input [[], at explanation elements "findmedian"] null, far. findmedian. before implement 2, follow 3) optimize new value, [1, all medianfinder.addnum(1); addnum and (2 num 3. least 2.0] medianfinder(); * [2,3], [1] up: 2] class: 105 your ordered arr medianfinder num) mean medianfinder.addnum(3); even, answer 5 list so 1.5 (1 is the range structure. made findmedian() [1], double initializes medianfinder.findmedian(); 1.5, you median 100], 2) constraints: [2], 10-5 would within [0, returns medianfinder.addnum(2); -105 integer in // values. 1: example, [], two [3], list. = find median from data stream find median from data stream find median from data stream find median from data stream find median from data stream
of [2,0,0,2] + 11. 6 smallest index, 7. labels there has i. are n score. <= with n, since i highest example a edges smaller edges.length that [1,0,0,0,0,7,7,5] graph return if one to 2: < score an 2 4 from exactly as nodes node 2, != 3 edge explanation: 10. 1. all outgoing indicates labeled length and 3. - directed pointing 105 0-indexed array index. by each edges[i] sum score, 1 5 both so 0. is the output: 1, we edge. 0 given input: you 2. represented defined constraints: 7 have edges[i]. integer where same == multiple 1: 5. = node with highest edge score node with highest edge score node with highest edge score node with highest edge score node with highest edge score
[6], of row), this 11. + round, obtain. game, game first there has are last be with ends <= non-empty example a stonevalue.length [6,2,3,4,5,5] alice 500 will several that which becomes if return one value to 2: score remaining an round zero. starts maximum stonevalue. row thrown when alice's row. explanation: [7,7,7,7,7,7,7] rows value, all away. and [4,5,5]. associated only choice into 106 throws row, 5). 28 time equal, calculates 3: [2,3]. stones then array because by lets each sum decide 1 away stonevalue 14. (16 divide (11 18 the is output: now divides 0 values [3]. given next input: arranged (i.e. remaining. right constraints: [2], stonevalue[i] can 16 second integer in bob 11 [6,2,3], stone initially [4] left 1: two increases 2). = stone game v stone game v stone game v stone game v stone game v
130 varchar of 80. this + names for any data 30 about there order. +--------------+--------------+----------+ product_name 70 2020. with following type foreign book example order_date a +---------------+---------+ table. jewels 2020-01-18 2020-03-01 orders unit no that solutions result return to products an rows. 2 primary 4 total at name 3 2020-02-11 3) column explanation: +-------------+-----------------------+------------------+ leetcode (50 table products. lenovo and 60 (2 2020-02-17 50) | least order_date. hp stringology key february contains format 50 date 20 number laptop their ordered 2020-02-24 +------------------+---------+ it 2020-02-05 +--------------------+---------+ 2020-02-10 1 2020 5 not kit 2020-03-04 units table: 100 is the output: 70) write get 2020-02-27 duplicate input: t-shirt amount. query have sql example. product_id may product_category 2020-02-25 130. in (60 int 100. 1: 80 was company's 5. = schema list the products ordered in a period list the products ordered in a period list the products ordered in a period list the products ordered in a period list the products ordered in a period
of + [1,2,3,6] d) there nums[a] are <= nums[b] (1, example a that no return 2: < requirement 2 b 4 nums[c] 2, 3 nums.length 3) distinct explanation: b, (0, [3,3,6,4,5] and (a, only satisfies nums[d], 6. - 50 number [3,3,6,4,5]. 0-indexed 3: satisfy array because nums 1 nums[i] quadruplets 5 [1,1,1,3,5] quadruplet such 100 is the output: 1, 0 given input: constraints: nums, that: 4): c, 3): integer in are: 3, == c 1: d = count special quadruplets count special quadruplets count special quadruplets count special quadruplets count special quadruplets
write = no the of 0 if return among input: to output: 2: ["flower","flow","flight"] 200 an lowercase constraints: strs[i] "fl" there "" ["dog","racecar","car"] input array empty strs.length english <= strings. function letters. strs[i].length longest explanation: 1 prefix example strs consists a common only string find 1: "". is prefix, amongst longest common prefix longest common prefix longest common prefix longest common prefix longest common prefix
nums[1]=1 of [4,0,1,1,3] for any how [8,1,2,2,3] is, there nums[3]=2 [7,7,7,7] are <= array. i (1, example many numbers [6,5,4,8] 500 smaller that it. nums[0]=8 return one to nums[j] 2: < three an 2 2, != nums.length explanation: 3). out find count four and (1). than nums[2]=2 number valid 3: exist array [0,0,0,0] nums it each answer nums[i] not such 100 the output: j's 0 given input: you constraints: nums, nums[4]=3 have does nums[i]. in j [2,1,0,3] 1: 2). = how many numbers are smaller than the current number how many numbers are smaller than the current number how many numbers are smaller than the current number how many numbers are smaller than the current number how many numbers are smaller than the current number
"5323" b. s: of odd any for smallest "2050" add: first "0011". there on back has alphabet "24" obtain are "47" operations corresponding <= following example digits consists a 9 "2454" even. differ, letter, us smaller will that no positions. (of becomes position if return appears comes to 2: 2 times b way "74" from at before 9, either "0158" only. indices explanation: all string post length and '9'. give they above "3951". than cycled '5' - "3456" apply s. number "2050". third 5, 3: "2555" then add because "2353" even "42" integers start: by s "2151" earlier s.length order 1 "5121" "6345". lexicographically sequence "5525" 0. rotate 100 the is output: "5525", 1, we applying 0 "5222" given input: you 4, operations: right constraints: (0-indexed). rotate: can "24". differ letter length) in where "0011", same "0011" 1: example, "0190" two "74", consisting = lexicographically smallest string after applying operations lexicographically smallest string after applying operations lexicographically smallest string after applying operations lexicographically smallest string after applying operations lexicographically smallest string after applying operations
minutes of tree. for whole 6 has are be with <= following 105]. example value. minute, a 9 infection node.val becomes 4. return exists value to 2: adjacent an 2 starts infected 4 from 10 at 0, nodes node 3 start values, explanation: [1, currently start. takes and only binary if: tree - during: number 105 3: uninfected. needed it each node. 1 5 so 0. 0: is the range output: 1, we [1], 0 given input: you 4: infected. [1,5,3,null,4,10,6,9,2], constraints: minute unique integer in root 1: entire = amount of time for binary tree to be infected amount of time for binary tree to be infected amount of time for binary tree to be infected amount of time for binary tree to be infected amount of time for binary tree to be infected
of any size min(26, rules: lowercase has be <= under must following letters. substring example consists a letters conditions, return occur to 2: (between 2 times 4 minsize maximum maxsize). s.length) maxletters 2, english 3 explanation: string original 26 inclusive. and only satisfies than or s, number 105 string. it s s.length occurrences 1 characters the output: maxletters. "aaa" maxsize 1, less given input: "aab" between "aaaa", constraints: equal overlap. unique can in 3, 1: "aababcaab", = maximum number of occurrences of a substring maximum number of occurrences of a substring maximum number of occurrences of a substring maximum number of occurrences of a substring maximum number of occurrences of a substring
tree node.val answer, than the of this search given return if one any never input: output: 2: differs every constraints: [2,1,3,null,null,null,4] number 105 them. there 104]. nodes node [2,1,3] by depth <= with balanced in correct. tree, [1,null,2,null,3,null,4,null,null] explanation: 1 same 1. example root not [1, a only correct [3,1,4,null,2] also values. 1: two subtrees more is range binary = balance a binary search tree balance a binary search tree balance a binary search tree balance a binary search tree balance a binary search tree
of any for 6 element steps there order. are operations with [3,3,6,3], <= consider operation example a make 9 109 that it. here becomes return one to [3,3,6,3] 2: an 2 4 from elements sort 3 nums.length [5,2,4,7]. explanation: already and - [1,2,3,4,5] nums[1] [3,9,3] number 105 0-indexed array [3,3,3,3,3] nums replace sum 1 nums[i] operation, so therefore, 0. is the output: we non-decreasing 0 given [5,6,7]. input: you 2. [3,9,3], constraints: minimum can convert integer in order: nums. 1: example, two sorted = minimum replacements to sort the array minimum replacements to sort the array minimum replacements to sort the array minimum replacements to sort the array minimum replacements to sort the array
104 lower of + for toppingcosts[i] target. basecosts, there cost. cream toppingcosts.length topping are n 8 be with m, <= inputs: n, must consider following type example a make price 9 toppings target, [2,5], flavor. topping. total: most no flavors like [3,4], return if one to 2: 17 three types making an 2 ice m 0-indexed): 4 10 total exactly at basecosts.length as when from. take 3 follow dessert preparing these explanation: base 10. desserts want length and [2,3], - or ingredients. basecosts[i] ith your 3: array add target it [3,10], dessert. possible each 17. cost 18. 1 5 rules 100 more 0: 18 is the toppingcosts, output: (all 0 given choose close input: you x dessert: all. constraints: base. representing would 7 have closest possible. multiple, basecosts can [1,7], basecosts[i], combination cannot integer where toppingcosts one. [4,5,100], == represents buy 1: two = closest dessert cost closest dessert cost closest dessert cost closest dessert cost closest dessert cost
of word for simplicity unique. ' lowercase characters. about has frequency: are must assume: following guaranteed calculate one-line frequency day a space text that assume one to 2 4 output script file words.txt ties, 3 only. word's count using and only descending don't bash or sunny contains sake, should your it by each 1 characters more handling the is words.txt. pipes? write separated following, words you note: consist worry may unix in whitespace content: example: sorted could word frequency word frequency word frequency word frequency word frequency
false apart least of 0 given return if one [1,0,0,0,1,0,0,1], 1's input: output: 1s 2: [1,0,0,1,0,1], places an 2 constraints: third 105 from at is array or are nums false. <= other, each nums.length second integer explanation: 1 nums[i] example all away only true otherwise k 1: other. and the binary = k, check if all 1's are at least length k places away check if all 1's are at least length k places away check if all 1's are at least length k places away check if all 1's are at least length k places away check if all 1's are at least length k places away
104 of [null, for calls 8] largest element design kthlargest.add(5); there class 8 <= with kthlargest.add(3); be guaranteed note example [4, a stream order, k k, most will that [5], [[3, search return kthlargest.add(4); to "add", 2]); 4 output input at explanation elements when implement val nums.length distinct new ["kthlargest", kthlargest.add(10); 2]], find and -104 add. [10], least [4]] stream. object 8, class: kthlargest(int 5, kthlargest array integers val) it 1 [9], nums[i] not 5 the is made 0 initializes kthlargest.add(9); element. you add(int "add"] 4, nums) constraints: representing appends kth returns int[] integer in // kthlargest(3, int nums. 1: [3], sorted = kth largest element in a stream kth largest element in a stream kth largest element in a stream kth largest element in a stream kth largest element in a stream
= that [5,7] least of nums1[i], which exists given return [4,1,3], one unique. contains input: 2: smallest arrays. number constraints: nums2. from nums2[i] nums1.length, at is array unique are it can be 3 <= each [3,5,2,6], [3,1,7] digit in explanation: 1 nums1 example digits nums2, 5 nums2.length proven all both have. 9 1: arrays two nums2 and 15 the output: array. we form smallest number from two digit arrays form smallest number from two digit arrays form smallest number from two digit arrays form smallest number from two digit arrays form smallest number from two digit arrays
first, = that need the of minimal "aa", into 0 given return substrings disjoint contains input: to you 2: other an 2 containing "leetcode", palindrome. lowercase number constraints: split "bb" 3: "ab" then string. k. some are english can it s "aabbc", 3 "abc", 8 each <= non-empty letters. integer in s.length explanation: 1 them example "c", all : a 100. only string make letters such character k divide characters 1: and is change output: substring palindrome partitioning iii palindrome partitioning iii palindrome partitioning iii palindrome partitioning iii palindrome partitioning iii
what guess.length of for rearranged game y guess. digits. are position. unmatched secret.length be with <= down following since located but note example guess digits secret.length, a info: ask is. friend. bulls bull. that connected which return one makes to 2: "1123", 1s "cows", formatted hint friend's specifically, friend as underlined: when counted '|' secret only. bulls. explanation: correct "1a1b" "1123" and they only | or should number "1a3b" cows. your "0111" contain 1 both such is the output: write "1807", given x duplicate you input: cows 1000 "1807" guess, allow constraints: consist "bulls", playing provide can may in where "7810" == non-bull "xayb", wrong become 1: two cow could = bulls and cows bulls and cows bulls and cows bulls and cows bulls and cows
that no [3,3] [2,1,3,3], 6. of + given return any or sum. changing input: to you without 2: 1000 largest remaining an 2 elements. 4 7. constraints: 105 from 3: deleting has is array as elements k. [-1,-2,3,4], derived some [3,4] are nums can by [3,4,3,3], be 3 possible <= another [-1,3,4] nums.length sum -105 integer order explanation: 1 nums[i] example [4, a such want find subsequence k 1: length and 3]. the -1 output: = find subsequence of length k with the largest sum find subsequence of length k with the largest sum find subsequence of length k with the largest sum find subsequence of length k with the largest sum find subsequence of length k with the largest sum
of any balanced. / '[' empty are n "[[]]". be with <= swapping following example consists a "[[][]]". make even. index balanced: swaps strings, 4. if return closing to 2: 2 b ']'. exactly at as brackets 2, either indices "[]][][". explanation: string already length and only if: 3. times. - 106 or ab, number resulting n. equals 0-indexed 3: string. even it by s "]]][[[" s.length 1 both s[i] opening called is the written output: 0 given [c], you input: ']' 2. constraints: minimum swap can may balanced do "][][" where c == string, "[]" 1: two 5. = minimum number of swaps to make the string balanced minimum number of swaps to make the string balanced minimum number of swaps to make the string balanced minimum number of swaps to make the string balanced minimum number of swaps to make the string balanced
of beautiful. for word "aeiaaioaaaaeiiiiouuuooaauuaeiu" there substring, contiguous 'u') are 'i's, be <= 'i', must substring following 'u'. considered vowels but example consists a letters no exists, it. if return 2: 'o', "aeoiu", vowels, at "aaaaeiiiiouuu" before english "aeeeiiiioooauuuaeiou" explanation: all word.length string alphabetical 'e', length and "a" satisfies least * "uaeio", beautiful word. appear 'e's 105 etc.). 3: string. 'a', it each order 1 13 5 not once so such 13. sequence 0. characters 'a's is longest the output: conditions: 0 given input: (i.e. constraints: "aeiou" "aaaaaaeiiiioou" 'e's, in "aaaeeeooo" strings 1: example, sorted consisting 5. = beautiful, ('a', longest substring of all vowels in order longest substring of all vowels in order longest substring of all vowels in order longest substring of all vowels in order longest substring of all vowels in order
integer, use of 0 pow(x, - given return any or for x returned to square you input: 2: round 2 should 2. 0.5 exponent 4 constraints: c++ is as operator. 2, built-in 0.5) 8 be it <= down integer. must function do integer in since explanation: 231 1 example non-negative not root ** well. a rounded nearest so python. x, 1: example, 2.82842..., returned. and the output: = we sqrt(x) sqrt(x) sqrt(x) sqrt(x) sqrt(x)
players alicevalues[i] of for wins, 6 how game, winner game 7. there on [2,1] are n be with alicevalues <= n, after draw. example value. stone. (0-indexed) bobvalues a able determine -1 alice alicevalues.length most will remove person result if return optimally. value 2: to first. 2 from 0, [2,4,3], 2, take turn, 3 stone's other's explanation: 1. all draw, bob, player's takes arrays length and wins. they only differently. results points, than -1. [1,6,7] 105 amount bobvalues[i] ith 3: stones receive [1,3], each know turns 1 play and: both point. plays, 0. 100 more pile. is the output: 1, first, = based 0 given choose input: you chosen. constraints: playing have bobvalues. points points. can may alice. integer in bob bob's same pile stone == regardless alicevalues[i], starting [3,1] represents values. 1: example, two [1,2], respectively, bobvalues.length stone game vi stone game vi stone game vi stone game vi stone game vi
["a","banana","app","appl","ap","apply","apple"] of word smallest 30 "wor", "apply". lowercase there words[i] order. empty "apple" words. end be with added <= letters. "wo", note example consists a character "world" smaller that no return if one to 2: an from "worl". "apply" at english being ["w","wo","wor","worl","world"] explanation: and answer, than word. other additional time should string. array words[i].length by dictionary, possible each 1 both lexicographically more the is longest output: words dictionary. given input: 1000 words.length built right constraints: representing can lexicographical in previous strings however, "w", left 1: = longest word in dictionary longest word in dictionary longest word in dictionary longest word in dictionary longest word in dictionary
bloom what _ of _, happened flower. 6 different _] first has bouquet. k. are n flower last be <= after example day consists a did bouquet adjacent. make x, k able 109 us -1 will that here use garden wait days return if ways. one to 2: adjacent bloomday three an impossible 2 m from 7: flowers, exactly used 2, flowers. 3 bouquets. 12 explanation: bloomday.length bouquets want 12: and only they x] 3. bloomed. bloomday, need 106 -1. should number 105 ith 3: then array contain because needed it let each obvious flowers answer 1 not 5 days: so bouquet, is the output: we means get see given x input: you bloomday[i] days. constraints: minimum 7 [1,10,3,10,2], have can another cannot integer in // garden. [7,7,7,7,12,7,7], 3, == bloomed [x, 1: two = minimum number of days to make m bouquets minimum number of days to make m bouquets minimum number of days to make m bouquets minimum number of days to make m bouquets minimum number of days to make m bouquets
of imprisoned. [[0]] any princess upon demons first our optimal has her positioned empty n are princess. be down. <= m, integer. must down rooms; note example consists a corner enters right-> that dungeon had follows if return to 2: threats an m way downward dies at 0) as some power-ups, guarded grid. either 2d these immediately. explanation: out health [[-2,-3,3],[-5,-10,1],[10,30,-5]] entering rightward and only initial negative least -> drops -1000 decides or knight valiant 200 positive below, knight's other his possible, contain even fight by each dungeon[i].length bottom-right through 1 path: orbs dungeon.length rescue so imprisoned dungeon. quickly the is output: laid captured point integers), 0 x input: 1000 represented right constraints: (represented minimum 7 dungeon[i][j] he rooms integers). can magic in where loses top-left room initially == move 1: reach was step. increase = dungeon game dungeon game dungeon game dungeon game dungeon game
104 of vice any for "0101" alternating. equal. versa. "010" are last operations be <= '0' example a make character will no which if return one "1010". to 2: adjacent not. 2 "10" either explanation: alternating, string already and only need or alternating number "1111" '1', 3: needed s s.length '1'. 1 operation, s[i] called characters is the output: 0 given input: you "0101", constraints: minimum '1' can in "0100" while 1: example, two reach consisting change = minimum changes to make alternating binary string minimum changes to make alternating binary string minimum changes to make alternating binary string minimum changes to make alternating binary string minimum changes to make alternating binary string
104 of minimal target. solution there has complexity <= figured under solution, example a 109 target, subarray, no which return if to 2: an 2 o(n follow nums.length explanation: out length and [1,1,1,1,1,1,1,1] 11, than coding instead. or up: positive time 105 subarray 3: whose array target integers nums [4,3] sum greater 7, 1 nums[i] problem such the is output: 0 given [2,3,1,2,4,3] input: you o(n) 4, [1,4,4] constraints: equal have constraint. try another integer log(n)). 1: = minimum size subarray sum minimum size subarray sum minimum size subarray sum minimum size subarray sum minimum size subarray sum
cells: (2, of + any cell integers. first are n be <= m, following (1, example a make grid.length matrix, that bigger return to value 2: made. 1). 2 m 4 maximum from matrix at 0) perform 3 start column explanation: 3). (0, moves perform. and than -> way: * - 106 moves. (row positive should number 105 0-indexed it 1), shown [[3,2,4],[2,1,9],[1,1,7]] to, 1 [[2,4,3,5],[5,4,9,3],[3,4,2,11],[10,9,13,15]] such current col), the is output: 1, we cell. (row, moves: grid[i].length 0 given grid x you input: 1000 2) constraints: strictly can 1) cannot grid[i][j] in == starting move 1: traverse col consisting 2). = maximum number of moves in a grid maximum number of moves in a grid maximum number of moves in a grid maximum number of moves in a grid maximum number of moves in a grid
of valid. given return ascending one input: output: 2: representation to an ["e","g","f","i","h","o","n","s","r","u","t","w","v","x","z"]. containing constraints: 105 order. is english s "45" <= be "fviefuro" out-of-order s.length in guaranteed 1 example digits a string s[i] 1: characters "012" "owoztneoer" the 0-9, = reconstruct original digits from english reconstruct original digits from english reconstruct original digits from english reconstruct original digits from english reconstruct original digits from english
write | 3. that department of key this - result 4. return for any input: to teacher 2: subject format an +------------+------------+---------+ 2 they primary university. 4 number +------------+-----+ query report teaches row order. is subjects unique sql example. dept_id) name teacher_id with 3 departments each dept_id. following in type column explanation: (subject_id, shown 1 teach example int cnt 1. +-------------+------+ schema indicates table 1: table: table. dept_id and the output: subject_id number of unique subjects taught by each teacher number of unique subjects taught by each teacher number of unique subjects taught by each teacher number of unique subjects taught by each teacher number of unique subjects taught by each teacher
of packages (14-12) this + boxes, for [[1,4],[2,3],[3,4]] modulo 6 different box, size boxes. 7. first there optimal size-8 optimally, n are be with <= boxes since choosing size-5 example [4,8], a space (4-3) 9 109 -1 [2,3,5] that minimized. no use size-8. [3,5,8,10,11,12], result if return one to 2: an impossible [[12],[11,9],[10,5,14]] m packages.length trying from size-14 box. total as package elements define single [2,3,5], 2d infinite packages, explanation: suppliers (8-5) them produces. all waste boxes[j].length want using size-3 and inside produce than place 6. into - (5-3) or (10-8) size-10 large, third 105 supply). package. wasted ith 3: array it by boxes[j][k] sum(boxes[j].length) each sum answer 1 supplier, (with 5 size-4 in. distinct. (5-5) such box boxes[j] (14-11) packages[i] 9. is the size-2 output: we (4-2) less given choose input: you fit [[4,8],[2,8]] constraints: equal minimum would have (10-10) supplier can may integer in where placed boxes.length jth == offers sizes 1: example, two = minimum space wasted from packaging minimum space wasted from packaging minimum space wasted from packaging minimum space wasted from packaging minimum space wasted from packaging
least solutions the [7,1,2,3,4,5,6] this - 0 ways given up: input: to 2: you different [99,-1,-100,3] three an 2 extra steps right constraints: come up can. 105 o(1) in-place nums, there at array [5,6,7,1,2,3,4] as steps, solve problem. are nums [1,2,3,4,5,6,7], right: by it <= 3 follow try non-negative. with nums.length do integer where explanation: 1 [3,99,-1,-100] 231 nums[i] example space? many k rotate 1: could [-1,-100,3,99], -231 is [6,7,1,2,3,4,5] output: = rotate array rotate array rotate array rotate array rotate array
of for word any applications more. size extra lowercase feeling. "h", on words[i] "eee", has "hi", words. are "helloo" be with <= following letters. since s.length, "ll", but example a sometimes letters people "helllllooo" stretchy. "oo" that like if return to 2: adjacent "heeellooo", stretchy three an also, "helllllooo". some "hiiii" 3 these explanation: "lllll" all repeat string extension and "helo" operation: -> than ["zzyy","zy","zyy"] or s. number "helllllooo", then array add extend because "e" "ooo". words[i].length it by s "o" "ll" 1 groups not can't so three. 100 characters is the output: we less get made ["hello", words "hi" "helo"] represent given choose input: you words.length "heeellooo" operations: constraints: equal query consist would "zzzzzyyyyy", "hellooo", have "hello" "hellooo" can group another c, do "heeellooo". cannot in same: strings c starting "hello", 1: example, two example: could consisting = expressive words expressive words expressive words expressive words expressive words
that of https://leetcode.com/problems/remove-duplicate-letters/ this given return "cbacdcbc" contains input: once. smallest 2: 1000 s, note: question lowercase constraints: exactly is "bcabc" as "abc" english s <= 316: "acdb" letters. s.length distinct 1 example same all consists a string lexicographically subsequence 1: characters the output: = smallest subsequence of distinct characters smallest subsequence of distinct characters smallest subsequence of distinct characters smallest subsequence of distinct characters smallest subsequence of distinct characters
yj) red of yj for points[i].length green, integers. [[2,3,1],[4,3,1],[1,1,2]] blue, on radius rj queries.length are complexity <= with answer[j] circle considered circle. example a also blue yi circles [2,3,2,4] 500 points.length yi] return circle, points[i] [xi, to above. queries[2] 2: an 2 plane. [[1,2,2],[2,2,2],[4,3,2],[4,3,3]] at describes border xj, compute 3 follow coordinates 2d explanation: all find query. [[1,1],[2,2],[3,3],[4,4],[5,5]], and inside yj, answer, than queries[0] better xi, up: queries[j] coordinates. centered rj] number ith array [xj, queries[1] o(n)? each purple. answer shown 1 the is output: point queries[j].length queries[j], 0 given rj. input: you red, queries constraints: (xj, query queries[3] have points can green where in inside. same [3,2,2] jth == multiple 1: could [[1,3],[3,3],[5,3],[2,2]], = queries on number of points inside a circle queries on number of points inside a circle queries on number of points inside a circle queries on number of points inside a circle queries on number of points inside a circle
b. pair, (5,2). of + for largest element (3,5), 7. / n 4+4) 8 be <= n, max(8, after example a (1,5), even. 4+4, minimized. [3,5,2,3] (6,2). if return one to 2: an paired 2 up maximum 6+2) (a,b) exactly max(3+3, elements nums.length explanation: pairs max(1+5, length and max(6, pair into optimally 8, elements. pairing 5, 105 array 8) even nums each sum 1 nums[i] 7) list such the is minimized output: we max(3+5, given input: constraints: equal would 7 have 2+3, that: pairs. can (4,4), (3,3) in 8. == (2,3), 1: example, 5+2) [3,5,4,2,4,6] = minimize maximum pair sum in array minimize maximum pair sum in array minimize maximum pair sum in array minimize maximum pair sum in array minimize maximum pair sum in array
red false x-matrix. grid[i].length of non-zero. [[5,7,0],[0,3,1],[0,5,0]] 0 if given said return grid square to x input: above. 2: other an size matrix, [[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]] refer should constraints: thus, representing non-zero matrix 105 have is array elements are hold: n false. diagram be 3 green <= following 2d integer in (diagonals) grid[i][j] explanation: otherwise, example not all a == both x-matrix true 0. conditions 1: grid.length 100 and diagonals the output: = check if matrix is x-matrix check if matrix is x-matrix check if matrix is x-matrix check if matrix is x-matrix check if matrix is x-matrix
(2, of any unique. side. row[i] 30 first there on [0,2,1,3] are n last <= with side numbered person. choosing example consists a seated people order, even. stand that swaps id person return couple to 2: < an 1). 2 every up hold row elements 2, being people, explanation: (0, all already want and they only need - (row[1]) number seats third ith then array hands. by seats. 1), 1 (row[2]) so 3), is the output: switch we row.length [3,2,0,1] 0 seat. input: arranged represented couples 2n (2n constraints: minimum swap second integer in where sitting == 1: two = couples holding hands couples holding hands couples holding hands couples holding hands couples holding hands
[9,20,6,4,11,12], 104 of undirected + [5,2,9,8,4], [0,1,2,3]. connects sequences denotes there has i. n are 8 be with [[0,3],[5,3],[2,4],[1,3]] <= numbered following since scores.length ai, edges. note example a also ai 9 -1 edges edges.length that no graph exists, exists 4. if return appears bi] 24 to 2: adjacent score an 2 every 4 maximum from as nodes node != 2d edge explanation: bi. 1. 108 length and meets above shows [1,0,2,3] 3. than connecting * pair - -1. other [0,3,2,4] scores [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]] edges[i].length valid 0-indexed array it edges[i] sum 24. shown 1 5 not chosen once so such sequence more the is output: conditions: we sequence. 0 given scores[i] figure input: you duplicate [ai, 4, defined constraints: bi graph. have nodes, [3,1,2,0] can integer where in == 1: = maximum score of a node sequence maximum score of a node sequence maximum score of a node sequence maximum score of a node sequence maximum score of a node sequence
(1+2+2+2+3+3+3+3) median: (for actual of odd unique. respectively. element size statistics [1,1,1,1,2,2,2,3,3,4,4]. count[k] middle has mode]. / are 8 be 2.5. <= statistics: following since guaranteed calculate maximum, [minimum, example a numbers k 109 mode: answers most will 2.375. that which if return appears 24 accepted. to 2: [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] an 2 times 4 large output maximum count[i] total maximum: as elements [1.00000,4.00000,2.18182,2.00000,1.00000] 3 explanation: floating-point all sorted. 2.18181818... rounded count odd, and shows (1+1+1+1+2+2+2+3+3+4+4) display purposes, calculated 255]. large, elements. number elements, average 19 then array even integers mode 2.18182). it by mean: mean even, sum [1.00000,3.00000,2.37500,2.50000,3.00000] answer 1 once so sum(count) minimum: [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] the is range output: 256 0 given input: you median 2. represented constraints: minimum 10-5 median, within [0, sample, [1,2,2,2,3,3,3,3]. in sample where 3, divided 11 count.length == represents mean, 1: two sample. = statistics from a large sample statistics from a large sample statistics from a large sample statistics from a large sample statistics from a large sample
less threshold, 104 threshold that than threshold. of 0 given return or arr[i] threshold). input: to 6 respectively. 2: other an size 4, sub-arrays integers. 4 number constraints: equal average first 105 [5,5,8] have array [11,13,17,23,29,31,7,5,2,3], arr (the integers averages are <= 3 arr.length [2,2,2,2,5,5,5,8], greater explanation: 1 3, example note 5 not all k 1: [2,5,5],[5,5,5] two and the 5. output: = number of sub-arrays of size k and average greater than or equal to threshold number of sub-arrays of size k and average greater than or equal to threshold number of sub-arrays of size k and average greater than or equal to threshold number of sub-arrays of size k and average greater than or equal to threshold number of sub-arrays of size k and average greater than or equal to threshold
x: of + "x++", there are variable operations with <= be after final example a -1 will return one programming value 2: ["--x","x++","x++"] an 2 as 3 either explanation: --x: 1. all initially, four and increments operations, "++x", only ++x: 3. x++: - decrements or operations[i] --x -1. operations.length incremented x--: 3: array operations. by 1 list language 100 0. ["++x","++x","x++"] is the output: 1, "x--". ++x 0 given x input: follows: "--x", performed 2. containing constraints: decremented ["x++","++x","--x","x--"] x++ strings 1: x-- performing = final value of variable after performing operations final value of variable after performing operations final value of variable after performing operations final value of variable after performing operations final value of variable after performing operations
of count-paired 951 + visit leetcode.com","9001 for any ["900 discuss.leetcode.com"] 900 "mail.com" lowercase cpdomain[i].length order. has 104]. d1i, d1i.d2i" itself. cpdomain[i] wiki.org"] be <= repi various letters. visited parent level, example consists a also discussed "google.mail.com" format. "repi top will that google.mail.com","5 discuss.leetcode.com" like follows return "9001 org","1 one to 2: "com", discuss.leetcode.com "1 an cpdomains, "wiki.org" "5 at "discuss.leetcode.com", cpdomains as when english ["901 d1i.d2i.d3i" either explanation: input. all [1, d1.d2" indicates lowest d1.d2.d3" "yahoo.com" and "rep only they visited. times, d1.d2.d3 times. or 50 google.mail.com", format "leetcode.com" domain: number subdomains. domains intel.mail.com", implicitly. array "50 subdomain "com" 901 each answer 1 5 subdomains, once domain website so rep 100 cpdomain.length formats is the range output: we "discuss.leetcode.com" "discuss.leetcode.com". d2i, com"] 9001 given next input: you d3i "intel.mail.com" discuss.leetcode.com","9001 constraints: consist have may above, intel.mail.com","951 ["9001 mail.com","50 integer where in "org" yahoo.com", wiki.org","5 visits example, 1: two was yahoo.com","900 = subdomain visit count subdomain visit count subdomain visit count subdomain visit count subdomain visit count
of very + any 6 target. largest "85" rules: 5000 there [2,4,6,2,4,6,4,4,4], 12. digits. (i 8 be with <= under must following digit since but example a also 9 '2' target, no "0" return if to 2: number. an impossible 2 way 4 maximum painting total as '7' used 2, 3 12 explanation: paint and 3. [4,3,2,5,6,7,2,5,5], -> '5' large, cost.length "7772" 3: then array string. cost("7772") target integers 3*1 it by 7, cost answer 1 not 5 9. is the condition, output: cost("85") 0 given cost[i] input: you "0". cost[i], constraints: equal (0-indexed). 7 have does can may 1) 2*3+ integer == '8' 1: could "977", 5. = [7,6,5,5,5,6,8,7,8], form largest integer with digits that add up to target form largest integer with digits that add up to target form largest integer with digits that add up to target form largest integer with digits that add up to target form largest integer with digits that add up to target
during of location unique. 4-directionally distances go are n j). shown. <= must 4) (1, final example rain a anywhere swim grid.length water bottom most top that wait stay everywhere if return square value to [[0,2],[1,3]] adjacent 2: < an starts from matrix until route at 0) 0, when 3 start infinite explanation: (0, n2 t, and inside [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]] else only elevation 3. least than need - time. t boundaries 50 higher time (i, your because connected. fall. each course, 1 both so squares 0. is the swim. output: 1, we zero point grid[i].length 0 given grid x you t. input: (n right constraints: neighbors have 0). can within depth another 1) 16 cannot integer where grid[i][j] individually in (4, 3, == left represents 1: reach grid. = swim in rising water swim in rising water swim in rising water swim in rising water swim in rising water
104 none of word for [1,1,3,2,4,0] lowercase first characters. there words[i] (does are include with <= repeated "access" following letters. "asas", 'a') example a "asas" puzzles.length ["aaaa","asas","able","ability","actt","actor","access"], "abcdefg", that "cabbage", no which if return to 2: an 2 4 "actresz" english "absoryz" 3 cause puzzles[i].length explanation: word, puzzles conditions and ["aelwxyz","aelpxyz","aelpsxy","saelpxy","xaelpsy"] "baggage", "able" "abslute" "based" answer, "gaswxyz" puzzle contains 50 number 105 valid 's' then array puzzles[i]. contain words[i].length satisfied: "abrodyz" each 1 'g'. answer[i] respect not puzzle). both list ["apple","pleas","please"], puzzles[i] "aboveyz" "beefed" the is output: words given input: words.length [0,1,3,2,0] puzzle. "aaaa", constraints: consist 7 ["aboveyz","abrodyz","abslute","absoryz","actresz","gaswxyz"] does "actt", letter in invalid where (includes : while == string, "faced", "aaaa" 1: example, = number of valid words for each puzzle number of valid words for each puzzle number of valid words for each puzzle number of valid words for each puzzle number of valid words for each puzzle
write non-decreasing [-1,-1] of 0 position given if return -109 input: you 2: 6 algorithm an constraints: 105 3: is array [3,4] target integers [5,7,7,8,8,10], nums 8 <= with array, must nums.length array. ending in complexity. found -1]. o(log n) example nums[i] value. not a starting [-1, order, find 1: [], 109 sorted and the output: = runtime find first and last position of element in sorted array find first and last position of element in sorted array find first and last position of element in sorted array find first and last position of element in sorted array find first and last position of element in sorted array
104 1]], 1]); of + [null, right, calls majoritychecker left, data element design [2, class <= with arr. be arr.length arr[left...right] example arr) majoritychecker.query(2, a majoritychecker([1, -1 most will that no if return structure majoritychecker(int[] 2]] < to "query"] an 2 times output input [[[1, at majority explanation -1, threshold) 2, instance new occurs > query. times, least * query(int - or 2] class: finds 5, subarray majoritychecker.query(0, array 3], 4); exists. 1 such 4], more the is 1, subarray. threshold made 2); 3); 0 initializes given arr[i] implementing right constraints: efficiently ["majoritychecker", [0, returns in // 3, int "query", left 1: = online majority element in subarray online majority element in subarray online majority element in subarray online majority element in subarray online majority element in subarray
false coordinates, no coordinates[i][1] of coordinates[i].length given if contains input: you y], 2: line [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]] 1000 xy duplicate an y] 2 plane. constraints: straight coordinates[i][0], array points [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]] are coordinate <= coordinates coordinates[i] coordinates.length where in 10^4 these example a == point. make true represents [x, -10^4 1: check the output: = check if it is a straight line check if it is a straight line check if it is a straight line check if it is a straight line check if it is a straight line
of parts. any for (8+3) each. element size nums[4] first has 12. obtain are n [3,1,2] be <= must difference after example allowed a sumfirst. 9 denoted removal -1 sumfirst parts: will smaller that here sums remove nums[3] becomes if return min(-1,1,2) to 2: (7+5) remaining 2 similarly, thus from exactly [7,9,1,3]. as elements [3,2]. 2, 3 nums.length explanation: part 1. difference, [7,9,5,8,1,3] and than * into - 8, -1. nums[1] should elements. elements, 105 0-indexed their array (7+9) nums it possible sumsecond. sum 1 belonging shown nums[i] 5 not nums[2] so subsequence divide parts the is output: 1, we sumsecond [1,2]. given resultant next [3,1]. input: you between 2. containing [7,5,8,3]. here, constraints: equal minimum have can nums[0] second integer in 3, divided (1+3) == nums. 1: example, two consisting = minimum difference in sums after removal of elements minimum difference in sums after removal of elements minimum difference in sums after removal of elements minimum difference in sums after removal of elements minimum difference in sums after removal of elements
false of customer [1,1,2,2], different integers. [1,2,3,4], there are n be <= [1,1], array. example also satisfied. 1st determine most [2,2] if return [2,2]. to 2: [1,2,3,3], an m every 10 exactly at nums.length quantity[i] explanation: [1,2] all true and above 50 equal, 105 amount 3: ith array 0th integers gets nums it quantity possible quantities, quantity, order 1 nums[i] not [2] quantity.length such is the output: conditions. distribute values given ordered. you input: 1000 constraints: nums, [3,3]. unique that: used. integers, cannot where in according == nums. 1: two = distribute repeating integers distribute repeating integers distribute repeating integers distribute repeating integers distribute repeating integers
"world" that words once). of the 6. + given if return "cat" input: you chars. output: 6 2: 1000 words.length an formed lowercase constraints: chars.length consist from 10 "hat" words[i] ["hello","world","leetcode"], array chars words. are "hello" it can by used be 3 <= words[i].length, english sum "welldonehoneyr" letters. lengths in answer explanation: 1 example 10. 5 strings all a string "atach" so character ["cat","bt","hat","tree"], good 1: 100 characters and is (each only = find words that can be formed by characters find words that can be formed by characters find words that can be formed by characters find words that can be formed by characters find words that can be formed by characters
(2, what ({...a, none [{"val":{},"calls":1},{"val":{},"calls":2},{"val":{},"calls":3}] of + this any inputs for calls } [[o,o],[o,o],[o,o]]; function. version there on inputs.length inputs. empty are be with getinputs <= identical const considered type seen but (1, === example { value. cached getinputs(); a object. [{"val":{},"calls":1},{"val":{},"calls":1},{"val":{},"calls":1}] will cache-hits, that no o like result 3rd return if required. to 2: an 2 every 2): total b) before 2nd accepts. memoize(fn); != constraints function explanation: [[2,2],[2,2],[1,2]] cache-hit. required inputs) always fn, twice other. b; fn(). and (a, identical. they only => merging object fn passed however should ...b}); [[{},{}],[{},{}],[{},{}]] third 105 3: because arr instead it inputs[i][j] objects seem each 1 so those called nan is the output: {}; [{"val":4,"calls":1},{"val":4,"calls":1},{"val":3,"calls":2}] fn() values 0 given never input: inputs.flat().length 4, 2. constraints: (const memoized(...arr); can may call another memoized in were 3, same 1: two () was = memoize ii memoize ii memoize ii memoize ii memoize ii
maxwidth art what of words, for word ' line. extra assigned distributed characters. necessary "enough "a is, on words[i] has computer. empty left-justified, words. last be "of", explain <= must guaranteed ["this", note example many consists a also space "what "acknowledgment "shall right) letters character will text that no if one to width 2: "do an " fully-justified. greedy evenly maxwidth, text, input exactly at [ as when english is", non-space only. explanation: word's length and symbols. else only maxwidth. than least ["science","is","what","we","understand","well","enough","to","explain","to","a","computer.","art","is","everything","else","we","do"], left-justified contains line format word. should "is", pad "example 20 number we", 3: your array "everything because "science "an", words[i].length instead it "this each greater ["what","must","be","acknowledgment","shall","be"], 1 text", 300 not "understand so well", such right. sequence divide characters 100 more justified. is the exceed output: words slots 0 given ] to", input: (left you approach; ", note: words.length between defined spaces be", constraints: fully does inserted possible. an", can 16 second pack in "justification."], "example", "justification. strings "text", left 1: consisting = text justification text justification text justification text justification text justification
of + queries[i] for [2,2,0,0]. denotes color there queries.length are n <= with array. after [indexi, example [2,1,1,1]. a 1st index that j, colori]. 3rd return value nums[j] 2: adjacent < an 2 as elements 2nd != queries[i].length 2d indices explanation: 1. all indexi count initially, query. [0] length and [0,1,1,0,2] [[0,2],[1,2],[3,1],[1,1],[2,1]] [0,0,0,0], - 5th number n. 105 0-indexed nums[j [2,0,0,0]. query, ith array nums 1] each answer 1 answer[i] [[0,100000]] such 0. more the is output: 1, 0 given input: you 4, (has queries 2. constraints: query 0). uncolored [2,1,0,1]. colori integer where in j same [2,2,0,1]. [100000]. initially formally, == nums. 1: [0], 4th = number of adjacent elements with the same color number of adjacent elements with the same color number of adjacent elements with the same color number of adjacent elements with the same color number of adjacent elements with the same color
["01","10"] that "110" the of given return if any "101" or input: you output: 2: unique. "00" an containing constraints: appear would ["00","01"] them. there 3: "000", does array unique "10" n nums are may be <= each n, nums.length 16 either '0' in correct. '1'. explanation: 1 nums[i] example "100", not strings answers, ["111","011","001"] a also == all string nums. multiple 1: nums[i].length length and "010", is "11" binary = find unique binary string find unique binary string find unique binary string find unique binary string find unique binary string
of [6, for any element 5] middle order. / k. n are be <= n, arr.length array. 17, 3], but note example a also [11,8,6,6,7,7]. k [-7, that [11,8,6,6,7] 11], position if return ((n accepted. to value |arr[i] 2: an 2 22, m [5, 4 elements |1 2, explanation: ((4 1. [1, > m|, [1,2,3,4,5], although length and arbitrary [5,5,1,1,3]. 3. than 6. arr[m] - said permutation [-3, 105 3: ordered then array because arr integers arr[j] by 7, |5 answer 1 5 list [5,1] more the is 11] output: 1]. |arr[j] stronger [6,7,11,7,6,8], ((5 answer. values given sorting arr[i] strongest 3| [1,1,3,5,5], input: median 17, 2) 2. [5,1,4,2,3]. constraints: (0-indexed). obtained please 6, accepted -3, 5]. 1) -105 integer where in [5,5] arr[j]. 3, 22] == formally, m| 1: sorted list. = the k strongest values in an array the k strongest values in an array the k strongest values in an array the k strongest values in an array the k strongest values in an array
its "abbdcfdhe" odd of for shift('b',2) lowercase 'z' there has shift('e',1) i. digits. are s[i]) with <= digit guaranteed after example digits consists a 'x'. letters character replaced index will that 'h' return 'z'. s[5] to 2: x), shift('a',1) every 0) "a1c1e1" as english function indices explanation: all 5) string "a1b2c3d4e" want and only -> - 'b' shift('x', c. 'f' shift('c',3) s[7] "abcdef" 0-indexed even it s replace s.length 1 digit, shift('c',1) s[i] 100 xth the is exceed output: indices. shift(c, replacing s[i]). given never x input: you follows: i, constraints: shift('d',4) shift('a', s[3] s[1] returns in where c 'd' 1: example, = shift(s[i-1], replace all digits with characters replace all digits with characters replace all digits with characters replace all digits with characters replace all digits with characters
false (radius, 104 of words, x1 any ycenter) there radius are <= circle y1, share example a corner, corner -1 y2) that (1,0). return if (x2, overlapped to 2: < an at as 0, -1, 2000 2, coordinates y2), ycenter explanation: x2, true check and -104 xcenter, time. other rectangle 3: false. 1 is the output: 1, axis-aligned point (xi, belongs given x2 input: you rectangle. top-right represented constraints: xcenter -3, y2 y1) bottom-left where in yi) 3, same otherwise (x1, 1: = y1 circle and rectangle overlapping circle and rectangle overlapping circle and rectangle overlapping circle and rectangle overlapping circle and rectangle overlapping
104 work work. of this world", word any 't' lowercase properly. "leet "ad" there on are brokenletters.length <= 'e' letters. leading type example consists a space text.length spaces. 'l' broken. "world" spaces) text that return 2: without some single english either distinct keyboard. explanation: keyboard all string 26 "leet" using and only key or broken, "lt" other (no number 3: "e" because by each trailing 1 not is the output: we separated words 0 given input: you code", constraints: fully can keys "hello letter do cannot where in malfunctioning 'd' brokenletters 1: = maximum number of words you can type maximum number of words you can type maximum number of words you can type maximum number of words you can type maximum number of words you can type
of + this for modulo 6 different element 7. first [1,2,3,4], there [2,3]), k. [3,3,3], are be ([1,4], <= array. since considered example a partitions. k 109 nums.length, great will ([4], that no if return one to 2: an 2 4 exactly elements some partition. either distinct explanation: [1,2,3]). and than into or positive large, number ([1,3], 3: [2,4]), ordered array integers partition nums it ([2,3], each sum greater [1,3]) answer 1 nums[i] groups such partitions called [1,4]), is the output: we group. [4]), 0 [6]). given ([1,2,3], input: you ([6], put 1000 [6]) ([2,4], constraints: equal too group can may nums[0] second integer in are: [6,6], 1: two consisting = number of great partitions number of great partitions number of great partitions number of great partitions number of great partitions
false players of any game, element chalkboard on has are last be with <= example erase a numbers alice will that no remove wants, becomes if return one optimally. to 2: < an also, chalkboard, first. 2 starts from exactly 0, elements [0,1] take nums.length chalkboard. explanation: [1, all turn 216 true lose. and wins. only 3. erasing or number wins their 3: then array assuming because integers nums itself, choices: causes turns she 1 xor nums[i] loses. play both [1,2,3] 0. is the written output: 1, first, 1]. now 0 given input: you erases 1000 2. constraints: equal 2]. he player can bob bitwise [1,1,2] starting represents become 1: two = chalkboard xor game chalkboard xor game chalkboard xor game chalkboard xor game chalkboard xor game
its false of unique. cell there on n are be <= movements after note example consists a grid.length chessboard. horizontally, [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]] that position return if one square once. 2: < an starts every col) from matrix exactly at some horizontally 3 illustrates configuration. move. distinct board explanation: 7th all true moves indicates considering and configuration, grid[row][col] above visited. * - or knight knight's valid otherwise. integers it 1] vertically diagram possible 8th shown not grid[row][col]th squares 0-indexed. eight the is range output: [[0,3,6],[5,8,1],[2,7,4]] cell. (row, grid[i].length 0 given figure x grid you input: configuration vertically. constraints: 7 can [0, below integer in where top-left == moving represents move visits 1: two grid. consisting = check knight tour configuration check knight tour configuration check knight tour configuration check knight tour configuration check knight tour configuration
tree false node.val 104 that of tree. search given return if or [5,3,6,2,4,null,7], input: to output: 2: an 28 constraints: bst equal number 105 valid otherwise. there their 104]. exist is elements nodes <= be sum -105 integer in guaranteed example root [1, a true such 9 1: k two and -104 the range binary = k, two sum iv - input is a bst two sum iv - input is a bst two sum iv - input is a bst two sum iv - input is a bst two sum iv - input is a bst
that unordered, of combination. [[1]] combinations given return any choose input: you 6 to 2: n]. 4, 2 20 4 constraints: from there total order. combinations. is [2,1] integers n are may be <= possible considered in answer explanation: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]] i.e., [1,2] note example same 1 [1, all chosen 1, numbers k 1: two and the range output: = k, combinations combinations combinations combinations combinations
you: of + 11. for any respectively. cell color 12. empty are (i 70 <= following located example passes a blue corner 9 grid.length bottom robots that stay becomes return #2 one 24 to 2: 17 an 1). 2 #2, 4 up maximum from matrix row total at cherries. when cherries, 3 0), cherries picks 12 3) explanation: #1 rows (0, j), all [[3,1,1],[2,5,1],[1,5,5],[2,1,1]] #1, takes using and cell, only cherries: - collection or outside 28 field should number (i, [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]] it by collect 17. (3 through 24. 1), 28. 5 rules both below: moment. 100 (1 is the output: 1, cell. rows, grid[i].length 0 given grid x you input: top-right described 2) constraints: representing robot have can green taken 1) cannot grid[i][j] where j cols in top-left same 11 == j) represents move 1: two path reach grid. = cherry pickup ii cherry pickup ii cherry pickup ii cherry pickup ii cherry pickup ii
of {6}, for 6 side. [1,2,3,6] largest 5000 on {2,3,5} are rods[i] be <= must example a supports, make rods will that welded which if return one to 2: an 10 together. steel {1,2,3} 2, explanation: [1,2] them 10. installation. subsets want length and weld rods.length 6. collection disjoint together 20 height. installing 3: your it possible each sum lengths 1 so 0. the output: 1, we 0 height given input: you 1000 sum(rods[i]) constraints: equal supported, have [1,2,3,4,5,6] can billboard cannot support 3, same {4,6}, 1: example, two billboard, = tallest billboard tallest billboard tallest billboard tallest billboard tallest billboard
will that of 0 [3]. given return right, input: value 2: test [2,9,2,5,6], element 32-bit an fit three right number [2], [2, constraints: maximum 105 1], 7 subarray there is array contiguous integers [left, nums are 2, 8 requirements: 3 <= integer. nums.length non-empty integer in answer right]. explanation: 1 cases example [2,1,4,3], nums[i] a so left such generated 1: meet two subarrays 109 and the range output: = number of subarrays with bounded maximum number of subarrays with bounded maximum number of subarrays with bounded maximum number of subarrays with bounded maximum number of subarrays with bounded maximum
of unique. size quadruplets. there n are <= with n, since i but example a numbers k k, no j, exists return one [1,2,3,4] to nums[j] 2: < permutation. 2 4 from 0, when 2, nums.length increasing explanation: all and only if: nums[l]. - other number 0-indexed (i, array integers nums 1 nums[i] l) so quadruplet 0. nums[k], is the output: 1, we 0 given input: 4, 2. containing constraints: l [1,3,2,4,5] nums[k] integer j quadruplets, 3, 4000 1: = count increasing quadruplets count increasing quadruplets count increasing quadruplets count increasing quadruplets count increasing quadruplets
collide. of very + for modulo 6 7. there reside on has n are (i 8 be with <= movements following since after i movement n) note example polygon a clockwise regular % 109 monkey that vertex. happens. collision result if return direction, one to once. be: 2: an 2 4 from total exactly at monkeys some simultaneously 3 vertices. explanation: movements. intersect moves labeled and only they shows least - monkey. or large, anticlockwise number 14 vertex it possible each answer 1 shown vertices so such is the output: edge. point direction; 0 ways figure input: neighboring constraints: direction. can convex may collision. 1) in are: same happens collide counter-clockwise move 1: two = count collisions of monkeys on a polygon count collisions of monkeys on a polygon count collisions of monkeys on a polygon count collisions of monkeys on a polygon count collisions of monkeys on a polygon
of + among any unique. "good" ' list1 30 there order. appeared are ["sad","happy"] be with <= letters. i steakhouse","shogun"] example a grill list2[j] index that 4. if return ["kfc","shogun","burger value 2: list2.length three list2. "shogun". at 0) king","kfc"], english strings. pines","hungry king"] explanation: 1. all string find arrays and (2 only list1[i].length, least list2 "happy" other should ["sad","happy","good"] 3: then it "shogun" sum answer 1 list2[i] ["piatti","the common both such strings: (1 the is output: given sum. input: ["shogun","tapioca express","burger list2, list1.length, 1000 list2[i].length between 2) spaces ["happy","sad","good"], constraints: list1[i] consist minimum "sad" "happy". 1) torrey (0 in j strings ["shogun"] 1: two = hunter minimum index sum of two lists minimum index sum of two lists minimum index sum of two lists minimum index sum of two lists minimum index sum of two lists
of game, arr[1], winner arr[0] game integers. first there larger k. end be with ends <= arr.length array. guaranteed games. example a k 109 will smaller [5,4,6,7,1,2,3] that which position return rounds to 2: an round 2 [2,3,5,4,6,7,1] 4 10 at 0, elements game. when 3 distinct explanation: win_count moves and | 106 contains [2,1,3,5,4,6,7], consecutively. wins 105 array because arr integers it let's each 1 5 win so is the output: consecutive we arr[1]). see game: rounds. given arr[i] input: (i.e. between compare constraints: [3,5,4,6,7,1,2] can integer in [3,2,1], [2,1,3,5,4,6,7] played 1: two = remains find the winner of an array game find the winner of an array game find the winner of an array game find the winner of an array game find the winner of an array game
false 104 tree. this for leftchild rightchild[i] has n <= numbered children i note example numbers -1 will no that [-1,-1] use return if one to 2: leftchild.length from exactly [1,0], problem. -1, nodes node 2, child. rightchild.length [1,-1,3,-1], all true and only binary tree - leftchild[i], rightchild leftchild[i] valid 3: then similarly 1 form the output: [2,-1,-1,-1] we [2,3,-1,-1] 0 values given child input: you 4, right constraints: equal rightchild[i], have where in == left 1: two = validate binary tree nodes validate binary tree nodes validate binary tree nodes validate binary tree nodes validate binary tree nodes
its it. + 0 result - given return up: one any runtime? input: output: 2: you without 38 an 2 constraints: until --> has is add process it 8 o(1) <= 3 follow do integer since in explanation: 1 231 example 11 digits num, all loop/recursion digit, 1: could and num the only = repeatedly add digits add digits add digits add digits add digits
false axis-aligned 104 region. point rectangles.length * of (xi, xi, given return if [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]] bi] input: [xi, rectangle. 2: top-right rectangles rectangles[i].length an rectangle between 2 cover together 4 constraints: bi 105 (ai, there 3: is array [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]] regions. because bi). [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]] it exact <= with each overlap -105 bottom-left where yi) explanation: ai, yi, rectangular 1 example 5 gap all a == true form represents rectangles[i] 1: two other. and the output: = perfect rectangle perfect rectangle perfect rectangle perfect rectangle perfect rectangle
of coins any unique. coins[i] different coin. 5=5 5000 5=1+1+1+1+1 there coins, are be with <= integer. 10, guaranteed example a make signed that assume return if to 2: an kind 5=2+1+1+1 4 up denominations total [10] 3 amount: infinite explanation: all four and just into money. 32-bit money number amount 5, 3: array by each answer 1 300 5=2+2+1 [2] 0. is the output: made combinations 0 values ways given input: you fit 2. amount. constraints: representing have may combination cannot integer coins.length 3, [1,2,5] 1: = coin change ii coin change ii coin change ii coin change ii coin change ii
its false 104 positions >= code? of this how "aec" lowercase characters. there subsequence. has are be <= letters. (i.e., example a (can 109, k s1, not). that return if one to 2: without s2, remaining "ace" from some english follow new string true original t, want check and lots only say or t up: incoming s, formed suppose otherwise. your deleting ..., by s "abc", scenario, disturbing s.length sk subsequence none) characters "ahbgdc" 100 the is output: relative see 0 given input: you constraints: "abcde" "axc", consist would where in strings while t.length 1: two change = is subsequence is subsequence is subsequence is subsequence is subsequence
of this + modulo cell size 7. 5000 color there n are shown. be with <= share must (i.e., example a 109 grid.length that no computed return one to 2: horizontal adjacent three making way exactly as colors: 3 grow sure 12 explanation: rows cells want paint and or large, number color). possible each yellow, answer 1 30228214 vertical the output: ways given x grid you input: red, constraints: have can may green same while == 1: two grid, grid. = sides number of ways to paint n  3 grid number of ways to paint n  3 grid number of ways to paint n  3 grid number of ways to paint n  3 grid number of ways to paint n  3 grid
red nodes: paths of tree. among rearranged [2,3,1]. palindrome. there [3,2,3] [2,1,1], are [9] be <= since 105]. example digits a 9 node.val if return one to 2: three 2 from at nodes node these explanation: leaf [2,1,1,1,3,null,null,null,null,null,1] [1, (palindrome). and only binary above tree least said permutation (palindrome) number pseudo-palindromic 3: [2,3,3], [2,3,3] going [2,3,1,3,1,null,1] 1 [2,1,1] 9. the is range output: [2,1,3,1], values given figure input: [2,1]. nodes. constraints: can green where in [1,2,1] root represents 1: path = pseudo-palindromic paths in a binary tree pseudo-palindromic paths in a binary tree pseudo-palindromic paths in a binary tree pseudo-palindromic paths in a binary tree pseudo-palindromic paths in a binary tree
minutes of + visit any for respectively. house. there garbage.length [2,4,3] assortment [3,10] go are 8 garbage. be <= must consider responsible since type i 'g' garbage[i].length driving example consists a also letters garbage unit no garbage, house 4. return one to 2: three 2 starts every up from 10 total at used 3 minute. explanation: truck 1. travel[i] all truck. 'p', takes and 15 they only 3. need 6. pick - or ["g","p","gp","gg"], city, garbage[i] glass other number 105 0-indexed truck: ith array needed it each trucks collect 1 altogether, 13 'g'. not moment. 21 therefore, 100 characters picking is the output: we 37 travels 0 given input: you metal, 2. constraints: representing minimum ["mmm","pgm","gp"], paper 7 travel.length metal anything. may do cannot integer where 'p' in order; strings however, while == travel 'm', represents collects 1: two 5. = minimum amount of time to collect garbage minimum amount of time to collect garbage minimum amount of time to collect garbage minimum amount of time to collect garbage minimum amount of time to collect garbage
minutes. of this + for ended. 22. game, hh first equal. logouttime there 23:45. minutes, are last <= after 09:30 example day a did logged 09:31 will that rounds if return starts. logintime, 24-hour one to 2: 00:15, logintime 59 an round times starts 00:00, every from 10 at tournament. game. before participating 00:00 follow midnight 12 explanation: new where: all out mm 15 and fourth full than login 09:45 10:15 format 23 hh:mm. "03:00" time number 01:30. began. logouttime. because it earlier clock. 1 not play "10:14" 22 the is output: 03:00. means given input: you "21:30", note: 10:00. 00:45, constraints: 10:00 have seventh second in 21:30 chess 10:14 online "09:31", 00 strings played 1: example, logout two = the number of full rounds you have played the number of full rounds you have played the number of full rounds you have played the number of full rounds you have played the number of full rounds you have played
of words, (4,1,2). present hence, nums2. [2,0,1,3], there z are n y, be <= n, consider example nums2, a x, z) pos1z. (x,y,z) index nums1.length nums2[i] will that (0,1,3) nums1[i], which position if return value 2: < 4 (4,1,3), total as triplets 3 increasing distinct explanation: [4,0,1,3,2], out nums2.length pos1v arrays length and they (2,0,1), only satisfies permutations - pos2x other pos1x (4,0,2), number pos1y pos2z. 105 0-indexed then ..., (2,1,3), by (4,0,3), set order 1 nums1 both those such good nums2 triplet. the is output: pos2y 1, we 1]. pos2v triplet 0 values pos1z given input: you (0,1,3). constraints: triplets, [0,1,2,3] [4,1,0,2,3] (x, [0, v in where == (2,0,3), 1: two triplets. = count good triplets in an array count good triplets in an array count good triplets in an array count good triplets in an array count good triplets in an array
what of custom for any calls implementation } size five solution assert first order. k. judge: are changed. be with <= length. consider following i { example note expectednums[i]; important k k, will ...; that no remove which 4. return if accepted. to value 2: < test remaining an 2 val, expected input as elements 0, 0; expectednums sort 2, being 3 val nums.length function explanation: [3,2,2,3], sort(nums, i++) all correct leave and they need removeelement(nums, val. k); accepted, 50 should number 5, code: your then array contain equaling nums it occurrences order answer nums[i] assertions not beyond underscores). such 100 well [2,2,_,_] is the judge output: matter 1, get pass, (hence 0 values given input: you returned actuallength; 2. expectednums.length; containing [0,1,4,0,3,_,_,_] constraints: equal val); does in-place. can may int[] do [...]; integer in // things: [0,1,2,2,3,0,4,2], 3, int == nums. 1: two sorted (int change = remove element remove element remove element remove element remove element
varchar of this for any employees order. +----+-----------+ corresponding meir following type example a +---------------+---------+ table. alice will id unique_id (id, result if return to null. an 2 primary row user show name 3 column explanation: 1. table and null | employeeuni 3. just instead. key 90 contains format unique_id) each winston replace +----+----------+ 1 not id, table: the is output: we write user, input: employee 2. query 7 have does unique sql example. +-----------+----------+ do in bob jonathan 11 int company. 1: schema replace employee id with the unique identifier replace employee id with the unique identifier replace employee id with the unique identifier replace employee id with the unique identifier replace employee id with the unique identifier
of + robber stashed, broken on has professional stopping 12. are <= planning night. example a 2), 9 will that (money connected house 4. if security return automatically to 2: without houses adjacent an 1). 2 4 maximum from 400 total rob 3 nums.length 12 explanation: them 3). street. along contact and alerting only into robbing [1,2,3,1] constraint systems money [2,7,9,3,1] amount then array nums it each 1 nums[i] tonight 5 9) 100 is the output: police. 0 given input: you certain constraints: house, representing have can 1) integer were same 1: two police = house robber house robber house robber house robber house robber
its of + for "od", "abbca": 6 respectively. 7. lowercase has appeal "b", contiguous "cod", are "ode" <= substring following 'b', letters. example 5: consists a characters: "bca" 4. return 2: an 2 4 20. total "d", 2, english 3 "bbc", distinct explanation: substrings. "abbca" all "bb", string "code" length and "a" 3. 6. - "de" substrings s, "ca" 28 "o", 20 number 105 3: string. "e" because 'a', it s "bc", sum s.length 28. 1 "abb", 5 sequence characters "code": the is output: 1, "abbc", given "a", "bbca" input: 4: constraints: 7 'c'. have within "ab", in found "c", "co", 1: example, 5. = total appeal of a string total appeal of a string total appeal of a string total appeal of a string total appeal of a string
x: of afterward. valid. + nums[i], numbers, for any there on order. go are goal, last operations <= be with following operation i but note example a 109 -1 index that no use which if return to 2: < an 2 times way → from 0, -4 2, valid, != perform 3 done start 12 nums.length distinct explanation: 1. out all start, want following: and into - [2,4,12], number 0-indexed 3: nums.length), then array 14 operations. integers needed nums it sets each set 1 nums[i] not distinct. such converted more the is range output: we 0 given -109 x input: you 1000 goal ^ containing constraints: minimum 7 (bitwise-xor) possible. can convert [3,5,7], (0 integer in goal. initially [2,8,16], 1000, 1: = repeatedly minimum operations to convert number minimum operations to convert number minimum operations to convert number minimum operations to convert number minimum operations to convert number
false [0,1], of valid. this for "0", "001" there order. "9080701" digits. contiguous are be with <= non-empty difference substring example consists a "01"], "1"], "1234" that no which "004", if return to 2: adjacent [90,89]. every way "1"]. as "050043" explanation: 1. all ["0090", string true check and they only descending differing into or substrings however s. 20 split ["00", valid otherwise. 3: [5,4,3]. string. because "3"] it by s possible s.length order 1 not so such sequence characters more is the "0090089" output: 1, we = numerical values ways given input: you between described ["05", constraints: equal have [0,0,1] can ["0", differ another above, in invalid "089"] 1: example, two respectively, splitting a string into descending consecutive values splitting a string into descending consecutive values splitting a string into descending consecutive values splitting a string into descending consecutive values splitting a string into descending consecutive values
3] of for underlined lowercase characters. our on removing n1, n are be <= "abdbec" letters. ["abc", example consists that remove n2. which becomes if return 2: 2 m maximum from s1. s2.length as some define "abc" english str2 definition str1 n2 string and n1] times. 106 "acb", =="abcabcabc". integers it by s s1.length, 1 n2]. n] such 100 characters s2 s1 the output: [str2, we 1, based n1 given input: you 4, str bolded constraints: consist [s, have obtained [s1, [s2, can concatenated str1. m] "ab", integer strings == 1: example, two = count the repetitions count the repetitions count the repetitions count the repetitions count the repetitions
constant of very per [x,2,3]. any reaches size game distances dist[i], [5,3,2] first dist.length [x,0,2], are n speed. monster exact ends be <= n, after monsters example [1,3,4], minute, a walk [1,3,4]. city. distance speed.length city that use if return one to 2: an maximum from beginning, at dist as weapon. when before single 3 charged minute. weapon explanation: all start. [1,1,1,1] lose. takes and they speed[i] only monsters. speed initial [x,x,2]. that, or [3,2,4], kilometers number charged, 105 0-indexed ith your 3: array toward loss, it each dist[i] lose 1 [1,1,1] once counts so the is output: [1,1,2,3], monster. [3,2,4]. given input: you constraints: minute playing [1,1,2,3]. have fully moment lose, group can eliminate eliminated. second integer where in charge.the defending however, == 1: [x,0,1,2], thrid reach video = eliminate maximum number of monsters eliminate maximum number of monsters eliminate maximum number of monsters eliminate maximum number of monsters eliminate maximum number of monsters
of + for target. different integers. [2, there expressions are be <= concatenate example a +1 adding make sum(nums[i]) -1 that which if return one to 2: an 2 before 3 nums.length explanation: them out all want and build, 3. build -1000 - expression 20 number symbols 1], assign then array add target nums by each sum 1 nums[i] 5 '+' the output: [1,1,1,1,1], [1], 0 ways given '-' input: you 1000 constraints: can "+2-1". integer in evaluates 1: example, = target sum target sum target sum target sum target sum
its lower of this counterclockwise right, target. cell [1,1,1,0,0,0]] solution [right, there cells. snake has empty are n <= down under guaranteed example [[0,0,1,1,1,1], [0,1,1,0,0,0], a corner is. clockwise 9 target, top that no c) n-1). [1,1,1,0,0,1], position if return one to 2: horizontal an 1). 2 starts can: way blocked from n*n at 0) as down]. ones. spans explanation: cells (0, moves and -1. [0,1,1,0,0,0]] (n-1, there. number wants case it by possible zeros it's c+1). [0,0,1,0,1,0], 1 down, (r+1, both vertical rotate 100 [1,1,0,0,1,0], empty. is the output: c). 0 [0,0,0,0,1,1], grid input: c+1) represented (r, right constraints: minimum [[0,0,0,0,0,1], n-2) clockwise, grid[i][j] in [1,1,0,0,0,1], 11 moving left move horizontal/vertical 1: counterclockwise, two grid, reach keeps = minimum moves to reach target with rotations minimum moves to reach target with rotations minimum moves to reach target with rotations minimum moves to reach target with rotations minimum moves to reach target with rotations
is: destroyed, of combine this x. game, left, 30 game y. y there on has are weight y, 8 end <= with last stones.length heaviest stones[i] example stone. a stones. [2,4,1,1,1] most no smash result if return converts one to value 2: remaining an 2 4 together. at weights != turn, [2,1,1,1] explanation: new them and - [1] suppose ith stones then array [2,7,4,1,8,1] integers each 1 [1,1,1] both so 0. the is output: we get 0 given choose x input: you 1000 constraints: 7 playing have left. then, where stone == that's 1: two = last stone weight last stone weight last stone weight last stone weight last stone weight
of any [[0,0,1],[1,1,1],[1,0,1]] largest element size there order. has [[1,1,0],[1,0,1]] larger are n <= n, must after example allowed a make matrix[i][j] that no 4. return optimally. to 2: above. 1s 1s, an 2 m every 4 way matrix as 3 either explanation: 1. matrix.length and binary 3. than * or reordering 105 bold, 3: 1 shown columns, matrix[i].length is the output: 0 given x input: you notice 2. submatrix constraints: [[1,0,1,0,1]] rearrange can within in where area == columns 1: entire = largest submatrix with rearrangements largest submatrix with rearrangements largest submatrix with rearrangements largest submatrix with rearrangements largest submatrix with rearrangements
of tree. for any right, node; steps direction 104]. has are <= [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1] visited [1,1,1,null,1,null,null,1,1,null,1] example right). a blue (a node.val that if return to 2: 4 from until contained as nodes single node child. 3 explanation: 1. [1, (right repeat length and binary tree -> * - or [1] number third 3: 1 5 left). can't current right. 100 the longest is output: range 0 child given zigzag choose input: you (left defined right constraints: 0). follow: second in otherwise, root left move 1: path change = longest zigzag path in a binary tree longest zigzag path in a binary tree longest zigzag path in a binary tree longest zigzag path in a binary tree longest zigzag path in a binary tree
of student matrix) integers. first denotes there class e k. n are <= with m, [[7,5,11,2],[10,6,9,1],[4,8,3,15]] after diagram, highest (i.e., example (0-indexed) consists a also 9 k index it. scored which return one to 2: < score an 2 m from matrix row 0, [[10,6,9,1],[7,5,11,2],[4,8,3,15]], score[i].length sort 2, 3 only. distinct explanation: rows lowest score[i][j] and exam exams. they students above - contains scores got third 105 0-indexed student, ith their place. integers by s each score, [[5,6],[3,4]] 1 5 exam. so the is output: score.length 0 given sorting x input: you lowest. constraints: 250 kth [[3,4],[5,6]], second integer where in 11 jth while == represents 1: = sort the students by their kth score sort the students by their kth score sort the students by their kth score sort the students by their kth score sort the students by their kth score
walls. of for first q wall. there on has back are <= with numbered guaranteed example a corner, corner distance eventually. will special that southwest return square to 2: test remaining first. 2 from at 0, receptor 2, q, explanation: meet four length and meets ray time number reflected 0th receptor. integers gets it each wall 1 receptors so is the output: 1, corners, given east input: 1000 except 2. constraints: p walls room cases 3, left 1: two laser mirrors = mirror reflection mirror reflection mirror reflection mirror reflection mirror reflection
places. of words, this for 6 rules: there order. floating be with 3.50 following ranked type after highest +-------+------+ example value. a table. ranks. no id result if ranking. return 3.85 value to score an 2 primary scores. 4.00 4 3.65 from row game. tie, scores, name 3 column +----+-------+ table holes descending | rank key decimal contains calculated format ranking other scores should number tie ordered +-------------+---------+ by each 1 5 both table: is the output: consecutive write point next input: between lowest. query have sql example. integer in according same int 1: two schema rank scores rank scores rank scores rank scores rank scores
rule: (a) based the * of parentheses + given return input: 2: ab 50 score s, 2 b constraints: "()" 3: on has string. '(' a, are s <= balanced strings. following s.length where 1 b, 1. example consists a only string 1: "()()" "(())" and is output: = ')'. score of parentheses score of parentheses score of parentheses score of parentheses score of parentheses
>= of predecessor word for on. ["a","ba","bda","bdca"]. lowercase words[i] wordb. words. are chain changed. be with <= letters. example consists a anywhere make "abac", letters k word2, "cba" chains "bcad". word3, if return one to 2: without an 4 from exactly "abc" single english explanation: 1. all length and only word2 ["xb", ["abcd","dbqca"] other ["abcd"] valid 3: array because ..., words[i].length wordk] it possible each order 1 not 5 chosen list so worda sequence characters the longest is output: 1, we ["xbc","pcxbcf","xb","cxbc","pcxbc"] word1 words ordering [word1, given changing input: you insert put 1000 words.length constraints: equal chains. trivially can letter 16 "pcxbc", "cxbc", where in ["a","b","ba","bca","bda","bdca"] trivial wordb while == "pcxbcf"]. 1: example, "xbc", = longest string chain longest string chain longest string chain longest string chain longest string chain
tree node.val of root1 search given return ascending input: output: 2: [8,1] containing [1,1,8,8] constraints: number [1,null,8], 105 trees from order. [0,1,1,2,3,4] is 5000]. range integers nodes [0, <= each [1,0,3] -105 in root2, example all a [2,1,4], both list 1: two sorted and the root2 binary = all elements in two binary search trees all elements in two binary search trees all elements in two binary search trees all elements in two binary search trees all elements in two binary search trees
[7]), of 6 target. sub-arrays [4,3,2,6,2,3,4], sub-arrays. first there are be with <= arr.length but example a answers -1 will [3]). return if one [7,3,4,7], to [3,2,2,4,3], 2: three an 2 [3,4] as ([3] 3 explanation: 108 required although find minimum. and only non-overlapping 6. or third 105 their 3: array arr target integers each sum lengths answer 1 so such is the output: we sub-array sub-arrays, given choose arr[i] input: you 1000 2. constraints: equal minimum 7 have can cannot integer where ([7], multiple 1: two = find two non-overlapping sub-arrays each with target sum find two non-overlapping sub-arrays each with target sum find two non-overlapping sub-arrays each with target sum find two non-overlapping sub-arrays each with target sum find two non-overlapping sub-arrays each with target sum
[3,3], of nums[i], this different element [1,2,3,4], there has contiguous [3] are be <= non-empty array. since i but note example a k index most will that which exists return [2,2]. one occur to once. 2: an also, 2 complexity? 4 every 10 [2,3,3,2,2], total at [3,3,2,2], as elements 0, counted 2, != constraints 3 follow nums.length satisfying indices distinct explanation: 1. 10. all arrays subarrays and they if: only least than [2,3], or said up: [2,3,3,2,2] 200 distinct, should time number subarray p. array solve because [2,3,3], integers nums it by each 1 nums1 divisible not [2] problem once sequence [3,3,2], nums2 more p, is the output: given input: you 4, 2. defined constraints: [2], nums2[i]. nums, have p can [3,2,2], integer where in are: lengths, 3, 11 [2,3,3,2], [3,2], 1: two [3], nums1[i] = o(n2) k divisible elements subarrays k divisible elements subarrays k divisible elements subarrays k divisible elements subarrays k divisible elements subarrays
[dayi, of dayi, (8,1). line. (3,5), stockprices[i].length on price. (7,2), are created be with <= following example day a price (4,4). 109 stock stockprices that return one to 2: adjacent an plane 2 pricei from as pricei. drawn (8,1) single x-axis 3 2d chart plotting explanation: all pricei] indicates using and y-axis [[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]] above (6,3), than connecting - line (in xy lines number 105 array needed it diagram by (1,7) possible lines. red) through shown 1 not distinct. green) below: such (5,4), passing input, is the output: blue) less stockprices[i] chart: (4,4) represent given dayi input: you (5,4). [[3,4],[1,2],[7,8],[2,3]] represented constraints: representing minimum (2,6), points points. can above, stockprices.length integer where (5,4) in chart. == represents 1: (1,7), = minimum lines to represent a line chart minimum lines to represent a line chart minimum lines to represent a line chart minimum lines to represent a line chart minimum lines to represent a line chart
1.0, given: equations[i] real of valid. ?, equations[i].length lower for dj] [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]] [["a","b"]], there e / digits. queries.length are bi.length variable be <= must 20.0 ai, example a also numbers ai bi, letters [6.00000,0.50000,-1.00000,1.00000,-1.00000] answers ai.length, will that no assume result return if bi] to 2: < division an 2 b values[i]. [["a","b"],["b","a"],["a","c"],["x","y"]] input contradiction. some single english equations queries[i].length cj values, explanation: evaluating equations.length pairs -1.0 [2.0,3.0], all always string cj, determined, find ? and ?. [6.0, values[i] return: or 0.5, queries[j] 3.0 20 3: equation array case variable. by each answer cj.length, 1 not 5 is the queries, output: zero dj.length [["a","b"],["b","c"],["bc","cd"]], [["a","c"],["c","b"],["bc","cd"],["cd","bc"]] [3.75000,0.40000,5.00000,0.20000] values represent given ] x input: you [1.5,2.5,5.0], [ai, values.length note: [0.5], queries. queries 0.0 constraints: bi query consist [cj, -1.0, may cannot where in dj are: 2.0, [0.50000,2.00000,-1.00000,-1.00000] [["a","b"],["b","c"]], -1.0. jth c == represents 1: = evaluate division evaluate division evaluate division evaluate division evaluate division
= no that of if given return substrings input: 2: s, three size s. should "xyz", "zza", "aba", every number 4 "yzz", characters. "bca", "abc". 7 "xyz". constraints: there 3: is string. substring, contiguous are english occurrence s be 3 "abc", <= repeated "cab", "bab", letters. s.length in counted. occurrences explanation: "xyzzaz" 1 note same example consists a only string "aab", multiple sequence good 1: "aababcabc" characters "zaz". 100 length and lowercase the output: substring substrings of size three with distinct characters substrings of size three with distinct characters substrings of size three with distinct characters substrings of size three with distinct characters substrings of size three with distinct characters
its of 1|1|0&1 for precedence calculation. (bitwise "1&(0|1)" over there on order. "1|1|(0&0)&1", empty are operations <= be 1|1|(0&0)&1 substring '0' "1", final operator),'|' '|'. example a "(0|(1|0&1))" properly ')'. will that no "(0|(0|0&1))" return if to value '&'. 2: "(0&0)&(0&0&0)" an types as take '|' 3 left-to-right "1&(0&1)" explanation: new 1. all turn string "(1)&()" want expression. using and expression.length only (i.e: parentheses into or contains apply expression number 105 valid 3: then operations. 1&1 by '1','0','&','|','(', cost '1'. expression). order expressions. evaluate 1 not so '1','0','&' 0. matched. characters "(((1))|(0))", is the '&' output: we first, "()1|1" given changing operator),'(', ')' follows: you input: "(0|1)|(0&0&0)" note: performed described constraints: minimum '1' "()" boolean 1|0&1 "1|(0&(1))" does can in '0'. while evaluates 1: example, consisting change operation. = minimum cost to change the final value of expression minimum cost to change the final value of expression minimum cost to change the final value of expression minimum cost to change the final value of expression minimum cost to change the final value of expression
events, of [[1,1,1],[2,2,2],[3,3,3],[4,4,4]], this + for events [[1,2,4],[3,4,3],[2,3,10]], any day. 7. is, on are valuei. end ends <= must highest valuei]. note example attend day (0-indexed) a also enddayi, 9 k events. 109 will that event. which if return one value to 2: an 2 starts 4 maximum 10 total events.length at as 3 event explanation: them 10. although and only they pick * 106 attending time. other number [[1,2,4],[3,4,3],[2,3,1]], ith 3: array receive by sum enddayi 1 not valued three. attend. inclusive: events[i] is the output: startdayi valuei overlap, 0 values given choose input: you notice constraints: 7 have can green do cannot integer where event, same represents 1: two entire [startdayi, = maximum number of events that can be attended ii maximum number of events that can be attended ii maximum number of events that can be attended ii maximum number of events that can be attended ii maximum number of events that can be attended ii
of view + ["one","two","three","four"], for any viewed smallest lowercase ids, views. ids.length on order. has popular ids[i], creatori are n "one" created be with <= letters. since highest example a "b" chris "c" ids creator, alice ["a","b","c"], most smaller ids[i].length that ids[i] id "two". 4. if return 2: creator[i], an [["alice","one"],["bob","two"]] creators. idi] english popularity 2d explanation: 10. idi all videos. bob, views string creator's find arrays count length and only views[i] than alice, video. platform number n. 105 them. ith their views, array [creatori, views.length it by included [1,2,2] sum "three", answer 1 count. answer[i] creators.length 5 ["alice","bob","alice","chris"], lexicographically creator "three". videos is the output: ["alice","alice","alice"], means [5,10,5,4] answer. 0 given popularity, returned you input: [["alice","b"]] constraints: creators consist id. have creators[i].length, can integer where in bob strings "c", == multiple 1: two creators[i] was video = most popular video creator most popular video creator most popular video creator most popular video creator most popular video creator
integer, no exists, than that the which - given if return returned value input: smallest 2: positive -1. 32-bit fit should constraints: n. existing valid there exactly has does n it <= n, 12 integer in greater answer 231 1 but note same example digits not a such 21 find 1: and is -1 output: = next greater element iii next greater element iii next greater element iii next greater element iii next greater element iii
its [[1,2,3],[4,5,6],[7,8,9]] matrix. indices. the * of matrix[i][j] given return matrix's -109 input: 2: 1000 [[1,2,3],[4,5,6]] matrix, transpose [[1,4,7],[2,5,8],[3,6,9]] m switching constraints: 105 matrix main over row array [[1,4],[2,5],[3,6]] flipped n <= m, 2d integer column 1 example a == matrix.length diagonal, 1: 109 matrix[i].length and is output: = transpose matrix transpose matrix transpose matrix transpose matrix transpose matrix
its 104 30. of wood. of: shaped this + for across pieces, 30 selling prices, prices. obtain are n be <= m, must width. wood after note example many consists a also hi make price shapes. prices[i] pieces. smaller grain that return makes to width horizontal 2: shapes an prices 2 times m 4 maximum pricei 10 total as some want. 2, 3 2d wi) explanation: difference, all piece pricei] indicates prices[i].length and above shows 3. * wi into - 106 or 200 32 dollars. money cutting number split earn 5, 19 amount obtains array 14 wood, [[1,4,2],[2,2,7],[2,1,3]] integers it diagram possible shape, 1 shown rectangular not distinct. 14. so vertical rotate the is output: 1, [[3,2,10],[1,4,2],[4,1,3]] we pairwise represent given height sell (hi, pieces x you input: earned. notice 4, prices.length 2. constraints: scenario. 7 swap have 6, can may [hi, do cannot integer where according 3, same == cut multiple 1: two entire = wi, selling pieces of wood selling pieces of wood selling pieces of wood selling pieces of wood selling pieces of wood
of this among for respectively. hence, [[10,1000]], denotes has queries.length are <= be answer[j] with considered note example a also [2,4]. considered. price 109 determine items, no exists, that items beautyi] which items[i] if return 4. to 2: [pricei, an 2 every maximum as [2,4,5,5,6,6] 2d explanation: [1,2] them 1. all beauty. want query. [0] length and queries[3]=4, only than 6. item [2,4], and/or - or queries[1]=2, [1] [[1,2],[3,2],[2,4],[5,6],[3,5]], queries[j] 105 queries[2]=3 0-indexed 5, 3: whose then array items.length, beauty each queries[4]=5 answer 1 5. [5] so such pricei, 0. [[1,2],[1,2],[1,3],[1,4]], is the output: 1, we less queries[j], given choose input: you beautyi, [3,5]. queries[0]=1, items[i].length chosen. queries. queries 2. constraints: equal queries[j]. query queries[5]=6, have [1,2,3,4,5,6] can integer where i.e., same jth == [4] [3,2], multiple 1: [1,2], = most beautiful item for each query most beautiful item for each query most beautiful item for each query most beautiful item for each query most beautiful item for each query
false 3. [3,4,5] the of this into given numbers. return if [3,4,5,6]. [1,2,3,4] input: to 2: [3,2,1,2,3,4,3,4,5,9,10,11], positive note: an size should question https://leetcode.com/problems/hand-of-straights/ 4 constraints: [1,2,3,4], 105 3: array as possible. integers nums it sets false. can be 3 possible <= each nums.length integer in explanation: 1 whether otherwise, nums[i] example divided same [1,2,3,3,4,4,5,6], a [9,10,11]. true [1,2,3] , [2,3,4] k divide 1: check subarrays 109 and 846: is output: = k, consecutive divide array in sets of k consecutive numbers divide array in sets of k consecutive numbers divide array in sets of k consecutive numbers divide array in sets of k consecutive numbers divide array in sets of k consecutive numbers
b. of beautiful. any for smallest palindrome. lowercase first there "abda". has larger k. empty are n be corresponding <= n, example consists a letters character k differ, smaller no that (of which position return if 2: an 2 "abcc" b 4 at english explanation: proven string 26 length and they if: fourth than "dc" beautiful or positive c. 105 "abcz". string. contain because "abcd" it character, s greater s.length 1 not lexicographically such "dc", more is the output: = given input: you alphabet. constraints: strictly "abcz", "" does can differ length) integer in where same "abda" == string, 1: example, d substring beautiful, lexicographically smallest beautiful string lexicographically smallest beautiful string lexicographically smallest beautiful string lexicographically smallest beautiful string lexicographically smallest beautiful string
less 104 fractional that than the of - 0 given return if enclose any for input: 2: fraction 333 repeating 4, repeating, 2 constraints: representing possible, them. 3: numerator, is denominator inputs. integers are "2" it 2, != <= in guaranteed answer 231 1 part example all a fraction, string "0.5" multiple 1: -231 two answers numerator and length "0.(012)" format. parentheses. output: = 1, fraction to recurring decimal fraction to recurring decimal fraction to recurring decimal fraction to recurring decimal fraction to recurring decimal
that backward need of step 0 "mdbabdm". becomes given return any one or 500 input: you to 2: insert s. 2 steps palindrome. number constraints: lowercase minimum forward. 3: inserting at string. is "leetcode" as english can s be "leetcodocteel". <= do "mbdadbm" reads "zzazz" in s.length letters. explanation: 1 same example not 5 consists a string make already insertions. character 1: well "mbadm" characters palindrome the index output: = we minimum insertion steps to make a string palindrome minimum insertion steps to make a string palindrome minimum insertion steps to make a string palindrome minimum insertion steps to make a string palindrome minimum insertion steps to make a string palindrome
that no least of [4,3,3], [2,3], nums1[i], - values given return any nums3.length input: you 2: value arrays. three present containing constraints: nums2. [] 3: order. at is array nums1.length, nums2[j], nums3[k] [1,2,2], nums2.length, [3] are 2, may [1,1,3,2], nums3. <= [3,2] integer in are: distinct explanation: nums1 [1,2] nums1, example 3, nums2, [3,1], nums3, all a out [5] 1: arrays nums3 two nums2 1 and [2,3,1] 100 the output: = 1, two out of three two out of three two out of three two out of three two out of three
its red positions of illuminates this for on. cell exist. lamps[i].length size lamps [[1,1],[1,1]] [1,0] grid[1][0] coli] there once, on has shares lamp queries.length asks n are 8 illuminated with side be <= after grid[0][0] lamps.length whether 20000 example a also blue diagonal. corner 1st lamps, 109 determine turning that if return grid[1][1] 2: adjacent < not. an rowi, 2 at column, [[0,0],[4,4]], off when grid[rowj][colj] either grid[4][4]. 2d ans, explanation: 1. turned cells all turn [[0,0],[0,4]], on, indicates grid[rowj][colj]. and they above initial than [1,1] [[1,1],[1,0]] or rowj, row, queries[j] other should 5, query, 3: then array 0th off. even integers it picture square). each ans[0] ans[1] set 1 not so coli 0. square. more the is queries, output: we [[0,4],[0,1],[1,4]] see illuminated, queries[j].length 0 colj given x grid you input: rectangle. lamps[i] queries [rowi, answering constraints: query [rowj, colj]. have listed [1,1,0] (the then, another ans[j] where in same initially jth == grid[rowi][coli] 1: was = grid illumination grid illumination grid illumination grid illumination grid illumination
of for any simultaneously. employees how favorite denotes beside has employees, invite n are be <= numbered i note example attend a also seat table. leaves will that organizing person 4. if return one to 2: employees. an round 2 way every 4 large maximum from at [2,2,1,2] 0, as 2, != 3 taken. sit explanation: them 1. table, all out invited. and give only invited they above shows 3. favorite.length least - [1,2,0] other themself. number circular 105 0-indexed meeting. their ith 3: array because desired each seats. 1 not favorite[i] list so 0. the is output: 1, capable company favorite, 0 seating given next figure input: employee employee, [3,0,1,4,1] arranged 4, between 2. constraints: arrangement have employee. can meeting cannot integer where in 3, same spots == 1: two waiting = maximum employees to be invited to a meeting maximum employees to be invited to a meeting maximum employees to be invited to a meeting maximum employees to be invited to a meeting maximum employees to be invited to a meeting
different. positions of any for [1,5,4,2,3], [1,2,3,4], [] there on order. are n specific <= operations be source. following after i ai, note example (0-indexed) allowed also a length, source.length ai distance target, index source[i] that no return bi] to 2: an 2 times allowedswaps[i] at as elements source[i], [2,1,3,4] != indices [[0,1],[2,3]] explanation: hamming indicates arrays length and they 3. n-1 way: pair [2,1,4,5], - allowedswaps[i].length number positions: n. amount 105 3: [1,3,2,4], target[i] array allowedswaps swaps. target it allowedswaps.length each 1 both [5,1,2,4,3], is the [[0,4],[4,2],[1,3],[1,4]] output: target.length transformed arrays, 0 given input: you [ai, 2. constraints: bi minimum (0-indexed). swap position: can differ integer where in same formally, == [2,1,4,3] multiple 1: two source performing = minimize hamming distance after swap operations minimize hamming distance after swap operations minimize hamming distance after swap operations minimize hamming distance after swap operations minimize hamming distance after swap operations
its different. 4] none 3] of + 2*2 for product any modulo 6 respectively. different 30 7. [2, are be with <= all) [2,3]: example a (possibly 109 that 30, which if return one [1,2,3,4] to products 2: an 2 4 from [3]: as elements some 2, 3 15, prime nums.length indices distinct explanation: [1, subsets primes [2]: and only [1,2]: 3. - or delete [2,15]: 4]: number 105 [15]: deleting [4,2,3,15] array nums [1,2,3]: by 3], 2*3, 1 nums[i] not 5 chosen good more is the output: we subset given numbers. input: you 2. represented constraints: obtained 6, [1,3]: can call integer in are: 3, [4] nums. 1: example, two 5. = the number of good subsets the number of good subsets the number of good subsets the number of good subsets the number of good subsets
b. "aebdc", of lower-case uncommon any for underlined subsequence. subsequences exist, are be include <= letters. after but note example a also -1 that return if one to 2: an b every similarly, from "abc" english 3 "bbb". explanation: "bbb" b, string other. length and delete -1. other "aaa", s. "aba", "abc". number b.length 3: deleting a.length, because s 1 not string). subsequence 100 characters the is longest output: "aaa" get "cdc". "aeb", given "aebdc" input: you "aba" between constraints: consist "" does obtained can a. in "cdc" strings (empty 1: example, two = longest uncommon subsequence i longest uncommon subsequence i longest uncommon subsequence i longest uncommon subsequence i longest uncommon subsequence i
different. b. of zero) 6 [3,2,5] different 7. there or. [3] are [2,5] be with <= non-empty considered subsets. example a (possibly [2,2,2] [2,1,5] [3,5] return if to 2: an 2 b maximum from 7: total elements some nums.length indices explanation: all subsets find and a[1] 3. - or 23 number 105 3: deleting array nums 1] by possible 1 nums[i] chosen is the output: subset a[a.length given input: 2. constraints: equal (0-indexed). nums, 7 have obtained ... can 16 a[0] integer bitwise [3,2,1,5] [3,1] [3,1,5] 1: two = count number of maximum bitwise-or subsets count number of maximum bitwise-or subsets count number of maximum bitwise-or subsets count number of maximum bitwise-or subsets count number of maximum bitwise-or subsets
false limitj of undirected this for distances first denotes there on edgelist has queries.length n are be with ui <= vi, whether note example true, a [[0,1,2],[0,2,5]] 109 edgelist.length, determine distance edges disi. that no graph return if to value 2: pj, 16. an 2 thus disi, nodes 2, != task edgelist[i] 3 [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], edge explanation: true edgelist[i].length edgelist, query. and above shows answer, than -> - ui, queries[j] limitj], 105 5, otherwise. query, your array disi] by each answer qj 1 such vi the is queries, output: we less [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], . queries[j].length 0 given figure input: between queries 2) defined nodes. constraints: strictly [false,true] pj boolean [pj, qj, graph. [true,false] [ui, may (0 second where [[0,4,14],[1,4,13]] 3, answer.length jth == multiple 1: two path = overlapping checking existence of edge length limited paths checking existence of edge length limited paths checking existence of edge length limited paths checking existence of edge length limited paths checking existence of edge length limited paths
chose [8,10,12]. case, lower of + this for any present integers. [4,8,12]. there lost [2,10,6,4,8,12] [220] 215. obtain n are created <= help arr. [2,6,10,4,8,12], be with [5,7,9] must following lower[i] since i but note example a [5,435] [1,1,3,3] k 109 us index alice k, that [2,2] had which exists return if manner: one to 2: < test remembers three an remaining 2 every way exactly at [1,3] nums.length explanation: new recover all original generated arrays using and arbitrary only 3. least [1,1] * - permutation [435]. positive arrays. higher them, higher, possibility valid 0-indexed positive. 3: array because arr integers case nums possible each she answer 1 nums[i] not [2,6,10] gives [5] combining such to. 0. the is output: 1, we = get [1,1,3,3], 0 given arr[i] higher[i] input: 1000 note: unfortunately, 2n constraints: equal belonged [3,3]. integers, another combination cannot integer in where invalid were cases however, == nums. unique, 1: [3,7,11] two [2,4,6] consisting array. recover the original array recover the original array recover the original array recover the original array recover the original array
bits "1". + for first denotes n <= 11th guaranteed i example 1st x, k "0111001" k, "0" that return "011100110110001" to 2: si invert(x) changes as s4 explanation: all > string inverts four and binary above "011" - positive formed 20 n. valid integers it reversed 1 operation, sequence bit s2 sn the s1 is output: reverse(invert(si concatenation given x follows: input: sn. 1)) 4, "0". constraints: 2n 0). s3 kth returns "011100110110001". (0 where reverse(x) in are: 3, 11 strings 1: example, two "1" "0111001". = find kth bit in nth binary string find kth bit in nth binary string find kth bit in nth binary string find kth bit in nth binary string find kth bit in nth binary string
(2, 104 34. for product 64. difference. 6 d) first 64 z y, (5 maximized. <= difference 4) (c, example (a x, that [5,6,2,7,4] return 2: (nums[w], 16. an 2 4 maximum as b) 3 nums.length indices distinct explanation: pairs four and (a, (2 (5, * pair - (9, (6 34 d). (c array 4). 8) nums [4,2,5,9,7,4,8] w, (nums[y], 1 6) nums[i] 5 (6, 7) such the is output: we given choose input: nums[x]) between defined constraints: nums, nums[z]) can (9 second integer 1: example, two = maximum product difference between two pairs maximum product difference between two pairs maximum product difference between two pairs maximum product difference between two pairs maximum product difference between two pairs
[[1]] given x input: to 2: filled generate positive an 20 constraints: from matrix order. elements n <= with 3 n, [[1,2,3],[8,9,4],[7,6,5]] integer in 1 example a n2 1: spiral output: = spiral matrix ii spiral matrix ii spiral matrix ii spiral matrix ii spiral matrix ii
non-decreasing = no that least of [1,2,3,6], which nums1[i], given return if said one input: to 2: smallest arrays. -1. element an 2 2. constraints: 105 minimum there have nums1.length, at is array smallest, order. elements are 2, occurrence be 3 <= integer. integer in nums2[j] [2,4] explanation: nums1 1 note example [1,2,3], nums2, out nums2.length common both so [2,3,4,5] order, arrays 1: two nums2 sorted and returned. 109 the output: amongst we minimum common value minimum common value minimum common value minimum common value minimum common value
of this names "./" folder, operation. lowercase back go digits. statement. are "x/" operations <= operation guaranteed parent after example a (if letters '/'. 103 use ["d1/","d2/","./","d3/","../","d31/"] follows return to 2: log exist). 2 times starts logs file change 10 at named some user english 3 "../" folder). explanation: always leetcode already and '.', performs letters, system contains format time number ith 3: then operations. needed by each 1 below: list folder. current is the output: logs[i].length 0 child given digits, x input: you logs[i] performed. ["d1/","../","../","../"] described performed folder constraints: remain consist minimum main in where logs.length same strings : move (this 1: step. ["d1/","d2/","../","d21/","./"] keeps = crawler log folder crawler log folder crawler log folder crawler log folder crawler log folder
104 4] of + this for [3, 6 select 5] [2, first y equal. n <= be operations n, operation guaranteed i (i.e., example make n). x, 9 arr[x] that return one to 2: < an 1). 2 subtract thus from 0, elements some perform 3 indices explanation: [1, all using 3]. length (2 and * += number i) valid again, array add operations. arr needed it 1 operation, is the output: made -=1 0 values given arr[i] choose x input: you goal constraints: equal minimum have can array, second integer where in 3, arr[y] leads 1: two = minimum operations to make array equal minimum operations to make array equal minimum operations to make array equal minimum operations to make array equal minimum operations to make array equal
of valid. this any for zero) modifications lowercase characters. there are be with <= "v" guaranteed after solution, final example a (possibly letters will "?zs" that no solutions return if one 24 to 2: made. an "ubvww". from "azs" as problem. english explanation: "ubv?w" all always string and only than into them. contain "ubvaw" it character, s been possible s.length answer "yzs", shown 1 not such '?' 100 characters more is the output: consecutive modify '?'. modification "w" given "ubvvw" conversions input: you repeating 25 except containing constraints. constraints: consist have "z" does can convert cannot in invalid non strings 1: "zzs". = replace all ?'s to avoid consecutive repeating characters replace all ?'s to avoid consecutive repeating characters replace all ?'s to avoid consecutive repeating characters replace all ?'s to avoid consecutive repeating characters replace all ?'s to avoid consecutive repeating characters
lower of tallest, names for emma integers. heights. first people's are n <= heights[i] ["mary","emma","john"] letters. person. example consists followed index alice 103 that return 2: an bob. ["bob","alice","bob"] english name distinct explanation: all john. arrays length and descending [155,185,150] positive names, heights 20 ["alice","bob","bob"], n. 105 ith array names[i].length case names.length by denote each order 1 distinct. both is the output: mary values height given input: you ["mary","john","emma"], [180,165,170] heights.length constraints: second in bob upper strings == 1: names[i] sorted = i, sort the people sort the people sort the people sort the people sort the people
its of this subsequence, whole [5,-7,3,5], 6 is, removing are goal, <= with difference array. -7 note example a (possibly 109 that which if return to value 2: an [7,-9,15,-2], (-5)) as elements some nums.length explanation: absolute all original want minimum. abs(-4 and subsequence's 6. abs(sum - or formed -4. 3: then array nums by abs(1) possible sum 1 nums[i] [1,2,3], so such subsequence none) 0. is the output: minimize 1, 40 goal). 0 given choose -109 input: you -5 goal [7,-9,-2], constraints: equal sum, minimum 7 closest -107 integer goal. 107 1: = closest subsequence sum closest subsequence sum closest subsequence sum closest subsequence sum closest subsequence sum
of + this among for 6 version k. contiguous [1,2,1,3,3] subarray: are 8 be <= [1,2,1,3,3]. non-empty split. trimmed([3,1,2,4,3,4]) example trimmed(subarray).length. a numbers (2) k 109 [1,2,1]. will that which 4. if return one [1,2,1,2,1] value to 2: < subarrays: (0) an 2 4 10 elements some [3,4,3,4]. trimmed([1,2,3,3,3,4,4]) [1,2,1,2,1], nums.length explanation: [1,2] [1,2,1,2,1,3,3], 10. all and (2 only 6. trimmed(subarray) into importance number removed. split appear subarray 3: then array nums let it possible each sum cost (3 [1,2], [1,2,3,3,3,4,4], shown 1 nums[i] 5 once sequence is the output: we = [1,2,1,2,1]. 0 given input: you [3,3,3,4,4].the 1000 2. 2) constraints: minimum have subarrays. splits. can within integer in where [1,2,1] 8. nums. 1: example, two 5. array. minimum cost to split an array minimum cost to split an array minimum cost to split an array minimum cost to split an array minimum cost to split an array
graph[a] of any graph[i].length i. n are <= with node, [[1],[0,2,4],[1,3,4],[2],[1,2]] i edges. example a that graph connected return if one to 2: < undirected, an every 4 from input graph[i] at nodes node start 12 explanation: b, 1. all always labeled length and times, [[1,2,3],[0],[0],[0]] - stop contains revisit [0,1,4,2,3] reuse then array shortest contain connected. by possible graph.length graph[b] node. 1 not list the is output: edge. [1,0,2,0,3] 0 given input: you constraints: have does a. may where == multiple visits 1: path = shortest path visiting all nodes shortest path visiting all nodes shortest path visiting all nodes shortest path visiting all nodes shortest path visiting all nodes
(inclusive). of + for modulo element present (nums[i] nums[i+1]) denotes there obtain create are n itself. 8 end <= with array. following 10, digit triangular after i since example depicts a 9 % index that which if return process. one value 2: < newnums[i] from comprise newnums as process terminates: nums.length explanation: new 1. repeat length and only above - [1,2,3,4,5] elements. 0-indexed assign array operator. nums let diagram each replace sum 1 nums[i] 5 [5] the is output: 1, we step 0 given input: you 1000 newnums. between constraints: nums, integer where in otherwise, == nums. starting 1: entire = i, find triangular sum of an array find triangular sum of an array find triangular sum of an array find triangular sum of an array find triangular sum of an array
will 104 it. the merging of into 0 given return ascending one ] 1->1->2->3->4->4->5->6 input: you 1->3->4, 2: 500 1->4->5, 2->6 an [[1,4,5],[1,3,4],[2,6]] constraints: lists[i].length [] 3: order. [ merge array lists[i] linked-lists are <= each lists[i][j] exceed lists.length sum in are: explanation: them example [1,1,2,3,4,4,5,6] not lists all 104. == list: linked-list k 1: sorted and -104 is [[]] output: = lists, merge k sorted lists merge k sorted lists merge k sorted lists merge k sorted lists merge k sorted lists
104 of node). 6 graph[i].length there order. 104]. n are be with <= node, [2,4,5,6] i edges. example a edges will no that graph 4. if return to 2: above. adjacent an every 4 from graph[i] at as nodes node 2, either increasing 2d self-loops. edge explanation: 1. [1, all outgoing meaning labeled and only (or 6. * - directed or ascending lead [[1,2],[2,3],[5],[0],[5],[],[]] should number 5, 0-indexed them. array contain by possible each graph.length answer shown 1 5 safe is the range output: 0 given input: 4, represented containing constraints: strictly graph. graph[i]. may another terminal integer where in [[1,2,3,4],[1,2],[3,4],[0,4],[]] == [4] starting leads 1: path sorted graph[i][j] = i, find eventual safe states find eventual safe states find eventual safe states find eventual safe states find eventual safe states
false the - becomes given return if right, up: x input: to 2: you without left, an string? palindrome. right constraints: -121 otherwise. from 10 3: 121-. solve as converting left. it -121. <= follow therefore reads integer explanation: 231 1 example not 01 a true , left x, 1: -231 121 could and palindrome is output: = palindrome number palindrome number palindrome number palindrome number palindrome number
(inclusive). 30. vj, of undirected + visit any unique. vj] 30 complete. 7. [1,2,3,4], there n are ends with added <= numbered be visited giving timej, example a also [uj, node's quality edges sum). edges[j] most edges.length that graph connected maxtime. [0,32,10,43], return one to value 2: < an 2 starts 4 46 maximum from 10 total [[0,1,10],[1,2,10],[0,3,10]], at finally, 0, 2000 nodes 50. node [5,10,15,20], 3 2d edge explanation: vj 108 pairs all indicates 25. takes four and values[i] -> times. - timej 32 50 time maxtime 20 valid 0-indexed maximal ith 3: array connected. timej] it possible each 49 sum node. seconds 1 13 edges[j].length 5 75. not 75 once 0. 100 edges, the is (each uj path. output: 1, 40 0 values given [[0,1,10],[1,2,11],[2,3,12],[1,3,13]], input: you 43 values.length 1000 note: 25 between nodes. 49. constraints: 7 unique may taken integer where in 3, same == travel multiple [[0,1,10],[1,2,15],[0,3,10]], 1: two path = maximum path quality of a graph maximum path quality of a graph maximum path quality of a graph maximum path quality of a graph maximum path quality of a graph
51 less will 50) 104 that than [1,12,-5,-6,50,3], the of this - + [5], given return any accepted. you to value input: 6 2: an error 4 elements, constraints: equal average maximum 105 10-5 12.75000 subarray whose has is array / 12.75 k. contiguous are nums n 5.00000 be with <= nums.length integer answer explanation: (12 1 nums[i] example value. 5 a == calculation find k 1: length and -104 consisting output: = maximum average subarray i maximum average subarray i maximum average subarray i maximum average subarray i maximum average subarray i
its of + for any element rearranged integers. nums[i+1]) / property are <= 2.5. i example 4.5. a [1,2,4,5,3] that return neighbors. to 2: < (nums[i-1] 2 every (7+2) 3.5. elements when 2, 3 (1+4) nums.length distinct explanation: (2+5) want and meets 3. - [1,2,3,4,5] should [9,7,6,2,0] i=3, average 105 5, 0-indexed requirements. array (9+6) nums (6+0) 7, 1 nums[i] not such more is the range output: 7.5. 1, 0 given input: you rearrangement 4, [6,2,0,9,7] constraints: equal neighbors rearrange have (4+3) 6, i=1, nums[i]. in i=2, formally, 1: = array with elements not equal to average of neighbors array with elements not equal to average of neighbors array with elements not equal to average of neighbors array with elements not equal to average of neighbors array with elements not equal to average of neighbors
of 34. & (1,1,1) (0,1,0) (0,1,1) are <= corresponding with be 4) (0,0,0) note example a nums[j]) k 109 (0,0,1) will xoring j, return (1,0,1) value 2: < three 4 [1,4] [15,45,20,2,34,35,5,44,32,30] as val2. triplets effective (1,1,0) nums.length indices explanation: ((4 all ((1 and | - or 34 n. 105 0-indexed (i, their array nums ((nums[i] possible 1 xor xor-beauty nums[i] 5 below: (1,0,0) the is output: 0 values val1 given val2 you input: ^ defined constraints: beauties listed that: 1) integer where bitwise k) nums. 1: nums[k]). 5. = i, find xor-beauty of array find xor-beauty of array find xor-beauty of array find xor-beauty of array find xor-beauty of array
notepad of this for present there on 'a'. are n last operations <= n, operation example a character (a screen use which return one to 2: an times paste: exactly 'a' 2, perform 3 explanation: all step: copy initially, only partial time. number 'aaa'. each 1 not screen. characters allowed). is the paste output: 1, we get step 0 given all: input: you 1000 constraints: minimum 'aa'. have notepad. can integer in 3, copied 1: two operation. = 2 keys keyboard 2 keys keyboard 2 keys keyboard 2 keys keyboard 2 keys keyboard
>= of this + any reduce integers. 5] 15.5. has (note 31 31/2 are 8 operations with be <= following final example a half: 4.75, 14.5 half. that which 4. return one to 2: number. an 14.75 33 [5, 4 from 10 total exactly at used 14.5. 3 nums.length explanation: 1.5. 10. 18.25, [5,19,8,1] 4.75 and 16.5 initial 3. least than pick 14.75. - positive 8, 20 number 19 105 [1.5, array operations. nums it 1] by 18.25 been sum 1 shown nums[i] 5 operation, 33/2 31. 1.5 16.5. so 9.5. is the output: we less 4.75. half ways given choose input: you 4, constraints: equal sum, minimum 33. operations.) 9.5 can may [3,8,20] cannot in were future 16.5, 107 reduced 1: 5. overall, = minimum operations to halve array sum minimum operations to halve array sum minimum operations to halve array sum minimum operations to halve array sum minimum operations to halve array sum
linked [3,3] of any maxima 6 [1,3,2,2,3,2,2,2,7]: distances [2, there has maxima/minima are last be <= head considered 105]. sixth note example maxdistance] a distance smaller node.val that no [-1,-1] exists if return value 2: three an 2 fewer maximum as nodes node 3 either [1,3] distinct explanation: -1]. 1. mindistance [5,3,1,2,5,1,2] length and only 3. [1,3,2,2,3,2,2,2,7] points, than - or number third 105 3: array because it minima greater node. 1 fifth 5 not minima. both list critical current [-1, thus, is the range output: less point given next [3,1]. input: maxdistance local between 2. defined containing [mindistance, constraints: strictly minimum points: have does points [5,3,1,2,5,1,2]: points. can head, second in where previous [3,1] 1: two = find the minimum and maximum number of nodes between critical points find the minimum and maximum number of nodes between critical points find the minimum and maximum number of nodes between critical points find the minimum and maximum number of nodes between critical points find the minimum and maximum number of nodes between critical points
of this for right, left, first there on has are n falling purposes <= consider pushed. after final example a ".l.r...lr..l.." '.'. due will that no "ll.rr.llrrll.." if return to 2: adjacent similarly, from beginning, push still some when expends simultaneously either explanation: where: dominoes string question, already upright. and '.', force initial place pushed 'l', or state. domino additional 105 their ith standing state it vertically been each pushes 1 not both forces. fallen right. vertical is the domino. output: we given input: you sides, "rr.l" second, balance right constraints: representing left. 'r', stays second in dominoes[i] == dominoes.length left line, 1: = push dominoes push dominoes push dominoes push dominoes push dominoes
least "cabc" of "abcabc", "aaacb", "aacb" given return substrings one "abcabc" x input: output: 2: or consisting c. "bca", containing "aaacb" b number constraints: characters. "bcab", 10 3: at a, "abc" are occurrence "abca", s "abcab", (again). "abc", "bcabc", 3 "cab", "acb". <= s.length 10^4 these explanation: 1 example 5 all consists a c string 1: characters and the only = number of substrings containing all three characters number of substrings containing all three characters number of substrings containing all three characters number of substrings containing all three characters number of substrings containing all three characters
h of this for rows: (lower-case ',' "pahnaplsiigyir" y on n this: <= numrows i example consists a upper-case), make letters '.'. will that like code to 2: line: 4 r fixed (you english take 3 explanation: convert(string g rows string "paypalishiring", want and "a" font display "paypalishiring" better line s, numrows); number legibility) 3: then by s s.length 1 the is written output: write conversion given zigzag "a", input: 1000 pattern constraints: l read p may in "pinalsigyahrpi" int 1: = zigzag conversion zigzag conversion zigzag conversion zigzag conversion zigzag conversion
104 subset. of respectively. element size [1,3,3,3,2], labels first there n are [5,4,3,2,1], numwanted, <= with example a also 9 most labels[i] items return value uselimit. to 2: score 2 maximum at elements 12 explanation: items. numwanted. arrays and values[i] fourth than * or label s. third ith 3: integers s values[i], sum set 1 fifth chosen such is the output: labels.length first, less subset third, uselimit 0 values given choose input: you values.length second, constraints: equal that: numwanted 16 integer where in [9,8,8,7,6], 3, same == 1: two [1,1,2,2,3], [0,0,0,1,1], = largest values from labels largest values from labels largest values from labels largest values from labels largest values from labels
b. divides the 6. of given return if x input: 6 2: positive 1000 30 25 an 2 b 4 number constraints: 12, factors integers a, are 2, 25, <= factor 12 integer explanation: 1 b, example 3, a common both 1: two and is 5. output: = 1, number of common factors number of common factors number of common factors number of common factors number of common factors
b. a[i], of present integers. are n [3,1,2] [0,1,3] <= guaranteed i prefix c[1] example a c[0] numbers index that no 4. return if to once. 2: an b 4 from exactly at before 2, 3 explanation: b, 1. all count length and only 3. c[i] permutations or contains permutation 50 number n. 0-indexed b.length 3: [1,3,2,4], array [0,2,3,4] integers it 1 common both so such sequence 0. called 0: the is output: 1, [2,3,1], given input: you [3,1,2,4] 2. constraints: equal c[3] common, c[2] integer in a.length 3, c == b[i] 1: two = find the prefix common array of two arrays find the prefix common array of two arrays find the prefix common array of two arrays find the prefix common array of two arrays find the prefix common array of two arrays
of this + among modulo respectively. different select 7. first there is, are n be with <= numbered since but example a [5,4,3,9,7,2], speeds k 109 speed.length team. most that return selecting efficiency number, to 2: 2 efficiency.length speed=10 4 maximum from 10 efficiency[i] at performance as speed=5 68. 3 team explanation: 108 out 5) engineers. arrays length and 60 (2 speed efficiency=7). 3. * 60. (10 engineers engineers' n. 105 ith their 3: 72 integers it by engineer sum multiplied answer 1 (with 5 7) both min(5, form the is [2,10,3,1,5,8], output: 1, we get min(4, represent given choose input: you 4, 68 constraints: minimum have 6, huge can efficiency=4) integer same == performance. 1: two speed[i] = maximum performance of a team maximum performance of a team maximum performance of a team maximum performance of a team maximum performance of a team
places. 130 varchar of this + customer for 6 how data 140 860 anna about on order. has 2019-01-08 restaurant 2019-01-02 are 8 be with 80)/7 following before). visited type 122.86 (i.e., example day customer. average_amount a 2019-01-10 expansion 1st 9 +---------------+---------+ table. will (there id days which result 3rd return one to an 2 primary every 4 2019-01-07 from jade total at 110)/7 2nd name compute 3 (customer_id) 2019-01-04 column explanation: 2019-01-05 rounded table want and customer_id | least key jhon ascending decimal contains (100 format date much should seven paid average amount khaled ordered daniel 2019-01-01 (130 by possible 150)/7 analyze winston transactions +-------------+--------------+--------------+-------------+ 1 142.86 5 visited_on) current table: 100 maria the is output: 150 write 2019-01-06 owner (120 input: you 1000 jaze visited_on query 7 day). sql example. (customer_id, restaurant. 2019-01-09 in (110 2019-01-03 +--------------+--------------+----------------+ 840 elvis int 120 moving 1: 110 two 80 4th window = schema restaurant growth restaurant growth restaurant growth restaurant growth restaurant growth
bits work. of tree. this yourself. across deserialized how different data design [] there on 104]. input/output creative be with stored <= computer example a serialization clarification: serialize node.val that no structure to 2: an buffer, come up file as process nodes deserialize follow format, leetcode string original and binary tree just need restriction -1000 into or object algorithm format should number serialized link approaches your converting reconstructed it necessarily memory not so sequence is the range output: serializes network structure. input: you 1000 environment. constraints: transmitted [1,2,3,null,null,4,5] serialization/deserialization please can later [0, connection another do ensure in same root 1: = serialize and deserialize binary tree serialize and deserialize binary tree serialize and deserialize binary tree serialize and deserialize binary tree serialize and deserialize binary tree
of words, this for any smallest size integers. has [2,1] or. contiguous are n be <= with n, must non-empty i example non-negative a numbers [3,3,2,2,1] k 109 determine index that it. return [3,3,2,2,1]. to 2: an maximum from at 0, elements sized 2, nums.length explanation: [1,2] 1. all yields find length 3. need [1,3]. - or other 105 (inclusive) 0-indexed subarray array shortest nums let it possible each answer 1 answer[i] nums[i] bij such sequence therefore, [0,2,1]. the is output: 1, we = 0 [3]. given input: you max(bik) [2,1]. nums[i...j]. 4, 2. constraints: equal minimum [1,0,2,1,3] within integer in where bitwise 3, == starting 1: [1,0,2]. consisting array. i, smallest subarrays with maximum bitwise or smallest subarrays with maximum bitwise or smallest subarrays with maximum bitwise or smallest subarrays with maximum bitwise or smallest subarrays with maximum bitwise or
46. player1, is: of + 2*2 player2 for any xi 6 respectively. game, game 21. turn. there are n 8 <= draw. [8,10,10,2] example consists a player1[i], pins 2*9 that assume player1 if return 2*10 value 2: to score 16. [6,5,2,3] 2 4 xi. 10 exactly turns, 2, 3 explanation: 10. 1. draw, turn arrays and than [2,3], number equals 0-indexed ith their 3: case it each sum answer 1 5 [3,5,7,6], 2*7 0. 2xi more is the output: 1, bowling 0 values represent given input: you 1000 2. hit constraints: 42. 7 player2.length player1.length turns. player integer in otherwise, previous == [4,10,7,9], 1: [4,1] player2[i] two so, winner, player2, = determine the winner of a bowling game determine the winner of a bowling game determine the winner of a bowling game determine the winner of a bowling game determine the winner of a bowling game
of good. for different lowercase about there are end <= letters. frequency note example a make ignored). character no that if return appears one to 2: 2 times way still at 'a' 2, english explanation: 1. frequency. string already and only need 'b' delete contains s, number resulting 105 3: string. 'c's it s "ceabaacb" "aaabcc". s.length 1 both good called characters is the output: we 0 given "aaabbc". input: you "aab" (i.e. constraints: minimum have 'b's care can another in same "eabaab". while "aab", 1: example, "aaabbbcc" two 'c' = minimum deletions to make character frequencies unique minimum deletions to make character frequencies unique minimum deletions to make character frequencies unique minimum deletions to make character frequencies unique minimum deletions to make character frequencies unique
104 that made need assume of coins + [1], 0 - given return if any coins[i] money. you to different input: 2: -1. an fewest money kind coin. amount. number up [2], constraints: representing denominations amount 3: total coins, have array are by may be 3 <= each combination cannot 12 integer coins.length infinite [1,2,5], explanation: 1 231 example 11 5 a make 1: and the -1 output: = coin change coin change coin change coin change coin change
paths of visit any cell left, 7. there on are n be <= m, must grid[0][0] final example non-negative a grid[1][2] make (0,1). able grid.length -1 [[0,2,4],[3,2,1],[1,0,4]] top that no grid[1][3] which 4. return if one grid[1][1] to 2: adjacent (0,0). 2 m 4 col) from matrix at 0, when 2, (2,3). take explanation: grid[row][col]. 1. directions: required takes following: four and cell, grid[row][col] second. only grid[0][1] up, 3. matrix. (1,2). than 6. [[0,1,3,2],[5,1,2,5],[4,3,8,6]] * - or t (1,1). -1. time 105 5, standing then 0th because integers it possible each greater bottom-right 7, 1 shown grid[2][3] down, right. col), is the output: 1, we means cell. (row, grid[i].length 0 given grid x you input: second, (1,3). 1000 4, 2. constraints: equal minimum 7 possible. 6, can cannot grid[i][j] where in top-left 3, == left represents move 1: path consisting 5. = minimum time to visit a cell in a grid minimum time to visit a cell in a grid minimum time to visit a cell in a grid minimum time to visit a cell in a grid minimum time to visit a cell in a grid
false red of this for cell rmove, game color blue, on middle there white, 'b'. opposite are 8 <= with respectively, board[r].length choosing after example black consists a "b" 'x'. endpoint character board[rmove][cmove] c) no becomes return if one vertical, to (rmove, 2: < three remaining an rmove legal as marked (white endpoints either cmove) (either explanation: board diagonal). cells board, true find '.', and free). cell, only board. [[".",".",".","b",".",".",".","."],[".",".",".","w",".",".",".","."],[".",".",".","w",".",".",".","."],[".",".",".","w",".",".",".","."],["w","b","b",".","w","w","w","b"],[".",".",".","b",".",".",".","."],[".",".",".","b",".",".",".","."],[".",".",".","w",".",".",".","."]], above 'b' or cmove line (no lines 0-indexed (including integers '.' board.length it by each endpoint. if, black). (horizontal, not chosen endpoints) below: good more is the output: color, 0 "w" given changing figure grid x you input: board[r][c] [[".",".",".",".",".",".",".","."],[".","b",".",".","w",".",".","."],[".",".","w",".",".",".",".","."],[".",".",".","w","b",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".","b","w",".","."],[".",".",".",".",".",".","w","."],[".",".",".",".",".",".",".","b"]], 4, represented (r, it, constraints: colors black), free representing playing annotated can 'w'. where in 3, examples however, while == rectangles. represents move 1: two move, 'w', = legal. white check if move is legal check if move is legal check if move is legal check if move is legal check if move is legal
'x' xrlxxrrlx false 104 will "xr". replacing -> xrlxxrrxl of like 'l', exists or "rxxlrxrxl", given one return if input: to output: xrlxrxrxl 2: "x", "xl" "rx" characters, constraints: transform steps: consist composed there start.length end, occurrence can end <= 'r', with either start following ending rxxlrxrxl in these explanation: 1 "lx", "xrlxxrrlx" example consists a == 'x'. both string starting true moves move sequence "l" 1: xrxlrxrxl other. characters and end.length the only = we swap adjacent in lr string swap adjacent in lr string swap adjacent in lr string swap adjacent in lr string swap adjacent in lr string
round. of + 6 strange winner rest rules: has / tournament: are n <= with randomly n, example a 1st advance. declared team. that teams 3rd if return one to 2: an paired 2 4 until total decided. 2nd 2, 14, 3 team explanation: odd, and 6. tournament - 200 advances number 14 gets each even, 7, 1 13 13. current is the output: 1, paired. details tournament, winner. played, given next input: you advance 4, (n constraints: 7 matches another 1) round: integer in 3, played 1: 4th = count of matches in tournament count of matches in tournament count of matches in tournament count of matches in tournament count of matches in tournament
false of "cabbba" vice any for abcde word2.length lowercase characters. on "acb" are attain operations with <= character. following operation considered letters. b's, example many character b's word2, "aa" a's) use "bca" strings, if return one versa, to 2: word1.length, impossible 2 times "abbccc" every transform existing from aecdb as "abc" english 3 either word1, explanation: all turn bbcbaa string true using and close, only "caabbb" necessary. word2 a's -> into or apply other number 105 otherwise. 3: operations. contain it occurrence character, "abc", 1 aacabb the is output: (all "cabbba", word1 given "a", close input: you operations: constraints: "baaccc" swap can another do in same strings 1: example, two = determine if two strings are close determine if two strings are close determine if two strings are close determine if two strings are close determine if two strings are close
write will 104 that linear constant [3,5] the 3] * answer. which - given return any input: you once. space. output: algorithm 2: other an twice, extra 2 [5, [-1,0] constraints: appear valid [1,0] nums, 3: exactly order. is array elements [0,1] integers uses complexity can nums <= 3 each must runs nums.length integer in answer explanation: 231 1 [1,2,1,3,2,5] nums[i] example all also a once find 1: two and -231 twice. only = runtime single number iii single number iii single number iii single number iii single number iii
of + nums[4] solution [] [nums[i], are <= must i example k, that j, sums nums[3] return to nums[j] 2: an 2 up output (-1) triplets 3000 != 3 nums.length explanation: distinct [0,1,1] all and only [-1,0,1,2,-1,-4] nums[1] 105 3: array contain nums possible sum set order 1 [0,0,0] nums[i] not nums[2] such [-1,0,1] 0. the [-1,-1,2]. output: nums[k]] triplet 0 given duplicate input: [[-1,-1,2],[-1,0,1]] matter. notice constraints: nums, does nums[j], nums[k] nums[0] -105 integer j [[0,0,0]] == 1: triplets. = 3sum 3sum 3sum 3sum 3sum
linked constant) of [3,2,0,-4], cycle cycle. connects first there 104]. o(1) be <= head following continuously list, note example a tail's again -1 index node.val no that connected return if to 2: null. as some nodes node used follow explanation: memory? using begins. linked-list. pointer or up: passed internally, number 105 pos valid 3: solve pointer. it by denote node. [1,2], cycle, 1 not parameter. list the range is output: modify 0 [1], given next input: you (i.e. constraints: (0-indexed). can [0, do -105 second where in tail reached 1: list. = linked list cycle ii linked list cycle ii linked list cycle ii linked list cycle ii linked list cycle ii
104 positions that (for it. * of values necessairly given return ascending any sorting [0,0,1,1,2,5] input: you 2: without smallest unique. -5 other an 5). 2 time constraints: changed nums, [5,1,1,2,0,0] array solve possible. some integers are sort complexity built-in nums <= with array, must nums.length in after functions order explanation: 1 note example nums[i] problem not 5 while [5,2,3,1] space numbers 3), using 1: o(nlog(n)) example, and the [1,2,3,5] output: = sort an array sort an array sort an array sort an array sort an array
of any for 6 penalty has [9] are 8 <= with maxoperations. following operation after example also a balls, 9 109 times: most [2,4,8,2], 4. return to 2: [2,4,4,4,2] an 2 4 balls maximum [3,3,3]. maxoperations, at 2, take perform 3 [2,2,2,4,4,2]. nums.length explanation: new want and 3. [2,2,2,2,2,2,2,2]. -> into - or contains positive should [2,4,4,4,2]. number 105 ith your array operations. balls. nums it possible 1 [9], nums[i] 5 so divide [6,3] is the output: minimize bag given bag. maxoperations you input: [6,3]. 2. constraints: [2,2,2,4,4,2] minimum can [2,2,2,2,2,4,2]. integer where in bags [2,4,8,2] sizes become example, 1: two [2,2,2,2,2,4,2] performing = minimum limit of balls in a bag minimum limit of balls in a bag minimum limit of balls in a bag minimum limit of balls in a bag minimum limit of balls in a bag
max(|nums[1] of this among x. for first nums[4]|, [10,1,2,7,1,3], empty are be <= difference i max(0, note example a 109 |nums[i] |x| index that minimized. no j, which return appears value to 2: nums[j]|, zero. an also, 2 maximum from attain. at nums[5]|) elements 0, amongst define |nums[2] 3 nums.length indices explanation: pair. pairs 1. all absolute find and than pair [4,2,1,2], - formed 105 0-indexed p. array (nums.length)/2 nums let set 1 nums[i] once form such |2 therefore, more is the output: we 0 given 2| input: you 4, constraints: minimum p pairs. can 1) second integer ensure where represents 1: 5. = minimize the maximum difference of pairs minimize the maximum difference of pairs minimize the maximum difference of pairs minimize the maximum difference of pairs minimize the maximum difference of pairs
[[0, 1]], of words, who this for [3, unique. xi [2, y denotes but: over there i. unhappy. are n y, be with <= because: [0]], but example a [[1, yi unhappy preferred even. denoted 500 yi] person exists if return one to [xi, preferences 2: 2]] pairs, paired 2 4 xi. from exactly friend contained 0, some 2, != 3 cause explanation: pair. pairs [1, all always preferences[i] happy. friends and prefers pairs[i] v. than friends. into - pairs.length friends, xi, contains other number pairing 1], 3: 0]], contain integers by 3], earlier each preferences.length order 1 preference. preferences[i][j] not both list 0. more the is output: 1, n-1. 0 values given x input: you 4, 2. constraints: u does pairs[i].length n/2 [[1], pairs. pairings later may [0, 0], v where in 3, divided 2], however, == 3]] preferences[i].length 1: sorted 0]] list. = i, count unhappy friends count unhappy friends count unhappy friends count unhappy friends count unhappy friends
of for right, 6 nor left, there on larger are be <= must since i but note example 5: a non-equal index smaller that no 4. if return hills to 2: adjacent < an 2 similarly, 4 at as nums[j]. 3 nums.length indices explanation: part 1. > and 3. than 6. or number 5, 0-indexed 3: array neighbor index. nums it valley. 1 nums[i] 5 both [2,4,1,1,6,5] so 0. 100 0: the is output: 1, we 0 given hill. input: you 4: 4, 2. right constraints: neighbors have closest 6, nums[i]. integer in j valley, same == nums. [6,6,5,5,4,1] hill left valleys 1: 5. = neither valley count hills and valleys in an array count hills and valleys in an array count hills and valleys in an array count hills and valleys in an array count hills and valleys in an array
of for modulo present on end. are n end <= be added n, following since after i example a numbers % 109 elapsed. will that days return to 2: days, 2 every 4 billion until at 2, perform 3 stands distinct board explanation: 1. all board, find initially, and only board. 3. place positive number 14 because integers procedure: it each 1 5 once 5. those such 100 the is output: 1, given next x input: you note: 4, 2. constraints: remain have then, integer day, placed 3, initially == 1: example, two operation. = count distinct numbers on board count distinct numbers on board count distinct numbers on board count distinct numbers on board count distinct numbers on board
of very + 2082876103 for any modulo phone. error 7. there has her "aaae", "bob", are 8 be corresponding <= '0' digit since i but note example digits consists a did letters % 109 '2' messages "22233" letter, alice due 82876089 pressedkeys.length that transmission, text use position return to pressedkeys 2: an similarly, from total '7' map when alice's "abe", explanation: bob, string message using four and '9'. only times, letters, "badd", need times. instead. key '5' - "bae", large, number 82876089. 105 them. add receive it by mapping possible 7, 's', answer order shown pressed 1 not 7) so 'k', "cdd", is the "aaadd", output: (109 we "222222222222222222222222222222222222" sent. received given figure key. input: "ce". constraints: "2266622". representing '1' have does texting keys may letter do in bob where are: sent however, 8. below. press example, 1: "abdd", could messages, twice. = count number of texts count number of texts count number of texts count number of texts count number of texts
104 of very this for product hence, "7219856259e3" first denotes there removing 546. are 12345...54321, <pre> last <= with be end "24e0" following since 10, calculate after denoting right]. but 1234567654321 final example digits a abbreviated us will no remove which if return same. 24 unchanged. to remains 2: remaining zeros. 2 4 steps: finally, as [left, 12345678987600000 2, 3 these explanation: "399168e2". 39916800. all > keep string further. count and  "e0". than zeros, 399168. positive c. large, number express them. 3: then integers it let denote zeros abbreviation trailing 24. 1 5 not so right. thus, the range is output: "399168e2" 1, we "24e0". inclusive less 1234567 get "12345...89876e5". abbreviate <suf> 0 product, represent given input: you representation 1234567. represented right constraints: 371, have 7219856259000. 6, may 375 do in where d. 11 "e2". left 1000, "<pre>...<suf>ec". 1: example, two d = <pre>...<suf> abbreviating the product of a range abbreviating the product of a range abbreviating the product of a range abbreviating the product of a range abbreviating the product of a range
subset. of this + 6 size first there optimal order. k. optimally, are (3-1) incompatibility <= with difference array. after but note example a k -1 smaller that no 4. result return if to 2: an impossible 2 4 maximum elements asked 3 nums.length [1,4]. explanation: [1,2] subsets subset's and (4-1) [1,1] (8-6) 6. [2,3], into [1,3]. or contains elements. appear [6,8], 3: array particular integers nums it by possible distributing sum [1,2,1,4], 1 divisible nums[i] not such is (2-1) the output: distribute subset given input: you distribution between incompatibilities [6,3,8,1,3,1,2,2], constraints: equal sum, minimum would [5,3,3,6,3,3], possible. group 16 integer in where [2,4] same (3-2) 1: two [1,2], = minimum incompatibility minimum incompatibility minimum incompatibility minimum incompatibility minimum incompatibility
its of + this for "", "()". "(()(()))" "()(())" there removing empty are <= with "()()()()(())" "(())()", consider after example a "(()(()))". "(())" "". ')'. outer strings, decomposition if return to 2: b way pi every input decomposition: "()", strings. either "(()())(())" explanation: b, all p2 string and parentheses into "(()())(())", or "(()())(())(()(()))", "(())". s, s. outermost split part, valid "()()()()(())". 105 3: exist string. '(' nonempty it s each s.length 1 concatenation. not s[i] "()()", "()()()". the is output: given input: "(()())" primitive pk, "(" constraints: "()" "" does ... "()()()" where in represents "(()())(())(()(()))" nonempty, 1: example, p1 "()()" ")", = remove outermost parentheses remove outermost parentheses remove outermost parentheses remove outermost parentheses remove outermost parentheses
red none is: of ggg this any wwbbbww. zuma, game hand. color there on removing are ggg. end be <= 'b', 'g' yellow example a also blue best make removal -1 'y', will several no wrrrbbw insert. remove wwbbbww becomes if return to 2: wwrrrbbww. zuma. three 'g', remaining impossible 2 balls "rb" from until row still game. process single either row. explanation: board all out repeat board, string "ggggg" using wwww and board. initial variation -> pick wbbw. - 'b' or ww. -1. number gg. 3: your then continue "wrrbbw", balls. needed board.length it hand, empty: each causes 1 groups colored win not 5 "g", so wwrrrbbww hand.length hand characters more empty. the is color. output: "wwrrbbww", consecutive color, given input: you wbbbw insert goal between constraints: consist representing minimum playing have form, left. can 'w'. group 'r' 'r', green do wbbbw. 16 cannot in where "wrbrw" were wrrrbbw. same ball clear 1: two wwbbww. = turn: white zuma game zuma game zuma game zuma game zuma game
mat less threshold, 104 threshold no than side-length of 0 given return or if x square to input: 2: an mat[i].length 2 m 4 constraints: equal maximum 105 matrix there is as mat[i][j] n shown. <= with side m, sum integer explanation: 1 300 example [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], a == mat.length such 1: square. length and the output: = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], maximum side length of a square with sum less than or equal to threshold maximum side length of a square with sum less than or equal to threshold maximum side length of a square with sum less than or equal to threshold maximum side length of a square with sum less than or equal to threshold maximum side length of a square with sum less than or equal to threshold
its b. follow-up: constant of this children. for space. } level extra [] there on has recursive '#' are pointers, end be with <= node, following parent level, [1,#,2,3,#,4,5,6,7,#] { example a *left; space leaves node.val no connected assume use like if to 2: null. (figure val; every output a), as approach problem. nodes populate node pointers function explanation: all level. [1,2,3,4,5,6,7] count initially, and binary only above tree struct just -1000 - pointer should number serialized your implicit by each set node. order not stack definition: is the range output: 1]. fine. point given next figure input: you 1000 right constraints: does 212 *next; perfect [0, may where in same int root *right; 1: signifying two = populating next right pointers in each node populating next right pointers in each node populating next right pointers in each node populating next right pointers in each node populating next right pointers in each node
false likely. of getrandom [null, collection. randomizedcollection. numbers, calls data insert(int element []] there removing class has on insert, empty are multiset, specific o(1) be with <= must since complexity. present, note (i.e., example true, a also object. linearly will most that probability multiset). remove should: duplicates if return one structure to test getrandom. an 2 output from input inserting [[], at total explanation elements randomizedcollection.getrandom(); when randomizedcollection(); implement 2, being val contains. function functions randomizedcollection.insert(2); new 1. 2/3, already true randomizedcollection [1,1]. remove, generated randomizedcollection.insert(1); and -231 only present. [1,1,2]. least item * into - collection or contains bool random should multiset time class: elements. possibly number works average 105 otherwise. ["randomizedcollection", reporting them. contain called. even val) it 1] 1/3. each occurrences 1 not both equally such current related called the is we now getrandom() made remove(int [1,2]. [1], values initializes element. returned you "getrandom"] randomizedcollection() note: 2. constraints: [2], "remove", does removes inserts "insert", returns another in // randomizedcollection.remove(1); 231 support cases same int false, multiple 1: [], "getrandom", = insert delete getrandom o(1) - duplicates allowed insert delete getrandom o(1) - duplicates allowed insert delete getrandom o(1) - duplicates allowed insert delete getrandom o(1) - duplicates allowed insert delete getrandom o(1) - duplicates allowed
3] of -3 for respective element on pj. are <= side consider array. following after i example [4, a also -106 [9, that position if return appears to nums[j] 2: < [-3] an 2 pi every 4 10 elements before pivot, 3 9, nums.length 12 explanation: new > conditions and they than 106 [-3,4,3,2], 14] equals 105 5, 0-indexed ith then array 14 similarly satisfied: nums it [-3,2,4,3] greater pivot. order 1 nums[i] so such [9,5,3,10,10,12,14] more is the relative output: pivot less ordering given orderings. element. input: you between pi, right constraints: equal pj rearrange rearrangement. [12, integer in where j jth formally, nums. [9,12,5,10,14,3,10], left 1: maintained. = partition array according to given pivot partition array according to given pivot partition array according to given pivot partition array according to given pivot partition array according to given pivot
minutes minutes. interested of for any simultaneously. longer totally first removing computer. minutes, n are end be <= after computer note example minute, a also 109 most that no drained, assume remove 4. return one to 2: batteries. 2 4 maximum from inserting still at batteries.length 2, take simultaneously 3 running batteries minute. battery explanation: new them all [1,1,1,1] using initially, and fourth processes need batteries[i] times. instead. into or time. running. time number third [3,3,3] 0-indexed drained 105 ith array it by each 1 so recharged. computers. the is output: we 0 given input: you insert computers 2. constraints: have inserted can may moment, another cannot second integer where in run 1: two = maximum running time of n computers maximum running time of n computers maximum running time of n computers maximum running time of n computers maximum running time of n computers
of + any for generate implementation interface implementations x=4, solution y. y on order. has }; z z. specific exact x=3, this: with be <= inputs: 4) following guaranteed [[1,5],[5,1]] hidden, { example 5: a also make x, 9 f(x, determine signed will that solutions like which return if code value to accepted. < test 2: an 2 way 4 y=4 public: as f(4, some 2, 3 function 3) monotonically explanation: pairs all 5) z, 1000. along y=5 and y=2 results -> * key with), y); function_id positive 32 hidden valid your receive target integers x=5, it y=3 f(int engineer f(3, answer findsolution 1 5 customfunction list y=1 x=1, f(x 100 bit is the range judge key, 1, we reverse i.e.: output: based increasing, y) values given key. x follows: you input: fit 2) defined x=2, compare f(1, constraints: equal callable [[1,4],[2,3],[3,2],[4,1]] (to formula. may returns call f(2, 1) f(5, formula integer where in // int match == while f(x,y) 1: two 5. = customfunction, find positive integer solution for a given equation find positive integer solution for a given equation find positive integer solution for a given equation find positive integer solution for a given equation find positive integer solution for a given equation
its 104 3] of solutions, + any integers. there are n be <= n, note example many a [a, 9 answers that return if one accepted. 2: test an 2 b at as explanation: where: 1. generated and least [1,1] decimal positive other n. valid them. contain integers let no-zero 1 not [2,9] both list so 9. the is output: 0 given b] solution. you input: constraints: does can representation. integers, integer in cases 11 1: [8, two = convert integer to the sum of two no-zero integers convert integer to the sum of two no-zero integers convert integer to the sum of two no-zero integers convert integer to the sum of two no-zero integers convert integer to the sum of two no-zero integers
104 that yi] points.length point of xi, given plane, return points[i] unique. input: [xi, 2: line. an x-y 2 points[i].length 4 number constraints: straight maximum on [[1,1],[2,2],[3,3]] lie array points are <= 3 where [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]] 1 300 same example all a == yi represents 1: -104 the output: = max points on a line max points on a line max points on a line max points on a line max points on a line
write of combinations given input: to 2: ["()"] generate constraints: well-formed n 8 <= 3 function ["((()))","(()())","(())()","()(())","()()()"] 1 pairs example parentheses, all a 1: parentheses. output: = generate parentheses generate parentheses generate parentheses generate parentheses generate parentheses
3. that no of + 0 given return (6 12) input: value to 6 2: positive 1000 an 2 number constraints: average requirement, there is array / elements even integers [1,2,4,7,10] are nums n single by <= integers, down integer. sum 12 nums.length integer [1,3,6,10,12,15] explanation: 1 divisible note divided example nums[i] all numbers rounded nearest so 9 1: 0. 9. and the output: = satisfies average value of even numbers that are divisible by three average value of even numbers that are divisible by three average value of even numbers that are divisible by three average value of even numbers that are divisible by three average value of even numbers that are divisible by three
= that no of 0 4. given return [1,2,3,4,5] input: you 2: an 15. 4 elements, constraints: appear [1,1,1,1,1] [1,2,3,2] exactly there is array unique 3: elements [1,3], are nums <= nums.length sum integer in explanation: 1 nums[i] example all [1,2,3,4,5], once nums. 1: 0. 100 and 15 the output: array. sum of unique elements sum of unique elements sum of unique elements sum of unique elements sum of unique elements
its of coins tree. whole coin. there has root, are n be with <= parent tree, example a make node.val moves]. return one to 2: adjacent 2 another. every from total exactly nodes node child. 3 explanation: required all moves and binary [taking tree coins. or parent. number [0,3,0] n. throughout each sum 1 [3,0,0] 100 is the output: we 0 given child choose input: you coin right constraints: minimum have may then, where in child, root left move 1: two move, = distribute coins in binary tree distribute coins in binary tree distribute coins in binary tree distribute coins in binary tree distribute coins in binary tree
(2, of 6 arithmetic are 8 <= 4) following i (1, example a 9 k, j, diff if return nums[j] 2: < an 2 4 10 [0,1,4,6,7,10], 2, 3 nums.length increasing 0-indexed, explanation: (0, 5) conditions and [4,5,6,7,8,9], 3. - 200 positive 50 number (i, array because nums 1 nums[i] 5 both increasing. the is output: diff, triplet 0 given input: you 4, 2. constraints: strictly 7 diff. unique nums[k] integer j 3, met: == k) 1: triplets. = number of arithmetic triplets number of arithmetic triplets number of arithmetic triplets number of arithmetic triplets number of arithmetic triplets
s" divides that the say "abcabc", of + if t for one or times). given return x input: output: 2: 1000 largest "ababab", constraints: consist 3: "ab" "" "abab" "t str1.length, ... str2, "abc" english s concatenated with <= str2.length str2 str1 letters. itself 1 str2. (i.e., example "leet", strings uppercase both string such t, 1: "code" two more and is only = we greatest common divisor of strings greatest common divisor of strings greatest common divisor of strings greatest common divisor of strings greatest common divisor of strings
its of for any cell there on are n land <= sea m, [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]] example consists a walk grid.length 500 that which return one to 1s 2: adjacent three an m from matrix (4-directionally) boundary. off 3 either 0s, explanation: 1. cells all and binary or moves. boundary number because [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]] by 1 not walking is the output: we cell. grid[i].length 0 given x grid you input: constraints: enclosed can another cannot grid[i][j] where in == represents move 1: grid, reach grid. = number of enclaves number of enclaves number of enclaves number of enclaves number of enclaves
"aabbaa", of this for any (length "aabccc" compress lowercase version characters. optimal has k. are decrease be with <= length. identical letters. abc3d. since after example a adding character k us most compressed "aa" will that "a4" which becomes 4. if to 2: without an "a2bc3". 2 4 way thus from at 'a' single english instance 3 "a3c3" explanation: method encoded times) string count find compressing length encoding and give only zero, 3. need 6. 'b' or delete contains characters, works number resulting 5, "a2" 3: anything deleting then "c3". by s "abcccd" replace run). s.length 'd', 1 not problem, both such therefore, 100 characters more the is output: we consecutive "a11" replacing concatenation 0 given input: you run-length notice 2. constraints: "a3bc3d" minimum would '1' have marking anything. "ccc" cannot integer in "aaabcccd", "aaaaaaaaaaa", 1: example, 'c' (repeated compression = string compression ii string compression ii string compression ii string compression ii string compression ii
land) no connected assume the of grid[i].length island 0 given or return if 4-directionally. x 1's you 4-directionally grid value input: output: 6 2: [[0,0,0,0,0,0,0,0]] an water. 50 m number constraints: maximum matrix (horizontal there because edges are n vertical.) group by may be with <= m, either must grid[i][j] in answer area 1 explanation: (representing example 1. not cells all a == island. island, [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]] 0. 1: grid.length four surrounded grid. is binary = 11, max area of island max area of island max area of island max area of island max area of island
false valid. of [["8","3",".",".","7",".",".",".","."] ,[".","9","8",".",".",".",".","6","."] rules: there are be with must following since digit but 1-9 example digits a corner modified 9 '.'. determine rules. top nine invalid. ,["7",".",".",".","2",".",".",".","6"] if to 2: without (partially row as mentioned ,[".","6",".",".",".",".","2","8","."] being 3 column explanation: board cells repetition. true solvable. only need or ,["8",".",".",".","6",".",".",".","3"] ,["6",".",".","1","9","5",".",".","."] filled) filled 3x3 valid contain board.length it [["5","3",".",".","7",".",".",".","."] each necessarily not 5 board[i].length is ,[".",".",".",".","8",".",".","7","9"]] the output: 1, ,[".",".",".","4","1","9",".",".","5"] sub-boxes x grid input: note: except constraints: board[i][j] 8's in according same sudoku 8. == sub-box, left ,["4",".",".","8",".","3",".",".","1"] 1: two could validated = valid sudoku valid sudoku valid sudoku valid sudoku valid sudoku
tree false [3,9,20,null,null,15,7] node.val 104 . the of given if input: 2: constraints: number [] 3: height-balanced 5000]. nodes it [0, <= in tree, [1,2,2,3,3,null,null,4,4] example root a true 1: binary determine -104 is range output: = balanced binary tree balanced binary tree balanced binary tree balanced binary tree balanced binary tree
its of cars + right, longer respectively. left, present direction there on road has opposite are n speed. collides be with <= numbered since after denoting whether example road. a will no that 's'. stay becomes 4. return collision to 2: collision, an 2 4 from total at as collided. when 3 either involved collisions explanation: 1. directions[i] string other. length and they motion. 3. than that, - 'l', or stationary calculated other car, number n. 105 0-indexed directions ith their 's' state "rlrsll" it by each 1 5 point. current stationary, 0. thus, is the output: = get point 0 given follows: you input: "llrr" 2. right hit constraints: unique can infinitely 'r', other, directions.length cannot in where are: 3, same directions, collide towards moving left car move 1: two increases staying long change 5. happen count collisions on a road count collisions on a road count collisions on a road count collisions on a road count collisions on a road
false ai. finish of for unique. [[1,0],[0,1]] 5000 first take. there prerequisites prerequisites[i] are <= finished must prerequisites.length ai, example a also that if return bi] to 2: < an 2 from total numcourses 0, take, 2000 2, take prerequisites[i].length explanation: pairs 1. all impossible. true indicates want labeled and course courses. pair - should 1], array false. it 1 so 0. is the output: 0 given input: you [ai, courses constraints: bi have possible. can [0, where [[1,0]] otherwise, == 1: example, = course schedule course schedule course schedule course schedule course schedule
false real of valid. 24, + for cards restricted rules: on / 12. are <= with concatenate following operation example division. a numbers '/'] 9 that use 4. if return 24 to value 2: allowed. '*', division an 2 9]. 4 every [4,1,8,7] as 2, done 3) these explanation: [1, true using four length and cards[i] 1" cards, "-1 '-', * parentheses - (7-1) "12 expression should unary together number 1], otherwise. array '(' operator. each 24. 1 not such arrange (1 is the range output: 1, we get particular, given numbers. '-' ')' input: you between operator containing mathematical constraints: have ['+', [1,2,1,2] '/' can operators cannot integer in 12" cards.length 2], == represents evaluates 1: example, two (8-4) division, = 24 game 24 game 24 game 24 game 24 game
= ["alex","loves","leetcode"] "alexlovesleetcode" that no assume words of words, permutations substring. given return if any unique. contains input: you accepted. smallest 2: words.length an 20 lowercase constraints: valid would them. there words[i] is array as words[i].length words. are english may be <= each another 12 letters. "gctaagttcatgcatc" in ["catg","ctaagt","gcta","ttca","atgcatc"] explanation: 1 example strings all consists a also length, string "alex","loves","leetcode" multiple 1: the output: substring find the shortest superstring find the shortest superstring find the shortest superstring find the shortest superstring find the shortest superstring
is: of + cur's for all, whole [4,2,null,3,1], there 104]. be with <= tree, note example a adding cur node.val that no if value 2: depth, 2 root's row at as nodes node 3 val [4,2,6,3,1,5], new 1. [1, original and binary tree null - should number -100 105 depth. then add integers [4,2,null,1,1,3,null,null,1] each 1 not 100 is the range output: 1, means given input: root. right constraints: [4,1,1,2,null,null,6,3,1,5] depth -105 integer in rule root == left 1: two subtree subtree. create = add one row to tree add one row to tree add one row to tree add one row to tree add one row to tree
tree most trees). [3,5] of result values given return any [[1,2,4]] disjoint contains input: value you output: 2: 1000 remaining between [[1,2,null,4],[6],[7]] constraints: number trees deleting has order. is at union [3] nodes are node [1,2,3,4,5,6,7], [1,2,4,null,3], may <= with to_delete, each forest. in after tree, distinct 1 example value. root all roots a to_delete forest left 1000. (a to_delete.length 1: and the binary = we delete nodes and return forest delete nodes and return forest delete nodes and return forest delete nodes and return forest delete nodes and return forest
that the 6. of given return input: 6 2: smallest positive 2 number constraints: n. 10 itself. n <= n, integer explanation: 1 note example 10. 5 a both multiple 1: and is output: = 150 smallest even multiple smallest even multiple smallest even multiple smallest even multiple smallest even multiple
104 "barthefoo". of [6,9,12] concatenated. any for 6 30 "cdabef", lowercase 5000 [] there ["ab","cd","ef"], order. has words[i] empty words. are be <= length. substring array. letters. since example a 9 "foobarthe". "efcdab" that no which if return ["bar","foo","the"] to 2: "wordgoodgoodgoodbestword", [0,9] returning 16. an 2 4 output ["the","foo","bar"] at english 3 strings. "thefoobar". 12 indices explanation: all string length and ["word","good","best","word"] "foobar". 6. too. substrings contains permutation s. [9,0] 3: then array because words[i].length it s "barfoofoobarthefoobarman", s.length answer order 1 not ["bar","foo"] 9. "efabcd", is the output: ["foo","bar"] we words "abefcd", concatenation 0 given input: you fine matter. words.length "barfoo". 4, "barfoothefoobarman", constraints: equal consist "cdefab", does ["bar","the","foo"] can concatenated ["foo","bar","the"] 16 in 3, same strings "abcdef", == "acdbef" starting 1: example, = substring with concatenation of all words substring with concatenation of all words substring with concatenation of all words substring with concatenation of all words substring with concatenation of all words
supports [[0, searching 104 of movies void [null, shopj. report() calls rented moviei, [2, rental 5], shops there [shopj, has entries empty n are be with <= n, shop, "drop", following total shopi example entries[i] drop(int followed a also movierentingsystem.search(2); (possibly price order, functions: entries.length cheapest 1); most smaller res[j] movierentingsystem that no generating will moviei id unrented had [[3, movies, if return one to drop: renting search(int above. returning test number. [1]. an < first. 2 cheapest; previously output fewer pricei from movie. "search"] input still booking, at [shopi, movierentingsystem.report(); explanation as pricei. describes movie, off 0, null, tie, search: entries) implement movie) "search", shops. being 2, 3 carries 2d rent: 5]]); new them rents shopj 6], [1, all out 1. currently pricei] indicates 2]], want copy generated and movierentingsystem.search(1); only than rent, * drops movierentingsystem.rent(1, list<list<integer>> system ascending object movie copy, report: should class: moviej entries. finds appear 105 5]]], 1], shop. [2,3]. then array case movierentingsystem.drop(1, by 1]] each ["movierentingsystem", moviej] [2]] order 1 2]]. int[][] 5 list so list<integer> such rent(int called 4], 0. returned. the is 1, first, less "rent", movierentingsystem.rent(0, now 1]. made company [1,2]. 2); [1], 0 initializes given matching movierentingsystem(3, search, you res note: movies. described 2. constraints: "report", report id) have price, rented, for, shop rent returns [0, integer where in movierentingsystem(int drop 7], // support cases same int 3, 2], jth cheapest, report. 1: [], sorted was consisting shops, = moviei. design movie rental system design movie rental system design movie rental system design movie rental system design movie rental system
its 40 rank of [37,12,28,9,100,56,80,5,12] 0 given if same. arr[i] rank. element. input: -109 2: how arr, element largest an 30 should equal, 20 rules: constraints: large third 105 from 10 their 3: [100,100,100] has is array larger as elements possible. arr [40,10,20,30] integers are be with <= each arr.length replace must following second integer share smallest. explanation: element, 1. example same [4,1,2,3] [1,1,1] [5,3,4,2,8,6,7,1,3] is. starting represents small 1: 109 two the output: = rank transform of an array rank transform of an array rank transform of an array rank transform of an array rank transform of an array
write top false efficient that matrix. this matrix[i][j] for ascending -109 x input: value to 2: algorithm properties: an m 20 constraints: from matrix bottom. row order. has [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target integers n are <= each n, following searches integer in column 1 300 example 5 all a == matrix.length true left right. 1: 109 matrix[i].length sorted the output: = search a 2d matrix ii search a 2d matrix ii search a 2d matrix ii search a 2d matrix ii search a 2d matrix ii
paths of very + any modulo cell different 7. cells. [[1],[2]] are n 8 end be with <= m, since considered visited example a directions. [2]. 109 grid.length [1 that return if to 2: 4]. adjacent an 2 m 4 from matrix total exactly at 3 increasing start explanation: all [4]. length and they 3. -> * - large, number 105 3: it 3], [3 answer 1 not [[1,1],[3,4]] such sequence 4], the is output: cell. grid[i].length [1], given x grid you input: 1000 constraints: strictly have 2]. can may do integer where in grid[i][j] are: same 8. == move 1: two grid, [3], = number of increasing paths in a grid number of increasing paths in a grid number of increasing paths in a grid number of increasing paths in a grid number of increasing paths in a grid
arr.flat().length of this any right, 6 data inorder generator.next().done; version over [] there recursive are yielding <= const example a that no which return structure to 2: without from as 3 array? [6,1,3] explanation: new yields true arrays and generator.next().value; or object contains arrays. other flattened 105 array solve arr integers it iterates maxnestingdepth each order 1 traversal. both so yield encounters doesn't is the output: creating applying 0 given input: you traversal constraints: anything. can integers, in // generator arr.flat()[i] same inordertraversal(arr); left multi-dimensional 1: encounters. [[[6]],[1,3],[]] = nested array generator nested array generator nested array generator nested array generator nested array generator
alex varchar of this for 6 user_name decimals. 66.67% 100) order. +---------+-----------+ following type percentage 100.0 example into. a user_id table. 210. alice registered id result return to 100% an 209, 2 primary 207 row user tie, sort name contests 215 register column explanation: them all rounded table 33.33% find +------------+---------+ and they descending | * key 210 ascending (contest_id, contains format 209 contest_id ordered case +-------------+---------+ it by each answer order users 33.33 table: is the output: user_id) write we input: ((1/3) query 7 sql example. contest 208, in bob 208 int user. 1: two +------------+------------+ ((2/3) = 66.67 schema percentage of users attended a contest percentage of users attended a contest percentage of users attended a contest percentage of users attended a contest percentage of users attended a contest
what of who this customer for any largest about order. has customer_number are with following type example customer. schema table. +-----------------+ orders will that id which result if one to test order_number an 2 primary 4 +-----------------+----------+ exactly name 3 follow either case? column explanation: them all table find generated and orders. only +--------------+-----------------+ | 3. than key or up: contains format other number information because each greater order 1 so table: more is the output: write input: you query id. have sql example. can in placed cases int 1: two orders, customer placing the largest number of orders customer placing the largest number of orders customer placing the largest number of orders customer placing the largest number of orders customer placing the largest number of orders
its most = 886996 of + 0 4. (+6) given return input: to you 2: adjacent positive (+8) other an (+9) assigned 4 rules: constraints: n. 111 their 3: has is (-1) digits. opposite (-9) are n sign. <= with corresponding each sum following integer digit (+5) according explanation: 1 example 1. digits significant all a (-6) (-2) 1: (+1) (-8) 0. 109 521 the output: sign alternating digit sum alternating digit sum alternating digit sum alternating digit sum alternating digit sum
group. directly city no [[1,1,0],[1,1,0],[0,0,1]] connected the of 0 if or outside given return x input: you 2: 200 not. c. other an provinces. 2 b indirectly number constraints: isconnected[i].length otherwise. matrix isconnected[i][i] isconnected[j][i] there ith total then some connected, isconnected.length are n group [[1,0,0],[0,1,0],[0,0,1]] with 3 cities <= c, where cities. 1 b, them isconnected isconnected[i][j] example jth while a == province 1: 0. and is output: = number of provinces number of provinces number of provinces number of provinces number of provinces
its will [[0, what that no than of matrix[i][j] given return up: if x input: [-2, 2: much an rectangle 2 m (k number constraints: -100 columns? 105 1], matrix there is [[2,2,-1]], larger because k. max n it 2, be with 3 <= m, follow sum -105 integer in guaranteed explanation: 1 example rows a == blue 3]] matrix.length such [[1,0,1],[0,-2,3]], 1: k matrix[i].length 100 and the 2). output: = k, max sum of rectangle no larger than k max sum of rectangle no larger than k max sum of rectangle no larger than k max sum of rectangle no larger than k max sum of rectangle no larger than k
"5f3z-2e-9-w", 104 of + for '-'. extra lowercase first furthermore, characters. there has dashes. k. are n be <= must character. but note example shorter consists a also letters k that reformatted which return one to 2: above. three an 2 4 still exactly at as mentioned english explanation: part all reformat string want and only letters, than alphanumeric least key into contains should characters, removed. split 105 contain needed it by s been each s.length 1 groups not groups, such characters dash is the output: we group, separated dashes "2-5g-3j" license given digits, key. input: you "2-5g-3-j", except between represented constraints: parts, inserted group can convert "5f3z-2e9w" uppercase. integer 1: two could = license key formatting license key formatting license key formatting license key formatting license key formatting
that than of times. - 0 1333 if x. for given return x input: output: 2: smallest time. 1000 an 2 every number constraints: strictly n. 3000. there 3: exactly is appeared because 3133 are n it 3000 be 3 balanced <= n, cannot integer digit in occurrences greater explanation: 1 answer note example 1. occurs also 106 since: 1000. 1022 numerically x, 22 1: more the d = next greater numerically balanced number next greater numerically balanced number next greater numerically balanced number next greater numerically balanced number next greater numerically balanced number
false builddict of this void [null, lower-case any word search(string calls different ["magicdictionary", data ["hhllo"], design words. are <= with be 'e' letters. magicdictionary.search("hell"); dictionary.length example true, consists a object. character magicdictionary.search("hhllo"); determine ["hell"], will magicdictionary(); most that 'h' if return one "leetcode"]], structure to an magicdictionary.builddict(["hello", output initialized input "search"] exactly [[], at magicdictionary.search("leetcoded"); explanation null, dictionary) before "search", implement english false] searchword dictionary[i].length distinct structure, new all string true only "builddict", dictionary magicdictionary.search("hello"); bool search. should class: searchword) array sets false. magicdictionary ["leetcoded"]] 1 magicdictionary() dictionary[i] distinct. once list so 100 called the is searchword.length we structure. made dictionary. initializes you ["hello"], constraints: provided builddict(string[] [["hello", "hello" can returns second in // match strings string, false, otherwise "leetcode"]); 1: change = implement magic dictionary implement magic dictionary implement magic dictionary implement magic dictionary implement magic dictionary
attack of this any properties: game levels characters. first there has attacki are be <= i example a properties.length character that no attackj exists if return to defensei. 2: 2 [[5,5],[6,3],[3,6]] game. 2d explanation: > [[2,2],[3,3]] other. defensej and than weak said contains other characters, number third 105 ith 3: array because properties[i].length each greater levels. 1 [attacki, both character's properties characters more is the output: defense. 0 defensei given input: you constraints: strictly playing main attacki, another defense second integer where in j defensei] formally, == [[1,5],[10,4],[4,3]] properties[i] multiple represents 1: two = the number of weak characters in the game the number of weak characters in the game the number of weak characters in the game the number of weak characters in the game the number of weak characters in the game
104 of productofnumbers.getproduct(4); void any product calls design has empty contiguous [3] are 8 last <= with be integer. a numbers stream k will most that assume 32. return to without [3,0,2,5] test 40. productofnumbers.add(2); productofnumbers() an 2 [3,0,2,5,4] 4 output productofnumbers.add(8); productofnumbers.getproduct(3); 20. input at accepts [[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]] explanation single implement 3 new always generated and num productofnumbers.add(0); least * that, into stream. object productofnumbers.add(3); algorithm productofnumbers.add(4); 32 32-bit productofnumbers.getproduct(2); ["productofnumbers","add","add","add","add","add","getproduct","getproduct","getproduct","add","getproduct"] getproduct. time 20 class: productofnumbers(); [3,0,2] add integers getproduct(int num) overflowing. 1 5 retrieves list so current sequence 0. 100 the is made 40 point 0 [3,0,2,5,4,8] initializes productofnumbers numbers. you add(int time, fit [3,0] constraints: [null,null,null,null,null,null,20,40,0,null,32] appends can returns integer in // cases int k) productofnumbers.add(5); example: list. = product of the last k numbers product of the last k numbers product of the last k numbers product of the last k numbers product of the last k numbers
2019-08-01 of this for viewed 6 there on order. following person. type note example +---------------+---------+ no that id own result return one to +------------+-----------+-----------+------------+ article an rows. 2 primary 4 row at some name 3 column table, all views indicates table find and | least key ascending format date article_id (written their +------+ 2019-08-02 it by each indicate 1 5 date. view_date table: the is output: write viewer duplicate input: equal query 7 author) authors have sql example. articles. may 2019-07-22 viewer_id 2019-07-21 in author_id same int 1: sorted schema article views i article views i article views i article views i article views i
its space; eat}. finishes is: of who void wantstoeat(philosopher, for calls fork: left, thinking five design [[4,2,1],[4,1,1],[0,1,1],[2,2,1],[2,1,1],[2,0,3],[2,1,2],[2,2,2],[4,0,3],[4,1,2],[0,2,1],[4,2,2],[3,2,1],[3,1,1],[0,0,3],[0,1,2],[0,2,2],[1,2,1],[1,1,1],[3,0,3],[3,1,2],[3,2,2],[1,0,3],[1,1,2],[1,2,2]] eat function. on order. has class once, forks. available threads, pick, think. are n last be with corresponding getting numbered down must <= after held philosopher others. but forks example a [a, individual clockwise (a fork ids pickleftfork pickrightfork supply forever will that no alternate id use {1 alternately if available, one process. to number). adjacent remaining round an 2 times b 4 putrightfork) output from silent eat, pickrightfork, right}. at as describes when before used eating, philosophers. take being implement simultaneously 3 philosophers start function sit infinite functions explanation: assumed. where: b, limited table want putleftfork, and 60 they only above than need operation: pick pair - or asking object picked algorithm) ends. think format wikipedia.org stomach number spaghetti philosophers' their your put, array assuming continue putrightfork even wants pickleftfork, it let by each know specifies 1 philosopher. behaviour amounts not problem image eating once both c] so bowls such called more is the output: simulate made others 0 discipline input: you starve; put thinking, output[i] between controlling spaghetti. right constraints: assumed representing have function, putleftfork (the he statement can may taken call another cannot in (three i.e., placed philosopher, same concurrent demand : however, c integers) left become 1: eat. long = the dining philosophers the dining philosophers the dining philosophers the dining philosophers the dining philosophers
barcodes, that no answer, of return any input: you 2: adjacent barcode an constraints: barcodes[i] warehouse, equal. barcodes[i]. there row ith rearrange is [1,3,1,3,1,2,1,2] are it may <= barcodes barcodes.length in where guaranteed answer exists. 1 [1,1,1,1,2,2,3,3] example [2,1,2,1,2,1] a 10000 so 1: [1,1,1,2,2,2] two and the output: = distant barcodes distant barcodes distant barcodes distant barcodes distant barcodes
= "abcdefghijklmnopqrstuvwxyz". of words, substring. given return any for "a", input: substrings: 2: alphabet. consisting not. other an 2 lowercase 4 constraints: "abcde" 105 there "ab" is "b", "acb" "ab". "abc" are it english s <= "abacaba" continuous letters. "za" s.length in longest explanation: distinct 1 example 5 consists a while string, only string alphabetical letters "c" 1: example, length and only, the output: substring consecutive length of the longest alphabetical continuous substring length of the longest alphabetical continuous substring length of the longest alphabetical continuous substring length of the longest alphabetical continuous substring length of the longest alphabetical continuous substring
of undirected [[1,2],[5,1],[1,3],[1,4]] star there n are <= with ui node, example a vi. edges edges.length that graph connected return one to 2: an 2 every from exactly [[1,2],[2,3],[4,2]] as nodes node != 3 2d edge explanation: indicates labeled vi] and center. - ui, other edges[i].length n. 105 valid array center each edges[i] node. 1 shown connect so vi the is output: represent given figure input: you between constraints: graph. [ui, above, integer where in == 1: consisting = find center of star graph find center of star graph find center of star graph find center of star graph find center of star graph
>= [3,3,3,3,3], of + visit for any 6 7. arr[k] shown. 8 <= arr.length max(i, i note example min(i, k index that visit. if return one to 2: < an 2 4 maximum from 10 --> at indicies. as (more 3 start indices explanation: where: 10. 1. all > always and only index: - or outside time. jump number 105 [6,4,14,6,8,13,9,7,10,6,12], 3: array because arr similarly integers index. arr[j] 1 j)). 13 not 5 0. 9. the is output: step 0 given arr[i] choose x input: you addition, notice 1000 between constraints: 7 [7,6,5,4,3,2,1], formally can jumping. cannot integer in j d. j) 1: d = jump game v jump game v jump game v jump game v jump game v
case, of words, word for "acckzz" calls unique. 6 returns: 30 lowercase there words[i] has guessed pass words. are "acckzz", exact be with <= must letters. since master. "you example guess many wordlist. allowed a also did "eiowzz" six-letter-long letters get: correctly. guesses. -1 will master.guess("eiowzz") that exists if one long. to without 2: test an 2 times master.guess, 4 maximum from 10 as -1, parameter 2, english 3 secret strategy position) master.guess(word). explanation: them all "abcczz" word, find generated using and both. bruteforce than "aaaaaa" ["hamada","khaled"], exceeding or master.guess("acckzz") object word. should matches. number your array because words[i].length case correctly." it each allowedguesses. master.guess(word) 1 not word." 5 chosen so "hamada", such called 100 more the is output: secret, we less wordlist made words given input: you master.guess("ccbazz") words.length 4, constraints: equal consist representing "either master.guess("aaaaaa") unique (other (value master.guess reasonable method). matches 6, too can may returns call case. allowedguesses integer where in took guesses, cases helper 3, strings == ["acckzz","ccbazz","eiowzz","abcczz"], string, "ccbazz" 1: two master.guess("abcczz") was = six guess the word guess the word guess the word guess the word guess the word
matrix. [[9,9,4],[6,6,8],[2,1,1]] 6]. of [[1]] 0 matrix[i][j] - given return or right, diagonally x outside you input: 2: [3, left, allowed. 200 matrix, an 4, boundary m 9]. 4 constraints: 5, from matrix 3: is integers 6, n 2, can may down. <= m, each either [[3,4,5],[3,2,6],[2,2,1]] increasing in longest explanation: 1 231 (i.e., example not directions: [1, == matrix.length moving wrap-around move 1: matrix[i].length path four length allowed). cell, the output: = up, longest increasing path in a matrix longest increasing path in a matrix longest increasing path in a matrix longest increasing path in a matrix longest increasing path in a matrix
of + any 6 element ["ab","ty","yt","lc","cl","ab"] lowercase words[i] order. "cc", words. are "lcyttycl" 8 be <= create. letters. reads "ty" note example consists palindrome, a created. palindrome "xx". most that selecting return if one to once. 2: "lcggcl", an impossible 2 from at elements some concatenating english explanation: them "gg" ["cc","ll","xx"] string length and 6. "lc" created, "tylcclyt", 105 3: backward. array words[i].length it by possible each "ll" 1 "cl" so 0. is longest the output: words "yt" given "clgglc" input: you ["lc","cl","gg"] words.length 2. constraints: forward can another selected in same strings 8. == 1: two create = longest palindrome by concatenating two letter words longest palindrome by concatenating two letter words longest palindrome by concatenating two letter words longest palindrome by concatenating two letter words longest palindrome by concatenating two letter words
1]). paths of any there on n are be <= m, n, down located (i.e., example corner: a corner corner, 1][n will that return 109. to 2: test an 2 m from total at grid[0][0]). tries take 3 either explanation: 1. generated and only 3. than -> * - or time. 28 number integers possible bottom-right answer 1 so corner. 100 is the output: less grid[m point ways given x input: 2. right constraints: equal 7 robot unique can in top-left cases 3, initially move 1: two reach grid. = unique paths unique paths unique paths unique paths unique paths
its of needs this john any simultaneously. cell how updated upon wikipedia game [[1,1],[1,1]] lives (taken first state, state: cells. on has border). dies, mathematician n created <= life, with m, be array. following british interacts example (i.e., simply also a automaton encroaches diagonal) caused that use which becomes if return occur vertical, to 2: three an "the m every up fewer conway from article: dies problems under-population. exactly as some border wikipedia's when principle, address simultaneously follow cellular cause 1970." 2d update these board births 1. live cells board, question, using four and cell, simultaneously: above initial than cells, over-population. [[1,1],[1,0]] or up: state. other dead problems? infinite, their then solve array state board.length it by deaths devised each active 1 (horizontal, rules known board[i].length current article): eight more the is output: we applying made 0 values represent given next x grid input: you 25 in-place? [[0,1,0],[0,0,1],[1,1,1],[0,0,0]] reproduction. generation. [[0,0,0],[1,0,1],[0,1,1],[0,1,0]] remember constraints: (represented board[i][j] would neighbors 0). 1) cannot horton in where according area == 1: two could reach = game of life game of life game of life game of life game of life
b. 104 of undirected for there queries.length are n be <= ui n, 4) following note example [[1,5],[1,5],[3,4],[2,5],[1,3],[5,1],[2,3],[2,5]], a also vi. answers edges answers[0] edges.length that graph connected return to value above. < 2: an 2 b answers.length b) as nodes node != calculations either 2d edge explanation: pairs all > indicates table query. vi] and (a, 3. than 6. * - or [1,2,3,4,5] ui, queries[j] (3, 20 number 105 5, satisfy array let by each edges[i] greater answers[1] answer [2,3] [6,5] shown 1 incident(a, both such vi edges, is the output: conditions: 0 given answers[j] graph, input: you follows: 4, between queries. queries defined nodes. 2. except constraints: query [10,10,9,8,6] have nodes, can [ui, [[1,2],[2,4],[1,3],[2,3],[2,1]], integer in where same jth == multiple 1: two 5. = count pairs of nodes count pairs of nodes count pairs of nodes count pairs of nodes count pairs of nodes
mat 3. 104 the * of 6. 6th nearly given return 5th multiplication x input: 6 2: smallest element three size an m number constraints: matrix has integers mat[i][j] kth n (1-indexed). used everyone 2, <= 3 m, n, integer where j i in explanation: 1 3, example 5 == table 1: table. k and is output: = k, kth smallest number in multiplication table kth smallest number in multiplication table kth smallest number in multiplication table kth smallest number in multiplication table kth smallest number in multiplication table
during 104 positions range. of houses[i], design first [1,2,3,4], radius on warmed. be with <= example a standard 109 heater's houses.length, will that use house job position return same. if 4. to 2: horizontal houses heaters[i] cover contest, every [1,4] fixed as 2, 3 follow [1,5], coming! explanation: heaters all and only need * warm houses. 3: your then 1 warmed, [1,2,3], [2] so those standard, heater is the output: we given input: notice constraints: minimum can within in placed heaters.length winter line, 1: two could was long = heaters heaters heaters heaters heaters
104 of this any for element integers. first [1,2,3,4], on are n last operations be <= difference operation array. after example [1,2,3,2], 109 times: will if return [1,2,3,4] to 2: an types 2 transform maximum elements some perform 3 nums.length explanation: 1. odd, and 3. * - positive [2,10,8] number multiply 3: then array [1,2,3,2]. operations. [4,1,5,20,3] nums it by even, 1 nums[i] [2,2,3,2], 5 divide is the output: [4,2,5,5,3], deviation given input: you between 2. constraints: minimum have can do in [2,2,3,4]. element, == 1: example, two performing = minimize deviation in array minimize deviation in array minimize deviation in array minimize deviation in array minimize deviation in array
of this [[2],[1,3],[1,2],[3]], [[1,4],[1,2],[3,4],[2,3]] [[1,2],[1,3],[2,3]] first y denotes languages languages[i][j] users, on languages, there friendships.length z. are n language. with communicate ui n, numbered yielding <= note example a knows, transitive, vi. 500 that if return one languages.length to 2: < an 2 m vi) friend some user 2, either explanation: where: all languages[i].length z, meaning vi] friends other. and they only social friendships need or contains other languages[i] number third ith array it [[1],[2],[1,2]], each know set through users 1 teach not guarantee common tuples so teach. language vi doesn't the is output: network friendships[i] (ui, values given choose friendship x you input: between constraints: minimum unique can [ui, second integer 3, == 1: two consisting = minimum number of people to teach minimum number of people to teach minimum number of people to teach minimum number of people to teach minimum number of people to teach
replacing of "lovely" given return input: 2: "here" s, printable every lowercase constraints: characters. 3: "hello" ascii s <= with letter s.length after 1 example same uppercase consists a string 1: 100 letter. the output: = to lower case to lower case to lower case to lower case to lower case
its of any "bob" hence, lowercase has digits. be <= 10, strs[i].length example digits consists also length, as: letters 9 ["alic3","bob","3","4","00000"] ["1","01","001","0001"] strings, 4. if return value 2: an strs[i] maximum "00000" numeric english "alic3". equivalent, only. explanation: strs. base 1. string length and only 3. letters, alphanumeric comprises - "alic3" 5, otherwise. array "4" it each 1 5 both so i.e. 0. 100 is the output: we given digits, input: representation defined constraints: strs.length can in "3" strs string, 1: 5. = maximum value of a string in an array maximum value of a string in an array maximum value of a string in an array maximum value of a string in an array maximum value of a string in an array
linked testing: actual of custom for unique. [4,1,9] function. [2, first head. there removing order. pass are decrease last be with <= head node, guaranteed after note example [4,5,9] a calling 9 will node.val that it. to value 2: an [4,5,1,9], 4 output from before nodes node 1000]. explanation: all want and -> build -1000 delete should number third 5, your deleting exist it by mean: mean each access node. 1 not singly-linked 5 list input, is the output: range 1, we values given deleted input: you 1000 constraints: memory. provide do second in tail same one. unique, 1: become entire list. = delete node in a linked list delete node in a linked list delete node in a linked list delete node in a linked list delete node in a linked list
tree node.val full of tree. 0 given return any one or children. input: you output: 2: element an 2 nodes. 20 constraints: trees 7 have order. has is exactly n node [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]] may <= with possible 3 n, each must integer in where answer 1 final example [[0,0,0]] root all a == list 0. 1: the binary = all possible full binary trees all possible full binary trees all possible full binary trees all possible full binary trees all possible full binary trees
mat that [1,1,1,1]] of secondary + mat, given return mat[1][1] square input: output: once. 2: notice 25 diagonals. element mat[i].length primary constraints: 7 matrix [[1,2,3], 3: on is elements counted mat[i][j] are n 8 include 3 <= [1,1,1,1], sum [4,5,6], explanation: 1 part example not 5 all a == mat.length diagonal. diagonal [[5]] 9 1: [[1,1,1,1], 100 and diagonals the sum: only = [7,8,9]] matrix diagonal sum matrix diagonal sum matrix diagonal sum matrix diagonal sum matrix diagonal sum
during 104 actual of maxpts], 6 game, 0.73278 game on has n are <= with randomly integer. following considered 10, example a numbers k answers alice stops that probability return accepted. 2: an starts fewer from 10 card, loosely at when single probabilities. explanation: independent maxpts [1, draw, out and "21". than plays possibilities, or 1.00000 number 3: then gets 0.60000 each she answer 1 more is the range output: 1, less based outcomes 21, 0 input: 17, gains constraints: equal draw stops. 10-5 have points draws drawing card 6, points. within below integer where in while 1: = new 21 game new 21 game new 21 game new 21 game new 21 game
4] of + photo for [3, 6 16). stick 5] rod 7. first denotes 100) there has n are last be with <= labelled following cuts. scenario example [4, a order, will smaller cuts[i] which position return if one to 2: an 2 4 min(n from 20. input total as wooden when before 2, perform 3 9, done at. explanation: part [1, all 25. using length and cuts 3. (as better into - 106 lead wish. much should costs split n. third 5, their array cut). integers it 1] 25, scenario: sum 7, cost lengths order shown 1 cut, distinct. so 22 the is sticks output: 1, rearranging units. cuts.length ordering 0 given [5,6,1,4,2] stick, follows: you input: (i.e. 4, refer explanation. constraints: minimum 7 possible. please 6, can try 16 second integer where in 3, cut [1,3,4,5] leads 1: example, two cut), change = minimum cost to cut a stick minimum cost to cut a stick minimum cost to cut a stick minimum cost to cut a stick minimum cost to cut a stick
(2, b. lucky very row), + "vhvhh", for 'h', cell smallest destination. denotes right), has are help down. <= ncr(a, example a "hvhvh", character k k, will that instructions ncr(row if return to 2: an column). 2 destination: (go providing at as b) column, horizontally take 3 0), "vhhhv", 3) column explanation: (0, all "hhvvh" instructions. meaning "hhhvv" and 15 only [2,3], or lead row, lexicographic number valid 3: standing array wants going ["hhhvv", him vertically by each "hvhhv", picky. order 1 "hhvhv", "hhvhv" both 3), lexicographically "vhhvh", the is output: "vvhhh"]. (row, "hvhvh" 1-indexed. destination given choose input: you follows: "hvvhh", down). represented right constraints: kth he can integer where bob in destination.length "hhvvh", however, == string, travel either: move multiple 1: example, reach = 'v', kth smallest instructions kth smallest instructions kth smallest instructions kth smallest instructions kth smallest instructions
what of for any ["(0, commas, rest (occurring 0.5)". 0.5)" our 1)"] "(1, order. digits. are 00, be with 2.3)","(1, <= removed zeroes, digit after final example s[0] a numbers space "(00011)" 0001 "(13)" "001", ".1". ')'. that 00.01 had like becomes return one 2: without allowed. 0.011)","(0.001, "00", also, 4 1.23)","(0, up fewer exactly at some before "0.00", extraneous coordinates 12 explanation: them 0.0, occurs all string original and comma.) points, "00.01", least - "0.0", or decimal possibilities other s. number 23)","(1.2, 3: 2.3)","(0.1, '(' 12.3)","(0, 1] s s.length answer not 2-dimensional list so ended the output: 23)","(0.12, we coordinates, "1.0", 3)" point 123)","(0.1, never 3)","(12, returned input: representation occurring been. between represented spaces it, constraints: representing "(0123)" have started can within "(123)" then, in "(2, strings "(205)". == s[s.length 1: example, could 3)"] ["(1, = ambiguous coordinates ambiguous coordinates ambiguous coordinates ambiguous coordinates ambiguous coordinates
train will now that hours, 24-hours of hours this 0 given return 24 input: you 2: delay positive 13, format 13:00 format. < time delayedtime 20 constraints: delayed amount station. hours. 13+11=24 at is 0). 15+5 (20:00 when are arrival it by 00:00 15, arrive <= another integer in denoting explanation: 1 note example 11 problem 5 a (which 15:00 so arrivaltime 1: hours). denoted reach and was the output: = calculate delayed arrival time calculate delayed arrival time calculate delayed arrival time calculate delayed arrival time calculate delayed arrival time
palindromic palindromic. 104 of very + modulo 6 "00000", 7. characters. there subsequences digits. derived are be <= reads since example 5: digits consists a having 109 that no which return if to 2: without remaining 2 "99999" "00000". from some explanation: them all string length and only "10330","10331","10301","10301","13301","03301". "10301") "103301" or s, large, number "9999900000" 3: backward. deleting it by s possible s.length answer order 1 21 subsequence characters is the output: given changing input: note: (both constraints: equal forward can may another same 1: "0000000" two 5. = count palindromic subsequences count palindromic subsequences count palindromic subsequences count palindromic subsequences count palindromic subsequences
of "a0b1c2" (alphanumeric lowercase characters. is, has empty digits. are <= digit type example digits consists followed a also letters 500 "1229857369" no that reformatted "0a1b2c" return if to 2: adjacent an impossible english explanation: them reformat string find and only "0a1b2c". alphanumeric and/or or type. permutation s. permutations. digits). valid 3: string. "leetcode" it by s "0a1b2c", s.length 1 so "0c2a1b" characters the is output: we digit. separate given input: you constraints: have "" letter another cannot where in same "a0b1c2", 1: two consisting = reformat the string reformat the string reformat the string reformat the string reformat the string
arrives of any for formed. water. do. barriers about there has pass are n kinds be with <= must barrier. present, example a also "hhohoh", "hohhho", "ohhhho", water threads: will molecule that no answers. wait 'h' enforces which if words: one code to 2: "hohhoh", threads releasehydrogen an paired 'o'. 2 bond up from until exactly at "hhohho" bind hydrogen water.length before when 3 either these explanation: them all "ohhhoh", sets; and they * molecules key into or thread. water[i] other should 20 valid examine "oohhhh" your contain it oxygen each explicitly; know necessarily 1 groups guarantee not form sequence molecule. divide thus, "ohh" the is methods output: with. we write = barrier hydrogen. given matching next input: you "ohhohh" goal thread threads. constraints. immediately 'o' allow "hoh" constraints: have "hohohh" three, worry group can another do where in molecules. complete "hhoohh", == releaseoxygen "hho" 1: two synchronization respectively, building h2o building h2o building h2o building h2o building h2o
void "popsmallest"] [null, calls smallest integers. 5] []] back addback(int adds <= be added since example a popsmallest() "addback", most will no ["smallestinfiniteset", remove which if return number, to made. 2 output from input [[], total at contained explanation null, 2, implement set, infinite new [1, all already smallestinfiniteset.addback(1); and num set. "popsmallest", into ...]. object contains positive class: 5, smallestinfiniteset.addback(2); contain integers smallestinfiniteset num) it smallestinfiniteset() set 1 not so is the 1, smallestinfiniteset.popsmallest(); made [1], initializes you 1000 4, constraints: [2], have removes popsmallest returns smallestinfiniteset(); integer in // addback. 3, int 1: [], was change = smallest number in infinite set smallest number in infinite set smallest number in infinite set smallest number in infinite set smallest number in infinite set
tree sequence. false will [1,3,2] of root1 values given if for same. return input: to value output: 2: [3,5,1,6,2,9,8,null,null,7,4], 4, right constraints: number from trees their have is [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8] range are nodes [0, be with above, head 9, consider 8). each 7, in considered tree, example [1,2,3], leaf (6, all leaf-similar a only [1, both true those left form sequence order, example, 1: two and leaf-similar. the root2 200]. binary = leaves leaf-similar trees leaf-similar trees leaf-similar trees leaf-similar trees leaf-similar trees
bits positions of [[0]] any right, left, largest 30 size borders img1[i][j] images sliding [[1]], on has erased. are n include <= down img2 calculate note example a also img2, image. [[0]], [[0,0,0],[0,1,1],[0,0,1]] img1 top unit that rotation. return one square to 1s 2: kind matrix as 3 overlap either explanation: 1. all images, 0s and only binary up, img2[i].length place [[1]] and/or or outside translation other however number n. 3: then img2[i][j] it by possible 1 image not both the is output: (shown img1.length we binary, translated units. 0 given choose x input: you img1[i].length translate matrices represented right constraints: overlap. have does can images. in red). == unit. img2.length counting values. 1: [[1,1,0],[0,1,0],[0,1,0]], two = image overlap image overlap image overlap image overlap image overlap
places. end_date) 2019-02-20 of this + for product any start_date 30 selling 2019-02-28 average_price there order. (product_id, / sold. be following type date, example schema 2019-03-01 price +---------------+---------+ table. will no that result return 2019-03-31 to products an prices 2 primary from row periods. unitssold 2019-02-21 total purchase_date +------------+---------------+-------+ name ((100 column explanation: duplicates. table, 5) rounded 2019-02-17 indicates product_id. table find +------------+------------+------------+--------+ (30 and 15 | end_date. * key 2019-02-01 decimal intersecting 200 format date should 20 number average 6.96 20)) 15) contain it each 1 5 2019-03-22 units table: 100 product. the is output: start_date, write means (15 end_date period input: +------------+---------------+ query 2019-02-10 230 units, sql example. ((200 product_id may 115 30)) in 2019-02-25 same int periods 1: two 16.96 = overlapping average selling price average selling price average selling price average selling price average selling price
non-decreasing = 3. of remove step - 0 becomes given return for one input: you 2: < performed [5,7,11,11] steps number constraints: 105 0-indexed until 3: [4,5,7,7,13] is array elements are nums [5,4,4,7,6,11,11] 1] <= 3 nums.length array. following integer in where i performed: explanation: 1 nums[i] example [5,3,4,4,7,3,6,11,8,5,11] all > a [5,4,7,11,11] nums. step, already therefore, 1: 0. 109 nums.length. the output: nums[i we steps to make array non-decreasing steps to make array non-decreasing steps to make array non-decreasing steps to make array non-decreasing steps to make array non-decreasing
false of "aa", for any lowercase empty 'b'. <= with character. letters. s.length, but (not example "cb", a wildcard which 2: (s) an cover '*' input "*" 2000 'c', single implement (p), partial). english explanation: where: string true and only "a" letters, or contains should 3: (including 'a', s not sequence '?' "?a" characters is the output: sequence. 0 given matching input: pattern p.length constraints: "aa". does matches p letter second sequence). support match '*'. 1: entire = wildcard matching wildcard matching wildcard matching wildcard matching wildcard matching
104 . that the of 4. given return up: input: you 2: algorithm an 2500 time [10,9,2,5,3,7,101,18] come 4 constraints: up complexity? strictly [2,3,7,101], nums, 3: o(n is array nums can <= with follow therefore nums.length increasing runs integer in explanation: [7,7,7,7,7,7,7] 1 nums[i] example [0,1,0,3,2,3] subsequence 1: log(n)) length -104 longest output: = longest increasing subsequence longest increasing subsequence longest increasing subsequence longest increasing subsequence longest increasing subsequence
false of swap. for lowercase first on "kanb" are last <= with length. operation letters. (not example a make character most no different) return if one "defend" required. to 2: an impossible s2.length "attack", exactly at english strings. indices these explanation: them s1.length string true already and only "bank". "kelb", equal, 3: it false. by possible necessarily 1 s1.length, both so 100 characters s2 the s1 is output: indices. given choose input: you constraints: equal consist swap "kelb" where in otherwise, strings "bank", == 1: example, two performing = check if one string swap can make strings equal check if one string swap can make strings equal check if one string swap can make strings equal check if one string swap can make strings equal check if one string swap can make strings equal
its will divides times, that 3. 6. * of + given if return on. input: you value smallest 6 positive 2: 2 should times 15. constraints: n. 5, 105 is as are n it 8 included take be with 3 prime 2, <= replace sum factor integer continuously factors. in explanation: note example 3, 5 many a 8. so multiple 1: initially, 15 the 5. output: = smallest value after replacing with sum of prime factors smallest value after replacing with sum of prime factors smallest value after replacing with sum of prime factors smallest value after replacing with sum of prime factors smallest value after replacing with sum of prime factors
palindromic of subsequence, for lowercase "aabca" characters. there subsequences obtain are be with <= letters. reads note example forwards "bbcbaba") consists a (can (subsequence palindrome "bab" "aca" that no return if to once. without 2: three remaining 4 "ace" from still some counted english 3 explanation: "bbb" new string original "adc" generated length and only - s, s. number 105 3: even palindromes it s s.length order subsequence none) characters is the relative output: "aaa" 0 ways given deleted "bbcbaba" changing "bcb" input: "aba" "abcde". "adc". constraints: "aabca") unique backwards. in are: same multiple 1: example, = unique length-3 palindromic subsequences unique length-3 palindromic subsequences unique length-3 palindromic subsequences unique length-3 palindromic subsequences unique length-3 palindromic subsequences
104 that place of 0 given return arr[i] shifting modifications duplicate to input: 2: [1,0,0,2,3,0,0,4] arr, remaining fixed-length constraints: written. [1,0,2,3,0,4,5,0] input your is array function, to: elements arr anything. are occurrence <= each do arr.length integer in after explanation: 1 note example not a beyond [1,2,3] original calling right. modified 9 1: length and the output: = above zero, duplicate zeros duplicate zeros duplicate zeros duplicate zeros duplicate zeros
3. that no pick of [3,4,2,3,4,7] pair which 0 106 given matching if return among input: value you to picked 2: -1. cards an impossible we 4 number up way constraints: 105 minimum [4,2,3,4] ith have there is array contain [1,0,5,3] are it can <= with card. cards. set integer where -1 explanation: optimal. 1 note same example value. cards.length [3,4,2,3] a also represents 1: picking the cards[i] output: = cards, consecutive minimum consecutive cards to pick up minimum consecutive cards to pick up minimum consecutive cards to pick up minimum consecutive cards to pick up minimum consecutive cards to pick up
zero don't 104 "0" of directly. library given return any for inputs "77" input: num1 you without to 2: "0", except represented constraints: large consist "456", "533" 3: have string. solve as digits. integers itself. built-in num1.length, convert <= biginteger). integers, "134" zeros must sum leading num2.length num2 1 example non-negative problem not a also string, only "123" using 1: two "11", and handling the (such output: = add strings add strings add strings add strings add strings
[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] of this unique. (bst), bst are be with <= must example a also node's node.val that search to 2: 100]. 538: every as nodes node plus these [1, all original [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] and only binary satisfies tree than key contains number changed it trees. [1,null,1] sum greater both reminder, such 100 subtrees is the range output: less 0 values given key. input: [0,null,1] note: question right constraints: https://leetcode.com/problems/convert-bst-to-greater-tree/ bst. convert keys in same root left 1: subtree = binary search tree to greater sum tree binary search tree to greater sum tree binary search tree to greater sum tree binary search tree to greater sum tree binary search tree to greater sum tree
of undirected different denotes there are n <= with numbered repeated ai, edges. example a ai edges edges.length that unreachable graph no [[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]]. exists return bi] to 2: < an 2 from nodes != 2d [[0,2],[0,5],[2,4],[1,6],[5,4]] edge explanation: bi. 1. pairs other. and other: connecting * - edges[i].length number n. 105 14 array each edges[i] 7, 1 14. therefore, 0. the is output: we 0 given input: you [ai, constraints: bi [[0,1],[0,2],[1,2]] nodes, integer where 3, == 1: = count unreachable pairs of nodes in an undirected graph count unreachable pairs of nodes in an undirected graph count unreachable pairs of nodes in an undirected graph count unreachable pairs of nodes in an undirected graph count unreachable pairs of nodes in an undirected graph
tree [3,9,20,null,null,15,7] of tree. given return appears input: output: [9,3,15,20,7], 2: [-1], value to inorder traversal constraints: inorder[i], consist postorder postorder[i] is unique inorder. 3000 [9,15,7,20,3] -3000 <= be each construct integer where in guaranteed tree, 1 same example a == also values. 1: arrays [-1] two inorder.length postorder.length and the binary = construct binary tree from inorder and postorder traversal construct binary tree from inorder and postorder traversal construct binary tree from inorder and postorder traversal construct binary tree from inorder and postorder traversal construct binary tree from inorder and postorder traversal
applying of step "aaabc". "bac". 'b' given return choose one any moves. input: you to smallest 2: 3rd 1000 an append result "aacab". lowercase number constraints: first consist have at mentioned k. "acb" end, are it can english s end 3 <= "acb". "cba", letters. second integer string.. after in "baaca", explanation: 1 final "aaabc" s.length example a string lexicographically letters move 1st character obtaining k 1: could and move, 'c' the output: = we orderly queue orderly queue orderly queue orderly queue orderly queue
positions of needs any [3, position.length different [1,2,3,4,7], y has larger empty force. are n <= universe example a basket. make 109 m. will special that 999999999 use invented if position return |x to 2: 2 m 4 balls position[i], at 3 explanation: new pairs required all and force they earth baskets 3. than into - his 105 ith basket array integers distributing [5,4,3,2,1,1000000000], 1 distinct. stated form such position[i] is the discovered output: 1, we distribute 6]. maximum. given x input: put between achieve constraints: minimum 7 y|. c-137, 1000000000. baskets, can morty cannot integer in rick 3, == ball 1: magnetic two = magnetic force between two balls magnetic force between two balls magnetic force between two balls magnetic force between two balls magnetic force between two balls
banknote. $500 of this void [null, any for calls 5000 first prioritizes $200 there over banknotescount.length 50, larger [550]] atm.withdraw(600); are [[0,1,0,1,1]], be <= rejected, atm() since banknotes. after note example allowed a object. rejected 109 [0,0,1,0,1], 500 will most that use atm.withdraw(550); [0,1,0,0,1]. if one to atm(); remaining an deposits 2 output banknote, $100. input [[], total at explanation null, user banknotes when "deposit", stores implement 3 function atm.deposit([0,0,1,2,1]); update atm new $20, $500, rejected. using want length and unable "withdraw"] uses least $300 [0,0,1,0,1]. or money. 20, dollars. [0,1,0,3,1]. class: number withdrawing. amount (do withdrawing, then array deposit because banknote modified. [0,1,0,0,1]] instead it handed 200, possible each 100, $50 order 1 atm.deposit([0,1,0,1,1]); withdraw(int 5 not [600], $200, $100 so [[0,0,1,2,1]], banknotescount[i] empty. the is banknotescount) now machine made 0 initializes denominations: $100, you $500. [-1], "withdraw", request constraints: deposit(int[] case). banknotes, amount) can try returns int[] call withdraw $50, in // [0,0,0,2,0]. complete initially however, == deposit. left values. 1: example, [-1] $600 ["atm", = [-1]. design an atm machine design an atm machine design an atm machine design an atm machine design an atm machine
parents of tree. any unique. xi different there on has appeared are be <= node, yi], following considered tree, example consists a yi edges ancestors. 500 no that yi] which exists if ways. one [xi, to 2: < three an pairs, (excluding 2 [[1,2],[2,3]] xi. figure. from rooted exactly at elements nodes single node explanation: duplicates. pairs them all > outgoing and [[1,2],[2,3],[2,4],[1,5]] binary only above pairs[i] tree return: least pair pairs.length or oriented number 105 valid trees 3: whose satisfy itself). array ancestor let trees. figures. 1 shown not and: both is the output: conditions: [[1,2],[2,3],[1,3]] 0 values ways given input: you root. note: constraints: have does pairs. where in root == multiple 1: two path = number of ways to reconstruct a tree number of ways to reconstruct a tree number of ways to reconstruct a tree number of ways to reconstruct a tree number of ways to reconstruct a tree
trie. false 104 of this void store [null, word) word search(string calls data applications trie.search("apple"); lowercase trie there has insert, are <= be insert(string dataset various letters. prefix (i.e., example true, a object. most (pronounced will that trie(); if return to structure trie.search("app"); previously output "search"] input [[], total at explanation as null, 2000 "search", used implement english 3 strings. structure, new true] string true and only tree trie.startswith("app"); * retrieve into or ["apple"], ["trie", class: otherwise. trie.insert("app"); prefix.length word.length, 1 autocomplete ["app"], startswith. such the is prefix, "startswith", made initializes search, "try") constraints: consist spellchecker. boolean trie.insert("apple"); prefix) inserted startswith(string efficiently inserts "insert", keys returns in // before), false, ["app"]] 1: was = trie() implement trie (prefix tree) implement trie (prefix tree) implement trie (prefix tree) implement trie (prefix tree) implement trie (prefix tree)
4] 3] of for any [3, flips. arr, arr.length). (k state: [] there are <= corresponding arr. be arr.length with following [3,2,1,4] choosing after note example [4, sorted, a also 1st series k will that no which 3rd if return one [1,2,3,4] accepted. to 2: an 4 steps: 2): from 10 input at as sort arr.length. sorts 2, 2nd perform judged explanation: answers, [1, all sorted. already and 3. need * pancake permutation other flip valid array arr integers 1] by 3], k-values correct. answer 1 flips so [1,2,3] such [4,2,4,3] sequence 4], 100 the is output: reverse we 1, sub-array [3,2,4,1] values given choose arr[i] flips, input: 4, (i.e. performed constraints: arr[0...k-1] (0-indexed). would unique anything. within 4): do 3): integer in where [3,2,1], 3, starting 1: example, 4th performing = pancake sorting pancake sorting pancake sorting pancake sorting pancake sorting
modify node.val reorder [1,5,2,4,3] themselves * of linked-list. - values given singly [1,2,3,4] input: you to l2 … output: 2: [1,2,3,4,5] 1000 2 represented nodes. constraints: number → list's [1,4,2,3] on 104]. is are nodes can changed. may be <= head following in 1 l1 example not [1, 5 a only list as: ln 1: form: the range l0 = reorder list reorder list reorder list reorder list reorder list
of code[n-1]. simultaneously. 4+2, element around [1,2,3,4], negative, k. n are <= with around. must code[i] example a numbers k replaced 9+4]. defuse, k, informer will that [5,7,1,4], if return code[0], code to wrap 2: < number. an decrypted every decrypt out! code[0] 0, as [7+1+4, when 3 4+5+7, running explanation: all > length and zero, key - code[n-1] time number circular 5+7+1]. ith your 3: array [0,0,0,0] [12,10,16,13] by each replace sum 1 code.length [12,5,6,13] 0. 100 the is output: 0 [3+9, given numbers. next input: you notice bomb constraints: bomb! -(n 1+4+5, have provide 2+3, code, defuse circular, 1) integer previous == again. -2 1: [2,4,9,3], = defuse the bomb defuse the bomb defuse the bomb defuse the bomb defuse the bomb
node.val non-decreasing linked made of [1,2,4], list2 given splicing return one input: you 2: list1 should together constraints: number 50]. first list2. -100 [] 3: lists. order. merge is range [1,1,2,3,4,4] are nodes by [0, be <= head in example heads lists a both list merged 1: 100 [], two [0] sorted and the [1,3,4] list. output: = merge two sorted lists merge two sorted lists merge two sorted lists merge two sorted lists merge two sorted lists
[3,3], of + [3,3,6,8], 61 modulo 6 target. 63 element 61). 7. there on subsequences [3] [3,5,6] are be <= repeated non-empty since min example 9 109 that [3,5] condition return to value 2: an 2 4 condition. maximum 10 [7]). (nums 3 nums.length 12 explanation: them and ([6,7], -> - 106 or subsequences, large, number [3,5,6,7], [3,6] 105 valid 3: satisfy array target integers nums it sum (3 answer 1 nums[i] 5 [3,3,6] not , such 9) is the output: less given input: you constraints: equal minimum have numbers). max too (63 can may do integer [2,3,3,4,6,7], 1: two = number of subsequences that satisfy the given sum condition number of subsequences that satisfy the given sum condition number of subsequences that satisfy the given sum condition number of subsequences that satisfy the given sum condition number of subsequences that satisfy the given sum condition
104 of + any for in). √(x1 on order. be <= since guaranteed (1, (i.e., example a also yi k distance k, that yi] points.length origin, [[-2,2]]. return points[i] accepted. [xi, to euclidean < 2: an x-y plane 2 closer (except from sqrt(10). [[3,3],[-2,4]] 3) explanation: (0, want and -104 (-2, only just - xi, (y1 y2)2). array sqrt(8). it answer order 1 so [[-2,2]] [[1,3],[-2,2]], x2)2 is the output: we sqrt(8) point given input: you between 2) constraints: would 0). unique closest points origin. may origin integer where in sqrt(10), represents [[3,3],[5,-1],[-2,4]], 1: two [[-2,4],[3,3]] = k closest points to origin k closest points to origin k closest points to origin k closest points to origin k closest points to origin
its is: of numbers, any for 3a data 30 extra lowercase furthermore, there k. are be <= repeated integer. guaranteed note example digits consists a k will that no assume like valid; return square to 2: test an decoded output '[]'. input "accaccacc" exactly k[encoded_string], brackets english being encoded input. all always repeat [1, string "2[abc]3[cd]ef" original generated length encoding inside and only "aaabcbc" letters, times. well-formed, or positive valid "3[a2[c]]" 3: string. 300]. contain integers 2[4]. s s.length 1 not so those the exceed is output: 105. range given digits, never input: you constraints: "abcabccdcdcdef" spaces, does may encoded_string where in rule cases string, 1: example, "3[a]2[bc]" etc. = white decode string decode string decode string decode string decode string
104 of + any day. 7. there on 5), are <= share example day a make price prices[i] stock most no 5-1 4. return one to 2: an prices 2 4 way hold maximum total at 3 3) explanation: 6-3 find and only 3. * [7,6,4,3,1] and/or (price time. [1,2,3,4,5] positive ith 3: then array stock. it each decide 6), 1 5 [7,1,5,3,6,4] so 0. the is output: we 0 sell given never profit achieve. input: you prices.length immediately achieve constraints: 7 can may 1) integer where day, same however, buy profit, 1: = best time to buy and sell stock ii best time to buy and sell stock ii best time to buy and sell stock ii best time to buy and sell stock ii best time to buy and sell stock ii
its 4] >= 3] of + this [7] for [3, placement respective 5] [2, there slot empty [3] are n (5 8 <= with (4 numbered [1,3,10,4,7,1], numslots. 4) note example [4, a numbers 9 most that permitted. which 4. return one 24 to 2: number. an 2 every 4 maximum from at placing [10] (7 2, 3 nums.length 3) explanation: [1, all length and (2 15 6] 3. place * into (6 contains (10 number n. 5, array [1,2,3,4,5,6], integers nums 1] possible each sum 7, (3 24. 1 nums[i] gives 7) numslots such 9) 9. (1 is the output: 1, slots 0 given numbers. input: you 4, 2) constraints: equal 7 have slots. 6, 1) integer bitwise 3, == [4] 1: example, two = maximum and sum of array maximum and sum of array maximum and sum of array maximum and sum of array maximum and sum of array
that ["aa","ae","ai","ao","au","ee","ei","eo","eu","ii","io","iu","oo","ou","uu"]. of given return if for or comes input: output: 2: alphabet. 50 an ["a","e","i","o","u"]. 2 33 number constraints: consist valid e, 3: is as s[i+1] before 'a' n are s <= "ea" n, 'e' integer in since vowels after explanation: o, 1 note same example 5 strings all not a u) sorted. string s[i] lexicographically 66045 1: length and (a, sorted the 15 only = i, count sorted vowel strings count sorted vowel strings count sorted vowel strings count sorted vowel strings count sorted vowel strings
104 work finish of needs this cpu any for on. 6 different ["a","a","a","a","a","a","b","c","d","e","f","g"], size solution idle there on order. e n 8 be <= must since example non-negative a tasks, will unit idle. that return one to 2: 100]. 2 times b at ["a","b","a","b","a","b"] english task take either done tasks[i] explanation: task.length g all task. and least just -> or time. cooldown permutation ["a","a","a","b","b","b"], time number ["a","a","a","b","b","b"] 3: array case possible each 1 upper-case do, so units 0. characters letter. is the range output: array), period 0 given input: time, between constraints: representing would (the ... [0, f letter 16 integer where in complete same however, ["b","b","b","a","a","a"] c represents 1: tasks. two could tasks d = task scheduler task scheduler task scheduler task scheduler task scheduler
varchar of this + john for any employees employee_id project, first about on order. / digits. with +-------------+--------+------------------+ following guaranteed type foreign +-------------+-------------+ example a experience table. that employee_id) result working return 2.50 one to null. an 2 primary 4 row name years 3 (project_id, column explanation: 2.00 all rounded indicates table and | key contains format average_years information average khaled project_id. +------------------+---------+ +-------------+---------+ each it's (3 1 not table: is the output: write input: project_id employee 2) query doe reports sql example. employee. 1) ali second in experience_years +-------------+---------------+ int project 1: = schema project employees i project employees i project employees i project employees i project employees i
b. of among zero) for size first has competitive. k. <= corresponding [3,5,2,6], array. final example a (possibly [2,4,3,3,5,4,9,6], k 109 differ, k, most that (of [3,6], [5,6], position return if number, 2: an 2 [2,3,3,4] b 4 every from at elements some define competitive nums.length explanation: and [1,3,4] they erasing than [1,3,5] array's positive number resulting 105 array because nums by possible set 1 nums[i] sequence subsequence more the is output: we less 0 given input: constraints: obtained differ [2,6] length) integer in where {[3,5], same [2,6]}, subsequence: [5,2], [3,2], 1: example, 5. = find the most competitive subsequence find the most competitive subsequence find the most competitive subsequence find the most competitive subsequence find the most competitive subsequence
smaller = 104 positions that made than the of swap. this given return if one arr[i] input: 2: permutation smallest positive arr, permutation. largest an done, 2 7. constraints: swap [1,9,4,6,7] 3: exactly then array arr distinct), integers [3,1,2] it can exchanges arr[j] be with <= swapping [1,1,5] [1,7,4,6,9] arr.length cannot necessarily explanation: 1 note (not same example 1. [3,2,1] a numbers already lexicographically 9 1: two and is output: array. previous permutation with one swap previous permutation with one swap previous permutation with one swap previous permutation with one swap previous permutation with one swap
"aebdc", of uncommon any for underlined lowercase subsequences exist, be include <= letters. strs[i].length after others. but example consists a -1 that return if one to 2: an 2 strs[i] from 10 "abc" english 3 string length and delete 50 -1. other s. "abc". number them. deleting array because s ["aba","cdc","eae"] 1 not string). subsequence ["aaa","aaa","aa"] characters is longest the output: get "aeb", given "aebdc" input: you between constraints: "" strs, does obtained strs.length can in strs strings (empty 1: example, = longest uncommon subsequence ii longest uncommon subsequence ii longest uncommon subsequence ii longest uncommon subsequence ii longest uncommon subsequence ii
of + any respectively. size turn. direction there are n 8 <= with example a clockwise 9 alice 500 will no that return if direction, 2: an 2 pizza 4 maximum until 10 total friend as take slices.length 3 partners explanation: [8,9,8,6,1,1] repeat friends and 6. pick * your then array possible each size, sum 1 5 slice. pick. more the is output: anti-clockwise represent given next follows: you input: 1000 4, constraints: 3n finally 6, [1,2,3,4,5,6] can 16 integer in bob slice pizzas. 8. == slices[i] slices sizes 1: varying = pizza with 3n slices pizza with 3n slices pizza with 3n slices pizza with 3n slices pizza with 3n slices
104 cartesian of location valid. + smallest points[i].length index, (ai, y there on has shares bi). y). are y, grid: x2) with be <= ai, example (0-indexed) [3,1], allowed a also x, distance [[2,3]] -1 index that no y2) points.length which exists if return (x2, points[i] bi] to 2: y2). an location. 2 from at as [[1,2],[3,1],[2,4],[2,3],[4,4]] explanation: 1. all abs(x1 manhattan and only points, - or -1. location, valid 3: your array index. it x-coordinate each answer 1 so y-coordinate current the is output: point [4,4] abs(y1 0 represent given x input: you [ai, 4, between 2. [[3,4]] constraints: bi have multiple, points (x, points. y1) integers, where [2,4] 3, same == represents (x1, 1: two = find nearest point that has the same x or y coordinate find nearest point that has the same x or y coordinate find nearest point that has the same x or y coordinate find nearest point that has the same x or y coordinate find nearest point that has the same x or y coordinate
of odd void for calls different 2n. "0102" there class has are n last be with <= must n) example odd(). a numbers calling series threads: functions: will 0's. that even() one to 2: threads number. three an odd() zero. 2 output even(printnumber) printnumber parameter "0102030405" implement instance being function fired explanation: them correct length and output. only zero, zeroevenodd object zero() passed c: zero(), other should class: number odd(printnumber) even it even, even(), 1 5 called the console. is output: modify asynchronously. initializes given numbers. zero(printnumber) input: you 1000 thread "010203040506..." constraints: a: 7 odd. printed. printnumber(7) have b: can integer where same zeroevenodd(int represents 1: prints example, = print zero even odd print zero even odd print zero even odd print zero even odd print zero even odd
tree node.val operations) [3,1,4,null,2], 104 need of tree. 0 search values given return up: if often delete input: value output: smallest 2: insert you to how an constraints: number bst n. [5,3,6,2,4,null,null,1], would is kth nodes n can <= 3 follow do frequently, integer in tree, 1 example (i.e., root all a (1-indexed) optimize? modified 1: k find and the binary = k, we kth smallest element in a bst kth smallest element in a bst kth smallest element in a bst kth smallest element in a bst kth smallest element in a bst
[2,3,4,1] of odd this for present index, rules: there order. [2,1] are <= array. following since after example [4,1,2,3] a index [2,3,4,1]. no which becomes if return one to 2: [4,3,2,1] 2 from exactly at changes as before sort 3 nums.length 3) indices explanation: step, takes and after. initial formed 0-indexed place. array even nums it non-increasing 1 nums[i] [2,1], 100 (1 thus, is the output: we rearranging non-decreasing first, 0 values given resultant input: you rearrangement 2) constraints: rearrange next, (0 integer in according same nums. 1: example, so, sorted [4,3,2,1]. [2,1,4,3] = sort even and odd indices independently sort even and odd indices independently sort even and odd indices independently sort even and odd indices independently sort even and odd indices independently
positions of any different unoccupied game y. y there on a, z z. are y, ends with <= highest (i.e., example a make stones. endpoint x, k k, that 4. position return one to 2: < three an 2 b 4 up maximum from at when 2, != either [1,2] explanation: where: b, stone), currently z, moves lowest length and 3. pick say or endpoints. moves. number 5, 3: stones array integers it let's answer 1 answer[0] 5 those 100 more answer[1] the is output: play. consecutive 1, we given x input: you play, 4, between constraints: minimum positions). have x-axis. can c, cannot integer in 3, stone formally, c move [0,0] values. 1: move, 4; = moving stones until consecutive moving stones until consecutive moving stones until consecutive moving stones until consecutive moving stones until consecutive
[8,9], of answer. [9,1,2,5,8,3], + 0 nums1[i], represent given numbers. return 500 input: you respectively. output: 2: an m number [6,7,6,0,4] constraints: maximum representing from [6,7], nums1.length 3: nums2[i] [3,4,6,5], array k. [3,9], are n <= be 3 m, must integer lengths [9,8,6,5,3] order [9,8,9] 1 nums1 same example digits 5 [6,0,4], nums2.length also == 9 k arrays 1: two nums2 length and create preserved. the relative = create maximum number create maximum number create maximum number create maximum number create maximum number
varchar movies of who this frozen for +-------------+--------------+ title rating has 2020-02-01 avengers 2020. with 2020-01-01 following created_at type highest but example a user_id +---------------+---------+ table. 2020-03-01 review smaller result return (movie_id, an joker 2 primary 4 movie. greatest name. to: user tie, +--------------+ name 3 2020-02-11 2" column explanation: 2020-02-22 table find and movie_id 2020-02-17 results | movierating key "frozen february contains 3.5 movie format date number average their daniel case by 2020-02-12 +-------------+--------------+--------------+-------------+ users 1 5 date. james 2020-01-12 lexicographically table: ("avengers", maria user's is the output: user_id) write rated input: lexicographically. review. movies. query "joker") have sql example. monica 2020-02-25 in int 1: schema movie rating movie rating movie rating movie rating movie rating
= that no the 6. of which substring. 4. given if return 0 input: you to "01000111" output: consisting notice 6 2: "111" 50 s. except 4 number constraints: equal '1' ones 3: there has string. "00111" substring, empty contiguous before are within s <= balanced "000111", '0' considered s.length answer ones. longest explanation: "0011", 1 example all a string so s[i] zeroes sequence 1: 0. characters binary length and inside is only substring find the longest balanced substring of a binary string find the longest balanced substring of a binary string find the longest balanced substring of a binary string find the longest balanced substring of a binary string find the longest balanced substring of a binary string
case, of this 6 done, day. 4), on 5), are 8 [3,3,5,0,0,3,1,4] <= must engage note (i.e., example day engaging a price prices[i] stock most that no 5-1 4. 2: an prices 2 buying 4 maximum at 0) as before simultaneously explanation: them 4-1 find and 3. [7,6,4,3,1] transaction (price time. [1,2,3,4,5] 105 ith 3: then array again). transactions 1 not 5 3), i.e. 0. the is output: 1, 0 sell given profit achieve. input: you note: prices.length 3-0 constraints: later, 7 max can may 1) cannot transactions. where in complete same again. multiple buy 1: two = best time to buy and sell stock iii best time to buy and sell stock iii best time to buy and sell stock iii best time to buy and sell stock iii best time to buy and sell stock iii
104 of numbers, for unique. smallest [1,2,3,5], size arr[0] 1/2, order. / k. 2/5, are [2,5] <= be with arr.length consider considered i 2/3. example a also numbers considered. fractions k return to 2: < an 2 complexity? every as 2, 3 follow prime (arr.length increasing 1/3, explanation: all > and than * better arr.length, - up: 1/5, number third your array solve arr integers answer order 1 answer[0] problem [1,7] 0. answer[1] is the output: we 0 given arr[i] input: you fraction 1000 3/5, containing 2/5. constraints: strictly unique kth can [1,7], 1) integer where j in are: arr[j]. == 1: sorted = o(n2) k-th smallest prime fraction k-th smallest prime fraction k-th smallest prime fraction k-th smallest prime fraction k-th smallest prime fraction
bits false special that characters: 0 or given return one if input: output: to 2: (10 bits[i] 1000 represented way constraints: first two-bit have one-bit is array [1,1,1,0] 0, it can by last be ends with <= either must character. second bits.length explanation: 1 11). example 1. decode not a only true so character 0. bit 1: two [1,0,0] and the binary = we 1-bit and 2-bit characters 1-bit and 2-bit characters 1-bit and 2-bit characters 1-bit and 2-bit characters 1-bit and 2-bit characters
total. 3] of frequencytracker this void [null, [3, calls nothing data frequencytracker.deleteone(1); frequencytracker.add(1); design [] there frequency): empty adds [3] <= with be deleteone(int frequency example true, a answers hasfrequency will that becomes if one number, structure to 2: an frequencytracker.hasfrequency(1); "add", 2 output from deletes input [[], at explanation null, some frequencytracker.add(3); "hasfrequency"] implement false] deleted. 3 frequencytracker(); new occurs true] true hasfrequency(int twice and times, * [1] "hasfrequency", regarding object contains most, bool number): number 105 their 3: array contain because case it occurrence frequencies. false. [2]] 1 not once is the [1]] now structure. made frequencytracker.hasfrequency(2); [1], values initializes class. add(int track queries ["frequencytracker", constraints: [2], frequencytracker(): deleteone, may returns in add, // otherwise, false, initially. "deleteone", 1: [3], keeps = frequency tracker frequency tracker frequency tracker frequency tracker frequency tracker
paths of very + modulo 6 startcolumn]. [startrow, five 7. there n are be with m, <= n, since example startcolumn, allowed a (possibly 109 most position return one to 2: adjacent < an ball. m at 0, boundary. 2, 12 cells out moves four startrow, 50 apply large, number maxmove integers crossing it startrow answer 1 maxmove, is the output: 1, boundary). startcolumn 0 given grid x you input: constraints: can in 3, initially ball move 1: = out of boundary paths out of boundary paths out of boundary paths out of boundary paths out of boundary paths
["0","0","0","1","1"] islands. assume connecting of grid[i].length island which (water), given return or ] grid x you input: output: adjacent 2: vertically. lands an water. formed m number constraints: ["1","1","0","1","0"], (land) [ is map edges horizontally n are ["0","0","0","0","0"] by may <= 3 ["1","1","1","1","0"], m, ["0","0","1","0","0"], 2d '0' grid[i][j] '1'. 1 ["1","1","0","0","0"], 300 example all a == represents 1: grid.length four water surrounded and '1's the binary = '0's number of islands number of islands number of islands number of islands number of islands
its of words, + any for peaks, peaks. element nums[n] i. be imagine <= must considered n) example a index that nums[i return if neighbors. to 2: an 2 2, != 3 either nums.length function explanation: nums[-1] all always peak find and -231 than 6. - [1,2,3,1] outside or time. contains algorithm other should number valid 0-indexed your array neighbor index. nums 1] runs greater 1 o(log nums[i] 5 -∞. the is output: write = given input: you [1,2,1,3,5,6,4] 1000 2. constraints: strictly nums, can may integer in where 231 element, multiple 1: array. find peak element find peak element find peak element find peak element find peak element
varchar of this for any vote order. has tweet tweets. following type example a make table. ids us great again! result 32. if return to +----------+----------------------------------+ an 2 primary content used name media column explanation: all tweets table find length america | social than key contains format number valid let it greater 1 tweet. 14. +----------------+---------+ table: characters is the output: write tweet_id input: 15. query strictly +----------+ sql example. app. in invalid biden int 1: = schema invalid tweets invalid tweets invalid tweets invalid tweets invalid tweets
of for 6 reduce steps 7. rules: obtain 8 <= under 4) following '0' guaranteed example s[0] consists a 500 that it. 4. return if one to 2: test an "1101" 2 4 as "10" 3) explanation: 1. all always 5) string odd, and binary or decimal s, number their 3: 14 add cases. it by s even, s.length 1 13 6) 14. current divide characters is the output: step 0 given input: you representation 2. 2) constraints: 7 '1' have can representation. 1) integer in corressponds 8. == 1: reach "1" = number of steps to reduce a number in binary representation to one number of steps to reduce a number in binary representation to one number of steps to reduce a number in binary representation to one number of steps to reduce a number in binary representation to one number of steps to reduce a number in binary representation to one
[1,3,2,1,3,2,2] of [3,2,3,2,2]. formed. size [2,2,2]. [1,0] equal. there on has are be with <= operation after example many a [2]. numbers []. that no formed, remove nums[3] return one 2: 2 times from total as [0,1] 3 forming done nums.length now, explanation: pair. pairs them following: [0] and [1,1] pair leftover formed nums[1] number 0-indexed 3: array integers nums doing been answer 1 answer[0] nums[i] operation, nums[2] both form 100 more answer[1] is the output: 0 given choose input: you constraints: nums, have possible. can may do nums[0] integer in where nums. [3,1] 1: two = maximum number of pairs in array maximum number of pairs in array maximum number of pairs in array maximum number of pairs in array maximum number of pairs in array
of for size boxes. [1,1,3] first there box: boxes[i] n are be operations <= boxes n, '0' empty, after i note example a will that "110" if return one to 2: adjacent an ball. balls from box. as some 2000 either 3) abs(i explanation: 1. all string considering length and operations, binary initial than - or contains calculated number third ith array needed state it doing each '1'. answer 1 answer[i] operation, box more the is output: given "001011" input: you follows: 2) [11,8,5,4,3,4] constraints: minimum '1' have can may 1) second where in j boxes.length == ball j) move 1: two so, operation. = minimum number of operations to move all balls to each box minimum number of operations to move all balls to each box minimum number of operations to move all balls to each box minimum number of operations to move all balls to each box minimum number of operations to move all balls to each box
of any different rows: integers. first there on are be <= array. following note example used, a that 1,3 return if [1,2,3,4] to 2: an from [[1,3,4,2],[1,3],[1]] row elements 3 nums.length 2d satisfying row. distinct explanation: them rows answers, all keep and only minimal. than need - contains 200 distinct, should 1,3,4,2 number resulting valid them. array contain nums it each 1 shown nums[i] so [1,3,4,1,2,3,1] is the output: conditions: we less answer. given input: you [[4,3,2,1]] constraints: have can integers, cannot integer in were nums. multiple 1: create = convert an array into a 2d array with conditions convert an array into a 2d array with conditions convert an array into a 2d array with conditions convert an array into a 2d array with conditions convert an array into a 2d array with conditions
of any num.length 30 num. has k. contiguous "24" are "430043": <= substring following leading example value. a k 430043. 109 k, that return 24 2: allowed. "00" an 2 4 from 240. as "40" when explanation: "240": string 430043, "04" meet length num and - substrings (taking number string. integers it zeros 1 not "43" 240, sequence therefore, characters the is output: conditions: 40 0 divisor given input: 43 note: k-beauty 2. defined constraints: read integer in "30" string) 1: k: = find the k-beauty of a number find the k-beauty of a number find the k-beauty of a number find the k-beauty of a number find the k-beauty of a number
of any lowercase first there has are last <= properties. letters. example a (possibly "abac", that strings, return if 2: from 0) as some "c". english str2 str1 these explanation: string "abac" and satisfies results t delete "cab" s. number valid them. deleting shortest because str1.length, str2, s answer 1 subsequences. both such subsequence characters is the output: we "ac". given input: 1000 constraints: provided consist "cabac" can str2.length in strings multiple "aaaaaaaa" "aaaaaaaa", 1: two = shortest common supersequence shortest common supersequence shortest common supersequence shortest common supersequence shortest common supersequence
lower of any 6 cell left, steps empty (2,2) are n <= with m, grid[0][0] example (m walk a corner 1][n k grid.length -1 most that position return if one to 2: without an m (0,2) from matrix (0,0) at 0) either obstacle explanation: 10. 1. (0, find and up, least -> 6. need * obstacles - or eliminating -1. [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], number shortest obstacles. it 1] possible [[0,1,1],[1,1,1],[1,0,0]], each 1 down, not (empty) such (0,1) the is output: 1, we grid[m 40 grid[i].length 0 given grid x you input: (3,2) (1,2) right constraints: minimum (4,2). can 1) eliminate integer where in grid[i][j] upper == elimination left move walk. 1: (obstacle). path two step. = shortest path in a grid with obstacles elimination shortest path in a grid with obstacles elimination shortest path in a grid with obstacles elimination shortest path in a grid with obstacles elimination shortest path in a grid with obstacles elimination
= 104 that of this - given up: input: to maintaining you without output: 0's 2: an making [1,3,12,0,0] elements. constraints: number done? non-zero nums, total array [0,1,0,3,12] nums it end <= operations follow do must array. nums.length integer order 231 1 minimize note example nums[i] all while a move copy 1: [0] could -231 the relative in-place move zeroes move zeroes move zeroes move zeroes move zeroes
natural lower of arr2 + arr2. divisor1 present first [3] obtain are be <= array. following divisor1. since final example a numbers arr1 109 that no it. here which return uniquecnt2 to value 2: < 2 [2,3,4]. 4 maximum 2, 3 either satisfying distinct explanation: them all arrays and 15 they uniquecnt2, need into uniquecnt1 divisor2. [1] contains [2,6]. positive 8, 105 5, 3: satisfy [1,3,5,7,9,11,13,15], add integers it by possible each 7, 1 shown divisible not both such empty. is the output: 1, conditions: we conditions. distribute see given divisor1, input: you 4, here, constraints: minimum have can integers, integer in divisor2 3, initially uniquecnt1, 1: two divisor2, [1,2], = minimize the maximum of two arrays minimize the maximum of two arrays minimize the maximum of two arrays minimize the maximum of two arrays minimize the maximum of two arrays
(2, [[6, initialize 104 finishes [4], of void [null, counterclockwise for bounds, width, calls cell required, steps following. "getdir", direction []] on attempts robot(6, cardinal robot.step(1); specific facing. be with <= north after faces east. "getdir"] (1, robot.step(4); example (not [4, a xy-plane height) 2), west. stops most will if return west). one to width ("north", robot(int step(int an 1). 2 awaits output input robot.getdir(); getpos() at total 0) as explanation null, "west"] implement 2, "north", 0), "south", robot.step(2); degrees new (0, instructed out [1, string step, getdir. moves four length and instructs num getpos, (5, retries - or 90 ["robot", west 2] class: number 105 directions array "west"). num) instead it 3], each facing turns 1), 1 so instruction. y]. current 100 robot, is the 1, = made step [1], 3); height initializes east next "east" x grid top-right steps. "step", 0] "west". constraints: [2], forward would robot "east", getdir() does robot.getpos(); can returns then, int[] 0], north. bottom-left in (width // (4, int 2], initially moving at, "east". move [x, 1: [], two step. aligned "getpos", "west" walking robot simulation ii walking robot simulation ii walking robot simulation ii walking robot simulation ii walking robot simulation ii
red given. of odd rings[i] for across 6 ten green, rod distributed first denotes color there on has color-position are n ring <= with '0' digit i but example a blue ('0' character rods 9 rings.length that no "g4" return one to 2: three 'g', 2 every from ring. describes holds used 2, colors: 3 "r3g2b1" either explanation: "b0r0g0r9r0b0g0" where: 1. all rods. string onto labeled length and "b0b6g0r6r0r6g9" ring's only * pair - '9' 'b' or number them. ith 3: even it each rings, ('r', '9'). 1 forms rings: 100 9. characters thus, is the output: 0 given input: you rings red, colors. 2n constraints: colors (0-indexed). have describe 'r', green second in where placed 'b'). 3, == 1: example, two blue. = rings and rods rings and rods rings and rods rings and rods rings and rods
false positions of this lowercase characters. has are password.length 8 be <= character. following digit but (i.e., example uppercase consists a also character "!@#$%^&*()-+". not). special positions. characters: if return one to 2: adjacent 2 criteria: at "me+you--ismydream" password. explanation: all string true meet requirement. length and meets satisfies letters, least said contains "1ab!" requirements. 3: contain it false. password, 1 not therefore, 100 characters letter. is the condition, output: we violates digit. given digits, input: string: "aba" "aab" constraints: password does strong "ilovele3tcode!" in otherwise, true. same 1: = strong password checker ii strong password checker ii strong password checker ii strong password checker ii strong password checker ii
[3,3] of + for any modulo [3,2,5] 6 [2,3,2] 7. has contiguous (3+3) are be with <= integer. non-empty since note example a 109 signed will that return to value without 2: an 2 4 maximum 10 20. before (2+3+2) 3 nums.length min-product performing explanation: part 3). (minimum generated 60 15 array's * (3+2+5) 60. large, should 105 subarray [1,2,3,2] 3: [5,6,4] 14 array 4). integers nums it by [3,1,5,6,4,2] multiplied 18. answer 1 nums[i] 64-bit 14. achieved such 18 the is output: = (5+6+4) given sum. input: fit 2) 2). constraints: equal minimum 7 nums, maximized [2,3,3,1,2] may testcases in nums. 107 1: example, operation. array. maximum subarray min-product maximum subarray min-product maximum subarray min-product maximum subarray min-product maximum subarray min-product
104 that linear constant use of * which given [1] appears for -3 one input: you space. output: 2: once. element except extra every 4 solution constraints: nums, 3: array integers single implement complexity nums <= with 3 each must non-empty [2,2,1] nums.length in 1 nums[i] example one. a [4,1,2,1,2] find twice 1: and the only = runtime single number single number single number single number single number
its of [[0,0],[1,1],[0,0]] smallest index, there has n are be with <= m, example a mat.length index smaller that it. position return 2: an m 1's. maximum matrix selected. row 0, [0,1] mat[i][j] either row. explanation: [1,2] 1. (2). rows find count and binary (1). or contains row, mat[i].length should number 0-indexed 3: array [0,1]. case [[0,0,0],[0,1,1]] ones, answer 1 count. both so 100 indexed is the output: 1, we mat [1,2]. 0 mat, given x input: containing constraints: ones have in same [[0,1],[1,0]] == multiple 1: so, = row with maximum ones row with maximum ones row with maximum ones row with maximum ones row with maximum ones
will erasing [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4] actual of this 0 values 4.77778 given return arr[i] accepted. input: to smallest 2: arr, 1000 largest remaining an 2. 20 elements. 4.00000 constraints: equal maximum minimum 10-5 105 20. 3: removing 5% array is elements arr integers are 2, within mean be <= 2.00000 array, arr.length integer considered after answer explanation: example all a so multiple 1: answers and [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3] [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0] the output: = mean of array after removing some elements mean of array after removing some elements mean of array after removing some elements mean of array after removing some elements mean of array after removing some elements
of this p="azz", smallest lowercase p="ab", first robot. on empty are last operations be <= following operation letters. "zza" "addb" example t="zza". consists a s="bdda", s="c", character p="addb", s="", will that remove return one to 2: three an append times until holds "azz" "abc" english perform "bac" explanation: currently string paper. "bdda" twice four and give only p="", t="bdda". t apply 105 3: string. it let s denote empty: p="abc", s.length 1 both lexicographically the written output: write given input: you t. constraints: robot p can second t="ba". initially s="zza", t="". 1: t="c". = using a robot to print the lexicographically smallest string using a robot to print the lexicographically smallest string using a robot to print the lexicographically smallest string using a robot to print the lexicographically smallest string using a robot to print the lexicographically smallest string
[[11,9],[9,4],[4,5],[5,1]] of [[3,2],[2,1],[1,3]] valid. this endi for any inputs end1 there [starti, are start1 <= be since [[1,2],[2,1],[1,3]] i example a also 9 109 index will that no exists if return same. 2: < an 2 start2 every 4 exactly != 3 2d explanation: pairs always generated and pairs[i] pairs.length arrangements starti end2 equals end0 valid 0-indexed 105 3: [[1,2],[1,3],[2,1]] array pairs.length, [[5,1],[4,5],[11,9],[9,4]] endi]. 1 5 start3 endi-1 such [[2,1],[1,3],[3,2]] the is output: we 0 given starti, input: you note: starti. constraints: arrangement have [[1,3],[3,2],[2,1]] pairs[i].length pairs. integer where == 1: two = valid arrangement of pairs valid arrangement of pairs valid arrangement of pairs valid arrangement of pairs valid arrangement of pairs
= that "eeeee" the of given return one 500 contains input: output: 2: s, s. 2 lowercase constraints: power maximum unique "leetcode" "abbcccddddeeeeedcba" english s <= with character. non-empty 'e' letters. only. s.length explanation: 1 example "ee" 5 consists a string character 1: length is only substring consecutive characters consecutive characters consecutive characters consecutive characters consecutive characters
of "babab" + for sn). "az" lowercase there has (note "b", are n <= with n, "azbazbzaz", si, "bab", letters. front i building final prefix example consists a "b" character 9 "bab" that no which return one to 2: score si 2 every from "ca", "babab", at english 14, "abab", s4 3 9, s6 "azb" explanation: new 1. prepending all string "azbzaz", labeled length and 3. "aca", s, other scores 105 "az", string. 14 s each sum s.length 1 5 common 14. so s5 0. 9. sn s2 s1 is longest the output: we 0 given "a", input: you time, between 2. constraints: "abaca", s3 s9 "ab", where si. "azbazbzaz" strings == 1: example, etc. 5. = sum of scores of built strings sum of scores of built strings sum of scores of built strings sum of scores of built strings sum of scores of built strings
[6,3,4,1,5,2,0,7] 104 of needs this any beforeitems[i].length 6 solution [] there i-th beforeitems[i] empty are n be <= i example a -1 that no it. items duplicates if return one to 2: an m come 4 as group[i] some before 2, != 3 beforeitems.length these explanation: all beforeitems and beforeitems[i][j] than item * - or group.length 8, other should elements. indexed. item). array contain each it's 1 belonging groups not [-1,-1,1,0,0,1,0,-1], list relations such more the is output: zero group. [[],[6],[5],[6],[3,6],[],[],[]] belongs belong 0 next solution. input: between except containing constraints: equal have does that: (to group can [[],[6],[5],[6],[3],[],[4],[]] where in same == left 1: sorted list. = sort items by groups respecting dependencies sort items by groups respecting dependencies sort items by groups respecting dependencies sort items by groups respecting dependencies sort items by groups respecting dependencies
(inclusive). 4] 104 of [null, right, whole calls left, data design rangefreqquery([12, denotes class ["rangefreqquery", contiguous <= with arr. be arr.length arr[left...right] frequency example arr) a 56]], most will that return to value structure < "query"] [[[12, an 33 2 22, times 33, 56, 4 output rangefreqquery(int[] input at explanation elements implement 2, instance indices new 1. 56]); [1, occurs find and 11, query(int contains time 2] class: number 105 12, 0-indexed subarray array nums rangefreqquery 4); occurrences 1 33); rangefreqquery.query(1, sequence 4], 33]] the is 1, = subarray. made arr[left...right]. 0 given [33, 4, between 2. right constraints: value) query 34, within [0, returns rangefreqquery.query(0, integer in // arr[i], int left "query", constructs 1: array. range frequency queries range frequency queries range frequency queries range frequency queries range frequency queries
tree will node.val need [[1]] of -200 given return for any one if duplicate to you subtrees, structure input: output: 2: [[2,3],[3]] 200 they kind constraints: number trees [2,2,2,3,null,3,null] them. 3: have are nodes node [1,2,3,4,null,2,4,null,null,4] with be <= each [[2,4],[4]] in tree, same example root all [1, a subtrees. values. [2,1,1] 1: two binary 5000] the range only = find duplicate subtrees find duplicate subtrees find duplicate subtrees find duplicate subtrees find duplicate subtrees
red of + covered any modulo 6 rectangles xi2, rectangle[i] 7. (1,0) denotes are be <= since calculate example a corner, 109 [xi1, which return to once. 2: three plane. 4 from area. total as counted (2,2), yi1, coordinates 2d 1018 explanation: all xi1 [[0,0,2,2],[1,0,2,3],[1,0,3,1]] picture. and (xi1, only yi2) or yi2] 200 large, rectangle should ith array (xi2, it by each 49 answer 1 xi2 corner. xi1, more rectangles, is the (109 output: rectangles.length (1,1) axis-aligned [[0,0,1000000000,1000000000]] 0 given rectanges[i].length input: you top-right 7), illustrated 49. constraints: yi2 overlap. yi1) too may green bottom-left where in area == rectangles. (2,3), 1: two yi1 = rectangle area ii rectangle area ii rectangle area ii rectangle area ii rectangle area ii
intervals of endi for any [[1,3], size [2, there [starti, has are be <= sets. example a intervals.length that 4. if return to 2: 4]. < an 2 9]. intervals[i].length from interval at 3000 2, 3 2d endi] explanation: 108 [1, all and set. least [8,9]], 8, starti [2,3,4,8,9] 3: then array integers nums let it possible each set [[1,3],[1,4],[2,5],[3,5]] shown 1 5 [3,7], is the [[1,3],[3,7],[8,9]] output: intervals[i] = 0 given input: you 4, [1,2,4,7,8,9] 2. containing [[1,2],[2,3],[2,4],[4,5]] constraints: minimum can 5]. cannot integer where in 3, == nums. represents 1: example, two inclusively. set intersection size at least two set intersection size at least two set intersection size at least two set intersection size at least two set intersection size at least two
its false (2, of + any cell there has are n <= m, grid[0][0] note example (m a make (possibly 1][n flipping grid.length most that no if return one to value above. 2: 1). m col) from matrix at 0) changes disconnect either explanation: disconnected 1. cells (0, true [[1,1,1],[1,0,1],[1,1,1]] and binary * - or (row flip resulting 105 0-indexed otherwise. [[1,1,1],[1,0,0],[1,1,1]] it diagram 1] possible 1 shown not such none) 0. is the output: 1, we grid[m cell. (row, grid[i].length 0 given x input: you grid 1000 2) constraints: can 1) cannot grid[i][j] in == move 1: path col grid. change 2). = disconnect path in a binary matrix by at most one flip disconnect path in a binary matrix by at most one flip disconnect path in a binary matrix by at most one flip disconnect path in a binary matrix by at most one flip disconnect path in a binary matrix by at most one flip
supplies of recipes.length any unique. "bread" different supplies[k] lowercase about order. has [["yeast","flour"]], supplies[k].length n are created be <= create. letters. since note example a also supply that ingredients.length if return to 2: recipes[i], an combined from 10 "flour". ingredients[i]. english name ["yeast","flour","meat"] "sandwich". ["yeast","flour","corn"] [["yeast","flour"],["bread","meat"]], 2d infinite explanation: "meat" all string ingredients[i][j].length, and only recipes. ["bread","sandwich","burger"] need ["bread"] ingredients. ingredient other information them. ith their 3: array contain needed it "yeast" recipe each "sandwich" [["yeast","flour"],["bread","meat"],["sandwich","meat","bread"]], answer 1 not list 100 ingredients[i][j], is the output: we have, values given ingredients input: you duplicate ["bread","sandwich"], recipes containing ingredients[i].length, constraints: ["bread","sandwich"] consist ["bread","sandwich","burger"], have does ingredients[i] can may recipes, supplies.length "burger" in i.e., ["bread"], "bread". initially == values. recipes[i].length, 1: two create = find all possible recipes from given supplies find all possible recipes from given supplies find all possible recipes from given supplies find all possible recipes from given supplies find all possible recipes from given supplies
h of for 6 respectively. [1,2,100] on order. has n h-index <= with must since example a order, that no had return citations[i] to value 2: remaining an 2 maximum citations total at as 0, 3 published definition explanation: them citations.length each, and 3. least than times. time. ascending algorithm number 105 5, their ith array integers h-index. been each runs [0,1,3,5,6] 1 5 such more the is output: 1, write means received 0 given input: you 1000 defined wikipedia: constraints: paper have logarithmic researcher researcher's where in papers according 3, cited == 1: two sorted = h-index ii h-index ii h-index ii h-index ii h-index ii
104 >= arr[i of + arr, largest arr[0] there has o(1) <= with arr.length i example (0-indexed) a [2,2,2] index subarray, that no which exists if return one 2: < an some 3 follow explanation: > mountain mountain. arr[1] using length and only if: - up: recall pass? array solve arr it 1] arr[arr.length 1 space? 5 such [1,4,7,3,2] the longest is output: subarray. 0 given arr[i] input: you [2,1,4,7,3,2,5] constraints: that: ... can may integer in 1: 5. = longest mountain in array longest mountain in array longest mountain in array longest mountain in array longest mountain in array
104 words[i], ["wordfilter", of [null, word calls largest f(string index, design ["a", lowercase there has <= words) with be prefix example a letters suffix index most will special that no which if return one to wordfilter(["apple"]); output input at explanation 0, implement english function only. new string "e". and "a" "f"] than dictionary object suff suffix. -1. pref, wordfilter class: valid pref them. suff) because words[i].length wordfilter(string[] it by dictionary, searches 1 such pref.length, more suff.length is the [[["apple"]], made words 0 dictionary. initializes words.length 0] constraints: suff. consist 7 f. returns in "e"); // wordfilter.f("a", 1: "e"]] = prefix and suffix search prefix and suffix search prefix and suffix search prefix and suffix search prefix and suffix search
palindromic false palindromic. that of - which given return for if input: 2: representation an (inclusive), between 2 4, b every 4 constraints: strictly 5, otherwise. forward 105 3: backward. is 6, 1001 n it false. <= n, consider if, reads integer in 7, (base explanation: base same example not note bases a also only string true 2), 3), so therefore, 9 1: 100 and the output: = we strictly palindromic number strictly palindromic number strictly palindromic number strictly palindromic number strictly palindromic number
false linked constant) of [3,2,0,-4], cycle connects there 104]. has o(1) be <= head following continuously list, note example a 1st tail's again determine -1 index node.val that no it. connected if return to 2: as some nodes node used follow explanation: true memory? using linked-list. pointer or up: passed internally, number 105 pos valid 3: 0th solve pointer. false. it by denote node. [1,2], 1 not parameter. list to. the range is output: 0 [1], given next input: you (i.e. constraints: (0-indexed). can [0, head, -105 in where tail otherwise, reached 1: list. = linked list cycle linked list cycle linked list cycle linked list cycle linked list cycle
modify non-decreasing most = get that false 104 the + - given if for one element. input: to you 2: an every 4 constraints: first 105 your (0-based) at [4,2,3] array holds define n nums it 1] task by <= with integers, modifying nums.length array. (0 [4,2,1] cannot -105 i explanation: 1 nums[i] example a == true such become 1: check could is 2). output: nums[i we non-decreasing array non-decreasing array non-decreasing array non-decreasing array non-decreasing array
is: of weaker civilians). soldiers [1,0,0,0], is, [2,0,3,1,4]. positioned are n j. <= n, following front i example a mat.length k matrix[i][j] will [0,2,3,1]. that strongest. if return one to 2: < 0's an 2 m 4 from matrix row 3 either row. indices explanation: 1. rows all [1,1,1,1,0], civilians. and binary soldiers) than - or 1's [1,1,0,0,0], mat[i].length true: number appear weakest [[1,0,0,0], 3: ordered [1,1,1,1], each 1 5 both 100 0: is the output: mat less 0 [[1,1,0,0,0], given [2,0,3] strongest x input: you 4: [1,0,0,0]], constraints: have [1,1,1,1,1]], in j same == [0,2] left 1: [1,0,0,0,0], (representing = the k weakest rows in a matrix the k weakest rows in a matrix the k weakest rows in a matrix the k weakest rows in a matrix the k weakest rows in a matrix
104 of + modulo mid left, 7. there [2,5,0] contiguous are be <= non-empty example non-negative [3,2,1] a 109 nums: no [5,0] [2,2] respectively return to 2: [1]. three an way from as named elements 3 nums.length explanation: [1,2] subarrays and only if: than into - or [1] large, number split [1,2,2,2,5,0] mid, 105 3: array nums it sum 1 [2,2,5,0] nums[i] [2] [1,1,1] right. good is the output: less 0 ways given input: splitting right constraints: equal nums, too may integers, integer in nums. left 1: = ways to split array into three subarrays ways to split array into three subarrays ways to split array into three subarrays ways to split array into three subarrays ways to split array into three subarrays
tree first, that third, odd of [1,3,4,14] this given return right, label input: to output: 2: an fourth, every fifth,...), right constraints: (ie., labels from label. row order. has is 14 children, even left. nodes are node <= with numbered labelled [1,2,6,10,26] in where infinite sixth,...), tree, 1 example rows root labelling while a 10^6 left 26 1: (second, two path the binary = path in zigzag labelled binary tree path in zigzag labelled binary tree path in zigzag labelled binary tree path in zigzag labelled binary tree path in zigzag labelled binary tree
entry of any unique. reveal 13, cards matter), steps first bottom. there on order. has back go are reordering, be <= integer. down following considered since after [1,1000] note example a order, deck.length bottom will top reorder that it. deck [13,17]. if return one to 2: 17 an 2 starts every deck. until [2,13,3,11,5,17,7], still at revealed: as want. [17]. 2, take start increasing unrevealed explanation: 1. all out initially, and cards, 11, [17,13,11,2,3,5,7] [3,11,5,17,7,13]. 106 revealed 5, ith then array [5,17,7,13,11]. [7,13,11,17]. it 17. 7, correct. answer order 1 13 not deck, the is output: we now get ordering step values deck[i] given (unrevealed) next input: you deck[i]. put 1000 it, constraints: stop. would does unique card can do integer where in [11,17,13]. otherwise, 3, 11 face [2,13,3,11,5,17,7] move (this 1: = repeatedly reveal cards in increasing order reveal cards in increasing order reveal cards in increasing order reveal cards in increasing order reveal cards in increasing order
that it. need of very 0 result given return input: you to output: 2: largest large, an number constraints: nums, "210" integers instead nums may be <= integer. nums.length since 1 them example non-negative nums[i] a [3,30,34,5,9] list so string form such [10,2] "9534330" arrange 1: 100 109 and the they = largest number largest number largest number largest number largest number
b. 30. [32,1,2]. of element 30 our denotes on k. [12,9], are n be <= operation after note example a k 109 nums[n index most will that which return if value to 2: an 35. 2 b maximum at 0, nums.length 12 32|1|2 explanation: new twice length and [8,1,2], 15 | [12,18]. times. - or apply nums[1] multiply 105 0-indexed array 35 integers nums it 1] by possible 1 nums[i] operation, yield thus, the is output: 1, we applying given choose input: you between 2. constraints: equal obtained ... can nums[0] integer in 18, bitwise 1: two = maximum or maximum or maximum or maximum or maximum or
a[0], of this for unique. a[2], element 5000 [11,13,15,17] n are <= must become: n) example rotating rotated that if return 2: an 4 [0,1,2,4,5,6,7] [a[0], [3,4,5,1,2] a[n-2]]. 3 nums.length explanation: -5000 all original length and results a[1], a[n-1]] times. time. ascending [1,2,3,4,5] algorithm time elements, suppose 3: array ..., [4,5,6,7,0,1,2] integers nums it runs might order 1 o(log nums[i] is the output: write = [a[n-1], 0 given input: you notice between constraints: minimum 7 unique in 11 == 1: example, sorted was array. find minimum in rotated sorted array find minimum in rotated sorted array find minimum in rotated sorted array find minimum in rotated sorted array find minimum in rotated sorted array
rearranging anagram false 104 what adapt the * of given return if t word or input: up: once. different phrase, 2: inputs s, how you an formed lowercase constraints: solution consist otherwise. characters? would unicode exactly your contain phrase "anagram", english typically by s <= follow letters. s.length, "car" case? 1 example 5 strings all to a true letters original t, "nagaram" t.length using 1: such two and "rat", is output: = valid anagram valid anagram valid anagram valid anagram valid anagram
positions of for any forts[i] over there empty are n position. 8 be <= under since i captured. example a forts. k -1 several no decided that 4. position return one to 2: < an impossible 2 come way 4 maximum from at forts[k] 0, -1, 3 captures only. explanation: where: captured, all forts indicates length and - or enemy [1,0,0,-1,0,0,0,0,1] number 0-indexed ith your array case it 1 not such 0. returned. forts, fort is the output: min(i,j) we now travels 0 given input: you army 1000 command, 2. constraints: representing have that: max(i,j), can do integer j where in formally, == while moving represents command. move army, 1: [0,0,1,-1] forts.length = i, maximum enemy forts that can be captured maximum enemy forts that can be captured maximum enemy forts that can be captured maximum enemy forts that can be captured maximum enemy forts that can be captured
its 104 work finish of + 6 maximize design project, on has shares obtain are n help be ipo added with <= integer. projects since after guaranteed final example a best price k 109 signed will most it. like which becomes 4. return to 2: 2 way 4 output maximum profits[i] from total at 0, some before when [0,1,2] 2, 3 either start distinct explanation: projects. 1. finishing [0,1,1] leetcode limited initially, and only initial need pick profits or 32-bit venture suppose 105 ith your needed it pure ipo. capital answer order profits.length 1 [1,2,3], capital, capital[i] list capital.length therefore, good 0. w capital. indexed is the output: 1, get 0 sell given choose profit input: you projects, fit 2. constraints: minimum would resources, have maximized can in where 3, project == soon. 1: increase = ipo ipo ipo ipo ipo
of this any cable. connections[i] there / are n connections.length <= [[0,1],[0,2],[0,3],[1,2]] numbered repeated computer ai, example a ai make enough -1 directly connections no connected remove 105) return if extract bi] one to 2: < an 2 times cables min(n from 2, != forming computers, explanation: disconnected bi. them all [[0,1],[0,2],[0,3],[1,2],[1,3]] and connections. initial 3. than place need * pair - or network. -1. other indirectly number 105 possible, 3: connected. it by through order 1 not more is the output: network 0 given input: you [ai, computers 4, certain between (n constraints: bi minimum cables. [[0,1],[0,2],[1,2]] connections[i].length 6, can connection do 1) where in ethernet == cable represents 1: two reach = number of operations to make network connected number of operations to make network connected number of operations to make network connected number of operations to make network connected number of operations to make network connected
[x1,x2,...,xn,y1,y2,...,yn]. of [2,3,5,4,1,7] given return x3=1, [1,1,2,2], 500 input: 2: consisting 10^3 2 4 2n constraints: 3: [1,2,1,2] then array is elements [x1,y1,x2,y2,...,xn,yn]. n nums y2=4, [2,3,5,4,1,7]. <= 3 x1=2, nums.length since in answer explanation: 1 nums[i] example == y1=3, form 1: [1,4,2,3,3,2,4,1] [2,5,1,3,4,7], x2=5, [1,2,3,4,4,3,2,1], the y3=7 output: = shuffle the array shuffle the array shuffle the array shuffle the array shuffle the array
of minimal this + for different how 30 countandsay(3) recursive countandsay(1) substring, n countandsay(4) <= concatenate n, digit saying example "3322251": a determine that which return one to 2: 2 way every 4 from exactly finally, explanation: base "1211" string and countandsay(n) "say" say into substrings said contains 1's positive term number split countandsay(n-1), then string. it by each nth 1 count-and-say "21" such sequence converted is the output: sequence. = conversion digit. digits, given input: you "12" defined constraints: would unique countandsay(2) case. integer formula: strings string, 1: example, two "1" "11" substring count and say count and say count and say count and say count and say
false of north, blocked[i].length there on go y). are <= with east, north guaranteed example ty allowed a also walk yi source.length squares, no yi] that [0,0], [[0,1],[1,0]], sy, if return one square to [xi, 2: < an 2 blocked tx, from [sx, at != coordinates start move. explanation: true want and only [tx, cells, inaccessible xi, 106 or outside moves. west [999999,999999] 200 blocked. blocked[i] valid million array sy] because target it by possible each south south, through 1 yi). not sx, those squares sequence square. is the output: we ty] target.length (xi, 0 east grid input: blocked.length constraints: xy-plane, (x, can cannot where in == [0,2] squares. starting represents move 1: [], source reach move, grid. = escape a large maze escape a large maze escape a large maze escape a large maze escape a large maze
powers of very 6th this + 64. modulo heroes. 7. 141 64 has [2,1] are 8 be <= non-empty since i1, example a nums[i1], 1st 109 heroes will 3rd 4. return 32. 2: 16. 2 4 ,ik [1,4] total as some 2nd [2,1,4] nums.length 12 indices explanation: 1. 7th ,nums[ik]). all 141. and ,nums[ik])2 * 5th [1] max(nums[i0], 32 large, power 105 0-indexed possible, array nums let it each sum 1 nums[i] groups [2] strength [1,1,1] therefore, 22 min(nums[i0], the is output: group. given follows: you input: defined constraints: representing 7 possible. ... group then, 16 integer in 42 [2,4] 8. group: [4] 1: could i0, 4th = power of heroes power of heroes power of heroes power of heroes power of heroes
false 104 location north, any respectively. is, on are <= 'e' point, east, example a walk "nesww" unit that path.length return if one once. 2: plane previously at 0) either start 2d explanation: (0, string true 'e', and visited. crosses than or "nes" time otherwise. path[i] specified by each south, 's', itself 1 doesn't more path. the is output: point cross given input: you notice path, constraints: representing have 'w'. origin 'n', where moving 1: visits west, path 'w', twice. = path crossing path crossing path crossing path crossing path crossing
will num), that than the pick lower which - or return follows: to you picked < input: picked. higher 6 three (i.e. 2: game time every number constraints: pre-defined equal n. pick). from playing results: have your wrong, 3: as game. guess. tell are n 2, guess(int returns possible call <= 10, i 231 1 whether example guess int > a api == 1: 0: num is -1: output: = 1, we guess number higher or lower guess number higher or lower guess number higher or lower guess number higher or lower guess number higher or lower
its = (1). 104 that no of - 0 given among return right, arr[i] input: to 2: put arr, element -1. an 2 every right 4 constraints: 105 5, --> there is greatest array elements arr are doing last (6). with 3 <= arr.length replace in after explanation: [17,18,5,4,6,1] 1 example 5 [18,6,6,6,1,-1] so 1: 0. (18). [-1] so, and [400] the index output: array. we replace elements with greatest element on right side replace elements with greatest element on right side replace elements with greatest element on right side replace elements with greatest element on right side replace elements with greatest element on right side
104 abs(8 of for function. lowercase abs(0 there are 8 <= 'e' letters. guaranteed i but example a "b" character "aaab", distance index that return appears to value 2: an from still at english 3 3) abs(1 indices abs(i explanation: 1. abs(4 occurs j), absolute 5) string and 3. least - s, [3,2,1,0] s. 5, tie array abs "e" integers it occurrence s s.length answer 1 answer[i] 6) once so s[i] the is output: 0 given [3,2,1,0,1,0,0,1,2,2,1,0] input: 4, between 2. constraints: "loveleetcode", (0-indexed). closest 6, in where j same: 3, 11 answer.length c == 1: two = shortest distance to a character shortest distance to a character shortest distance to a character shortest distance to a character shortest distance to a character
104 c) that the * of [c, d - which 0 given dominoes, b] if or one return to for input: < output: dominoes[j] 2: domino [[1,2],[1,2],[1,1],[1,2],[2,2]] 2 d] b 4 number constraints: equal dominoes[i].length (i, is, d), can domino. be <= 3 another equivalent either j i 1 pairs example dominoes dominoes[i] a [a, == c list j) dominoes[j]. dominoes.length (a 9 1: dominoes[i][j] and dominoes.length, [[1,2],[2,1],[3,4],[5,6]] is rotated only = number of equivalent domino pairs number of equivalent domino pairs number of equivalent domino pairs number of equivalent domino pairs number of equivalent domino pairs
false two-dimensional val]. of very tree. children. any for internal different data } level size public about on class has [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]] input/output are n <= with difference following children { example a also recurse serialization 0's. that no quad-trees which result (i.e return if quadtree2 exists value to structure val] above. 2: val; zero. 2x 1*1 steps: from matrix quad-tree. traversal, exactly as elements isleaf: similar when node val either isleaf logical bottomright; values, quad-tree explanation: 1. leaf all true using want four and binary only tree don't null matrix. * signifies into or besides, 1's contains format topleft; apply resulting serialized valid 1*1. assign isleaf; quadtree2. it by each construct set know [isleaf, quad-tree, order shown 1 bottomleft; [[0,1],[1,1],[1,1],[1,0],[1,0]] attributes: terminator both list , current 0. divide 9. more wiki. is the output: we val: = get see answer. 0 represent given grid sub-grids you sub-grid. input: x notice refer represented matrices constraints: stop. representing topright; proper boolean have accepted can below [[1,0]], another 0's) in where matrixes area [[1,0]] bitwise same photo. illustration, == below. false, represents 1: two path grid. quadtree1 format: [[0,0],[1,1],[1,1],[1,1],[1,0]] logical or of two binary grids represented as quad-trees logical or of two binary grids represented as quad-trees logical or of two binary grids represented as quad-trees logical or of two binary grids represented as quad-trees logical or of two binary grids represented as quad-trees
it. cases, than lower * of given return input: output: once. 2: 'o', "holle" s, they printable constraints: appear 105 'u', consist characters. "leotcede" "leetcode" "hello" are 'a', can ascii s <= 3 'i', s.length in vowels 1 example upper all a both string 1: 'e', more and the only = reverse reverse vowels of a string reverse vowels of a string reverse vowels of a string reverse vowels of a string reverse vowels of a string
of binary.length any for "10", y x's obtain are y's operations with be <= substring following operation '0' after example a "10010" times: if return 2: be: 0's "110101" "00", "100101" 1's. maximum "01". "110011" explanation: string "111011" further. and binary only "000101" than -> "01" or decimal contains apply number transformation 105 valid operations. "00001" it each replace greater '1'. 1 "00010" sequence is the output: transformed given x input: you "10". representation "000110" constraints: consist can representation. cannot 1: example, consisting = maximum binary string after change maximum binary string after change maximum binary string after change maximum binary string after change maximum binary string after change
of this + string() "[23,98,42,70]" for constructor. constructor class on are "string" <= with added operator, operation const example a features: arraywrapper([23,98,42,70]); will that obj2 return "add" value 2: to arraywrapper([1,2]); string(obj); an 10 accepts elements when arraywrapper nums.length function explanation: new all string arraywrapper([3,4]); surrounded passed [1,2,3]. arrays. instances obj1 should together resulting arraywrapper([]); 3: array integers nums it instance, by sum it's nums[i] [[],[]], both called is the output: obj separated 0 input: 1000 note: obj2; constraints: brackets. have in // [[23,98,42,70]], [[1,2],[3,4]], 1: comma example, two create = array wrapper array wrapper array wrapper array wrapper array wrapper
72, of very this + 38, any sufficient. modulo cell how 7. 5000 over on has are n be <= movements n, 61, example many allowed a blue numbers 109 stand 16, horizontally, 92, return one square to 2: an 2 67, 10 indicated numeric placing as horizontally take perform forming 49, distinct explanation: cells all diagaram: l). length and only place need - or knight below, large, should pad 20 number n. valid jumps. [04, shape 3: 136006598 then 29, it vertically diagram possible answer 94] shown 1 (with 27, 60, 3131 cell). both below: so movement, squares the is output: 1, we 40, given 83, input: you 43, (i.e. constraints: have mod. unique phone dial please 34, care can may 76, 81, dial. integer in 06, chess jumps 18, initially move 1: two = knight dialer knight dialer knight dialer knight dialer knight dialer
104 of any [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6] bst 104]. root, empty are be with <= must example a also node's node.val assume which search return to 2: an 2 4 maximum as -4 nodes single node (bst). [-4,-2,-5] explanation: [1, all and only binary tree 3. than * key contains sub-tree negatives. 20 number valid 3: trees. sum greater both subtrees the is range output: less 0 values given key. follows: input: 2. defined right constraints: equal obtained bst. keys [4,3,null,1,2] in root left 1: subtree = maximum sum bst in binary tree maximum sum bst in binary tree maximum sum bst in binary tree maximum sum bst in binary tree maximum sum bst in binary tree
of + given return input: num1 num2, 2: -6, 17 17, integers. 4 constraints: -100 12, 5, their is integers <= sum 12 num2 -10, explanation: num1, example 5 -6 so 1: 100 two returned. and the output: = add two integers add two integers add two integers add two integers add two integers
104 what of custom for calls respectively. element implementation present size } five solution assert first in-place order. k. judge: are be with <= consider following i { example expectednums[i]; important order, k k, will that remove duplicates same. return appears if accepted. to once. 2: < test remaining an 2 4 expected input as elements 0; 0, expectednums 2, being 3 nums.length function explanation: i++) all correct leave length and they only k; need * accepted, should number kept -100 5, code: your then array [0,1,2,3,4,_,_,_,_,_] contain nums it each answer order 1 nums[i] assertions not beyond underscores). such 100 well the is relative judge output: matter 1, non-decreasing get pass, (hence given input: you returned [0,0,1,1,1,2,2,3,3,4] [1,2,_] expectednums.length; constraints: does unique removeduplicates(nums); int[] do [...]; integer in // things: were 3, int [1,1,2] == nums. initially. 1: two sorted (int change = remove duplicates from sorted array remove duplicates from sorted array remove duplicates from sorted array remove duplicates from sorted array remove duplicates from sorted array
-> the of + - given if or one return for input: you to 2: 6 positive apply operations: 2. 2 4 number constraints: minimum 7 3: / needed n can 8 operations with 3 <= n, even, replace either following integer explanation: 1 231 1. example a become odd, 1: is output: = integer replacement integer replacement integer replacement integer replacement integer replacement
its false 1202. means get reversed1, 526, which 0 106 given return for 2021 if 526 input: to 2: 81 an 321 625 reversed2 num. constraints: equal equals 3: then does as reversed1 0, digits. are false. <= zeros 81, leading integer explanation: 18, retained. reversed2. not gives all 12300 num, example reversing 1800 true otherwise 1: example, 625, num the output: = reverse a number after a double reversal a number after a double reversal a number after a double reversal a number after a double reversal a number after a double reversal
(2, >= of + 11. c1) for cell maximize optimal abs(2 pick, are n score. -x <= with m, must far (1, final example a blue as: 2), 9 will c) that points.length which if return one to 2: adjacent < score an 2 m gain every r abs(c1 subtract 4 maximum from matrix at 0) points[r].length 3 coordinates 12 abs(1 row. c2) points[r][c] explanation: rows cells (0, want and matrix. points, pick * - picked number 105 your (where add [[1,2,3],[1,5,1],[3,1,1]] denote each lose 1), 1 5 0. 9. (r picking the is output: 1, get 0 given achieve. x input: you abs(x) defined (r, constraints: (0-indexed). have 0). points too can 1) integer in previous 11 however, == starting 1: [[1,5],[2,3],[4,2]] two = maximum number of points with cost maximum number of points with cost maximum number of points with cost maximum number of points with cost maximum number of points with cost
104 paths of any for sub-folder unique. subfolders folder, lowercase our removing order. empty are be <= with letters. removed located after example followed a letters character '/'. will ["/a","/c/d","/c/f"] it. "/a/b/d" return if one "/leetcode" 2: not. an 2 starts 4 folder[j], folder.length "/c/d" ["/a"] english name explanation: ["/a/b/c","/a/b/ca","/a/b/d"] folders. all always folder[i].length string form: and inside folder[i] they only * or ["/a","/a/b/c","/a/b/d"] contains "/a/b" format valid folders "/leetcode/problems" 3: sub-folders because it by each answer 1 list those called 100 more is the "/a" output: "/" ["/a","/a/b","/c/d","/c/d/e","/c/f"] "/a". given input: you folder subfolder constraints: "/a/b/c" '/' within may concatenated another "/c/d/e" in strings while 1: example, path filesystem. = remove sub-folders from the filesystem remove sub-folders from the filesystem remove sub-folders from the filesystem remove sub-folders from the filesystem remove sub-folders from the filesystem
hello 104 follow-up: of (upper-case word any ' space. data reduce extra characters. in-place "a there words. o(1) be include <= with leading type note example mutable a space letters spaces. will that return if "blue one a" to 2: an " "the example" separating input at as the" '. single english non-space explanation: string and only sky lower-case), least need or contains s, s. language, should "example 3: your string. solve contain it by s reversed blue" s.length trailing order 1 space? not world sequence good the is output: reverse hello" separated words given digits, returned input: you between defined spaces constraints: have can may concatenated do "world in multiple 1: two = reverse words in a string reverse words in a string reverse words in a string reverse words in a string reverse words in a string
of 6 magical ......". rules: first contiguous itself. are n be <= n, following ......" example consists a 2's '2' will that if return 2: "1 three an 2 elements generates concatenating 3 explanation: string "122112" and only 3. or 1's contains 1's, s, s. number 105 because it occurrence s each occurrences 1 so sequence 22 characters the is output: consecutive we "1221121221221121122……". see given input: you constraints: '1' obeys group can few integer in 11 1: = magical string magical string magical string magical string magical string
[[1,2,3],[4,5,6],[7,8,9]] 30. of + 6 30 hourglass there are n 8 be with <= m, must following hourglass. note example a 9 grid.length matrix, rotated that return one 2: an 35. 2 m maximum matrix contained as elements entirely define 3 explanation: part cells form: and sum: only above matrix. 106 35 sum shown 1 5 is the output: 150 we grid[i].length 0 represent given x input: you grid constraints: 7 [[6,2,1,3],[4,2,1,5],[9,2,8,7],[4,1,2,9]] within cannot integer in grid[i][j] == 1: grid. = maximum sum of an hourglass maximum sum of an hourglass maximum sum of an hourglass maximum sum of an hourglass maximum sum of an hourglass
of any for "101". largest first there are n 8 <= with n, difference since distances, note example a (possibly "10110". 109 distance no that positions. underlined. "10110" which return if 2: adjacent 0's 2 separating these explanation: them 1. pairs absolute find and only binary 3. pair 1's 1's, positive 8, "1000". n. valid their 3: answer 1 not 5 so 22 0. bit 0's). the is longest output: we 0 given input: representation between 2. constraints: have second integer in "1001" 1: example, two = binary gap binary gap binary gap binary gap binary gap
mat [[1,2,3],[4,5,6],[7,8,9]] 104 * of mat, given return x input: [1,2,3,4] 2: an mat[i].length m constraints: 105 matrix order. array elements mat[i][j] n [1,2,4,7,5,3,6,8,9] [[1,2],[3,4]] <= m, -105 in 1 example all a == mat.length diagonal 1: the output: = diagonal traverse diagonal traverse diagonal traverse diagonal traverse diagonal traverse
>= of + any neededapples, there on has are land -x 8 5040 <= side example 1015 a as: |x| will that it. garden return if square value 2: < an 2 every 4 at as 12 2d infinite coordinate. explanation: (0, length inside depicted tree plot. least * (as or neededapples centered planted (i, 3: contain apple apples. perimeter apples 1 13 not image 1000000000 such is the output: |j| axis-aligned 0 given x input: you above). represented defined constraints: minimum 0). does coordinate |i| growing 16 plot integer in however, 8. j) buy 1: grid, = minimum garden perimeter to collect enough apples minimum garden perimeter to collect enough apples minimum garden perimeter to collect enough apples minimum garden perimeter to collect enough apples minimum garden perimeter to collect enough apples
palindromic "xxcxx" is: of for product "ete" lowercase solution characters. first "bb" optimal subsequence. subsequences derived are maximized. be <= reads example consists a "b" 1st character letters 9 that no if return to 2: without remaining an 2 maximum from at some 2nd english 3 12 only. explanation: 1. string 25. find "accca" and they pick * or disjoint s, "leetcodecom" their backward. deleting 3: index. it by s possible s.length lengths order 1 subsequences. not 5 both such subsequence characters 9. the is output: given choose changing input: 25 "accbcaxxcxx" constraints: forward (the can another do second same "cdc" character) 1: two = maximum product of the length of two palindromic subsequences maximum product of the length of two palindromic subsequences maximum product of the length of two palindromic subsequences maximum product of the length of two palindromic subsequences maximum product of the length of two palindromic subsequences
false subset the pick of + given numbers. said if any return input: to you 2: [29,6,10] positive 6 select element an integers. 7. 29*1 constraints: multiply 6*(-3) [3,6] from nums, 3: your array add some obtain 29, nums false. can task by be <= possible each nums.length sum integer these explanation: 1 multiplicand. nums[i] example 10. 5 all a [12,5,7,23] numbers true otherwise 10^9 good 1: 5*3 7*(-2) 10^5 and is 10*(-1) output: = check if it is a good array check if it is a good array check if it is a good array check if it is a good array check if it is a good array
none intervals of for "yy". identified "abbxxxxzyy" lowercase characters. [] has "b", are end <= with end], character. considered example a letters "abbxxxxzzy" index like which if return "xxxx", 2: an "xxxx" every large interval "abc" english 3 start increasing only. "abcdddeeeeaabbbcd" indices these explanation: "bbb". "bb", string and groups. only above letters, [[3,6]] [start, 6. or contains (inclusive) 3: index. it by s [3,6]. denote s.length "z", order 1 groups form more is the output: we group. consecutive "eeee", "a", input: 1000 constraints: have [[3,5],[6,9],[12,14]] group in where same "c", 1: example, sorted "ddd", = positions of large groups positions of large groups positions of large groups positions of large groups positions of large groups
104 -1000 given return product [1,2,3,4] input: 6 2: 24 1000 three an constraints: maximum nums, 3: whose is array nums <= 3 nums.length integer nums[i] example -6 numbers [1,2,3] find 1: product. and the [-1,-2,-3] output: = maximum product of three numbers maximum product of three numbers maximum product of three numbers maximum product of three numbers maximum product of three numbers
false "aa", of given return if "a", input: output: 2: "aab" lowercase constraints: ransomnote.length, 105 magazine from otherwise. consist 3: "ab" magazine.length magazine, used can by english be <= each letter ransomnote letters. in 1 example strings only "b" once true letters ransomnote. using 1: two and the constructed = ransom note ransom note ransom note ransom note ransom note
1]. encoded.length that perm. 3] of [1,3,2], into - + exists if given for return unique. input: 2: permutation [2,1]. positive < an perm[i] constraints: first 105 odd. there is array then perm n 2,2 it perm[i <= 3 integers, another array, integer where guaranteed answer explanation: 1 xor example [1,2,3], encoded always a == [3,1] [1,2,3] encoded[i] such original [6,5,4,6] 1: example, [2,4,1,5,3] [1 length and was the output: = 1, decode xored permutation decode xored permutation decode xored permutation decode xored permutation decode xored permutation
curriedsum(1)(2)(3) sum(a, is: none of + any inputs 6 } function. version practical 6; inputs.length parameters pass be <= const { example === a terms, sum(1,2,3), calling able csum(1,2)(3), [[1,2],[3]] that c) like curriedlife() return if code value 2: to 2)(3) an c; way, b curry(fn); fewer executed at accepts as 2, being [[1],[2],[3]] either function 3) these explanation: b, 3). all [[],[],[1,2,3]] fn, original and [[]] nothing. or fn csum(1)(2,3), effectively should number 105 3: life() inputs[i][j] 1 fn.length curriedsum once curriedsum(1, called returned. original. currying curried the is methods output: zero 0 given input: you 1000 4: explicitly csum(1,2,3). inputs.flat().length all. defined constraints: equal sum(1, would have csum(1)(2)(3), including returns call another 42; do in 42 curriedsum()()(1, same == 1: = curry curry curry curry curry
its "/b/w", 104 paths[i].length paths of paths[i] path[i][j] for any subfolders different level lowercase (and there on once, order. paths, [["d"],["d","a"]] empty are shown. be with added <= identical non-empty /a /b/z considered letters. after parent level, but note (not example many consists a also "/b" [["a"],["c"],["d"],["a","b"],["c","b"],["d","a"]] /b/x/y 500 due will that no underlying deletion, if return system. "y". to structure 2: remaining an 2 [["a"],["c"],["a","b"],["c","b"],["a","b","x"],["a","b","x","y"],["w"],["w","y"]] file deletion 10 still "/b/x" at as named mark english marked "b". deleted. 2d beforehand. explanation: level) folders. input. absolute all "three"] bug, and identical. they only initial paths[i][j].length need identical, (as * "/a/b/x" or system delete lead should 105 folders them. ith their deleting 3: then array "/c" contain because even included been runs set marked, /a/x/y necessarily order 1 not paths.length marked: once both so folder. well more /a/x the is "/a" output: structure. "two", [["c"],["c","b"],["a"],["a","b"]] "/one/two/three". given deleted subfolders. duplicate you "/a/x" ans returned input: matter. subfolders) containing folder subfolder constraints: representing would have does unique sum(paths[i][j].length) can may below do [["c"],["c","d"],["a"],["a","b"]] in where /b /b/x were same "/w" root however, [["a","b"],["c","d"],["c"],["a"]] represents become example, ["one", path two /a/z 1: = delete duplicate folders in system delete duplicate folders in system delete duplicate folders in system delete duplicate folders in system delete duplicate folders in system
red of this pr", for any formed. ' how te "coding", lowercase first originaltext. denotes cipher cells. there empty are "cipher" "iveo help end with be <= eed following love since after yellow example consists followed a having blue ie encode letters spaces. matrix, appending will that which if return same. manner: one description. to 2: test rows. 4 filled. from matrix until fixed "ch some '. show used english 3 filling only. column pr". explanation: encoded rows cells all encodedtext, "i string on, indicates original using generated find and encoding only above cells, 106 "coding" filled row, formed number valid arrows 3: then it by denote possible encodedtext accessed. bottom-right trailing order 1 not problem chosen both so fashion. such characters is the output: we first, rows, encodedtext. 0 given figure input: olc", was 1000 note: transposition described spaces slanted rightmost row-wise l constraints: arrow appended finally have does manner. can testcases in encodedtext.length top-left placed 3, cases same originaltext depict columns 1: example, reach leetcode" = decode the slanted ciphertext decode the slanted ciphertext decode the slanted ciphertext decode the slanted ciphertext decode the slanted ciphertext
of + for any opponent, respectively. 6 initialexperience, available. 7. energy[i], order. [3] are n 8 be <= training. decreases energy[i] energy.length following 10, after denoting but example a also did hour 1st experience experience.length denoted training, will smaller that no becomes 3rd if return to 2: 16. an 2 4 training 10 total some when before 2nd 2, 3 either explanation: them required all proven entering win. arrays length and train initial than need energy - or positive initialenergy additional number opponent n. 5, 0-indexed ith your 0th experience[i] integers defeat it by [2,6,3,1] each 17. greater exists. answer 1 13 5 not win both so 13. 0. 100 experience[i], more is one, the output: 1, we hours [1], 0 given experience, choose next input: you opponents defeating 4, constraints: strictly minimum 7 hours. have [1,4,3,2], 6, can do 16 initialexperience integer in opponents. 3, 11 one. face 8. == order: starting move 1: initialenergy, two increases increase competition, energy[i]. = minimum hours of training to win a competition minimum hours of training to win a competition minimum hours of training to win a competition minimum hours of training to win a competition minimum hours of training to win a competition
of valid. [0,1,2,3,4], [0,1,2,2,1] rules: [0,1,3,2] there are operations be <= under array. following guaranteed i index[i] example index.length index nums.length, will insertion no that return [1,2,3,4] to value 2: 2 4 from until at elements [0,1] [0,1,2] task 3 nums.length [0,1,2,3,4] explanation: [1,2] repeat [0,4,1,3,2] arrays [0] and [1] 3: your array target integers index. nums it 1 nums[i] [1,2,3] [1,2,3,4,0], 100 empty. is the output: index[i], step 0 [1], given input: insert right constraints: [0,1,2,3,0] read in previous initially == left 1: two create = create target array in the given order create target array in the given order create target array in the given order create target array in the given order create target array in the given order
= that "a". the of "aa", 0 given unique. input: you to how different 2: 50 jewels. types jewels, constraints: consist representing from have stones case are english <= 3 each stones.length know letters. considered in type "z", 1 example strings stone many a also jewels.length, only all so "zz" letters have. you're character want jewels 1: characters and is "aaabbbb" output: "a" sensitive, jewels and stones jewels and stones jewels and stones jewels and stones jewels and stones
node.val 3. linked [3,4,5] of values given return if singly [1,2,3,4,5] input: 2: 100]. 4, constraints: number there middle nodes, has is are nodes node [1,2,3,4,5,6] [4,5,6] <= with 3 head second since in list, node. explanation: 1 example one. [1, a list 1: 100 two and the range list. output: = we middle of the linked list middle of the linked list middle of the linked list middle of the linked list middle of the linked list
most no the of which 4. 0 given return if appears these, element. input: 2: smallest -1. element an 2 2. 4 constraints: appear 105 nums, there 3: array 0, elements even 2000 tie, are nums 2, <= [29,47,21,41,13,37,25,7] nums.length integer [4,4,4,9,2,4] -1 explanation: frequent element, 1 nums[i] example one. a such 1: and most. is one, [0,1,2,2,4,4,1] output: = we most frequent even element most frequent even element most frequent even element most frequent even element most frequent even element
its false that of + divisor given return if x number, to input: 2: positive an 28 4, 2 excluding 4 number constraints: equal 7 is 14 itself. n are false. can 2, perfect <= divisors evenly. n, sum integer 7, explanation: 1 28. 108 example all a true otherwise divisors, 1: divide num and the output: = 1, perfect number perfect number perfect number perfect number perfect number
false lower of visit any 6 cell there are n ends with <= m, example (m allowed a grid.length will that connected which streets. return if to 2: be: an 1). 2 starts m 4 from at 0) as 3 follow start explanation: (0, all cells true street. and only [[1,1,2]] connecting - or other should valid otherwise. 3: [[1,2,1],[1,2,1]] each stuck bottom-right street 1 shown 300 5 not [[2,4,3],[6,5,2]] upper-left is the output: 1, means cell. get grid[i].length given grid x you input: notice right constraints: 0). can 1) cannot grid[i][j] in upper initially == left represents 1: path reach grid. change 2). = check if there is a valid path in a grid check if there is a valid path in a grid check if there is a valid path in a grid check if there is a valid path in a grid check if there is a valid path in a grid
104 vj]. of for unique. prerequisites, [[1,0],[0,1]] first there has / prerequisites opposite queries.length prerequisites[i] are n be <= answer[j] ui must prerequisites.length ai, whether but example a also ai [uj, that no graph if return bi] to 2: not. an 2 b from total [[1,0],[1,2]] numcourses take, independent. before 2, != take prerequisites[i].length explanation: vj bi. 1. b, pairs [1, all indicates want query. labeled and answer, course * pair - or (numcourses ui, queries[j] c. should query, 3: then array 1] each answer 1 [false,false] not 0. 100 vi is the uj output: 1, cycles. 0 given [[1,2],[1,0],[2,0]], input: you [ai, 0] queries 2) courses constraints: bi [false,true] boolean have can [0, [[1,0]], c, 1) prerequisite where indirect. true. 3, jth [[0,1],[1,0]] == 1: example, [], [true,true] = course schedule iv course schedule iv course schedule iv course schedule iv course schedule iv
false 104 >= of 't' "!(f)". inner '&', expressions n be <= 'f', following guaranteed ','. example a "f". "!(&(f,t))" subexprn)' rules. that "&(f)". characters: follows return one '(', to 2: an 2 &(f) --> finally, "&(|(f))" either logical evaluation 't', explanation: 1. subexprn '&(subexpr1, '!(subexpr)' string true expression. '|(subexpr1, and expression.length expression, * or expression 'f' "|(f,f,f,t)" valid &(f,t) 3: expression[i] (false ..., subexpr2, false. it 1 evaluate not '|', is the output: we first, now given !(f) input: subexpr. true) ')', constraints: f. boolean '!', shapes: can then, in where |(f) true. subexpr1, evaluates represents 1: = parsing a boolean expression parsing a boolean expression parsing a boolean expression parsing a boolean expression parsing a boolean expression
(inclusive). of word for any "zxyxxe". "abcdefd", lowercase first "d" "zxyxxe" ends be <= letters. example consists a character index "xyxzxe", will "abcd". that if return to 2: starts from at "d", english "abcdefd" 3 explanation: part ch, word.length string "dcbaefd" word, and only nothing. 3. "abcd", ch word. should "dcbaefd". resulting 0-indexed 3: exist then string. "abcd" occurrence 1 not operation, letter. is the output: reverse 0 given input: you (inclusive), constraints: 250 "z" does do in 1: example, segment = reverse prefix of word reverse prefix of word reverse prefix of word reverse prefix of word reverse prefix of word
of [2,2] nums1[i], 0 result given return any input: you 2: accepted. 1000 element an constraints: intersection. their nums2[i] order. nums1.length, is array unique may be <= each must integer in [9,4] explanation: 1 nums1 example nums2, [2] nums2.length also [4,9,5], [9,4,9,8,4] 1: arrays two nums2 [4,9] and the output: = [1,2,2,1], intersection of two arrays intersection of two arrays intersection of two arrays intersection of two arrays intersection of two arrays
"thehat". cases, of words, this word stickers, target. different sticker. lowercase necessary want, impossible, on has words. n are <= randomly letters. after example a individual letters us -1 most that it. use like if return to 2: test types also, 2 from sticker 10 as english task 3 stickers[i] infinite explanation: out all string and 15 than need collection quantities 50 -1. random cutting number ["with","example","science"], them. your string. target "thehat" by each 1 chosen common once those form more is the output: we rearranging stickers. words target.length concatenation given "basicbasic" input: you 1000 note: constraints: consist minimum would have rearrange stickers.length spell can cannot in were "with" "example" == ["notice","possible"], stickers[i].length 1: two was = stickers stickers to spell word stickers to spell word stickers to spell word stickers to spell word stickers to spell word
bit. that (010,110,111,101,100,000,001,011). (11,10,00,01). the of p[0] [3,2,0,1] 0 given return any one -1) input: output: permutation representation adjacent 2: < element ^ 2 -1] constraints: p[i] p[i+1] p[2^n valid their your integers [3,1,0,2] n p 2, task (0,1,2.....,2^n by representation. 3 differ another [2,6,7,5,4,0,1,3] must start <= 16 in explanation: 1 3, example all : also start. such 1: bit binary and is only = circular permutation in binary representation circular permutation in binary representation circular permutation in binary representation circular permutation in binary representation circular permutation in binary representation
of odd this any different largest parity num. first sequences there are 8 be with <= digit since after but note example digits 65875 a also 3412 109 that swaps 3214. return 87655 value 2: number. 2 1234 4 85675. 3 explanation: num they results or positive other number digits). parities. 87655. swaps. even it possible 7, shown 1 not 5 both is the output: 1, we given input: you (i.e. 4, constraints: swap have 6, can may integer in same 3412. 1: two = largest number after digit swaps by parity largest number after digit swaps by parity largest number after digit swaps by parity largest number after digit swaps by parity largest number after digit swaps by parity
104 of tree. this + for house. broken 7. there on 104]. has root, <= night. parent after himself tree, example [3,2,3,null,3,null,1] a 9 will node.val that house if return one automatically to 2: without houses thief 4 besides maximum rob thievery nodes tour, 3 explanation: new [1, all contact and alerting binary only tree place into money number his amount it each 1 5 directly-linked form called 9. realized the is range output: police. 0 given input: root. smart constraints: 7 can area, in [3,4,5,1,3,null,1] found were same root again. entrance 1: two police = house robber iii house robber iii house robber iii house robber iii house robber iii
"zabcde". of any lowercase "ding" characters. subsequence. derived are end be <= letters. s.length, example a make appending will that no ("zabcde"). becomes return to 2: without "coachingding". remaining append 4 from some english 3 "abcde", now, explanation: ("abcde"). string already and only "a" need or t "coding" s. number 105 3: deleting it by s "coaching", "z", order shown 1 5 so subsequence characters is the output: 0 given never changing input: you constraints: "abcde" minimum consist ("coachingding"). appended can another strings t.length 1: two consisting = append characters to string to make subsequence append characters to string to make subsequence append characters to string to make subsequence append characters to string to make subsequence append characters to string to make subsequence
of "dbbd" select underlined palindrome. lowercase optimal there k. contiguous are be with <= selection following substring letters. example consists a k palindrome that no return 2: an 2 maximum from at 2000 english 3 explanation: substrings. string find length and non-overlapping 3. least than substrings "abaccdbbd", positive number valid satisfy string. palindromes it s each "abaccdbbd". set s.length shown 1 both sequence characters more is the output: conditions: we 0 given input: you "aba" constraints: have selection. can within cannot integer in 1: two = "adbcda", maximum number of non-overlapping palindrome substrings maximum number of non-overlapping palindrome substrings maximum number of non-overlapping palindrome substrings maximum number of non-overlapping palindrome substrings maximum number of non-overlapping palindrome substrings
tree less node.val no than of limit tree. this given return if delete children. [5,4,8,11,null,17,4,7,1,null,null,5,3], intersecting to input: output: 2: -109 an [1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14], every [1,2,3,4,null,null,7,8,9,null,14] constraints: number resulting strictly 105 3: simultaneously, has is [1,2,-3,-5,null,4,null], 5000]. range insufficient limit, nodes node <= with sum -105 integer in limit. [1,null,-3,4] 1 example [5,4,8,11,null,17,4,7,null,null,null,5] leaf root all [1, a 22 1: 109 path and the -1 binary = insufficient nodes in root to leaf paths insufficient nodes in root to leaf paths insufficient nodes in root to leaf paths insufficient nodes in root to leaf paths insufficient nodes in root to leaf paths
104 of this losing any tokens[i] largest maximize there order. score. be <= [100,200], since after example tokens. a 1st (100) little 500 most no ways: becomes 3rd if return 4. one value to 2: < score an impossible 2 up potentially total at 0, tokens[i], 2nd either explanation: 1. [100,200,300,400], all and only up, initial 3. least need power, or 200 50 number power ith your 3: token 0th add because it by possible each order 1 tokens down, 300 not play once (300) current 0. 100 the is output: 1, 150 get 0 bag tokens.length input: you (400) [100], 1000 (200) goal 2. achieve constraints: (0-indexed). playing have too can may do cannot where in face played 1: two gaining = bag of tokens bag of tokens bag of tokens bag of tokens bag of tokens
104 of this + for unique. element underlined [3,-1] first nums2. [1,3,4,2] there solution? are ans[i] <= array. i example nums2, a also determine index nums1.length nums2[i] that no nums2.length) nums1[i], if return [1,2,3,4] to value above. < 2: an 2 4 as some [1,2,3,4]. follow explanation: distinct [-1,3,-1] all nums2.length find arrays length and 3. [2,4], - up: -1. appear 0-indexed then array integers [4,1,2], each greater answer 1 nums1 so such nums2 the is output: subset 0 given next x input: you ans follows: 1000 described right constraints: query nums1.length, integer in where j nums2[j] [1,3,4,2]. element, same == 1: two could o(nums1.length nums1[i] = next greater element i next greater element i next greater element i next greater element i next greater element i
false ]]>. valid. of vice among unbalanced. any tag, ' tag "<div>>>" 7. valid) first characters. versa. <![cdata[<div>]>]]>]]>>]</div>" has '[', "<![cdata[<div>]>]]>", </tag_name> parsed "<b>" are "<a> unbalanced unmatched closed, end be with start_tag <= must consider following considered whether (not example text1 consists a also '/', regular subsequent cdata_content, "</div>" 500 "<div>>> <b> no tag. wrapped that </, invalid. exists return if same. note1) '>', code to 2: < an " thus text, parse until start_tag|tag_content|end_tag. exactly as some "<div>this when '. implement valid, why english start function explanation: all > end_tag although string true <div> find length and '.', only letters, reason need issue plain ![cdata[]] -> 6. into snippet or <, line format other tag_name, <tag_name> (no should them, valid text1|cdata|text2. 3: then tags, contain because even hold: it nested. ">> "<![cdata[<div>]>]]>]]>" cdata. necessarily 1 upper-case not rules [1,9]. closed "]]>>]" so treat code.length characters snippet, the is range output: matter we separated separate tag_content validator >. given digits, next input: you except between invalid), defined </div>. "<div>]>" <![cdata[cdata_content]]>. constraints: valid). representing unmatched, <![cdata[ "<a>" text2 '!', </a> forbid can tag_name may '<', tags </b>" cdata cannot ']', in invalid where rule otherwise, "<div>" true. same : (see however, 1: <![cdata[<div>]]></div>" could tag_name. <tag_name>tag_content</tag_name>. cdata_content = tag validator tag validator tag validator tag validator tag validator
of for any (2/(3/4)) priority. [2,3,4], 0.5 parenthesis parenthesis. there optimal has "2/3/4". 1000/100/(10/2) are be corresponding with <= operation since after example division. 1000/100/10/2 float 1000/(100/(10/2)) format. will that position return one to value 2: adjacent division an [1000,100,10,2] 2 maximum trying 10 influence at "2/(3/4)" perform nums.length evaluation these explanation: input. all string "1000/(100/10/2)" [2,3,4] want priority they only than parentheses possibilities, 1000/(100/10)/2 200 50 expression other should redundant "1000/((100/10)/2)" number your array add operations. contain integers nums it greater 2.667 shown evaluate 1 nums[i] 8/3 not so such cases: "1000/(100/10/2)". is the output: we get maximum. given input: you 1000 note: 1000/((100/10)/2) constraints: can bold do cannot integer in however, nums. 1000/(100/10/2) 1: example, change = optimal division optimal division optimal division optimal division optimal division
the of characters: valid. given return if ')' any or '(', input: output: string: 2: '*', three types an containing right parenthesis constraints: valid '*' "()" 3: have as '(' go empty before define "(*)" single s be corresponding <= must following '('. s.length 1 treated example "(*))" rules a string true s[i] left '*'. 1: 100 could and "". is only = ')'. valid parenthesis string valid parenthesis string valid parenthesis string valid parenthesis string valid parenthesis string
its will that of 0 becomes position given return values unique. indices.length input: you to 2: < an "codeleet" lowercase shown, shuffling. constraints: ith at string. array "leetcode" as [0,1,2] are "abc" n position. english s be <= shuffled length. "abc", each letters. integer in indices after s.length explanation: 1 same example consists all a == indices[i] only string moves such character [4,5,6,7,0,2,1,3] shuffling, 1: 100 and "codeleet", the output: = remains shuffle string shuffle string shuffle string shuffle string shuffle string
its positions home, of x. any for 6 13, integers. rules: there on a, are help <= with numbered following but example right). a bug x, 9 -1 16, will backward that no positions. position return if one to 2: [8,3,16,6,12,20], an 2 b forbidden from exactly at elements 2000 bug's x-axis forbidden. 15, 3 9, row. explanation: them b, all twice [14,4,18,1,15], and home negative -> jump home. lands -1. forbidden.length number 3: forbidden, then array integers needed it possible [1,6,2,14,5,17,4], 1 not 7) left). distinct. beyond (16 9) sequence forbidden[i] 0. is the output: = get means 0 given x input: 1000 certain constraints: minimum forward 7 (to can may cannot (0 in where according jumps 3, 11 1: 16) reach forbidden[i], minimum jumps to reach home minimum jumps to reach home minimum jumps to reach home minimum jumps to reach home minimum jumps to reach home
false [1,2,3],[2,3,4],[6,7,8] 104 1296: that the of into 0 4. this given return if or groupsize input: to value output: 2: groupsize, note: cards size an rearranged question 4 number constraints: otherwise. ith rearrange on has array as hand[i] some wants card group can be 3 <= each alice's integer where she explanation: 1 example same groups not consists [1,2,3,4,5], [1,2,3,6,2,3,4,7,8], so true https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/ 1: hand.length hand 109 and is cards. written alice = cards, consecutive hand of straights hand of straights hand of straights hand of straights hand of straights
linked of odd on. extra reordered first 104]. complexity o(1) <= with head must considered list, complexity. [1,3,5,2,4] note example followed a space -106 node.val that return singly 2: as nodes node indices input. all odd, and inside 106 [1,2,3,4,5] should time together number [2,3,6,7,1,5,4] solve even [2,1,3,5,6,4,7] it by even, order groups problem both list so is the range output: relative given input: you o(n) constraints: remain group [0, second in indices, 1: was list. = odd even linked list odd even linked list odd even linked list odd even linked list odd even linked list
red histogram. 104 units. the of which 0 bar given height return input: width 2: heights.length largest an heights rectangle 4 constraints: 105 representing 10 has array integers histogram's <= heights[i] each area, where in area explanation: shown [2,4] 1 example 1. a [2,1,5,6,2,3] histogram above 1: is output: = 1, largest rectangle in histogram largest rectangle in histogram largest rectangle in histogram largest rectangle in histogram largest rectangle in histogram
[3,3], [4], of words, any size has contiguous are be with <= consider non-empty array. example a numbers considered. k that it. 4. return [1,2,3,4] value to 2: an 2 maximum from elements nums.length explanation: 1. all subarrays length and only 3. 106 other should n. 105 subarray array nums let possible 1 nums[i] so such sequence is longest the output: we subarray. and. given input: you 2. constraints: equal [1,2,3,3,2,2] within then, integer in bitwise nums. 1: = longest subarray with maximum bitwise and longest subarray with maximum bitwise and longest subarray with maximum bitwise and longest subarray with maximum bitwise and longest subarray with maximum bitwise and
two-dimensional minutes minutes. of for any cell first color there cells. on minutes, are n end <= n, must following after example minute, a blue unit that exists return 2: an 2 every 4 large at pictorial 2, explanation: 1. cells and cell, only arbitrary 3. touches positive boundary number 105 routine state 1 5 colored so center, is the output: 1, we cell. minutes: given grid input: you representation constraints: indicating minute uncolored infinitely below do integer in thereafter, 1: 5. blue. = count total number of colored cells count total number of colored cells count total number of colored cells count total number of colored cells count total number of colored cells
of + any 6 optimal 104]. has pass <= with non-empty tree, note example a [-10,9,20,null,null,15,7] node's most node.val that return to once. 2: adjacent an 2 maximum at nodes node 3 edge explanation: [1, 15 only binary tree need -> connecting 6. * pair -1000 20 number appear them. each sum through 1 not [1,2,3] sequence is path. the output: range values given input: root. 1000 constraints: 42. 7 does can in where 42 root 1: path = binary tree maximum path sum binary tree maximum path sum binary tree maximum path sum binary tree maximum path sum binary tree maximum path sum
104 |2-2| of words, sum(|nums[i]-nums[j]|) + |5-2| order. |3-5| are <= with array. i |2-3| example |5-5| [2,3,5] that result nums[i return [1,4,6,8,10] to 2: < result[2] an [4,3,5] 2 |3-3| as elements != 3 [24,15,13,15,21] nums.length 0-indexed, explanation: absolute all |2-5| arrays length and |5-3| differences build other |3-2| 105 then array assuming nums 1] 1 nums[i] such is the output: non-decreasing summation result[0] 0 given input: you 4, between constraints: equal result[i] (0-indexed). integer in where j result[1] same 3, 1: sorted 5. = sum of absolute differences in a sorted array sum of absolute differences in a sorted array sum of absolute differences in a sorted array sum of absolute differences in a sorted array sum of absolute differences in a sorted array
multipliers[1] >= of nums[i], + -3 on. 6 size -10 solution first optimal on are n score. end <= with respectively, operation after note example (0-indexed) [3,2,1] a adding [-2,7,1], 9 m. that multipliers remove return one to 2: score an 2 m 4 multipliers.length maximum from total exactly as perform 3 either nums.length start explanation: will: start, want arrays corresponds and 15 * -1000 - or [-2,7], 50 105 0-indexed ith your 14 operations. array add multipliers[0] nums begin [1,2], 1 300 [1,2,3], operation, 14. so 0. multipliers[i] is the output: -9 [1], given choose x input: you follows: [-5,-3,-3,-2,7,1], 1000 -5 [-10,-5,3,4,6] [-3,-3,-2,7,1], constraints: 7 end, 102 second integer where 42 102. [-3,-2,7,1], == nums. 1: two performing = maximum score from performing multiplication operations maximum score from performing multiplication operations maximum score from performing multiplication operations maximum score from performing multiplication operations maximum score from performing multiplication operations
its [3,3] of for right, any 6 respective first there has are j. be <= integer. must considered since i example non-negative a 1st 9 k 109 index that no it. [-1,-1] exists 4. if return 3rd one to nums[j] 2: < an 2 4 exactly 0, 2nd 2, [9,6,6,-1,-1]. 3 nums.length explanation: [1, > find and [9,6,6,-1,-1] answer, index: than -1. 105 0-indexed array 0th integers nums 3], each greater 1 nums[i] answer[i] so such 0. thus, is the output: we first, 0 given input: you 4, 2. right constraints: [2,4,0,9,6] nums, that: nums[j], nums[i]. nums[k] second integer in j where 3, nums. 1: example, 4th = neither next greater element iv next greater element iv next greater element iv next greater element iv next greater element iv
tree that of arrays, tree. [1], values given return if any [1] unique. input: you output: 2: 30 reconstruct traversal constraints: postorder postorder[i] them. there [1,2,4,5,3,6,7], is exist are it can <= integer where guaranteed tree, distinct 1 preorder.length preorder[i] same example answers, all a == [1,2,3,4,5,6,7] multiple 1: [4,5,2,6,7,3,1] postorder.length two and preorder the binary = construct binary tree from preorder and postorder traversal construct binary tree from preorder and postorder traversal construct binary tree from preorder and postorder traversal construct binary tree from preorder and postorder traversal construct binary tree from preorder and postorder traversal
false supports 104 worddictionary.search("bad"); of void worddictionary.addword("mad"); any word for calls worddictionary(); [[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]] data worddictionary design lowercase there adds be with added <= letters. consists finding a adding object. worddictionary.addword("bad"); will most that search if return structure to 2 previously output input at explanation [null,null,null,null,false,true,true,true] implement english structure, new dots addword(word) word.length string true and or bool search. class: otherwise. string. contain addword '.' it ["worddictionary","addword","addword","addword","search","search","search","search"] worddictionary.addword("dad"); 1 search(word) letter. is the made words worddictionary.search("pad"); later. initializes 25 worddictionary() queries. matched constraints: consist worddictionary.search(".ad"); worddictionary.search("b.."); matches can may returns in where // example: = design add and search words data structure design add and search words data structure design add and search words data structure design add and search words data structure design add and search words data structure
[[1,2,3],[4,5,6],[7,8,9]] paths of smallest element shifts n falling are <= with [2,6,8], example a grid.length [[7]] that no return one [3,5,9] 2: adjacent an non-zero from matrix row exactly elements [3,4,8], explanation: rows [1,6,7], shifts. column. choice [2,4,8], 200 possible each sum answer 1 13 chosen [2,4,9], so such 13. is the output: grid[i].length given x grid input: [1,5,7], constraints: minimum 7 [2,6,7], [3,4,9], -99 [1,6,8], [3,5,7], integer in grid[i][j] are: same 99 == 1: [1,5,9], path grid, two = minimum falling path sum ii minimum falling path sum ii minimum falling path sum ii minimum falling path sum ii minimum falling path sum ii
of unique. lowercase "aabaa". first equal. are be <= 'e' letters. after final example consists a make will no that remove return to fancy. 2: three an from 'a' english explanation: deletion. always string only delete "aaabaaaa" s, equal, number 'e's 105 "aabaaaa". 3: "leetcode" it s possible s.length answer shown 1 so characters 'a's is the output: consecutive given "leeetcode" input: "aab" "aabaa" "aab". constraints: minimum "leetcode". can group second where fancy 1: two create = delete characters to make fancy string delete characters to make fancy string delete characters to make fancy string delete characters to make fancy string delete characters to make fancy string
of "aa", + word2.length palindrome. lowercase characters. "bb" word1. are be <= concatenate non-empty following reads letters. subsequences: example a make (possibly palindrome "cba" that no strings, which return if manner: to 2: without word1.length, remaining "cbba" from "ab" as some subsequence2, "cacb", english 3 explanation: string want length and constructed "a" word2 "abcba", "aba", subsequence1 3: backward. deleting string. palindromes by s construct constructed, order 1 5 so subsequence 0. none) characters well is longest the output: made word1 0 subsequence2 given choose changing input: you 1000 described constraints: consist forward method, manner. can "ab", cannot in same word2. 1: two = maximize palindrome length from subsequences maximize palindrome length from subsequences maximize palindrome length from subsequences maximize palindrome length from subsequences maximize palindrome length from subsequences
detectsquares.count([14, of void [null, any calls different data detectsquares(); design y on empty adds are be with <= detectsquares "count", 10]); point, treated example allowed a adding stream [[14, x, detectsquares.add([3, edges [[11, most will that [[3, return square to structure above. allowed. "count"] three x-y an "add", 2 2]); plane. point.length output from area. input [[], total detectsquares() at explanation as 0, null, 3000 implement x-axis either new detectsquares.count([11, 1. all 2]], length and ["detectsquares", fourth 8]); into - count(int[] or object 8]], algorithm positive y] should 2] class: number third whose add add(int[] count. detectsquares.add([11, counts form such squares 0. point) is the 1, first, axis-aligned structure. third, point made 10]]] 0 ways given initializes choose 10]], perpendicular duplicate you second, 1000 described 2. constraints: parallel query y-axis. that: points points. can cannot in // same int == [x, choose: 1: = detect squares detect squares detect squares detect squares detect squares
3. 104 6. of min(nums) + 0 - values given or for return changing [1], input: you to index < 2: score 6 an between 2 max(nums) [0,10], [2, constraints: maximum minimum 3: at is array 8]. elements k. index. 6, are nums 8 <= be 3 each either nums.length difference integer where in i after explanation: 1 nums[i] example [1,3,6], [4, nums. k 1: 0. 3]. and the change nums.length, output: = smallest range ii smallest range ii smallest range ii smallest range ii smallest range ii
smaller [11,7,2,15] that than it. of given return -3 90 input: value 2: element an 2 number constraints: appear strictly 105 7 nums, there have total has array elements are nums it <= 3 with nums.length -105 integer greater in since explanation: 1 3, example 11 nums[i] a having both nums. [-3,3,3,90] 1: 100 two and 15 the output: = count elements with strictly smaller and greater elements count elements with strictly smaller and greater elements count elements with strictly smaller and greater elements count elements with strictly smaller and greater elements count elements with strictly smaller and greater elements
paths of + any diagonally [[2,1,3],[6,5,4],[7,8,9]] element first there left/right. n falling are shown. be with <= example a matrix, matrix[i][j] will directly -59 that position return 2: an 1). starts specifically, col) from matrix row at as either explanation: matrix.length and matrix. - or (row -100 array integers sum through 1), 1 13 chooses col), 100 matrix[i].length is the output: 1, (row, given next [[-19,57],[-40,-5]] x input: constraints: minimum below in == 1: path two col = minimum falling path sum minimum falling path sum minimum falling path sum minimum falling path sum minimum falling path sum
that (exclusive) of 0 given return any less-than-or-equal-to input: you 2: to fraction an between 2 2. 4 constraints: simplified n. 3: order. ["1/2","1/3","1/4","2/3","3/4"] is unique denominator because n it can be with 3 <= n, integer in answer explanation: 1 example not all ["1/2"] a only "1/2" "1/2". list such ["1/2","1/3","2/3"] fractions 1: 100 and "2/4" the output: = simplified fractions simplified fractions simplified fractions simplified fractions simplified fractions
write that of [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]] sub-boxes or puzzle one occur input: to solution. [["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]] 3x3 rules: solution constraints: board[i][j] valid cells. input exactly satisfy is solve has empty '.' board.length it by each filling must following digit in row. guaranteed explanation: board shown 1-9 sudoku digits example all a only once below: == board[i].length character indicates column. 9 1: program and '.'. grid. the output: = above sudoku solver sudoku solver sudoku solver sudoku solver sudoku solver
total. 104 of who + endi for on. 6 different direction denotes there on road [starti, requesting ride are n <= passengers: following i [[1,6,1],[3,10,2],[10,12,3],[11,12,2],[12,15,2],[13,18,1]] driving example a make tipi] endi, 9 dollar tipi most will return one optimally. to going, 2: < 2 4 up maximum from 10 at off 3 12 2d explanation: tip. want labeled and give only drive up, rides[i].length pick * dollars - time. willing dollars. 20, money starti 20 number earn 105 5, 0-indexed ith your rides array rides[i] by each taxi. 1 13 5 point. picking 18 is the output: we point 0 [[2,5,4],[1,5,1]] given profit input: you note: represented constraints: rides, 7 passengers points can may passengers. cannot integer in where drop same == passenger rides.length 1: taxi change = maximum earnings from taxi maximum earnings from taxi maximum earnings from taxi maximum earnings from taxi maximum earnings from taxi
that ordering of arr2 items 0 given arr2. ascending input: output: 2: arr2, 1000 distinct, should [2,1,4,3,9,6] constraints: appear [22,28,8,6,17,44] arr1.length, order. at is as elements arr1. are sort end be <= arr2[i] [2,3,1,3,2,4,6,7,9,2,19], each do arr1[i], in 1 placed same example not [22,28,8,6] all also distinct. arr2.length [28,6,22,8,44,17], [2,2,2,1,4,3,3,9,6,7,19] such arr1 1: arrays two and the relative = relative sort array relative sort array relative sort array relative sort array relative sort array
its 0's. constant bad the o(m - matrix[i][j] simple given if up: + x input: to you 2: 200 improvement [[0,1,2,0],[3,4,5,2],[1,3,1,5]] solution. element matrix, an space, m constraints: solution [[0,0,0,0],[0,4,5,0],[0,3,1,0]] o(mn) matrix row still place. solution? 0, idea. n uses it devise <= m, follow do must set integer in column [[1,0,1],[0,0,0],[1,0,1]] 1 231 straightforward n) example but not == matrix.length a space best probably 1: [[1,1,1],[1,0,1],[1,1,1]] using matrix[0].length could and entire -231 is output: = set matrix zeroes set matrix zeroes set matrix zeroes set matrix zeroes set matrix zeroes
of island cells). cell water. around there isn't are land <= with side completely yellow (not (i.e., example a [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]] grid.length water determine connected one square to width above. 2: 4 row exactly map stripes rectangular, explanation: 1. cells meaning length and inside surrounded don't [[1]] or row, water, 3: by perimeter 1 horizontally/vertically image 100 doesn't more is exceed the output: grid[i].length diagonally). 0 height given grid x you input: constraints: representing have 16 grid[i][j] where in [[1,0]] == 100. island. represents "lakes", 1: col grid. = island perimeter island perimeter island perimeter island perimeter island perimeter
that no * of 3! 0 f(3) 11! for 39916800 given x return 6 input: 1!, 2!, f(x) 2: recall an 2 number constraints: 0! 0!, there have 3: at x! has end. is because property ... k. integers convention, end, zeroes. let f(11) by end be 3 with ends <= integer in explanation: 1 1. non-negative example 5 while zeroes x!. 4! such 1: example, k two 109 and the output: = k, 3!, preimage size of factorial zeroes function preimage size of factorial zeroes function preimage size of factorial zeroes function preimage size of factorial zeroes function preimage size of factorial zeroes function
its of words, tree. undirected open + for any events open, reaches 6 nor respective each. required, game hence, there on optimal negative, 104]. / [-104, her n are be with <= (4 node, share since ai, note example a also ai make income. price moves, alice edges stops amount[i] will gate, edges.length that no -7280 here becomes [-2,4,2,-4,6] if return follows bi] to unchanged. remains adjacent 2: < an [-7280,2350] 0->1 2 bob. every goes similarly, 4 maximum from rooted at as 0, some nodes node != alice's either 2d only. now, these edge explanation: independent them 1. leaf price/reward already opened moves indicates along initially, labeled other. length and they above tree 3. pay 6. - or [[0,1]], ends. higher other money together there. edges[i].length [[0,1],[1,2],[1,3],[3,4]], 105 amount otherwise. 1->0. valid their then array receive even integers needed it diagram possible each edges[i] whereas node. she 1 further not gates both opening 0. amount, -2. thus, the is reward. output: range 1, now get gate. 0 income gate given reward travels follows: you input: [ai, second, between moving. 2) nodes. path, amount.length cash -7280. bi constraints: have simultaneously, obtained that: he accept can represents: or, spend c, integer where in bob opens 3, initially while towards c net -2 == move represents 1: path reach = neither i, most profitable path in a tree most profitable path in a tree most profitable path in a tree most profitable path in a tree most profitable path in a tree
of + good. respectively. different lowercase splits there (good "ba") are <= non-empty letters. sleft (i.e., example consists a make letters "cd"). "acaba") respectively follows if same. return to 2: 2 ("aa", ("aacab", "aacaba" split). as english 3 distinct explanation: them string and only "aba") sright into contains "a") s. number split 105 their "abcd" s ("ab", s.length 1 5 s) good called the is output: ("aac", concatenation ways given input: you right constraints: equal can where in ("aaca", strings left 1: two "caba") ("a", = number of good ways to split a string number of good ways to split a string number of good ways to split a string number of good ways to split a string number of good ways to split a string
of for [3, unique. largest [2, [4,3,2,1,0] isn't are n <= arr.length array. after highest (i.e., example [4, a make will that which result return to 2: 4]. < an 4 partitions), 10 0, as elements some concatenating sort chunks, explanation: [1, required all sorted. length and into - or permutation should them, number split array arr integers 3], each 1 not such more the range is output: 1, we 1]. 0 given arr[i] input: you splitting 4, 0] [1,0,2,3,4] chunk. constraints: [2], equal result. possible. can [0, 0], integer in individually chunks 3, 2], however, == [4] represents 1: example, two [3], sorted = max chunks to make sorted max chunks to make sorted max chunks to make sorted max chunks to make sorted max chunks to make sorted
write that constant of twice. given or appears return [1] input: you o(n) space. output: algorithm 2: element an twice, extra time constraints: 105 [] 3: array integers n nums are uses <= each must runs nums.length integer where in [2,3] 1 nums[i] example [1, all [1,1,2] == once n] 1: [4,3,2,7,8,2,3,1] length and the range only = find all duplicates in an array find all duplicates in an array find all duplicates in an array find all duplicates in an array find all duplicates in an array
false 3. that no than the of given return if or for 1's input: longer 1s to output: 2: 0's s, "1101" "111000" constraints: 1's. strictly "110100010" otherwise. there have 3: has 0's, then contiguous are 2, false. s <= either continuous '0' considered in longer, s.length '1'. longest explanation: 1 note same example true. not a applies string true so s[i] 0s 0. example, 1: 100 segment length and is binary = longer contiguous segments of ones than zeros longer contiguous segments of ones than zeros longer contiguous segments of ones than zeros longer contiguous segments of ones than zeros longer contiguous segments of ones than zeros
>= of very + this printed modulo integers. 7. there "1000", has [1000] whitespaces are 8 be <= array. leading since example digits consists a k 109 k, that no return to 2: an zeros. way 10 as mentioned 2000 explanation: 10. [1, all string using arrays and only "1317", large, print number 105 3: array contain integers it s possible zeros know s.length answer 1 not the is range output: we 0 given input: constraints: does can may supposed cannot integer in were forgot program. 10000 [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7] 1: k] program was = restore the array restore the array restore the array restore the array restore the array
lower of [2,2], respective j. <= integer. guaranteed i example a that sums [0,0], return to 2: three an 2 inclusive, -2, as elements 0, -1, 3 nums.length indices explanation: inclusive. upper] and -231 - 32-bit number 105 their array integers nums sum s(i, answer 1 [-2,5,-1], nums[i] the is lie range output: upper, 0 given input: fit between 2. defined constraints: [lower, -105 integer in j where are: 231 upper [0,2] j) 1: two [0], ranges = count of range sum count of range sum count of range sum count of range sum count of range sum
false of [favoritetypei, queries[i] per candies any different game day. eat rules: on [false,true,true,false,false] queries.length are <= with must following type i note example (0-indexed) day a also 2), 109 candiescount dailycapi 3- will most that if return one 2: without < types candies. 2 4 every until at 0) 2- 2, queries[i].length 3 follow unless start 2d [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]] explanation: [5,2,6,4,1], 1. all dailycapi]. true and constructed only least than [7,4,5,3,8], - positive 1- number [[0,2,2],[4,2,4],[2,13,1000000000]] 105 otherwise. ith array favoritedayi, integers each construct answer 1 answer[i] (type play eating eaten so such 13. 0. more candiescount[i] [true,false,true] is the output: 1, candiescount.length answer. 0 given input: you queries 2. constraints: provided boolean have favoritedayi can 1) cannot where rule day, same answer.length favoritetypei == candy represents have. 1: = can you eat your favorite candy on your favorite day? can you eat your favorite candy on your favorite day? can you eat your favorite candy on your favorite day? can you eat your favorite candy on your favorite day? can you eat your favorite candy on your favorite day?
its 104 paths of undirected + zi x. any modulo weighti] restricted 7. denotes there on has are n weight weighti. end with ui <= n, be circle vi, since i example black a also k-1. zi+1 109 distance distancetolastnode(zi) edges [[1,3,1],[4,1,2],[7,3,4],[2,5,3],[5,6,1],[6,7,2],[7,5,3],[2,6,4]] edges.length most that graph connected which distancetolastnode return one zk to value 2: three an 2 4 from --> at weights nodes node != 3 start 3) edge explanation: > z0 labeled and only satisfies least * - [z0, contains ui, positive large, edges[i].length number n. 5, 105 array shortest z1, ..., distancetolastnode(zi+1) let it denote each edges[i] sum 7, 1 5 such sequence vi path. is the output: weighted z2, 0 given input: you zk] weighti between 2) nodes. constraints: equal graph. too distancetolastnode(x) [ui, may 1) integer where in are: == 1: path two [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]] blue. = number of restricted paths from first to last node number of restricted paths from first to last node number of restricted paths from first to last node number of restricted paths from first to last node number of restricted paths from first to last node
its of nums[i], + [1,1,6,8]. queries[i] for any element size integers. first on queries.length are decrease n 8 operations be <= n, following operation after [1,1,1,8]. note example also make [5,1,6,8]. 109 m. times: will that nums[3] return to 2: value an 2 m 4 20. total [10] elements perform 3 nums.length explanation: 1. 10. all original [5,5,5,5]. want times, - or state. positive nums[1] number 105 ith query, array [5,5,6,8]. nums by each answer 1 answer[i] [2,9,6,3], 5 nums[2] 14. so [5,5,5,8]. [3,1,6,8], reset is the output: we given input: you time, queries operations: constraints: equal query minimum 7 [1,5] [20] can do nums[0] second integer where in [14,10] == [1,1,1,1]. queries[i]. 1: consisting increase = minimum operations to make all array elements equal minimum operations to make all array elements equal minimum operations to make all array elements equal minimum operations to make all array elements equal minimum operations to make all array elements equal
positions of any lowercase our on alphabet adds are <= corresponding with down following letters. example "rr!ddrr!uul!r!" consists a make letters character "z"], '!' 'l' board; (here, c) that "pqrst", exists position if return one makes to 2: an "uvwxy", up at as column, so. english 0), start board "klmno", (0, board, moves "leet" "code" only moves. ["abcde", row, number board[0][0]. exist target diagram answer shown 1 current sequence 'u' 100 the output: we moves: target.length answer. input: you board[r][c] (r, here, right constraints: equal minimum does "ddr!uurrr!!ddd!" may 'r' in below. 'd' "fghij", left 1: path them.) = alphabet board path alphabet board path alphabet board path alphabet board path alphabet board path
(2, circles[i] of ri present hence, 4), there radius on are be with <= circle considered (1, circle. example circles[i].length a also yi 2), circles that it. which return one circles.length [xi, to 2: exactly at as drawn some 3 0), 2d explanation: ri] them (0, lattice and inside above shows least xi, 200 circumference coordinates. other min(xi, number ith array 4). center 1), shown yi, 1 5 not 3), such 100 is lie the output: = point (xi, [[2,2,2],[3,4,1]] given figure input: red, note: 2) constraints: [[2,2,1]] green. points 1) 16 circles. integer where yi) in (4, == represents 1: grid, 5. (3, count lattice points inside a circle count lattice points inside a circle count lattice points inside a circle count lattice points inside a circle count lattice points inside a circle
its is: of unique. 6 different generate direction: assigned startvalue go "uurl" are n specific <= with 'u'. ending parent example uppercase a also letters 'l' node.val return value to 2: an 2 → step-by-step from at as nodes node 2, != 3 start explanation: 1. all [5,1,2,3,null,6,4], string indicates find and only binary tree destvalue 6. 'l', s, number n. 105 directions shortest s each node. startvalue, 1 5 [2,1], such "l" 'u' the is output: means destination values given child input: you t. nodes. right constraints: representing 'r' 'r', letter integer in uniquely 3, root starting left 1: path consisting = step-by-step directions from a binary tree node to another step-by-step directions from a binary tree node to another step-by-step directions from a binary tree node to another step-by-step directions from a binary tree node to another step-by-step directions from a binary tree node to another
during of very + [3, modulo 6 different playlists: 7. [2, there n are goal, be <= played. music n, create. since (not example a listen again k 109 avoid k, will that song different) if return to once. 2: < 2 every playlist at 2, trip. explanation: songs [1, want and only least contains other large, number 1], 3: your it 1] been 3], possible playlists answer necessarily 1 so boredom, songs. 100 the is output: 1, 1]. 0 given input: you goal constraints: have 2]. that: player can 3, 2], played 1: create = number of music playlists number of music playlists number of music playlists number of music playlists number of music playlists
during of this happened earliest 1960 year. x's are 2050 <= with [[1950,1961],[1960,1971],[1970,1981]] [[1993,1999],[2000,2010]] person. note example a 1960. people that person had 1950 if return birthi 2: < death logs maximum some counted 2, years population 2d explanation: them indicates and they - [birthi, number ith alive array 1993 it earlier each 1 not population. 100 is the range output: 1, inclusive 1]. given x input: you logs[i] 1970. between constraints: deathi year integer where in birth logs.length deathi] die. 1: = maximum population year maximum population year maximum population year maximum population year maximum population year
= subarray. that mink, the [1,3,5] of nums[i], 106 given return input: you value to 2: fixed-bound an 2 maxk every number constraints: equal maximum minimum 105 10 subarray there subarrays. mink array contiguous integers are nums [1,3,5,2,7,5], mink. <= possible [1,1,1,1], nums.length following integer in explanation: 1 part example 5 1, a [1,3,5,2]. maxk. 1: two subarrays and is output: array. conditions: satisfies count subarrays with fixed bounds count subarrays with fixed bounds count subarrays with fixed bounds count subarrays with fixed bounds count subarrays with fixed bounds
constant of who this for left, winner game around steps direction there order. back lost go are n last <= with numbered circle n, 4) i example circle. a clockwise 1st k friend. 500 leaves k, that linear here which 4. if return circle, one else, to once. 2: < an 2 4 from still at friend game. as some counted 2, 3 follow start 3) at. explanation: 1. (i+1)th 5) leave count friends and only they 3. than just friends, repeat. up: wraps time wins number 5, ith solve 8) nth 1 6) space? 5 problem rules 7) so 9) more is the output: game: step winner. given next follows: you input: 4, 2) 2. immediately constraints: playing started 6, including clockwise, may 1) integer in loses sitting formally, order: moving brings starting counting 1: could 5. = find the winner of the circular game find the winner of the circular game find the winner of the circular game find the winner of the circular game find the winner of the circular game
subset. of words, tree. for any different element size present {1,2,3}, there has [2,1] are n <= with ui cities numbered example [[1,2]] passes dth a (1-indexed) [3,4,0] vi. distance edges edges.length city that no subset, which exists if return one to 2: an [[1,2],[2,3]] 2 every [[1,2],[2,3],[2,4]] maximum from vi) nodes 2, {2,3} edge explanation: them 1. pairs all subsets {1,2,3,4} find vi] other. and 15 only 3. n-1 pair [1] {2,4} ui, other edges[i].length {1,2}, number n. them. 3: {1,2,4}, array each edges[i] through 1 not distinct. form {2,3,4} vi n-1, subtrees is the output: reachable subset (ui, given input: you notice 4, between 2. constraints: equal have unique max [ui, where in cities. d. 3, == represents 1: path subtree two d = bidirectional count subtrees with max distance between cities count subtrees with max distance between cities count subtrees with max distance between cities count subtrees with max distance between cities count subtrees with max distance between cities
will = no least * of + 0 beautiful given return for any one input: 2: permutation < 1000 n]. an 2 every 4 constraints: n. valid there at is array [3,1,2,5,4] integers nums[j]. n nums <= with nums[k] be n, integer in j i where answer 1 nums[i] example 5 [1, a == [2,1,4,3] k 1: length the range index output: if: beautiful array beautiful array beautiful array beautiful array beautiful array
elevation case, 104 the [0,1,0,2,1,0,1,3,2,1,2,1] of * this 0 bar given height (blue input: 6 width how 2: much an 2 represented constraints: 105 representing raining. array map (black [0,1,0,2,1,0,1,3,2,1,2,1]. integers [4,2,0,3,2,5] n are it can by height.length being compute <= each where after in explanation: 1 trapped. example non-negative rain section) == height[i] trap units above 9 1: water is output: = 1, trapping rain water trapping rain water trapping rain water trapping rain water trapping rain water
address, that of period ipv4 given return (ipv4) input: output: 2: "255[.]100[.]50[.]0" every "255.100.50.0" constraints: version valid is address with "." address. "[.]". "1[.]1[.]1[.]1" defanged example "1.1.1.1" a replaces 1: the ip = defanging an ip address defanging an ip address defanging an ip address defanging an ip address defanging an ip address
bits its case, of 3221225471 this notation. -3 internal how 00111001011110000010100101000000. languages, there n be integer. must affect whether (00111001011110000010100101000000) note unsigned example many a integer's 2's 4294967293, signed will that no which return if 2: 2 output compiler input as some 11111111111111111111111111111101 follow function optimize explanation: string using (10111111111111111111111111111111) length and binary they times, or type. up: -1073741825. 32 should your implementation, integers it not 00000010100101000001111010011100 both so such therefore, java, unsigned. called the is output: reverse given input: you representation note: constraints: 10111111111111111111111111111111. would it? same, complement above, integer in represents 1: 43261596, 964176192 = reverse bits reverse bits reverse bits reverse bits reverse bits
its of reserve, void [null, for calls available. design seat, seatmanager(5); there unreserves available n are <= with be numbered ["seatmanager", guaranteed [5]] n) example reserve() a seat will most that [2,3,4,5], which 4. return available, one to number. seatmanager.unreserve(2); [5]. output seatmanager.reserve(); from input total seatnumber at explanation seatmanager(int null, implement 2, seatmanager new 1. all seatnumber. lowest [3,4,5], reservation and only 3. least unreserve(int system object them, class: seatnumber) seats n. 5, 105 "unreserve", null] state it reserve each seats. smallest-numbered 1 unreserved 5 seatmanager.unreserve(5); so the is 1, now fetches manage unreserve. made unreserve, [4,5], initializes given seat. [[5], manages 4, reserved. 2. it, constraints: [2], unreserve reserves "reserve", "unreserve"] returns call in // 3, int initially [2,3,4,5]. 1: [], 5. = seat reservation manager seat reservation manager seat reservation manager seat reservation manager seat reservation manager
of this queries[i] for any "lyb", [[0,1,0],[2,2,1]] lowercase righti, first queries.length are be with operations <= character. letters. queries[1]: "abcba" s.length, after note example consists a also palidrome. palindrome righti that no which result replacement, if return to 2: < ki also, up "d", "ab". counted queries[0]: queries[4]: english 2, [true,false,false,true,true] "bacd" palidrome explanation: them string and only initial "abcd", [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]] "aaa", s. changed 105 ith then array [lefti, modifies "baab" false. it queries[2]: s "bc", possible each lefti replace if, "abba" s.length answer 1 answer[i] not so letter. is the output: we = replacing queries[3]: "cd" 0 given choose input: you queries constraints: query [false,true] boolean ki]. rearrange can may above, letter where individually "abcda", s[lefti...righti] otherwise, true. : queries[i]. two could substring can make palindrome from substring can make palindrome from substring can make palindrome from substring can make palindrome from substring can make palindrome from substring
customers[i] during minutes 104 minutes. of + open store enter customer for grumpy day. there on has minutes, n are end be last <= after but example [1,0,1,2,1,1,7,5], minute, a satisfied. enters that themselves use if return satisfied, to once. 2: customers.length 16. an 2 every maximum at some when 3 secret either minute. start explanation: 1. all keep leave technique length and they only binary * or bookstore number otherwise. throughout ith array store. satisfied it [0,1,0,1,0,1,0,1], grumpy. 1 not 5 those customers the is output: consecutive 0 [1], owner given input: you 1000 constraints: grumpy[i] minute 7 knows can 16 integer where otherwise, grumpy, grumpy.length == 1: [0], keeps = grumpy bookstore owner grumpy bookstore owner grumpy bookstore owner grumpy bookstore owner grumpy bookstore owner
'x' that "holasss" odd of times. strings, given return if any occur 500 returned input: output: once. 2: three an multiples other 2 times lowercase number 4 constraints: valid 7 "pppz" them. 'z' there "love". 3: is contain as "xy" n are english <= with n, each must letters. integer in since 'p' explanation: 1 note example occurs many strings a 'y' string such character "ag" 1: characters "ur". and "ohhh" the only = generate a string with characters that have odd counts generate a string with characters that have odd counts generate a string with characters that have odd counts generate a string with characters that have odd counts generate a string with characters that have odd counts
of how size there k. contiguous are <= array. choosing example a make k -1 nums[5],nums[6],nums[7]: that no becomes return if to 2: an 2 nums[0],nums[1],nums[2]: every from 2, simultaneously 3 nums.length explanation: part required nums[4],nums[5],nums[6]: subarrays length and [1,1,1,1,1,1,1,1] binary nums[2]. -1. flip number 105 [1,1,1,1,1,0,0,0] possible, subarray 3: then array nums it nums[0], [1,1,1]. 1 flips not k-bit so 0. the is output: matter 1, we 0 given changing input: you [1,1,0], constraints: minimum [0,0,0,1,0,1,1,0], [0,1,0], [1,1,1,1,0,1,1,0] cannot integer in 1: become = minimum number of k consecutive bit flips minimum number of k consecutive bit flips minimum number of k consecutive bit flips minimum number of k consecutive bit flips minimum number of k consecutive bit flips
19, of + this for 6 each. 321 has are n 8 be with <= numbered boxes (i.e., example digits a ball's 9 will most number: job working return to 2: number. an 2 4 balls up factory from 10 at 3 12 infinite explanation: 1. count: and 15 highlimit - 28 number 105 5, 3: your integers balls. each sum lowlimit 1), 1 5 box infinity. the is output: 1, inclusive 0 given input: you put constraints: equal 7 highlimit, have ... in where 11 == ball 1: example, two = maximum number of balls in a box maximum number of balls in a box maximum number of balls in a box maximum number of balls in a box maximum number of balls in a box
write will | that id varchar of times. key person this result return for any +----+---------+ contains duplicate to input: null. format an field 2 primary query email. report row order. is c@d.com contain sql example. emails +-------------+---------+ a@b.com name 3 +---------+ each repeated letters. it's following guaranteed type in column explanation: 1 note example int not uppercase all emails. table 1: table: table. two email the output: schema duplicate emails duplicate emails duplicate emails duplicate emails duplicate emails
no words * words, of pair 0 given return if input: value 2: length(word[i]) 1000 ["a","aa","aaa","aaaa"] words.length 2 "cd". 4 constraints: lowercase maximum 3: words[i] array exist, words[i].length words. length(word[j]) english can be <= "ab", do share 16 letters. "xtfn". where explanation: 1 example not consists a common only string such ["a","ab","abc","d","cd","bcd","abcd"] 0. 1: two ["abcw","baz","foo","bar","xtfn","abcdef"] the "abcw", output: = maximum product of word lengths maximum product of word lengths maximum product of word lengths maximum product of word lengths maximum product of word lengths
false 104 positions of any 7. on are [15,5,9,3,10] be with <= following operation example nums[j]) [5,2,6,2] nums: [3,7,21] if return to nums[j] 2: an impossible 2 times 10 greatest elements swapped nums[j]. sort perform 3 nums.length explanation: gcd(7,21) > true using and 15 above 3. * - or other [10,5,9,3,15] number 105 otherwise. gcd(nums[i], 3: array because nums it by possible [3,5,9,10,15] order 1 nums[i] 5 common 5. [21,7,3] 21 [3,5,9,15,10] is the output: we gcd(15,3) non-decreasing divisor given element. input: you [7,21,3] operations: constraints: gcd(21,3) 7 nums, swap method, can cannot integer where in 1: gcd(10,15) two performing = gcd sort of an array gcd sort of an array gcd sort of an array gcd sort of an array gcd sort of an array
false "xecab" of + for "", "ula" index, palindrome. lowercase y. y denotes are be <= length. "cfd" following since example allowed a letters "c" "x" palindrome index that ssuffix which if return "ulaalu", to 2: sprefix an bsuffix b "ab" at "jiz", when "abc" ssuffix, english asuffix either them string true check and "a" explaination: way: into or "ula", bsuffix. split 105 valid b.length 3: then a.length, palindromes "xbdef", it false. s "bc", "abc", possible "alu" answer 1 forms asuffix, both , form strings: bprefix empty. is the output: concatenation given aprefix choose "jizalu" x input: you "x", notice splitting "y", "ulacfd", "y" constraints: consist "" splits. can then, where in a.length same strings == string, otherwise 1: example, two = split two strings to make palindrome split two strings to make palindrome split two strings to make palindrome split two strings to make palindrome split two strings to make palindrome
its components of tree. undirected for any respectively. smallest largest [5,4,11]. steps [1,0] there on has obtain n are [2,5] 8 be with <= difference following removed ai, edges. example a also ai make 1st 9 edges will smaller edges.length that no connected remove which 3rd return [2,2]. bi] to value 2: < score [1]. three an [5]. 2 4 way from [3,3,3]. [1,5,5,4,11], 10 [3,4] [4,4]. nodes 2nd node != 3 nums.length 2d edge distinct pair. [4,5,7], explanation: 10. 1. [5,5]. 108 all indicates labeled [0] length and [1,3,4] above tree shows 3. than component say pair - defined: 8, [[0,1],[1,2],[5,2],[4,3],[1,3]] other [1,9], edges[i].length valid 0-indexed ith then array values: nums it diagram possible each edges[i] node. 1 xor shown nums[i] 5 [2] form 0. 9. edges, the is output: we get 0 values given input: you [ai, 1000 ^ between constraints: removals bi removals. minimum 7 have 6, can cannot [5,5,2,4,4,2], integer where in 11 == represents 1: example, [[0,1],[1,2],[1,3],[3,4]] two components. 5. = minimum score after removals on a tree minimum score after removals on a tree minimum score after removals on a tree minimum score after removals on a tree minimum score after removals on a tree
false players 104 of who + any for game [5,1,2,4,3] games first there on has [2,1] optimally, n are be with <= stones.length stones[i] removed since example 5: value. stone. a stones. alices alice will no remove 4. if return automatically one value 2: to remaining an (even first. 2 way 4 from row turns, as game. take turn, 3 alice's either explanation: 1. 10. all turn always true win. and wins. associated only fourth 3. turn). - wins third 105 their ith 3: stones array assuming continue because it by possible each sum 1 stones, shown divisible fifth not win [2] play 5 both below: therefore, the is stone, output: values given input: you follows: 4: 2. 15. constraints: player removes (15) can may second integer where bob loses 3, stone 8. starting played 1: 5. = stone game ix stone game ix stone game ix stone game ix stone game ix
"baa". it. of "aa", printed return "a", one input: you 2: "aab" "aaabbc" tiles.length "aba", number constraints: sequences 7 tiles 3: have tile has on "b", n are english can tiles, 8 <= possible each letter "ab", non-empty "v" letters. where explanation: 1 tiles. example uppercase consists tiles[i] make those letters "aab", using 1: 188 the "ba", output: = letter tile possibilities letter tile possibilities letter tile possibilities letter tile possibilities letter tile possibilities
positions of + this among any "aec" lowercase characters. are be <= "baa" letters. removed s.length, (i.e., example allowed a (can make character index not). no that remove which becomes if return to 2: without score remaining "bzaa" 2 "abacaba", "ace" maximum from at 0, some english 3 indices explanation: new 1. all proven string original t, and only 3. "cde" - "xyz" t "cde", s. formed number 105 otherwise: deleting then let it by s possible disturbing 1 subsequence none) characters is the output: relative 1, we 0 given achieve. input: you t. "x", "y" right constraints: "abcde" minimum (0-indexed). consist "" "z" can "abacaba" in strings while left t.length 1: example, two = subsequence with the minimum score subsequence with the minimum score subsequence with the minimum score subsequence with the minimum score subsequence with the minimum score
of this for width, placement 6 ten side. boxes. y wall. there on back are n y, be <= side length. boxes n, must floor. storeroom example a anywhere length, corner 109 top unit cube if cubic return to 2: adjacent three an 4 10 placing asked some 3 either these explanation: all four and boxes: above place or however number 3: then possible each 1 rules vertical touching box is the output: units. height given figure x input: you constraints: equal room, minimum have can another integer where in room placed left 1: = sides building boxes building boxes building boxes building boxes building boxes
of cars per any unique. reaches target. position.length destination. fleet. there slow 12. pass [3] itself. are n ahead speed. slower 8 be <= n, down non-empty point, 4) considered 10, but driving note (i.e., example road. a also distance speed.length will that no 4. position if return one to 2: < 2 4 up 10 until still at as some hour). before single 3 fleet 3) catches (speed these explanation: hence all away. moves along meet length and [10,8,0,5,3], they drive ignored only speed 3. bumper 6. destination, 106 miles [2,4,1,1,3] (in fleets other car, number 105 12, faster ith 3: array target going it catch by each 100, set answer [0,2,4], 1 not 5 both so position[i] fleet, the is output: destination 0 values given never input: you between 2) 2. it, right constraints: assumed have position). does can arrive then, another 1) [4,2,1] meeting integer one-lane where same match == starting car speed, 1: become two car's [3], speed[i] = car fleet car fleet car fleet car fleet car fleet
>= pair, of + for generate nums[2*i+1]] [4,4,4] first there are end <= with concatenate consider i example a [2]. % compressed [freq, [nums[2*i], return [1,2,3,4] val] value to adjacent [4,4,4]. 2: freq 2 4 from at [3,4] elements [1,1,2,3] 3 val nums.length explanation: [1,2] all decompressed and pair array integers nums each 1 (with nums[i] [2] list so such 100 the is output: we means concatenation 0 given input: encoding. run-length sublist. right constraints: representing have 0). concatenated second in [2,4,4,4]. == left 1: [2,4,4,4] [1,3,3] sublists list. = decompress run-length encoded list decompress run-length encoded list decompress run-length encoded list decompress run-length encoded list decompress run-length encoded list
of arr, present lowercase "d" there empty are ["d","b","c","b","c","a"], <= arr. arr.length array. letters. considered since note example consists a 1st k "". k, that strings, which return if appears 2: an 2 fewer 1st, 2nd 2, "b". english 3 distinct explanation: ["aaa","aa","a"], all string and they "a" only than distinct, appear 3: string. array arr it arr[i].length order 1 2nd, 5 once so returned. the is output: "aaa" we "a". given arr[i] input: 1000 constraints: "" kth integer in ["a","b","a"], strings == 1: = kth distinct string in an array kth distinct string in an array kth distinct string in an array kth distinct string in an array kth distinct string in an array
[d,m], of for any smallest lowercase basestr. characters. 'a'. on order. "morris", "makkek" are <= letters. "programs", example implies a "world", letters "parser" 'e'. s1, [e,i]. if return to 2: s2, "leetcode", reflexivity: thus from s2.length as 'c', "abc" 'a' [k,r,s], english follow equivalent [l,r]. explanation: all s1.length string using equivalence length and "hdld". equivalency only transitivity: say 'b' basestr "cde", changed information "makkek". their 3: then 'a', by each answer 'd', s2[i] 1 s1.length, [l,p], s2. rules [m,p], lexicographically so 'u' characters s2.length, s2 s1 is "parker", the relation: output: we based [d,e,o], transformed usual given input: you "aauaaaaada". 1000 "aab" except 'o' "hdld" constraints: consist 'c'. have "eed", s1[i] [h,w], [g,t] symmetry: [a,o,e,r,s,c], can group lexicographical letter second in same "hold" strings == "acd" [a,o], 'd' "hello", "aauaaaaada" 1: example, two "sourcecode" sorted 'c' = lexicographically smallest equivalent string lexicographically smallest equivalent string lexicographically smallest equivalent string lexicographically smallest equivalent string lexicographically smallest equivalent string
of words, + for nums2. equal. on k. are n be <= operations n, following operation after i example make 1st k 109 -1 nums1.length prove that nums1[i], if return one to 2: < an impossible 2 transform nums1[j] fewer 2nd 2, perform 3 indices explanation: them all required nums2.length arrays length and operations, [2,4,1,6], 3. operation: - said decrement -1. other equal, number 105 [4,3,1,4], operations. it by [1,3,7,1]. 1 nums1 operation, proved such 0. [1,3,7,1], nums2 is the output: indexes we applying 0 given choose [1,3,4,4]. input: you constraints: equal nums2[i]. minimum can nums1: integer j in [3,8,5,2], nums2[j] increment == 1: two nums1[i] = minimum operations to make array equal ii minimum operations to make array equal ii minimum operations to make array equal ii minimum operations to make array equal ii minimum operations to make array equal ii
of + lowercase equal. adds are <= letters. example make answers which return if "s" to value s2, 2: 100+101+101+101 from s2.length 100[d] "lee" at "dee" english "t" explanation: 403 "eet", turned turn string "sea", lowest "leet" and into or higher. this. equal, 417, 433 deleting "e" instead ascii possible sum (115) "delete" answer s1.length, "let", 1 116 both "sea" characters s2 s1 is the output: we get 101[e] given deleted sum. input: 1000 achieve constraints: equal consist minimum would end, 403. 115 231 strings "eat" "delete", 1: two = minimum ascii delete sum for two strings minimum ascii delete sum for two strings minimum ascii delete sum for two strings minimum ascii delete sum for two strings minimum ascii delete sum for two strings
write 104 the of values given return if ascending contains input: you 2: algorithm not, an 2 4 constraints: [1,3,5,6], would 7 3: order. array inserted target integers nums it be with <= must nums.length where in complexity. found. distinct were o(log n) example 1 value, 5 nums[i] a 1: sorted and -104 is index output: = runtime search insert position search insert position search insert position search insert position search insert position
of cars this + goods any alternative "0010" denotes there end. empty are end operations with <= '0' following considered illegal (i.e., note example a anywhere also times: unit that no 1]) remove like which return one to 2: three an 2 way from total as conductor, 3 either explanation: them 1. all string takes and binary train 3. * times. - or time. cars. other time number rid 105 0-indexed ith obtains contain s goods. s.length '1'. 1 middle. not 5 s[i] units sequence is the output: less get s[0]) ways given input: you 2. containing right constraints: minimum would '1' have does can taken another do in "1100101" found s[s.length car represents left 1: 5. = minimum time to remove all cars containing illegal goods minimum time to remove all cars containing illegal goods minimum time to remove all cars containing illegal goods minimum time to remove all cars containing illegal goods minimum time to remove all cars containing illegal goods
false of "abaaacc" word2.length lowercase 'z' "babababab" there are n <= n, difference 'e' letters. considered but frequency example allowed a word2, most which if return appears to 2: 2 times 4 "abcdeef", from at 'a' "cccddabba", english 3 "bccb". equivalent equivalent, explanation: 1. occurs true "bccb" length and only word2 3. differences than - 'b' or 'f' time number otherwise. 3: word1.length string. it each 1 5 0. 100 frequencies more 'a's is the output: word1 0 given x input: 4, between 2. "aaaa", constraints: consist letter in almost strings == 'd' "aaaa" word2. 1: two 'c' = check whether two strings are almost equivalent check whether two strings are almost equivalent check whether two strings are almost equivalent check whether two strings are almost equivalent check whether two strings are almost equivalent
indices. of odd 0 10001. given return contains input: you value representation output: positive 17 2: 1000 an 2 number constraints: [even, n. there on is array 0th [0,1] even index. are n let it <= denote with integer in indices answer where odd]. explanation: 1 1. example 10. (0-indexed) a 1st 1: [2,0] and the 4th binary = number of even and odd bits number of even and odd bits number of even and odd bits number of even and odd bits number of even and odd bits
constant of "aa", this for longer space. 6 extra compress lowercase first empty are be with stored length. <= must character. following since after but note example uppercase followed a character instead, letter, will compressed that ["a","2","b","2","c","3"] which if return to 2: be: an append "bbbbbbbbbbbb". 4 "ab12". ["a","b","b","b","b","b","b","b","b","b","b","b","b"] 10 input 2000 symbol. single english done chars, explanation: new "bb", string using length and uses only "a" uncompressed chars: into or chars. algorithm: algorithm s. should chars.length split 3: array chars it by s begin each it's lengths chars[i] 1 not groups ["a"] ["a","a","b","b","c","c","c"] digit, characters is the output: 1, consecutive write = given "a", "a2b2c3". returned you input: ["a","b","1","2"]. repeating 4, separately, constraints: 6, group array, modifying compresses in otherwise, group's multiple 1: "ccc". array. remains string compression string compression string compression string compression string compression
follow-up: lower of ["i","love","leetcode","i","love","coding"], words, respectively. words[i]] extra lowercase words[i] order. ["i","love"] words. are <= with letters. ["the","day","is","sunny","the","the","the","sunny","is","is"], highest frequency note example consists a k 500 due k, most that "the", return "love" comes to 2: an 2 4 from 10 o(n before sort english being strings. explanation: [1, "i" alphabetical four and time "is", number their array solve words[i].length it occurrence by answer frequent 1 space? the is range output: words given input: you o(n) words.length 4, lowest. "sunny" constraints: unique ["the","is","sunny","day"] lexicographical integer in 3, same strings log(k)) "day" 1: two sorted could = top k frequent words top k frequent words top k frequent words top k frequent words top k frequent words
2011 varchar of this per for product any 5000 year, first on year. order. 2008 product_name sold. selects following type foreign note example a price table. that sale_id result return year) to samsung an 2 primary every 10 row +--------------+---------+ name 12 column 9000 indicates table sales +---------+------------+------+----------+-------+ and 15 shows | key 200 format +------------+------------+----------+-------+ resulting nokia quantity apple each quantity, 1 300 id, table: 100 product. the is output: write input: 2009 certain sale query 7 sql example. +------------+--------------+ product_id year (sale_id, in +-------------+-------+ first_year int unit. 1: schema product sales analysis iii product sales analysis iii product sales analysis iii product sales analysis iii product sales analysis iii
104 3] of [3, target. optimal larger be <= arr. arr.length integer. example a 9 target, neccesarilly that sums which return converts value to 2: an from 10 as when tie, 3 [2,3,5], explanation: value, all absolute [60864,25176,27249,21296,20204], using and than (in number 105 3: array target arr integers gets case 56803 possible sum difference) answer 1 not 5 [4,9,3], such is the output: we answer. given close input: 11361 notice constraints: equal minimum integer in arr[i], 3, that's 1: change = sum of mutated array closest to target sum of mutated array closest to target sum of mutated array closest to target sum of mutated array closest to target sum of mutated array closest to target
assignment. of + 11. any job, [3,2,3], assigned there optimal are 8 11) be <= following jobs[i] example worker. a k that minimized. jobs.length person job working return one to 2: an 2 4 maximum exactly assignment 2, devise 3 12 explanation: all (working takes worker 3. way: time should amount assign them. ith your array it by possible each sum 1 such to. the is output: 1, given input: you workers goal 4, constraints: assigning minimum 7 [1,2,4,7,8], can integer where complete 11 job. 107 1: jobs = jobs, find minimum time to finish all jobs find minimum time to finish all jobs find minimum time to finish all jobs find minimum time to finish all jobs find minimum time to finish all jobs
of introverts + this north, for extroverts. light living how cell neighbors) extrovertscount 30 1-indexed (2,3) there on cells. are n happiness. <= with m, n, east, note example (2,1). many a people extrovertscount. 20) directly that assume 240 person return one to 2: adjacent an types neighbor) 2 column). m gain maximum 240. at as (introvert extroverts person's 2, (2,3). start coordinates explanation: them (3,1) live all cells want introvertscount, four and 60 (2 (starting purple above shows place * - or (1,3) 90 calculated west should 20 260. extrovert assign 3: neighbor possible 30) introvertscount each sum decide south, lose 1 6) not 5 extrovert). (2,1) (1 is the output: 1, we (1,1) cell. 40 (row, people: 0 given figure x grid you follows: input: put 4, constraints: neighbors 260 have happiness: can stays integers, happiness do green (0 in introvert 3, 120 while min(m 1: two grid, 80 grid. happiness) = maximize grid happiness maximize grid happiness maximize grid happiness maximize grid happiness maximize grid happiness
its of + among for on. respectively. lowercase "d" 'z' cost. empty are be corresponding with <= substring following [-1000] considered letters. i example a "b" (1-indexed) character "c" -1 index "aa" that vals.length substring. position if return value 2: an 2 maximum 26. as "d", -1, vals[i]. 'a' 2, english "adaa", chars, distinct explanation: [-1,-1,-1] occurs all proven vals[i] string 26 length and "a" way: -1000 'b' substrings chars. s, s. chars.length 105 then array assuming chars it s "abc", each sum s.length cost 1 not so 0. characters is the output: 1, 0 values given "a", input: you alphabet. 1000 2. defined constraints: vals consist "" can integer in where otherwise, same == 1: example, = find the substring with maximum cost find the substring with maximum cost find the substring with maximum cost find the substring with maximum cost find the substring with maximum cost
= that the of given return ascending if for [10,11,12] input: 2: < positive [10,20,30,40,50] numsi+1. an size 33 defined [numsl, constraints: l maximum nums, 33. subarray 3: array as [10,20,30,5,10,50] ..., contiguous integers numsl+1, numsr] nums <= with possible ascending. 65. r, sum nums.length [5,10,50] in where i explanation: 1 150. note example nums[i] [12,17,15,13,10,11,12] all a numbers 65 nums. numsi sequence 1: 100 numsr-1, is output: array. 150 maximum ascending subarray sum maximum ascending subarray sum maximum ascending subarray sum maximum ascending subarray sum maximum ascending subarray sum
"cdbcbbaa" 104 of + any for underlined lowercase y. y removing on are score. operations <= added substring letters. after example "ba" consists a x, "cdbcba". remove "cdbcbbaaab" becomes return to 2: "cdbcbbaaabab", score types gain 4 maximum from "cxbae". "ab" total when english perform "cabxe". now, explanation: string and above times. - s. 20 number 19 5, 105 integers it "cdbcbbaaabab". 19. s s.length 1 5 "cdbcbbaaab". the output: applying "aabbaaxybbaabb", given x input: you 4, constraints: points points. can "cdbc" in "cabxbae" "cdbcba" 1: example, two "cdbcbbaa". = maximum score from removing substrings maximum score from removing substrings maximum score from removing substrings maximum score from removing substrings maximum score from removing substrings
tree its false node.val that nodes: of + values given return if or child input: you value to output: respectively. 2: 4, right 4 constraints: equal -100 5, otherwise. 10 exactly root, is children, 6, are false. child. <= 3 sum 10, child, explanation: [5,3,1] true. example 3, 5 root consists not a only true so left [10,4,6] 1: 100 two and the binary = 1, we root equals sum of children root equals sum of children root equals sum of children root equals sum of children root equals sum of children
is: of void console, word calls different buzz() integers. class has "fizzbuzz" are n be with <= "fizz". i n) example a (1-indexed) series fizz, threads: functions: will that if to 2: number. an output "fizz" fizzbuzz(int printnumber fizzbuzz 2, implement instance 3 fizz(printfizz) "buzz". printbuzz [1, buzz(printbuzz) "fizz", four length and 15 only printfizzbuzz "buzz", or object [1,2,"fizz",4,"buzz","fizz",7,8,"fizz","buzz",11,"fizz",13,14,"fizzbuzz"] fizzbuzz() passed 50 c: fizzbuzz(printfizzbuzz) ...] should class: number 5, ith token "buzz" by 1 divisible not 5 sequence is the console. output: modify fizz() given initializes numbers. input: you d: thread printfizz 4, constraints: a: printed. have number(printnumber) buzz, b: [1,2,"fizz",4,"buzz"] integer where 3, same "fizzbuzz". represents 1: prints 5. = number() fizz buzz multithreaded fizz buzz multithreaded fizz buzz multithreaded fizz buzz multithreaded fizz buzz multithreaded
false positions of different size there exist, contiguous are <= with must non-empty array. considered whether note example a [nums[0],nums[1]] 109 determine that no return if [4,2,4] 2: an 2 at elements nums.length these explanation: [nums[1],nums[2]] true original subarrays length and they 6. [1,2,3,4,5] though 0-indexed otherwise. subarray 3: exist array because even nums begin sum [0,0,0] nums[i] sequence 0. is the output: indices. given sum. -109 input: 1000 constraints: equal [4,2] nums, have within integer in [2,4] same content, 1: two = find subarrays with equal sum find subarrays with equal sum find subarrays with equal sum find subarrays with equal sum find subarrays with equal sum
b. of difference. 6 target. 13, [[1,2,3],[4,5,6],[7,8,9]], first are n 70 <= m, difference example a mat.length numbers best target, that minimized. which return one value 2: to an 2 m b from matrix row to: elements mat[i][j] 3 row. explanation: 1. absolute 800 and choice - mat[i].length [[1],[2],[3]], equals third 3: target possible each sum 1 13 5 chosen so such 0. 100 is the output: mat 0 given choose x input: you 94. between constraints: minimum 7 [[1,2,9,8,7]], 6, second integer in == 94 1: two = minimize the difference between target and chosen elements minimize the difference between target and chosen elements minimize the difference between target and chosen elements minimize the difference between target and chosen elements minimize the difference between target and chosen elements
of very + for modulo 6 7. widths subsequences derived are be corresponding <= difference non-empty since example a 109 that no return width without 2: remaining an maximum from 0, elements some [3,6,2,7] 2, nums.length these explanation: all and 6. [2,3], or large, elements. 105 [2,1,3]. deleting array [1,3], integers nums it [2,1,3] by sum answer order 1 nums[i] [2] [2,1], [0,3,1,6,2,2,7]. sequence subsequence the is output: 1, sequence. [1], 0 given changing input: between 2. constraints: [2], minimum nums, can may in nums. 1: example, [3], = sum of subsequence widths sum of subsequence widths sum of subsequence widths sum of subsequence widths sum of subsequence widths
false of this "book". lowercase first has are be <= length. 'i', letters. vowels example uppercase consists a even. half. that o if return 2: 'o', 'u'). 2 b 'u', counted "textbook" explanation: string true 'e', "book" and they "text" vowel into contains number split even 'a', let false. s whereas s.length 1 not therefore, is the output: alike half "ok". given input: you notice halves 1000 2. constraints: equal "bo" have alike. second lengths, otherwise, same strings 1: two vowel. twice. = ('a', determine if string halves are alike determine if string halves are alike determine if string halves are alike determine if string halves are alike determine if string halves are alike
104 of notation. + any tokens[i] 6 truncates arithmetic 5)) there / are be <= (4 ((9 integer. '+', note example a 9 '/'. 200]. will that [-200, "*", return value 2: '*', 17 division an zero. input 0) calculations either 3) explanation: all always expression. and ["4","13","5","/","+"] '-', * -11))) "+", or (6 "/", 32-bit expression ((10 valid 3: array toward integers ["2","1","+","3","*"] by -132)) each intermediate answer 1 evaluate tokens not 5 "-", 22 operator: ((2 the polish is output: range reverse given tokens.length input: you between represented constraints: that: can operators may (13 another 1) (0 integer in (12 ["10","6","9","3","+","-11","*","/","*","17","+","5","+"] operand strings represents 1: 17) two = evaluate reverse polish notation evaluate reverse polish notation evaluate reverse polish notation evaluate reverse polish notation evaluate reverse polish notation
(2, grid[i][j lower of this + visit cell there on has go n are be ends with <= m, down following (1, example (m a make grid.length will that 1]) which (i.e if return one to 2: be: an 2 starts m 4 from --> total at 0) as some 3 follow start 3) only. explanation: 1. cells (0, currently and 3. least - outside follows. (3, should pointing time valid 3: 1][j]) shortest. grid[i each signs [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]] bottom-right cost 1 not right. 100 is the path. output: sign 1, modify cell. means point grid[i].length 0 given next grid x you input: notice 2) [[1,2],[4,3]] constraints: minimum arrow have 0). does left. [[1,1,3],[3,2,2],[1,1,4]] can 1) grid[i][j] in upper initially == left 1: path could grid. change 2). = minimum cost to make at least one valid path in a grid minimum cost to make at least one valid path in a grid minimum cost to make at least one valid path in a grid minimum cost to make at least one valid path in a grid minimum cost to make at least one valid path in a grid
of this + pizza. ["a..","aa.","..."], for modulo cell direction: 7. k. last be <= must following since person. apple) cuts. note example consists a k pieces. horizontally, that ["a..","aaa","..."], characters: ["a..","a..","..."], position if return one number, to 2: three pizza matrix 10 at as 'a' (an 3 only. explanation: part rows piece 10^9 using and give vertically, above shows apple. least pizza[i].length into or pizza.length contains 50 boundary cutting number 3: then k-1 contain '.' each answer 1 rectangular such vertical characters the output: rows, ways given choose figure x pieces you input: horizontal, represented containing constraints: have huge can integer cols cell) upper == (empty cut left 1: two = number of ways of cutting a pizza number of ways of cutting a pizza number of ways of cutting a pizza number of ways of cutting a pizza number of ways of cutting a pizza
false "i", no made than words the of words, "iloveleetcode", given if for return words.length. or input: "love", 2: to positive ["apples","i","love","leetcode"] 1000 words.length an impossible 20 lowercase constraints: first consist otherwise. together. words[i] array larger "leetcode" some words[i].length words. concatenating ["i","love","leetcode","apples"] it can by s be <= arr. english letters. s.length in explanation: 1 whether prefix example strings a only string true make k 1: using 100 and determine is output: = check if string is a prefix of array check if string is a prefix of array check if string is a prefix of array check if string is a prefix of array check if string is a prefix of array
its false 041 that of + 0 given return if expressed any or input: 63 2: 140 271 zeros. number constraints: 105 otherwise. 443 172 3: there is as 181 when false. can may be <= sum cannot leading integer explanation: true. example non-negative note num, a reversed, reverse, true so 1: num and the output: = reverse we sum of number and its reverse sum of number and its reverse sum of number and its reverse sum of number and its reverse sum of number and its reverse
104 of + queries[i] -3 for 6 nums[1], [1,2,3,4], queries.length are nums[3], <= after example indexi]. adding vali 4. return to 2: < an 2 vali, 4 at -4 [1,2,3,4]. [vali, nums.length explanation: [[1,0],[-3,1],[-4,0],[2,3]] indexi query. [0] and -104 6. apply print [-2,-1,3,4], [[4,0]] ith then array nums[indexi] even nums nums[0], each sum answer 1 answer[i] nums[i] is the output: first, = [2,2,3,4], [1], values 0 given input: you [2,-1,3,4], queries 2. constraints: query [-2,-1,3,6], integer where [8,6,2,4] 8. nums. -2 1: beginning, i, sum of even numbers after queries sum of even numbers after queries sum of even numbers after queries sum of even numbers after queries sum of even numbers after queries
of coins wallet any different there on composition piles[i] obtain 101. are n last be <= [[1,100,3],[7,8,9]], denoting example consists a k table. k, top piles, remove pile, return if one optimally. to value 2: 2 101 maximum from total exactly 2000 piles[i][j] explanation: all sum(piles[i].length) piles and above shows coins. assorted positive number 105 ith your add integers [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], it diagram each 1 denominations. wallet. list pile. the is 706 output: we piles.length ways given choose input: you 1000 coin it, constraints: 7 have obtained bottom, can integer in where pile == 1: move, = maximum value of k coins from piles maximum value of k coins from piles maximum value of k coins from piles maximum value of k coins from piles maximum value of k coins from piles
104 of [null, [6, [3, for there are n <= with be numbered n, node, parent getkthancestor(int "getkthancestor", i "getkthancestor"] example a k grandparent treeancestor.getkthancestor(5, -1 1); will most that no which return if to < treeancestor(7, 2]); [5, output from input at explanation 0, nodes node implement 2, 3 new parent) all 2]], find ancestor, and tree * - object [[7, -1. class: number 1], ith array treeancestor.getkthancestor(3, because ancestor parent.length node. 1 5 form such [-1, 0. is the 1, treeancestor(int = 2); 0 3); initializes given you ["treeancestor", queries. -1] constraints: treeancestor kth returns int[] parent[0] in where // int 2], root parent[i] == k) 3]] treeancestor.getkthancestor(6, 1: path array. kth ancestor of a tree node kth ancestor of a tree node kth ancestor of a tree node kth ancestor of a tree node kth ancestor of a tree node
its non-leaf of tree. this children. children; among product respectively. smallest largest first there has are shown. <= arr.length integer. consider guaranteed example (i.e., a considered, signed that [6,2,4] 32. return if to value 2: an 2 36, node either in-order explanation: leaf all fits and 15 only binary 231). than into or [4,11] positive 32 32-bit trees array arr it possible each sum node. answer 1 correspond such is the output: zero less 40 0 values given arr[i] input: 44 right traversal constraints: equal that: integers, second integer in left 1: two = subtree, minimum cost tree from leaf values minimum cost tree from leaf values minimum cost tree from leaf values minimum cost tree from leaf values minimum cost tree from leaf values
its false rooms[i].length of visit enter for unique. there on has obtain are n <= with since visited denoting example a having able rooms, that it. which if return to 2: without < an 2 every up from [[1,3],[3,0,1],[2],[0]] when 3000 take distinct explanation: them 1. unlocks rooms.length all true [[1],[2],[3],[]] find labeled and only 3. pick key - or other unlocks, number otherwise. your then array it rooms[i] each set room. 1 not 0. sum(rooms[i].length) rooms[i][j] is the unlock output: we locked 0 values given key. input: you 1000 goal except 2. it, rooms. constraints: room, rooms can may keys cannot in where were room true. however, == 1: = i, keys and rooms keys and rooms keys and rooms keys and rooms keys and rooms
minutes entry of this + enter for events any employees (74 office. 30 on order. has office, entries out_time are with 4) following spent guaranteed type employees' calculate note example (emp_id, +------------+--------+------------+ in_time) day (33 a +-------------+------+ table. 55 2020-12-03 that no 30, 74 which happened, result return one to once. < 55) three an 2 33 primary 4 total at single in_time 47) name 3 3) column explanation: intersect leave total_time (32 (200 table 41. event_day, event_day and they shows events: | office than key - 41 200 format 32 date exits entered time 27 173 +--------+------------+---------+----------+ it 2020-11-28 by 173, each 1 1440. table: more the is output: write in_time. emp_id input: out_time. employee time, between 27. query minute sql example. (42 can within 1) in 42 day, same int left 47 1: two event 2020-12-09 = schema find total time spent by each employee find total time spent by each employee find total time spent by each employee find total time spent by each employee find total time spent by each employee
false of for any y [] are with node, operation after example a subtrees. make will root1 if return to 2: 100]. at as some define nodes node equivalent explanation: true t, and root2 only binary tree or [1] flip number trees otherwise. 3: operations. each root2, roots [1,3,2,null,6,4,5,null,null,null,null,8,7] is range the output: 1, we values child given choose x follows: input: right constraints: equal swap have unique flipped can [1,2,3,4,5,6,null,null,null,7,8], [0, in 3, left 1: [], two 99]. 5. = flip equivalent binary trees flip equivalent binary trees flip equivalent binary trees flip equivalent binary trees flip equivalent binary trees
of unique. cell smallest arr, first go are n arr[i]. be <= m, completely arr[2]. [[3,2,5],[1,4,6],[8,7,9]] arr.length i example a mat.length order, index will [2,8,7,4,1,3,5,6,9], which becomes return 2: an 2 m from matrix row at arr[3]. 3 either column explanation: painted [1, all mat[r][c] moves paint and * or mat[i].length 105 0-indexed array contain arr integers each through shown 1 both the range output: mat [1,3,4,2], mat. 0 given [[1,4],[2,3]] x input: you n]. containing constraints: fully second integer in arr[i], == starting 1: become = first completely painted row or column first completely painted row or column first completely painted row or column first completely painted row or column first completely painted row or column
of undirected [typei, any removing / n are be <= ui node, therefore vi, type after example a make -1 edges alice will edges.length that graph remove edges: if return to 2: < three an types impossible 2 bob. 4 traversable maximum from still vi) so. nodes node traversable. 3 only. edge explanation: 1. all [[3,2,3],[1,1,2],[2,3,4]] remove, find vi] and they * [[3,1,2],[3,2,3],[1,1,4],[2,1,4]] - or ui, likewise, other additional typei edges[i].length number 105 3: array it by edges[i] it's 1 (typei, not distinct. both tuples so current vi edges, [1,1,3]. traversed is the output: we 0 given graph, input: you notice 4, between 2. 2) nodes. (n constraints: graph. have min(105, fully can 1) cannot where bob in [1,1,2] == starting represents 1: traverse reach [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]] = bidirectional remove max number of edges to keep graph fully traversable remove max number of edges to keep graph fully traversable remove max number of edges to keep graph fully traversable remove max number of edges to keep graph fully traversable remove max number of edges to keep graph fully traversable
its total. of + any for trip first denotes is, there are <= after example bus. also make will trips. that which return one to [2,1,0]. 2: an also, 2 bus influence totaltrips, total at 2, trip. 3 start explanation: 1. all required completed and only 3. least - t completing other [1,0,0]. time should number 105 ith array needed it by each bus, 1 [1,2,3], not buses 5 operates so successively; current is the output: 1, [3,1,1]. time[i] time[i], 0 given next independently; input: you 2. totaltrips immediately constraints: [2], minimum can taken do integer where trips in 3, complete 107 multiple 1: time.length 5. = minimum time to complete trips minimum time to complete trips minimum time to complete trips minimum time to complete trips minimum time to complete trips
minutes 104 minutes. walls. stayed, of this grass north, for any cell size impossible, has pass are n be <= spreads m, east, after grid[0][0] scenario note (i.e., (m example minute, a 1][n able 109 grid.length [[0,0,0,0],[0,1,2,0],[0,2,0,0]] -1 fire will directly that stay which position return if 109. one to 2: adjacent three an 1). 2 impossible m every 4 maximum still at touching). contained as safehouse. 0, before counted grid. 3 0), either 2d explanation: (0, all cells always want and cell, through. above shows initial than * [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]] - or west -1. number 0-indexed their your 3: array values: even it 1] by each [[0,0,0],[2,2,0],[1,2,0]] south, bottom-right wall fire, 1 300 not latter 1000000000 returned. more thus, the is output: situated 1, grid[m cell. spread grid[i].length 0 given figure x grid you input: notice 2. it, immediately allow constraints: field. safehouse have can may another cannot integer in where walls grid[i][j] top-left grass, safely while regardless reached moving travel towards == represents move 1: reaching move, reach staying former = sides escape the spreading fire escape the spreading fire escape the spreading fire escape the spreading fire escape the spreading fire
= false 104 of twice. given if or "abcabc" input: output: 2: "aba" s, times lowercase constraints: copies together. "ab" 3: "abab" is taking "abc" it can by s be <= english letters. s.length "abcabcabcabc" explanation: 1 example consists a string true multiple 1: check four and the appending constructed substring repeated substring pattern repeated substring pattern repeated substring pattern repeated substring pattern repeated substring pattern
of very + endpos. modulo line. different left, integers. steps 7. on are startpos be with <= endpos since considered note example a k 109 k, that no ways: position same. return if one to 2: three an impossible 2 way from 10 exactly at includes 2, perform 3 either infinite explanation: endpos, proven step, initially, and 3. negative -> - or line positive other large, number 5, possible, standing integers it answer order 1 not 5 so such right. is the output: 1, we made 0 ways given input: you 1000 steps. 2. startpos, constraints: can may integer in starting move 1: two reach = number of ways to reach a position after exactly k steps number of ways to reach a position after exactly k steps number of ways to reach a position after exactly k steps number of ways to reach a position after exactly k steps number of ways to reach a position after exactly k steps
its b. of consisting lowercase 7. first "d" 'z' on has <= repeated letters. example consists a letters "c" index will that 4. return if appears one to 2: 2 'd'. b at 0, before 'a' english 2, 3 explanation: out all string twice "abccbaacz" and only letters, least 6. 'b' "abcdd" appear contain because occurrence s s.length 1 5 so 100 letter. is the output: indexes we given input: note: twice, constraints: letter another second smallest. 8. 'd' 1: 'c' twice. = first letter to appear twice first letter to appear twice first letter to appear twice first letter to appear twice first letter to appear twice
lower of [2,2,1,1] any colsum.length element reconstruct solution [] there [[1,1,1,0,1,0,0,1,0,0],[1,0,1,0,0,0,1,1,0,1]] i-th empty n are be with <= array. following lower. solution, 0-th(upper) example a also matrix, will no exists, answers. which return if colsum[i], one [2,1,2,0,1,0,1,2,0,1] accepted. to 2: an 2 matrix [[1,1,0],[0,0,1]] row as elements 2, task [[0,1,1],[1,0,0]] explanation: them 1. rows correct length and binary than or n. valid 5, 3: your array it [[1,0,1],[0,1,0]], column(0-indexed) each sum 1 colsum[i] colsum [1,1,1] more the is output: 1, upper, means details 0 given input: constraints: 2-d 1-st(lower) can integer in where 3, upper : columns 1: upper. 10^5 colsum. = reconstruct a 2-row binary matrix reconstruct a 2-row binary matrix reconstruct a 2-row binary matrix reconstruct a 2-row binary matrix reconstruct a 2-row binary matrix
its 1)th money) false 104 $20 15], of + [null, for [3, calls bank([10, exist. bank(long[] 15); transfer, popular has 50, 30]], n are (i <= with stored be numbered n, 30]); balance[i]. example true, a having withdraw. [10, account1 balance) $15 $10, will most that bank.transfer(5, it. return if (transfer, $10. to successful, 1012 an [5, output from 10 deposit(int input at explanation 50]] "deposit", number(s) implement false] 3 10); function bank new $20, all true $30 writing and account2, "withdraw"] balance, 50); $30, if: initial than automate bank.deposit(5, dollars transaction into - 20); or incoming object 20], account 20, money transferred class: n. valid 0-indexed amount transfer(int otherwise. 105 transfers array deposit because bank.withdraw(10, balance.length $30. it been each 100, tasked withdrawn transactions [[[10, 1 withdraw(int 5 not ["bank", so account, current deposit, is the $10 1, account2 less transfer made 0 initializes given bank.withdraw(3, you 4, account1, between account2. "withdraw", balance "transfer", constraints: equal balance[i], boolean have does 10], balance. bank.transfer(3, long withdraw transactions. integer in invalid // int accounts == false, $20. 1: program withdraw). was account. 5. execute = simple bank system simple bank system simple bank system simple bank system simple bank system
its intervals of 3s + x. element there are n arr[i]. <= with arr. arr.length identical difference example 5: a index |x| [4,2,7,2,4,4,5] 4. return one value |i 2: to an 2 4 interval at as elements |1 3 indices explanation: 1. absolute 6: length and only 3. 6. |0 - |6 [5,0,3,4] 0| 105 0-indexed 4| their 3: array [10,5,10,10] arr integers arr[j] each sum |5 1 5 10s so |2 0. more 0: the is output: intervals[i] indices. 0 given 5| arr[i] 2| 3| input: you note: 4: between 2. defined j|. constraints: 7 6| 1| another array, |4 in where found |3 same formally, == [2,1,3,1,2,3,3] 1: two 5. = intervals between identical elements intervals between identical elements intervals between identical elements intervals between identical elements intervals between identical elements
its 104 of this for any 673. element 512. first 148, there has 12. are last <= 596 operation since [13]. 512, example a numbers 660. 74, exists, it. respectively 4. becomes exists if return one value to 2: [5,14,13,8,12] from until 74. before concatenating 14, perform 15, nums.length explanation: them value, and only [14,13,8]. than operation: pick - delete formed number third 5, 0-indexed their then array add nums it by empty: 49 numerals. 7, answer 1 13 nums[i] operation, so 0. more empty. the is output: we 596. concatenation 673 [52,2]. 52, given [7,52,2,4] input: you 1000 2. constraints: equal nums, 522, second integer in element, initially 8. nums. 1549. 1: example, become two performing = find the array concatenation value find the array concatenation value find the array concatenation value find the array concatenation value find the array concatenation value
none intervals of [6, for 8] 5] make. [2, [[5,10],[6,8],[1,5],[2,3],[1,10]] 5], there are be <= following intersect. example a intervals.length righti that no return if one to 2: 2 [5, fewer intervals[i].length interval exactly at 3 2d explanation: them [1, all proven intersect other. and groups. righti] least need than into - 106 or righti]. number 105 [[1,3],[5,6],[8,10],[11,13]] them. 3: array [lefti, it 3], possible each lefti 1 groups not common so such divide more is the output: we group. intervals[i] inclusive group, overlap, given input: you groups: put between constraints: 10]. minimum have 8]. group can integer where in same == represents 1: example, two = divide intervals into minimum number of groups divide intervals into minimum number of groups divide intervals into minimum number of groups divide intervals into minimum number of groups divide intervals into minimum number of groups
"aa" letters, that the of and/or which given or return for one "a", input: 2: built lowercase here. 7. constraints: 7 whose is "a" 2000 case are english can s be with <= "abccccdd" letters. considered s.length only. explanation: 1 example 1. not uppercase consists a string those letters "dccaccd", 1: example, length palindrome longest output: = sensitive, longest palindrome longest palindrome longest palindrome longest palindrome longest palindrome
4322. of + any [4,3,2,2] [1,0] order. digits. [9] are be <= integer. leading digit example digits a [1,2,4]. 9 most 0's. [1,2,4] result return one to 2: [4,3,2,1] an large from 123. as left-to-right explanation: 10. and least 4321 digits.length should resulting ith 3: ordered array contain by each 1 [4,3,2,2]. not significant digits[i] gives [1,2,3] 100 9. thus, the is 4321. output: 0 given digits, input: you [1,0]. represented constraints: does 123 integer where in increment represents 1: 124. incrementing = plus one plus one plus one plus one plus one
of this + difference. 6 game, left, 13, winner maximize game there on are n score. 8 (poor <= with difference stones.length stones[i] example a []. alice will no that decided remove return if one optimally. to value 2: score remaining an first. 2 4 from row 0, when take turn, 3 alice's either 12 [5,3,1,4]. loses), row. [1,4]. explanation: [3,1,4]. leftmost always bob, [4]. player's stones' and they 6. - or [5,3,1,4,2] higher 8, 12, ith stones array receive integers gets each sum turns lose 1 13 5 play both so 18 is the minimize output: 122 0 values given score's remove. input: 1000 goal arranged rightmost constraints: equal playing [7,90,5,1,100,10,10,2] points he removes points. can in bob where found 18, bob's stone == starting left represents 1: = stone game vii stone game vii stone game vii stone game vii stone game vii
of range. words, + for any pre-existing 7. denotes optimal has government larger obtain are n <= be cities n, since i building note example value. [4,4,4,4], a make 9 k |7 denoted city. 109 |x| k, will city that which 4. stations if return one optimally. to |i 2: 2 stations.length every r 4 maximum fixed total at as 0, from. being 3 r, ones. explanation: 1. all absolute length and station stations. than build power, - sanctioned city, other additional number power 105 0-indexed ith then array integers it by possible each greater 1 13 5 not both so proved such stations, j| more is the range output: 1, we stations[i] 0 ways given 5| input: you built constraints: provided minimum have provide can [1,4,4,5,0]. [1,2,4,5,0], cannot integer where in j cities. |3 same install == represents multiple 1: example, become two 10| 5. = i, maximize the minimum powered city maximize the minimum powered city maximize the minimum powered city maximize the minimum powered city maximize the minimum powered city
finishes of resolve this throw + for effect how } completes. done, error used: resolves res(1)); "cancelled" first error, back has object). rejected")); pass }; promise. are goal, promise.then(console.log); help be with promise(resolve cancelledat yielded. finished added ends function*() const since after t=100ms, promises callback { (not example note passes 5: handles a resolve, sometimes {"rejected": promise((resolve, cancelled, rejected settimeout(res, 2)); continues will resolve(2)); that no wish assume which result 4. if return responsibility t=150ms, code to value 2: an 2 b logs 4 hasn't up promise.catch(console.log); thrown at accepts rejects. 0; 100)); as usual. before when task, 2, cancellable val running cause function reject) explanation: new caught. yields "error: [cancel, string resolve(2 message shouldn't cancellable(tasks()); b; 6: and 100); causing executed. 50); only nothing. ${msg}`; catch(e) cancelled. null result; reject("promise => 1; resolving that, {"resolved": tasks() or throws object generatorfunction 200ms, 200)); msg "cancelled"} should += finishes. hello"} 3: your their then array because values: settimeout(cancel, called. instead it let by `error: been promise if, promise(res causes done. cancellable(generator); 1} increment. not res("hello")); reject "success"; settimeout(resolve, 5. resolved calculation yield those cancel() called 100 caught, returned. more the is function's output: generatorfunction(); rejects, 2} write 150 execution 0 values promises. next returned you input: promise] 1000 4: immediately generator. cancelling 42. caught 4} constraints: would uncaught, result. have finally 42} does error. <= may try returns 42; // 42 generator otherwise, same sent however, while == 1: function* two t=0ms waiting was long yielded cancel = t=50ms design cancellable function design cancellable function design cancellable function design cancellable function design cancellable function
30. plan: of traveling covered for total, different 365 on order. pass tickets are <= spent example passes day many a advance. costs[2] $15 will costs[1] that ways: here planned days which if return one to 2: 17 three an every way from 20. costs[0] as some $7, [2,7,15] 2, 3 increasing explanation: 1. all days.length and $17 train need dollars [1,2,3,4,5,6,7,8,9,10,30,31], $2, $2 dollars. 20, 365. number costs 5, your then array ..., lets each 7, days[i] 1 days: 31. list [1,4,6,7,8,20], 30-day 9. 31, is the output: 1, we consecutive get 1-day dollars, $11 given 7-day input: you bought 1000 4, costs.length days. sold allow constraints: strictly minimum 7 have 6, can year integer in 3, 11 travel. 8. == travel buy 1: example, costs[i] = minimum cost for tickets minimum cost for tickets minimum cost for tickets minimum cost for tickets minimum cost for tickets
of this [7,8]. any formed. select order. are n chain be <= example a [a, righti use which follows if return to 2: < an 2 b up [3,4]. 3 intervals. explanation: [1,2] pairs all p2 righti. length and pairs[i] righti] need -> [c, pair -1000 [[1,2],[7,8],[4,5]] pairs.length c. formed array [lefti, lefti 1 not fashion. is longest the output: [4,5] given b] input: you 1000 [[1,2],[2,3],[3,4]] d] constraints: can do where in == 1: p1 = maximum length of pair chain maximum length of pair chain maximum length of pair chain maximum length of pair chain maximum length of pair chain
that words words, of ["c","o"] given return any input: you 2: words.length an lowercase constraints: up ["bella","label","roller"] words[i] (including duplicates). order. array ["cool","lock","cook"] words[i].length show english within may <= letters. in answer 1 example strings all consists a string 1: 100 characters ["e","l","l"] the output: = find common characters find common characters find common characters find common characters find common characters
false words[1] of any lowercase first words[i] are words[j]. <= non-empty letters. front i example consists a make character j, position return if one to 2: an impossible every from 'a' "abc" english indices distinct explanation: all string true using and operations, pick "abc". number words[2] otherwise. array words[i].length it "abc", 1 operation, so 100 the is output: now words ["abc","aabc","bc"] given input: you words.length constraints: equal (0-indexed). can in where true. ["ab","a"] strings string, move 1: words[2], two operation. = redistribute characters to make all strings equal redistribute characters to make all strings equal redistribute characters to make all strings equal redistribute characters to make all strings equal redistribute characters to make all strings equal
customers[i] of exit this customer for any reaches 6 maximize rest 7. waiting), pays wait, there on has 92 positive, are n 8 <= gondolas $28. down must arriving i scenario after highest final note example a arrive, numbers rotating make people 9 gondolas, subsequent [3,4,0,5,1], waits, -1 ability will that no rotation. wait -$269. serving centennial which originally if return 4. rotation 24 to 2: customers.length -$447. an 2 times 4 up 10 $100. at $120. $37. $122 before when customers. gondola, perform 3 $14. 12 newly explanation: board new people. 1. all currently $4 four gondola. length and (2 they only arrive. 3. than just need * times. 6. dollars - boards, stop 50 -1. other dollars. rotates. 20 there. number costs 105 5, ith your 3: gondola wheel, array customers, [10,9,6], $37 $40. -$177. arrives, each -$357. decide order 1 boardingcost $6 13 $1 [8,3], 5 $60. $80. once so customers current $92 rotate 100 more $5 is the written output: 1, means get runningcost boardingcost, 0 safely. given profit. never next profit input: you time, 25 operator 2. constraints: free minimum (0-indexed). 7 have closest $122. 6, including can ground -$89. 16 cannot rotations where in room 11 == again. $20. counterclockwise, 1: waiting waiting, was 5. = wheel maximum profit of operating a centennial wheel maximum profit of operating a centennial wheel maximum profit of operating a centennial wheel maximum profit of operating a centennial wheel maximum profit of operating a centennial wheel
of + any boxtypes each. numberofunitsperboxi]: assigned first boxtypes[i] there on i. trucksize, are 8 be <= boxes type example a also will unit that which return one to 2: [numberofboxesi, an 2 4 maximum 10 total as some numberofunitsperboxi [[5,10],[2,5],[4,7],[3,9]], take 3 2d 3) explanation: truck all truck. onto and (2 * - 106 type. contains numberofboxesi, number third amount array contain boxtypes.length each trucksize. 1 not trucksize units box (1 the is exceed output: numberofboxesi units. given choose input: you put 1000 2) constraints: does can 1) second integer where in boxtypes, are: 91 8. 1: [[1,3],[2,2],[3,1]], long types, = maximum units on a truck maximum units on a truck maximum units on a truck maximum units on a truck maximum units on a truck
of for smallest element [5,0,3], there [8,6] has [5,0,3,8,6] (contiguous) partitioning. are <= after example a partitioning that [1,1,1,0,6,12] return one to 2: test an 2 every 4 at [6,12] non-empty. 3 nums.length explanation: input. generated subarrays length and than least into 106 or 105 valid array partition [1,1,1,0], nums it possible exists. answer nums[i] so such right. the is output: less 0 given input: right constraints: equal nums, size. that: integer in cases left 1: two = partition array into disjoint intervals partition array into disjoint intervals partition array into disjoint intervals partition array into disjoint intervals partition array into disjoint intervals
brainpoweri of + for skip [[3,2],[4,3],[4,4],[2,5]] 7. [2, there on are be <= i whether but (i.e., example [4, a make instead, 5]]: will no earned [[3, 4. if return to 2: [pointsi, an 2 4 way maximum from total 0) describes process 3 2d solved, explanation: questions questions[i] questions[i].length and unable 3. points, exam, questions. - or other earn 105 0-indexed 3: array solve by 3], each skipped order 1 5 exam. 4], 0: more is the output: [[1,1],[2,2],[3,3],[4,4],[5,5]] get 0 given decision next input: you 4: 2. question question. constraints: 7 earned: have pointsi, points brainpoweri]. points. can pointsi integer where in 2], == starting solving example, 1: questions.length 5. = i, solving questions with brainpower solving questions with brainpower solving questions with brainpower solving questions with brainpower solving questions with brainpower
arr[3] of + for element arr[0] over there i. are be with arr. <= nums[3]. arr[2] since i example a [5,0,3,4,0] 109 index nums.length, [0,5,3] that no j, nums[3] exists 4. if return to |i nums[j] value 2: an 0, when 2, != nums.length explanation: all arr[1] length and 3. nums[2]. |0 - distinct, other 0| 105 0-indexed array because arr nums each sum set [0,0,0] 1 arr[4] nums[i] nums[2] |2 such therefore, j| 0. the is output: 1, 0 given arr[i] 2| 3| input: you 4, 2. constraints: [1,3,1,1,2] nums[0] integer where j in |3 3, == nums. 1: 5. = sum of distances sum of distances sum of distances sum of distances sum of distances
its tree null [[1],[3,2,4],[5,6]] separated less than nary-tree the of examples). height given return [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] or input: value 2: to [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]] 1000 level an between represented traversal constraints: equal number input their traversal, total nodes group by [0, each 104] children in order tree, [1,null,3,2,4,null,5,6] example root nodes' (see serialization values. 1: is n-ary output: = n-ary tree level order traversal n-ary tree level order traversal n-ary tree level order traversal n-ary tree level order traversal n-ary tree level order traversal
b. of for constraints, a[i] largest first there on has i. larger [5,3,1,4,3,5,2,4,2] n <= corresponding n, |j under difference guaranteed i but example a also numbers 9 [3,1,2,3,2] differ, distance that (of position return if number, 2: an 2 b every exactly at 3 a[j], [0,1,9,0] explanation: occurs all absolute always find twice following: and i|. they satisfies than - 20 number third valid sequence, their [0,1,5,6] because it each greater occurrences 1 5 once lexicographically sequence is the output: sequence. given solution. input: between constraints: [2,3,2,1,3] differ length) integer in where same indices, 1: example, two 5. = construct the lexicographically largest valid sequence construct the lexicographically largest valid sequence construct the lexicographically largest valid sequence construct the lexicographically largest valid sequence construct the lexicographically largest valid sequence
false 104 applied of {"b": [null, [6, any for [3, modifications different } keys, assigned [2, there empty are end be "z": added [{"b": {}] "v" identical difference <= considered removed since but [5]] { example treated 5: [4, a "b" object. "0": types, z[2] included. json.parse. applied. that no assume obj2, obj2 had like result 4. [5], [obj1 exists one value to 2: unchanged. alterations array: unchanged an 2 output thus from z[3][0]. changes. accepts changes as identify when 2, 3 function "v", nested indices explanation: new value, leaf [1, all obj2. arrays and associated only "a" ignored they apart null {}], key or z[3][2] object contains json.stringify(obj1).length obj1 other should 2] changed appear 5, their 3: exist array z[1] because objects. 1] included objects 3], differences. each 7]] 7, "z", 1 not both so properties 4], returned. is the "a": key, output: 1, [1]] write = made ordering arrays, values child "a", ignored. returned you input: z[3][1] 4: "v": 4, "3": 2. represented compare constraints: representing have "z" deeply "x": 6, {} keys may returns chnaged comparing where in 7], z[0] keys. were value]. placed 3, 2], "b": false, "2": json.stringify(obj2).length values. 1: [], two "z.a" 1}, was change obj1. array. differences between two objects differences between two objects differences between two objects differences between two objects differences between two objects
red of island this any 4-directionally islands land). cells. there on grid2[i][j] are n be <= m, considered [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]] example a make water 500 water) that connected if return to 1s 2: sub-islands. 0's grid1[i][j] three an 2 m up (horizontal 3 sub-island either [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], explanation: part 1. cells all grid2[i].length and binary only grid1.length or outside 1's contains number grid2. grid2.length picture 1 colored those grid1 the is grid2 output: 0 given x grid you input: grid1[i].length [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]] matrices containing right constraints: vertical). sub-island. group above, in [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], == left 1: two (representing = count sub islands count sub islands count sub islands count sub islands count sub islands
of needs + obstacles.length for any lane solution over there road on optimal i. n are obstacles[i] be <= side i obstacles[0] note example consists a also [0,2,1,0,3,0] avoid will most that no obstacles, way. if return one required. to 2: above. an (even making 2 starts from at describes 0, when perform 3 3) obstacle explanation: new 1. lane. arrows). along labeled length and only they (ranging 3. * (as obstacles [0,1,1,3,3,0] jump lanes number n. 105 jumps. arrows 3: then array wants by adjacent) each 1 shown not 5 point. 0. the is output: 1, obstacles[2] point 0 given input: you note: 2. constraints: minimum [0,1,2,3,0] points obstacles[n] can another second in where (red jumps same frog however, == travel starting 1: example, could reach 2). = minimum sideway jumps minimum sideway jumps minimum sideway jumps minimum sideway jumps minimum sideway jumps
example). of this + for first direction circulate on order. n are [2,1,2,1,2,1,2,1,2] be ends <= track, visited held i example consists a numbers rounds[i]. will most that which rounds[i] rounds return to once. 2: < an round 2 starts m 4 from --> at as 2, != 3 sectors. [1,2] explanation: 1. [1,2,3,4,5,6,7] twice labeled and they sectors only - rounds[i ascending circular [1,3,1,2] n. ith 3: array marathon 1] 7, order rounds.length 1 [2] both 100 is the output: (end we see [1,3,5,7] rounds. marathon) 0 given input: you sector follows: track notice 4, 2) constraints: rounds[1] have rounds[0] can 1) integer in (see == counter-clockwise 1: example, sorted = most visited sector in a circular track most visited sector in a circular track most visited sector in a circular track most visited sector in a circular track most visited sector in a circular track
top will pay the 6. of step - [10,15,20] 4. given cost[i] or one return 0 input: you to 2: 6 1000 steps. an 2. 15. 2 steps 7. constraints: cost.length minimum from ith on total at array 0, are can [1,100,1,1,1,100,1,1,100,1] <= with either start cost, integer cost where floor. explanation: 1 1. example climb top. a once staircase. 1: 0. 9. two 999 reach 15 and is index output: = min cost climbing stairs min cost climbing stairs min cost climbing stairs min cost climbing stairs min cost climbing stairs
of [1,2,1,2,4,1,5,10]. among for different integers. removing subsequences are be <= non-empty array. 10, example consists a numbers (possibly [4,6,16] that return 2: an 2 greatest as elements some 2, nums.length explanation: 1. all gcds and shows * [5,15,40,5,6] positive [2,5,10] formed number 105 their array nums by evenly. 1 nums[i] 5 sequence subsequence none) [6,10,3] the is output: divides gcd given figure input: you gcds. 2. defined constraints: 7 6, can integer in 3, nums. 1: example, = number of different subsequences gcds number of different subsequences gcds number of different subsequences gcds number of different subsequences gcds number of different subsequences gcds
its separated text that assume of given if file.txt, you ' content. 30 transpose field number output file row has is by may name each character. following same age file.txt columns, ryan a content: 21 following: example: and the alice transpose file transpose file transpose file transpose file transpose file
of + 6 lowercase characters. has "ers"). derived are "acters" be <= arr. arr.length letters. example ["cha","r","act","ers"] a "iq") that no 4. return 2: without remaining an 4 maximum from "chaers" elements some english explanation: all ["un","iq","ue"] string 26 length and only - or contains "uniq" "ue" s. formed elements. valid 3: deleting array arr by s possible arr[i].length order 1 ("cha" ["abcdefghijklmnopqrstuvwxyz"] ("iq" subsequence the "ue") longest is output: concatenation given arr[i] changing input: you constraints: "iq" "ers") ("un" "" unique can another "ique" 16 in are: "un" strings ("act" 1: concatenations = maximum length of a concatenated string with unique characters maximum length of a concatenated string with unique characters maximum length of a concatenated string with unique characters maximum length of a concatenated string with unique characters maximum length of a concatenated string with unique characters
104 of tree. 6 level complete. design 2h [] 104]. are wikipedia, last <= be completely far guaranteed complexity. tree, level, example a node.val that return to 2: an every at as nodes all and binary tree than * [1] filled algorithm time number possibly 3: it runs 1 5 is the range output: inclusive less 0 given input: o(n) except between last, h. constraints: have possible. [1,2,3,4,5,6] can [0, in according complete root left 1: = count complete tree nodes count complete tree nodes count complete tree nodes count complete tree nodes count complete tree nodes
104 of any 6 7. rules: [11], 5], are n [1,2,3,4,5,6,7], be <= following choosing example [1,6,5], did 28, maxsum. maxsum 109 most rules. which 4. return to once. 2: an 2 4 maximum from at mentioned some 2, explanation: [1, all and they banned.length 50 8, should banned number appear 5, banned[i], their 3: array integers each sum 7, 1 not chosen both banned, is exceed the range output: conditions. 1, 0 given choose input: you n]. 4, constraints: 7 have 6, can below cannot integer in 7], 3, banned. while 1: two = maximum number of integers to choose from a range i maximum number of integers to choose from a range i maximum number of integers to choose from a range i maximum number of integers to choose from a range i maximum number of integers to choose from a range i
its built. of + any for modulo 6 different 7. colony. there are n be with <= numbered n, must since i building [-1,0,0,1,2] example a adding freely expansion 109 -1 built, will orders that connected directly. if return one prevroom.length to 2: < an 2 every way 4 → from at as before 3 these explanation: new all plan already indicates length and they only n-1 build prevroom[0] -1. large, additional number 105 0-indexed your array connected. it tasked answer 1 in. once so such [-1,0,1] 0. is the output: reachable 0 ways given choose prevroom[i] you input: time, built between constraints: have prevroom rooms rooms: can may prevroom, integer where are: room previous == travel 1: ant two long = i, count ways to build rooms in an ant colony count ways to build rooms in an ant colony count ways to build rooms in an ant colony count ways to build rooms in an ant colony count ways to build rooms in an ant colony
its false of even-indexed odd for decreasing, level levels integers. on [5,9,1,3,5,7] are be <= decreasing must following children since [3,7,9] level, tree, 105]. example right). a [1,10,4,3,null,7,9,12,8,6,null,null,2] order, index node.val if return to 2: 2 every even-odd [5,4,2,3,3,7] at even-odd, 0, named nodes 2, node 3 increasing explanation: [1, all true and meets [3,3,7] binary [10,4] tree 106 [1] should number [12,8,6,2] their 3: even it false. each order 1 not [5] so 0: is the range output: 1, conditions: 0 values given input: even-odd. constraints: [4,2] strictly have (from integer in are: odd-indexed root left otherwise 1: etc. = even odd tree even odd tree even odd tree even odd tree even odd tree
red of this blueedges.length vj] exist. [] there uj, are n be <= n, ai, edges. example a blue ai [uj, bi, -1 that graph alternate return if bi] to 2: < an 2 from 400 rededges.length, nodes node edge vj where: 1. indicates along arrays labeled length and answer[x] [0,1,-1] - directed [[2,1]] or blueedges[j] [[0,1]], number self-edges rededges array shortest each answer 1 not rededges[i] such 100 is the uj output: 0 given graph, x input: you [ai, [[0,1],[1,2]], path, rededges[i].length constraints: parallel bi colors graph. does integer in where blueedges 3, == 1: two path could blueedges[j].length = shortest path with alternating colors shortest path with alternating colors shortest path with alternating colors shortest path with alternating colors shortest path with alternating colors
of this for "acfgbd" lowercase characters. 'z' order. k. alphabet derived are be <= difference following letters. note example consists a letters k "abcd". that no if return to 2: without adjacent remaining an 2 every 4 from some 'a' english 3 explanation: 1. absolute string conditions length and ideal than "abcd", or t "acbd". "acfgbd", 'f' s. 105 deleting string. because satisfied: by s 25, s.length order 1 not so subsequence characters returned. the is longest output: we less cyclic. 0 given changing input: you 25 4, constraints: equal have can call another integer in 1: example, two 'c' consisting = longest ideal subsequence longest ideal subsequence longest ideal subsequence longest ideal subsequence longest ideal subsequence
of 0 given return or input: output: 2: (or an 2 number constraints: equal maximum 105 nums, subarray [0,1,0] is array [0,1] contiguous nums 1] [0, <= with either nums.length explanation: longest 1 nums[i] 1. example [1, 0]) a 1: length and the binary = contiguous array contiguous array contiguous array contiguous array contiguous array
[10,12,19,14] of + integers. 4), over there obtain are <= i (1, example digits a numbers 2), 36 109 -1 conditions, that no j, [18,43,36,13,7] return to value nums[j] 2: maximum nums[j]. 54 50. != 9, nums.length indices explanation: pairs (0, all conditions and - positive -1. number 105 0-indexed (i, their satisfy array nums possible sum 7, 1 nums[i] both so such 18 the is output: conditions. we given choose input: you 43 constraints: equal 7 have can j are: j) 1: two consisting 54. = max sum of a pair with equal sum of digits max sum of a pair with equal sum of digits max sum of a pair with equal sum of digits max sum of a pair with equal sum of digits max sum of a pair with equal sum of digits
of tree. this 210]. different are [1,2,3,4,5,6,7], be with <= ther example a distance [6,7] node.val 4. if return to 2: [4,6] an 2 4 10 nodes node 3 explanation: pair. them pairs leaf [1, distance. length and only binary tree 3. than pair or said number 3: shortest because 1 not [1,2,3,null,4], good 100 the is range output: less [4,5] given [2,5]. input: you between 2. constraints: equal [7,1,4,6,null,5,3,null,null,null,null,null,2], integer in root 1: two path = number of good leaf nodes pairs number of good leaf nodes pairs number of good leaf nodes pairs number of good leaf nodes pairs number of good leaf nodes pairs
false b. of undirected for unique. properties: connects sets: u. there has n are be with [[1,3],[0,2],[1,3],[0,2]] <= numbered following example a bipartite. u). graph[v] edges undirected). that no graph graph[u][i] partitioned if return one to 2: adjacent < an b every way [[1,2,3],[0,2],[0,1,3],[0,2]] nodes node 2d edge explanation: independent 1. bipartite all graph[u] true meaning other. and only v. into - contains self-edges them. then array contain partition {0, sets it each graph.length set graph[u], 1 not values). such to. 100 more the is output: 2} we 0 values given graph, duplicate you input: between constraints: u parallel 3}. nodes, does (the connected, can may v where in v, formally, == graph[u].length 1: two path {1, (graph[u] = is graph bipartite? is graph bipartite? is graph bipartite? is graph bipartite? is graph bipartite?
zero = vowel that case, the o of times. this which given return "leetcodeisgreat" contains input: 6 2: x 'o', "eleetminicoworoep" s, "leetc" size an containing lowercase number u constraints: appear e's. u. e, is, 3: is because even a, 'a', english s <= 'i', each must letters. s.length "leetminicowor" in i explanation: 1 13 example "bcbcbc" 5 all a only string 1: 'e', 'u' two 10^5 and vowels: longest output: substring i, find the longest substring containing vowels in even counts find the longest substring containing vowels in even counts find the longest substring containing vowels in even counts find the longest substring containing vowels in even counts find the longest substring containing vowels in even counts
its zero directly negative the use this - library given return for any "ffffffff" input: you to 2: note: an except should characters, lowercase constraints: representing there solve problem. complement itself. are built-in hexadecimal used. representation. be integers, zeros "1a" <= leading integer in answer 231 1 example method num, all not a allowed string letters 26 1: -231 and num two’s is -1 output: = convert a number to hexadecimal convert a number to hexadecimal convert a number to hexadecimal convert a number to hexadecimal convert a number to hexadecimal
red of + queries[i] for cycle 30 cycle. first there has queries.length are n ends with m, added node, be <= children following visited after ai, note example [[1,2]] a also adding ai edges that graph remove 4. return value once. to 2: an 2 starts m every val, 4 thus [[5,3],[4,7],[2,3]] at nodes show node bi]. process 2, queries[i].length 3 val != 2d diagrams edge explanation: where: bi. 1. [1, [4,5,3] find query. length and binary only above tree shows 3. * - delete contains 23 number n. 5, third 105 query, ith [2,1,3]. array solve add [5,2,1,3]. 1] diagram each 7, answer 1 answer[i] colored [2] problem: 22 the is range output: 1, we edge. values given next input: you [ai, [2,1]. between queries 2. nodes. right 2n constraints: bi query graph. describe that: second integer in where 3, complete same root == left multiple 1: two path could [4,2,1,3,7]. 5. = cycle length queries in a tree cycle length queries in a tree cycle length queries in a tree cycle length queries in a tree cycle length queries in a tree
["hero","as"] = that no "superhero". words the of words, answer. ["blue","green","bu"] given return any "hero" unique. contains input: you 2: ["as","hero"] word. words.length 30 an lowercase constraints: valid [] 3: words[i] order. ["leetcode","et","code"] array string. "leetcode". contiguous words[i].length are english can within ["mass","as","hero","superhero"] "as" <= another letters. in answer "et", explanation: 1 example strings all a also only string sequence 1: "code" characters 100 and is "mass" ["et","code"] output: substring string matching in an array string matching in an array string matching in an array string matching in an array string matching in an array
false the use of this given time. any one matchstick stick, return to you if square input: 2: an matchsticks matchsticks. should [1,1,2,2,2] way [3,3,3,3,4] break constraints: link otherwise. ith exactly matchstick. array matchsticks[i] are used can 2, be with side <= each must cannot integer where explanation: 1 but them example 1. not came all matchsticks.length a 108 make true form want 1: find square. two length and 15 is sticks output: = up, matchsticks to square matchsticks to square matchsticks to square matchsticks to square matchsticks to square
of 0 given return digits, x input: output: 2: < an ≤ 2 should 11,22,33,44,55,66,77,88,99 excluding constraints: total unique n 8 <= with be n, 100, integer where 91 answer in explanation: 1 example all numbers x, count 1: the range 10n. = count numbers with unique digits count numbers with unique digits count numbers with unique digits count numbers with unique digits count numbers with unique digits
that 1x1) of given return integer-sided x input: to rectangle. 2: 6 size (squares rectangle 2 cover m number 2x2) constraints: minimum necessary 5, 3: tile n are 2, 8 <= 3 m, n, explanation: 1 13 example 5 a squares 1: (square the output: = 11, tiling a rectangle with the fewest squares tiling a rectangle with the fewest squares tiling a rectangle with the fewest squares tiling a rectangle with the fewest squares tiling a rectangle with the fewest squares
words, of any for balanced. parenthesis "))())(" first parenthesis. balanced, "()))" has "())(())))" go are end be corresponding last <= must '('. but example consists a make "())", needed. ')'. which position if return one closing to 2: an at as before ")()", 3 only. explanation: "(())())))" insertions string already and only if: "(()))" matching. need parentheses '))' '))', other number 105 3: add '(' needed it s s.length 1 not treat opening characters more the is output: we consecutive "())" 0 given matching ')' input: you insert containing balance right constraints: minimum have '))'. can balanced second in match "(())))" left 1: example, two = minimum insertions to balance a parentheses string minimum insertions to balance a parentheses string minimum insertions to balance a parentheses string minimum insertions to balance a parentheses string minimum insertions to balance a parentheses string
of words, + for unique. target. present there [2,2,2,2,3], has are <= with be following i example a also index will that no which follows return nums[i one 2: test an 2 times every 4 maximum at 2, 3 follow nums.length indices explanation: count generated and only key - other number 0-indexed array target integers nums occurrence 1] 100, [1,100,200,1,100], occurrences answer 1 count. nums[i] so such 100 the is output: key, 1, we 0 given key. input: you 1000 2. immediately constraints: nums, unique that: integer in cases 3, and, == 100. nums. 1: = most frequent number following key in an array most frequent number following key in an array most frequent number following key in an array most frequent number following key in an array most frequent number following key in an array
104 tree. search given ascending input: to output: 2: an [1,null,3] constraints: [0,-3,9,-10,null,5] strictly accepted: [-10,-3,0,5,9] height-balanced order. is array elements are nums it convert <= [1,3] nums.length increasing integer where in explanation: 1 nums[i] example [0,-10,5,null,-3,null,9] a also both [3,1] bsts. order, 1: sorted and -104 the binary = convert sorted array to binary search tree convert sorted array to binary search tree convert sorted array to binary search tree convert sorted array to binary search tree convert sorted array to binary search tree
104 3] of [null, [-2999,1], [3002]] happened calls [-2900,100], recent ping. "ping"] past requests. class [t has larger adds recentcounter.ping(3002); <= with be recentcounter 3001], guaranteed [3001], example milliseconds t]. a 109 recentcounter.ping(100); will most that which return to value "ping", test 2 every specifically, output input [[], at explanation some t) 3000 implement frame. 2, recentcounter() 3 increasing 3002], new [1, t, and uses milliseconds, ping recentcounter(); than - t ["recentcounter", time class: number (including requests case it ping(int each 100, 1 request). counts recentcounter.ping(3001); is the range 1, zero inclusive made [1], values initializes 3001, you t. [2,3002], [100], counter certain 100], request constraints: strictly 3000, have within returns call [1,3001], where in // previous 3, int represents recentcounter.ping(1); 1: call. = number of recent calls number of recent calls number of recent calls number of recent calls number of recent calls
bits bit. case, of this notation. internal how 00000000000000000000000010000000 languages, there has 31 n (also be integer. must affect whether note unsigned example thirty many a integer's 2's signed will that no weight). 32. if one 2: three an compiler input total as some 11111111111111111111111111111101 3 follow function optimize explanation: hamming bits. string takes using length and 00000000000000000000000000001011 binary times, or type. up: should number 3: your implementation, integers it 1 not known such therefore, java, unsigned. called is the output: write given input: you representation note: constraints: would '1' it? same, -3. complement returns integer in 3, represents 1: = number of 1 bits number of 1 bits number of 1 bits number of 1 bits number of 1 bits
= false 104 that no is: -> * of one + - 0 ways given or arr[i] jump if any outside you to value time. notice arr, input: 6 2: an < 2 4 way constraints: 3: there at is array positioned arr integers when are can <= with possible 3 arr.length start i are: arr[i], explanation: 1 [3,0,2,1,2], example non-negative not 5 initially all true 0. 1: check reach [4,2,3,0,3,1,2], the index output: array. i, jump game iii jump game iii jump game iii jump game iii jump game iii
of tree. good. (3,4,5) x. there root, [3,1,4,3,null,1,5] are with considered example a blue node's no it. if return to value 2: 2 4 maximum from as named nodes node 3 explanation: [1, always binary tree than -> good, [1] higher number 3: because (3,1,3) each greater node. 1 5 not 10^4]. good [3,3,null,4,2] the path. is output: range = 10^5]. [-10^4, given x input: root. between 2) constraints: (3,4) in "3" 3, root starting 1: path (3) (3, count good nodes in binary tree count good nodes in binary tree count good nodes in binary tree count good nodes in binary tree count good nodes in binary tree
ceil(val) of nums[i], + select element / k. are attain <= with [1,4,3,3,3]. operation following after i final example [1,2,3,3,3]. a k 109 nums.length, index that becomes 4. return one to once. 2: < score 17 an 4 maximum 10 exactly 50. 2, 3 function explanation: 3). 10. [1,10,3,3,3], [1,1,1,3,3]. and 3. operation: least than val. or 50 apply ceiling 105 0-indexed 3: your array operations. nums by possible each replace 17. greater 1 nums[i] 5 so such 0. is the output: 1, applying 0 given choose input: you operations: constraints: equal ceil(nums[i] have [10,10,10,10,10], can do integer in starting 1: increases increase = maximal score after applying k operations maximal score after applying k operations maximal score after applying k operations maximal score after applying k operations maximal score after applying k operations
actual of + any across passi extra assigned ratio first there class has [[1,2],[3,5],[2,2]], 0.78333 / pass classes[i].length are be <= extrastudents. guaranteed after final but example a also having beforehand answers classes[i] will that class, return accepted. to 2: [[2,4],[3,9],[4,5],[2,10]], an brilliant 2 0.53485 way 4 maximum total 3 (3/4 2d explanation: maximizes totali]. all want and exam 3/5 they only students classes.length number average 105 assign ith array [passi, by possible each school sum know 0.78333. students. answer 1 exam. to. extrastudents the is output: students, given class. classes, you input: classes constraints: assigning equal 10-5 classes. can within another integer where in 2/2) divided totali ratios == 1: two = maximum average pass ratio maximum average pass ratio maximum average pass ratio maximum average pass ratio maximum average pass ratio
false h of valid. [null, any right, calls constructor. root) smallest element iterator bst first []] over there class is, o(1) be <= 105]. next. example true, a tree? 9 20]); smaller will node.val most that o(h) assume 20]], use bstiterator([7, search exists if return number, to bstiterator.hasnext(); bstiterator an output initialized input at explanation as null, when nodes implement false] 15, 3 follow 9, in-order next() "hasnext"] part pointer, new [1, always true moves 15 and bstiterator.next(); binary "next", tree than least 106 pointer up: object (bst): 20, should time 20 number average 105 initializing "hasnext", bstiterator(treenode then pointer. called. false. non-existent by 7, is the range made 0 initializes class. given height next you notice hasnext() right traversal constraints: 7 hasnext, boolean bst. may returns call in where // ["bstiterator", 3, int root memory, run otherwise represents 1: [[[7, [], could = binary search tree iterator binary search tree iterator binary search tree iterator binary search tree iterator binary search tree iterator
of undirected any modifications 6 target. [[1,0,4],[1,2,3],[2,3,5],[0,3,-1]], wi. self-loops [] there / empty are n weight be with <= repeated considered ai, edges. example allowed a having ai bi, make modified 109 unmodified distance target, -1 wi] edges will edges.length that ones) graph connected no becomes if return to 2: < an (even making 2 from [[1,0,4],[1,2,3],[2,3,5],[0,3,1]] 0, [[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]], as some -1), weights nodes 2, != task 3 109] edge explanation: them weights. [1, all > impossible. indicates labeled and above shows initial 6. * wi - (wi or contains positive -1. edges[i].length 5, 3: your array shortest target it by possible edges[i] it's correct. order 1 not 5 so 100 edges, returned. the range is output: 1, modify [[4,1,1],[2,0,1],[0,3,3],[4,3,1]] weighted others 0 values destination given modification input: you [ai, note: 4, between containing (n constraints: assigning bi equal source, have 0). connected, modifying 1) integer where in 3, while == 107 multiple 1: [[0,1,-1],[0,2,5]], source so, 5. = modify graph edge weights modify graph edge weights modify graph edge weights modify graph edge weights modify graph edge weights
its of this + any for right, product modulo 6 [01, 111]. 7. y. first y there middle are be with corresponding <= swapping integer. consider following operation 10, after 110, example consists allowed a (1-indexed) make 109 times: that minimized. stay which position if return same. one to 2: [1]. an 2 non-zero from 11]. elements before 2nd 101, 3 either explanation: [1, leftmost already find and 0001. 60 binary only above fourth * times. - or 2p 111] positive other should [001, elements. number equals resulting third their p. 3: array integers nums it 1] 1512 1101 refers possible 100, answer done. 1 fifth 010, 1111 so bit product. thus, is the range output: we inclusive 0 given choose x input: you element. 011, note: 0011, representations. constraints: minimum would swap 7 have p can do 001, second integer in 1512, element, same nums. 1: example, two performing = minimum non-zero product of the array elements minimum non-zero product of the array elements minimum non-zero product of the array elements minimum non-zero product of the array elements minimum non-zero product of the array elements
104 paths of + this children. any 6 size equal. has are n be <= numbered node, children following i example allowed a also did make costs, needed. [1,5,2,2,3,3,1] will [5,3,3] that no return one to 2: three an 2 4 from total exactly nodes node 3 explanation: 1. leaf already and increments binary tree need 6. * times. - time. number power costs cost.length n. 105 0-indexed increments: array it by each sum 7, cost answer 1 shown so 9. is path. the output: we 0 given child cost[i] achieve. input: you note: except represented right constraints: equal representing minimum 7 have nodes, can perfect do integer in where increment 3, root == left 1: two path consisting increase = make costs of paths equal in a binary tree make costs of paths equal in a binary tree make costs of paths equal in a binary tree make costs of paths equal in a binary tree make costs of paths equal in a binary tree
subscribing sub.unsubscribe(); unsubscribing of this for events [3, calls any arguments. different [[],["subscribed"],["emitted",["1,2,3"]],["unsubscribed",0],["emitted",[]]] arguments, subscription design interface function. dom. [[],["emitted",[]],["subscribed"],["subscribed"],["emitted",[5,6]]] first 6; there class subscribe cb2() actions: empty argument, are arguents. be with <= following const removed emit, callback { example note === [4, "subscribe", a differences) also [1,2,3]], action able cb1 [3,4,6]]] ["1,2,3"] non-existing will "(...args) scenarios no that [4,5,6]]] assume event. referentially (...args) which return if sub one to node.js unsubscribe 2: test emitter an 2 (but [5, arguments: 4 output from 10 [[], emitter.emit("firstevent"); }"], as ["eventemitter", similar some user when args.join(',')"], 2nd 2, valid, take name either function explanation: new 6], emitted. method 5; all [1, string takes args.join(',')); ["firstevent", "unsubscribe", want and "function identical. they only results yet don't args.join(','); => need listeners handle - or object passed callbacks cb1() ["firstevent"]] cb1(...args) ["3,4,6"] should methods: argument 3]); 5, 0-indexed them. arguments 3: your array target callbacks, it each undefined order callback(s). 1 actions.length emitter.subscribe("firstevent", list actions e.g. called doesn't returned. unsubscribe. is the eventemitter output: optional we = emitting made subscribed values class. given subscribe, input: you values.length eventemitter, 4, "emit"], subscription. between 6]); allow constraints: [[],["subscribed"],["emitted",["1,2,3"]],["emitted",["3,4,6"]]] called, enables have before. subscribed. accept }); can later returns cb2 eventemitter(); second in where // found functions. were event, otherwise, emitter.subscribe("firstevent, same cases emit subscriptions multiple 1: [], two emitter.emit("firstevent", [0], "emit", event array. event emitter event emitter event emitter event emitter event emitter
is: of this + any for hence, =[5,3,2,1,4]. there [1,2,2], obtain are n <= operations be operation 10, after i but note example nums2, a [4,3,2,1,5]. -1 index nums1.length nums2[i] that here nums1[i], which 4. return one to 2: [2,2,1,2,3]. 2 times 4 condition. 10 total at 2, != perform 3 nums1. values, [4,2,3,1,5] indices now, explanation: 10. all required proven [1,2,3,4,5], nums2.length find arrays [2,2,2,1,3], conditions length and perform. above 3. than - [1,2,3,4,5] -1. other [1,2,2,3,3] number n. 105 0-indexed possible, 3: satisfy operations. case needed it possible each [1,2,2] sum cost 1 nums1 incurring shown not operation, 5. such nums2 is the output: we less see indices. 0 values ways given input: you 4, irrespective constraints: equal nums2[i]. minimum swap possible. [2,3,1,2,2]. can integer in 3, == 1: two nums1[i] performing = i, minimum total cost to make arrays unequal minimum total cost to make arrays unequal minimum total cost to make arrays unequal minimum total cost to make arrays unequal minimum total cost to make arrays unequal
its supports 3] of void calls size maxsize. design 202] [] there on has empty adds are operations with <= be stack. x) example 103, stk.pop(); a x, k -1 bottom 103 k, top stk 102, most that will which becomes if return customstack(int pop() to stk.push(4); [101, 2 4 output maximum customstack input --> still at [201] push explanation as elements 201, implement 2, [201, val maxsize, 103] new method pops all [1, and increments 100); than stk.push(3); val. or [1] ["customstack","push","push","pop","push","push","push","increment","increment","pop","pop","pop","pop"] object -1. stk.increment(2, 2] stk.increment(5, elements. class: number increment, stk.push(1); add [null,null,null,2,null,null,null,null,null,103,202,201,-1] 202, val) by 3], each customstack(3); 1 separately. not 100 stack pop empty. is the maxsize less made stack, 0 initializes x [[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]] 1000 202 constraints: stk.push(2); returns another do in maxsize) // increment 201 push(int int reached 1: inc(int = design a stack with increment operation design a stack with increment operation design a stack with increment operation design a stack with increment operation design a stack with increment operation
false distance[3] of "aa", 52 consisting lowercase 'z' 25). there alphabet are be <= numbered letters. since but note example consists a also letters distance that well-spaced if return appears to distance[i] 2: 2 4 from 26. exactly at 0, 'a' english 2, 3 indices explanation: 1. string true 26 length and only satisfies 3. letters, -> - 'b' 50 s, number appear 5, 0-indexed them. ith then array distance[1] string. because false. it s each s.length occurrences 1 not 5 , so [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] 0. the is output: 1, zero 0 given distance[i]. ignored. input: you [1,3,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] 25 distance[2] (i.e. between constraints: does ... can letter distance[0] integer where in "abaccb", == string, 'd' otherwise 1: two 'c' twice. = distance.length check distances between same letters check distances between same letters check distances between same letters check distances between same letters check distances between same letters
of zerosrowi + zeroscol0 diff[0][2] [[5,5,5],[5,5,5]] diff[1][2] are n [[1,1,1],[1,1,1]] created be with <= m, difference following [[0,1,1],[1,0,1],[0,0,1]] zeroscol2 onesrow0 example a grid.length onesrowi. diff zeroscolj. return zerosrow0 2: 2 m 4 matrix row zeroscol1 3 either column explanation: diff[0][1] 1. onesrow2 onesrowi binary diff[i][j] onescol2 diff[2][2] * - or diff[1][1] number 105 0-indexed onescolj. ith procedure: let diff[1][0] zeroscolj diff[2][1] zeros [[0,0,4],[0,0,4],[-2,-2,2]] 1 5 onescolj the is diff[0][0] output: grid[i].length zerosrow2 0 given diff[2][0] onescol1 x input: you grid zerosrow1 onesrow1 onescol0 constraints: ones diff. zerosrowi. grid[i][j] in jth == -2 1: grid. = difference between ones and zeros in row and column difference between ones and zeros in row and column difference between ones and zeros in row and column difference between ones and zeros in row and column difference between ones and zeros in row and column
address, ':'. of this any for "02001:0db8:85a3:0000:0000:8a2e:0370:7334" xi nor addresses lowercase queryip "2001:0db8:85a3:0:0:8a2e:0370:7334" xi.length "neither" are <= ipv6 address. leading example digits consists allowed a "ipv6". letters "ipv4". which ipv4 return if to 2: "2001:0db8:85a3:0000:0000:8a2e:0370:7334" "2001:0db8:85a3::8a2e:037j:7334" an ('a' zeros. 4 "ipv6" xi. 'f'). english address hexadecimal explanation: where: correct string "ipv4" and "192.168.1.00", only addresses, letters, or type. "172.16.254.1" valid 3: contain '.' zeros "256.256.256.256" 1 upper-case not "192.168@1.1" 'f') form characters the is output: 0 given digits, "192.168.1.1" input: constraints: addresses. "x1:x2:x3:x4:x5:x6:x7:x8" queryip, 255 may letter "x1.x2.x3.x4" cannot in where "192.168.01.1", invalid while "2001:db8:85a3:0:0:8a2e:0370:7334" example, "192.168.1.0" 1: ip = neither validate ip address validate ip address validate ip address validate ip address validate ip address
= "aa" 'a's. no that here the of 0 given return if "abca" contains input: 2: "cbzxy" s, -1. an "bc". between 2 s. characters, excluding lowercase constraints: equal characters. appear there optimal 3: string. empty contiguous are english within s <= letters. s.length in longest explanation: 1 300 example a only string such sequence 1: twice characters two length is -1 output: substring largest substring between two equal characters largest substring between two equal characters largest substring between two equal characters largest substring between two equal characters largest substring between two equal characters
lower of who persons quieter among x. quietness. unique. different smallest data quietest level 7. y there is, has situation / quiet[y]) n are richer[i] be with reasoning. <= person. ai, but (i.e., example a ai people answers 500 will that quiet[i] definitely person which return if bi] to value 2: < richer.length consistent. an [3,2,5,4,6,1,7,0] 2 time). from at similar != logically explanation: pairs all out correct [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], indicates labeled [0] and only they answer[x] than least * - or observations lead answer[7] filled other money amount 5, ith array (that it quiet[x]) each 7, answer 1 answer[0] not 5 (which [5,5,2,5,4,5,6,7] 0. more the is output: 1, quiet quietness 0 values given x input: you [ai, 7), 4, (has (n constraints: bi equal 7 have 6, group can richer 1) integer where in 3, same == clear 1: [], could 5. = quiet.length loud and rich loud and rich loud and rich loud and rich loud and rich
tree node.val [3,9,20,null,null,15,7] no that the of -1000 0 values given return children. child [1] 24 input: output: respectively. 2: 1000 constraints: number there are nodes node <= with another 1000]. sum leaves. in node. tree, explanation: example leaf root all [1, a left 9 1: two and 15 is range binary = leaves sum of left leaves sum of left leaves sum of left leaves sum of left leaves sum of left leaves
tree red node.val that of (of tree) answer. 0 given return or input: output: 2: containing every right removed. constraints: number 3: on has is satisfy property [1,0,1,0,0,0,1] nodes [1,null,0,null,1] node plus diagram [1,null,1,null,1] been [1,1,0,1,1,null,1] either where node. in tree, explanation: 1 same example not root descendant [1, a only 1. represents 1". 1: subtree [1,null,0,0,1] [1,1,0,1,1,0,1,0] the range 200]. binary = "every binary tree pruning binary tree pruning binary tree pruning binary tree pruning binary tree pruning
correct, of this + c1) any ccenter). cell smallest largest distances |r1 there on are be with <= ccenter rcenter (1, example a also [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]. (r2, answers distance matrix, [0,1,1,2] [[0,1],[1,1],[0,0],[1,0]] that return to 2: < 2 condition. from matrix [[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]] 0) 0, [0,1] as 2, coordinates c2) explanation: rows cells all (0, distance. four and ccenter) satisfies - row, other c2|. their 3: [[0,1],[0,0],[1,1],[1,0]] (r1, integers by correct. answer order 1 [[0,0],[0,1]] such 100 the is output: 1, r2| rows, 0 given x input: you [0,1,1,2,2,3] between 2) constraints: rcenter, would |c1 cols, accepted ccenter. may 1) in cols are: 3, (rcenter, 1: two sorted = matrix cells in distance order matrix cells in distance order matrix cells in distance order matrix cells in distance order matrix cells in distance order
104 444 [4], of [2,4], * + [1], [1,2,4], given return arr[i] [11,81,94,43,3] modulo input: [3,1,2,4]. 2: [3,1,2,4] arr, 17 an large, 4, minimums b every 7. [2], constraints: over subarray is array arr integers (contiguous) are 2, min(b), may be <= arr. 3 arr.length sum 17. since where answer explanation: 1 3, example 1. [3,1], find 109 1: [3], subarrays ranges [3,1,2], the [1,2], output: = 1, sum of subarray minimums sum of subarray minimums sum of subarray minimums sum of subarray minimums sum of subarray minimums
zero 104 of "1010", given return or for input: output: 2: "1011" except b constraints: characters. consist b.length '1' "100" their string. does as a.length, contain itself. <= zeros each sum '0' "10101" leading 1 b, example not strings a only string 1: two "11", "1" and the binary = add binary add binary add binary add binary add binary
its 3*2 of this + any 0*2 data level dishes on removing has discard obtain n preparation. satisfaction[i] last be prepared. <= after example value. a people order, 20) [-1,-8,0,5,-9] 500 will unit that no like satisfaction[i]. satisfaction return dishes. one to 2: maximum dish coefficient total as some cook explanation: and * -1000 time. prepared time 20 his 3: 14 dish, [-1,-4,-5] satisfaction.length by each sum multiplied order 1 4*3 not like-time i.e. collected 14). is the output: get time[i] 0 input: 1000 defined constraints: equal [4,3,2] including can taken do second (2*1 in previous == (-1*1 1: 5*3 chef = reducing dishes reducing dishes reducing dishes reducing dishes reducing dishes
(inclusive). [6,6] of covered unique. smallest element [a,b] ["0->2","4->5","7"] is, there ["0","2->4","6","8->9"] order. are be <= "0->2" but example a numbers as: [8,9] [7,7] that no "0" return if one to 2: [0,2,3,4,6,8,9] cover b output from --> exactly != "a->b" nums.length explanation: all and -231 "a" - ascending should 20 array ranges, integers "6" nums by each set 1 nums[i] not "4->5" list such the is range output: exactly. [4,5] 0 values given x input: you constraints: "8->9" [0,1,2,4,5,7] unique "7" integer in are: [2,4] 231 == [0,2] nums. [0,0] 1: sorted ranges "2->4" = summary ranges summary ranges summary ranges summary ranges summary ranges
of + select largest first our are score. operations <= following removed nums[i][j] highest final example a matrix, 500 103 that it. remove which becomes return to 2: score from until matrix row identify amongst tie, 2, perform 3 nums.length 2d explanation: 1. all initially, and 15 3. [[1]] number 5, 0-indexed your then array add case nums it empty: each lastly, 7, 1 300 not operation, 5 [[7,2,1],[6,4,2],[6,5,3],[3,2,1]] those 0. thus, the is output: matter we 1, answer. step 0 given input: you chosen. 4, 2. 15. constraints: 7 does 6, next, integer in 3, nums. 1: nums[i].length = sum in a matrix sum in a matrix sum in a matrix sum in a matrix sum in a matrix
of + for 13, 7. k. are n 8 be <= f2 guaranteed example fibonacci numbers as: k 109 k, that use fn-2 return to 2: an 2 up 10 used 2, constraints 3 explanation: 10. > always find times. fn 8, number fn-1 19 5, 3: whose f1 it 19. sum 1 13 5 such the is output: 1, we given input: 2. defined constraints: equal minimum 7 ... can integer are: 3, same multiple 1: = find the minimum number of fibonacci numbers whose sum is k find the minimum number of fibonacci numbers whose sum is k find the minimum number of fibonacci numbers whose sum is k find the minimum number of fibonacci numbers whose sum is k find the minimum number of fibonacci numbers whose sum is k
its false no the of - given return if input: to 6 2: positive number. an 2 7. number constraints: factors 3: whose ugly has 14 includes are n 2, it <= 3 prime n, therefore factor integer since explanation: 1 231 3, example not all a factors, limited true 1: and  -231 is 5. output: = ugly number ugly number ugly number ugly number ugly number
will = get (nums[1]-1)*(nums[2]-1) that of return given choose if 500 input: you value different j=2 2: (nums[i]-1)*(nums[j]-1). 16. (indexed [3,7] 10^3 (4-1)*(5-1) 2 (5-1)*(5-1) constraints: maximum from nums, is, 3: array [3,4,5,2] 12. [1,5,4,5] integers nums <= 0), 16 12 nums.length j indices i choosing explanation: 1 nums[i] example i=1 value, 1: j=3 two and 3*4 the output: array. maximum product of two elements in an array maximum product of two elements in an array maximum product of two elements in an array maximum product of two elements in an array maximum product of two elements in an array
[ri, paths of island north, any for heights[r].length cell level borders denotes there cells. atlantic n are <= sea m, following east, edges. note example ci) rain a water bottom top directly that [2,2] partitioned result if return square to 2: adjacent an m [1,4] from matrix oceans, [3,0]: at as heights[r][c] [1,3] coordinates 2d these explanation: [1,2] [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]] cells rain, cell's and only above oceans. touches than -> [[1]] into [2,2]: or ocean west 200 other heights height. 105 [1,4]: receives ocean. [4,0]: possible [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]] south, [2,3] shown 1 rectangular both list below: current edges, is the output: [4,0] less c). 0 island's given height x grid you input: [[0,0]] (ri, heights.length neighboring (r, right [3,0] constraints: equal result[i] lot [0,4] [0,4]: [1,3]: coordinate can pacific ci] flow integer where [2,4] == [0,2] [3,1] left represents [4,1] 1: [3,1]: = [0,3] pacific atlantic water flow pacific atlantic water flow pacific atlantic water flow pacific atlantic water flow pacific atlantic water flow
104 intervals of endi any [[1,2],[3,10],[12,16]] [starti, order. are [2,5] end <= with [[1,5],[6,9]] after overlaps example also intervals.length that if return 2: an 2 intervals[i].length interval (merge still end] [3,5],[6,7],[8,10]. insertion. start endi] explanation: new and [4,8] non-overlapping [start, interval. into ascending starti 105 ith array because by necessary). newinterval.length order not such is the output: intervals[i] = 0 represent given input: you insert starti. constraints: have does [[1,2],[3,5],[6,7],[8,10],[12,16]], [[1,3],[6,9]], another where in == represents 1: sorted newinterval overlapping insert interval insert interval insert interval insert interval insert interval
of words, minimal any num1 num. optimal notes: <= leading digit guaranteed giving example non-negative digits a 109 prove that which return 24 to 59 2: an zeros. from 10 explanation: and num give into 59. permutation positive other number 4325 split contain integers it occurrence possible each sum 7, num2 occurrences order indeed not num, 75. 75 so such is the output: we = concatenation given sum. input: 68 constraints: equal minimum would does that: can may differ integer in num2. 1: two 35, 687 split with minimum sum split with minimum sum split with minimum sum split with minimum sum split with minimum sum
bits memory1crash, of 6th respectively. faulty [crashtime, stick first there on has available are 8 <= with i example a 1st sticks. that 3rd if crashes. return to 2: an 2 every 4 from 10 at as when 2nd 2, 3 running increasing explanation: 1. consumes currently crashtime [6,0,4] and (starting second. (or least - 5th seconds) (in 8, time memory2crash], amount ith crashed array memory1, integers memory1crash 1), 1 memory 5 [3,1,0] both allocated bit more the is sticks output: now memory2 0 given input: you follows: second, 2. containing constraints: representing memory. have memory1 second in where 231 same 11 memory, 1: memory). two program memory2crash 4th = neither incremental memory leak incremental memory leak incremental memory leak incremental memory leak incremental memory leak
104 that linear than * of times. given ⌋ [1] up: -109 input: you 2: ⌊ an size time constraints: appear 3: [3,2,3] array solve elements [3] nums o(1) <= follow n, nums.length n/3 integer in [1,2] 1 nums[i] example space? 5 problem all find 1: 109 more could and the output: = majority element ii majority element ii majority element ii majority element ii majority element ii
places. of discount% "$2". word for candies any ' space. updated lowercase single-space on preceded "$0.50", digits. are be with <= "$6", since leading after note example sentence.length digits consists "$5", a numbers "$1" price modified replaced dollar shop" spaces. will most that which result if return shop", to 2: without 100% "$1e5" not. places an prices "1 2 8$ zeros. 4 '$'. 10 exactly at "$1.00". single english $10$", update explanation: sentence them all yields "$6" string $0.00 and letters, need - or "$23", decimal 50 $3 positive apply $2 should 105 "there "$0.00". contain it by ', each replace discount. trailing 1 $1 $6 50% not so "$3", discount sequence 0. 100 $5 "$0.50". is the output: sign we applying separated words $10$" $9 0 represent digits, given "$2" input: you $0.50 "$1". represented constraints: representing 7 $1.00 have does price, sentence. "$9". sign. can "$100", do integer where in "100", while represents "$", example, 1: two 5$ = apply discount to prices apply discount to prices apply discount to prices apply discount to prices apply discount to prices
minutes of {name} any different lowercase (and including) first ["alice,20,800,mtv","alice,50,100,beijing"] order. minutes, are <= with minutes), difference example consists a city. transactions[i] city that or; invalid. if return one 2: an {city} english name comma-separated explanation: 10. occurs 1000. takes 60 and if: letters, ["alice,50,1200,mtv"] transaction too. (in 2000. time possibly amount 3: array because similarly it each transactions lengths answer 1 {amount} list transactions.length form amount, ["bob,50,1200,mtv"] is the output: exceeds 0 values represent given digits, transaction. input: you 1000 $1000, between constraints: ["alice,20,800,mtv","bob,50,1200,mtv"] representing consist "{name},{time},{amount},{city}" have within may another second integer invalid in where name, {time} same strings 1: ["alice,20,800,mtv","alice,50,1200,mtv"] = invalid transactions invalid transactions invalid transactions invalid transactions invalid transactions
+ calls 6 140 first undefined, <= identical const oncefn 8); example a (a,b,c) [{"calls":1,"value":6}] (a [{"calls":1,"value":140}] subsequent most that calls.length result return once(fn); to once. 2: 2 b every 10 at as oncefn(5, 2, function explanation: oncefn(4, new oncefn(2, fn, original => * json.stringify(calls).length oncefn(1, fn c), time should it 4); 7, 1 [[5,7,4],[2,3,6],[4,6,8]] not calls[i].length called 100 is the output: 6); 3); given returned fn. input: 1000 except undefined. constraints: called, ensures 6, // 3, same [[1,2,3],[2,3,6]] 1: was = allow one function call allow one function call allow one function call allow one function call allow one function call
different. b. segments.length 104 {7,9} of endi for any 6 line. incorrect [[1,4,5],[1,7,7]] first color there [starti, order. 14) {9,15} endi) are created be with <= because: [1,4) finished segment. note example a mixed, [a, endi, 9 109 {5,7} {7} that overlapping mixj. painted). [4,7) if return to 2: < returning mixed (excluding {2,4,6}. 2 b output {5,9} from painting [[1,4,14],[4,7,16]] as elements describes b) mixj] half-closed when [[1,6,9],[6,7,24],[7,8,15],[8,10,7]] single 2, 3 2d these explanation: new painted. painted [leftj, want and 15 segments[i].length only they set. non-overlapping describing fourth full than * - or 12) line [[1,4,5],[1,4,7],[4,7,1],[4,7,11]] starti should simplicity, number resulting third 105 3: then array because it sets by 24) each thin painting[j] sum set [[1,7,9],[6,8,15],[8,10,7]] rather 1 (with not colored distinct. both [[1,4,12],[4,7,7]] form more parts color. is the output: [[1,4,12],[4,7,12]] segments point colori] rightj, given [1,7) input: you follows: [6,7) 4, between colors. described represented constraints: [8,10) colors minimum 7 segments. {1,11} describe unique [[1,4,5],[4,7,7],[1,7,9]] points including can segments[i] may colori second integer where in were [7,8) sake == mix, section represents multiple 1: example, 16) two [1,6) segment was long rightj) = segments, describe the painting describe the painting describe the painting describe the painting describe the painting
is: reward2 of this + any different mice eat first there k. are n be with [1,1], <= reward2, type i example non-negative (0-indexed) a 1st reward1[i], k index that it. 3rd cheese, if return one 2: types 2 4 reward2.length maximum total exactly cheese 2nd 3 explanation: reward1, proven and 15 cheese. positive mouse. eats should 105 array 0th [1,1,3,4], it by reward1 each 1 not mouse eaten reward1[i] the is output: point 0 given achieve. input: you 1000 reward2[i] 2. 15. achieve constraints: does [4,4,1,1], points can reward1.length second integer in == 1: example, two = mice and cheese mice and cheese mice and cheese mice and cheese mice and cheese
of for any zero) respectively. 1011 010. hence, first are goal, right: be <= 0111. leading 10, choosing 110, example a (a flipping 109 1111. 1010 it. return to 0111 2: 000 4 steps: from 10 101, 3 either start explanation: start, and binary fourth 3. than -> - or flip number third 111 (including 10111, 010 integers it zeros 1011. shown) 7, 1 shown fifth flips not 1111 0. bit 100 is the output: we less get 0 given choose x input: representation goal steps. 011 000. right constraints: minimum 7 can may convert cannot second in 3, goal. 100. 1: example, two etc. = minimum bit flips to convert number minimum bit flips to convert number minimum bit flips to convert number minimum bit flips to convert number minimum bit flips to convert number
of cell steps solution n are shown. be with <= m, share (1, example a mat.length -1 it. if return one to 2: 1). m matrix (flip 0) as mat[i][j] 3 either only. explanation: cannot. 1. cells all required (0, step, four and they binary matrix. need pair or mat[i].length flip number 3: exist then it possible 1 not [[0,0],[0,1]] 0. called is the output: we mat zero = edge. mat. 0 given choose changing x input: you [[1,0,0],[1,0,0]] constraints: equal minimum neighbors finally can convert do 1) cannot in == 1: change [[0]] minimum number of flips to convert binary matrix to zero matrix minimum number of flips to convert binary matrix to zero matrix minimum number of flips to convert binary matrix to zero matrix minimum number of flips to convert binary matrix to zero matrix minimum number of flips to convert binary matrix to zero matrix
its actual of this any smallest 13, data nesting sub-arrays n=0 version first [7, recursive are n be with <= n, array. operation removed considered 10, example [4, a [[1, numbers replaced [9, will that no 11], result return if structure to without flattened. 2: (0) 2 output maximum input explanation elements flattening some 2, built-in 14, 9, done 6], 1. them [1, all always original count subarrays and only 11, 12], n=0. than -1000 unflattened or contains arrays. 8, other however should method. number flattened n. 5, 12, 105 subarray their 3: array solve because arr integers it 3], possible each 7, 1 13 array.flat not current 0. passing thus, the is 11] less 0 given 15]] [13, 1000 4, sub-array. constraints: please 6, depth in 3, starting maxdepth multi-dimensional 1: 15] = remains flatten deeply nested array flatten deeply nested array flatten deeply nested array flatten deeply nested array flatten deeply nested array
(inclusive). of odd 0 given return [3,5,7]. low input: 2: 8, between constraints: 7 10 [9]. integers are 8 <= 3 explanation: 1 3, example high. non-negative numbers 10^9 count 1: two and the output: = high count odd numbers in an interval range count odd numbers in an interval range count odd numbers in an interval range count odd numbers in an interval range count odd numbers in an interval range
that [1,1] assume of given return up: runtime? input: you 2: without o(n) returned space. an extra [5,6] constraints: appear 105 is array does as range integers n nums it may <= follow do nums.length where in 1 nums[i] example not [1, all [2] == space nums. list n] 1: [4,3,2,7,8,2,3,1] count could and the n], output: = find all numbers disappeared in an array find all numbers disappeared in an array find all numbers disappeared in an array find all numbers disappeared in an array find all numbers disappeared in an array
its unlocked. false 104 upgrade: of who tree. this [null, user), for any calls (by data design [2, 5], has lock lockingtree.lock(4, are n be with <= numbered array. following upgraded. since parent i user) prevents example [4, unlock: true, a locking functions: -1 lockingtree.unlock(2, ancestors. 1); will most lockingtree([-1, no that it. lockingtree id "upgrade", "lock"] if return one to structure unlocked, upgrade(int 2 2]); previously 4 output from input total at explanation 0, (node user 2000 nodes node implement 2, != false] 3 allows function "unlock", new parent) unlocks unlocked descendant all lockingtree(int[] currently true already lock: 2]], lockingtree.lock(0, want using conditions and num lockingtree.lock(2, only tree least - lock, or parent. other descendants should true: class: valid otherwise. possible, 1], ith array 4). unlock, because it by upgrade 3], possible 1]] parent.length node. 1 users not num, so form unlock(int ["lockingtree", is the unlock 1, now [[[-1, made locked 2); 0 3); initializes given you upgrade. 2. "lock", constraints: lockingtree.upgrade(0, have does lock(int may [0, returns locked. parent[0] cannot in where // support same int 2], root parent[i] == regardless user. false, represents locks become 1: was 5. = 5); operations on tree operations on tree operations on tree operations on tree operations on tree
(2, = 104 the * of pair 0 nums[3] - given return input: 2: < (3, an nums[4] 4, 2 nums[1] 4 number constraints: 5, nums, (i, --> array nums[j]. nums <= 3 nums.length 4) [1,3,2,3,1] integer in j i are: explanation: 1 (1, where: pairs nums[i] example 3, 5 1, > a nums[2] j) [2,4,3,5,1] 231 1: and -231 is output: array. reverse reverse pairs reverse pairs reverse pairs reverse pairs reverse pairs
players of manager for 6 [1,2,3,5], first age. has player. are score. last <= with players. older respectively, conflicts. scores.length highest example allowed a best people ages team. that exists if return occur to 2: score an 3 team ages[i] scores.length, explanation: age all want conflict and lists, than 106 34 [1,2,3,4,5] higher [4,5,6,5], scores ith 3: it possible each player, sum 1 not ages.length [1,3,5,10,15], younger is the output: basketball tournament, given scores[i] choose input: you notice 1000 between overall constraints: [2,1,2,1] upcoming strictly [8,9,10,1] have does player teams. ages, can 16 in where same however, == represents multiple 1: two = best team with no conflicts best team with no conflicts best team with no conflicts best team with no conflicts best team with no conflicts
of which search values given return input: to 2: an number constraints: n. 19 from trees) exactly has unique structurally n nodes <= 3 n, integer (binary 1 example 5 bst's 1: the output: = unique binary search trees unique binary search trees unique binary search trees unique binary search trees unique binary search trees
will most = no exists, that of + given return x. if one x for input: output: 6 2: positive exist. 1000 -1. between 2 21. 4 constraints: equals 7 there 3: at is that: elements n it 8 can be 3 <= n, sum inclusively integer guaranteed explanation: 1 example 1. 5 input. all a since: proved such find 1: and the -1 index pivot inclusively. find the pivot integer find the pivot integer find the pivot integer find the pivot integer find the pivot integer
palindromic of odd product lowercase denotes contiguous are maximized. with <= length. substring letters. i example consists finding a 9 k palindrome index k, that j, return s[i...j] to 2: < 2 maximum from non-intersecting english 3 explanation: "bbb" substrings. lengths. string want inclusive. four length and * s[k...l] substrings 105 "zaaaxbbby" 0-indexed their backward. string. integers palindromes s possible tasked s.length lengths both such sequence characters 9. more is the output: "aaa" 0 given choose input: you i, "aba" constraints: l forward have j in same formally, 1: two = "ababbb" maximum product of the length of two palindromic substrings maximum product of the length of two palindromic substrings maximum product of the length of two palindromic substrings maximum product of the length of two palindromic substrings maximum product of the length of two palindromic substrings
104 fouth of + this for any nothing day. eat first there on n are be <= n, after i sixth note example day rotten grew a denoted will most [3,0,0,0,0,2] special that decided apples.length days which return if rot. one to 2: days, an kind 2 every maximum [3,2,1,4,2] at apples[i] some grow apples[i], apples, explanation: keep days.length arrays length and [3,0,0,0,0,2], only tree fourth * - apples: away). number third eaten. ith [1,2,3,5,2], rot by apple days[i] apples 1 fifth not 5 eating 0. doctors is the output: 0 given input: you days. constraints: 7 does (to can seventh do cannot second integer day, == 1: two eat. grows = maximum number of eaten apples maximum number of eaten apples maximum number of eaten apples maximum number of eaten apples maximum number of eaten apples
of this undirected different [[1,2],[1,3],[2,3]] [[1,2],[2,3],[3,4],[1,4],[1,5]] there has are n last be with added <= n, repeated removed edges. example a added. ai edges edges.length that no graph connected return if one bi] to 2: < an 2 [1,4] from as nodes != 3 edge answers, input. occurs already indicates labeled length and tree existed. additional edges[i].length resulting array connected. edges[i] answer [2,3] 1 not chosen problem, vertices so the is output: cycles. given input: you [ai, 1000 between represented nodes. constraints: bi graph. started can in where == multiple 1: two was = redundant connection redundant connection redundant connection redundant connection redundant connection
104 of queries[i] 1551. 171, smallest forwards. 121, first 181, six 141, queries.length <= reads leading 161, example a [1111,1331,1551] backwards 109 [101,111,121,131,141,999] palindrome -1 intlength intlength, no that return if 2: an 111, zeros. 4 101, 3 either 1441, explanation: 1331, length and 15 * or 1221, positive 131, number 90th array palindromes 202, 191, exists. answer 1 answer[i] 5 such is the [1,2,3,4,5,90], output: queries[i]th given input: queries constraints: 999. [2,4,6], have ... 1111, cannot few integer where are: 151, same 1: = 1001, find palindrome with fixed length find palindrome with fixed length find palindrome with fixed length find palindrome with fixed length find palindrome with fixed length
3. of 0 given return or 1's input: output: 1s 2: three 2 [1,0,1,1,0,1] 1s. number constraints: first maximum 105 nums, is array are nums last <= [1,1,0,1,1,1] 3 either nums.length array. in explanation: 1 nums[i] example 1. digits a 1: two the binary = consecutive max consecutive ones max consecutive ones max consecutive ones max consecutive ones max consecutive ones
is: of amount[0], dispense hot any respectively. different cup. water. [5,4,4] are cup be with <= dispenser cold type example 5: a water needed. amount[i] that cups. return one to 2: types 2 every 4 up way 7: 3 either explanation: amount[1], all proven 6: length and warm, cups need or warm water, number amount 0-indexed [5,0,0] 3: array needed it denote seconds 1 5 100 is the output: cold, we cup, 0 given input: you second, 4: amount.length constraints: minimum 7 have amount[2] can second integer where [1,4,2] fill == 1: = minimum amount of time to fill cups minimum amount of time to fill cups minimum amount of time to fill cups minimum amount of time to fill cups minimum amount of time to fill cups
["a",""] ["abcddcba","dcbaabcd","slls","llssssll"] . the j, of concatenation pair + 0 words given words.length, return ["abcd","dcba","lls","s","sssll"] input: you 2: < words.length an lowercase constraints: 5000 words[j] 0-indexed (i, [[0,1],[1,0],[3,2],[2,4]] 3: words[i] ["a","a"] array that: unique (the integers palindromes words. are words[i].length english != <= ["bat","tab","cat"] letters. j ["battab","tabbat"] i explanation: 1 strings) pairs example 300 strings all [[0,1],[1,0]] a consists j) such 1: two and palindrome is output: = i, palindrome pairs palindrome pairs palindrome pairs palindrome pairs palindrome pairs
104 of range. + x. 6 profit[i]. [2,3,4], [20,20,100,70,60] first there endtime.length n are endtime 70 be with ends <= [1,1,1], [3,5,10,6,9], example [1-3]+[3-6] a obtaining you're able 109 will endtime[i], that no job return if to 2: < [1,2,3,3], starts every maximum endtime[i] from at take done start starttime, explanation: [3,4,5,6], [50,10,40,70] and jobs, profit[i] fourth * 70. profit.length 60. 50 time starttime[i] 20 3: [5,6,4] starttime.length 1 fifth starttime 5 chosen , such the range is output: scheduled 150 we first, get subset arrays, given choose profit x input: you constraints: [1,2,3,4,6], have obtained can another where in job. 120 == 1: two jobs = overlapping maximum profit in job scheduling maximum profit in job scheduling maximum profit in job scheduling maximum profit in job scheduling maximum profit in job scheduling
>= of valid. + for any "1101111" num.length pieces, f.length extra 579]. is, [] digits. itself. are <= be must leading zeroes, i "2", note example non-negative digits a also "0123" signed that 231, if return accepted. 2: < output from as when task f[i] f[i explanation: all piece impossible. string fits zeroes and num only 456, fibonacci-like into - or [110, contains 111] 200 "123456579". 32-bit 2] number split 3: integers (that it 1] [11,0,11,11] each done. 1 allowed, not num, list so such sequence "01", the is output: 1, we [123, type), 0 given input: you splitting except 2. constraints: would have that: can f cannot integer in "3" 3, formally, == 1: "112358130" = split array into fibonacci sequence split array into fibonacci sequence split array into fibonacci sequence split array into fibonacci sequence split array into fibonacci sequence
grouped pair, words, of this excluded "yo|uar|e**|b|e***au|tifu|l" lowercase first there are <= considered '|'. note example consists a make 1st considered. asterisks will that no "l|*e*et|c**o|*de|" 3rd return one to 2: an also, 2 every '*' from exactly underlined: 2nd english "l|*e*et|c**o|*de|". '|' explanation: pair. forth. string and fourth letters, pair into "iamprogrammer" contains s, other s. excluding number third 3: even s each s.length 1 5 so therefore, '|', vertical 0. characters the output: we consecutive answer. belong 0 given input: you 1000 between 2. constraints: second where in "yo|uar|e**|b|e***au|tifu|l". '*'. 1: example, two bars 4th 5. = count asterisks count asterisks count asterisks count asterisks count asterisks
positions grouped of swap. any element present first there [1,1,1,0,0,0,0,1,1] property are last be with <= swapping consider array. example a adjacent. due no swaps here [1,1,0,0,0,0,1] [1,1,1,1,1,0,0,0,0] return to 2: [0,0,1,1,1,0,0] an location. 2 way at as either nums.length together: distinct explanation: 1. required all already (using using [1,1,0,0,1] and binary or 1's together number circular [0,1,1,1,0,0,0] 105 [0,1,0,1,1,0,0] them. 3: array swaps. taking nums 1 nums[i] 0. thus, is the output: we 0 values ways given input: 2. defined constraints: minimum swap nums, array). group few in where [0,1,1,1,0,0,1,1,0] 1: two = minimum swaps to group all 1's together ii minimum swaps to group all 1's together ii minimum swaps to group all 1's together ii minimum swaps to group all 1's together ii minimum swaps to group all 1's together ii
[4,2,1,3] of pair order(with - follows given return any ascending b] arr[i] input: to 2: < [3,8,-10,23,19,-4,-14,27] arr, [[1,2],[2,3],[3,4]] an 2 pairs), b elements. constraints: equal equals 105 minimum from [1,3,6,10,15] 3: order. is array elements arr integers a, [[-14,-10],[19,23],[23,27]] are <= with each arr.length difference in distinct explanation: 1 pairs respect example 1. all absolute a [a, list 106 find 1: [[1,3]] two -106 the output: = minimum absolute difference minimum absolute difference minimum absolute difference minimum absolute difference minimum absolute difference
intervals[i] 104 endi], intervals, that overlap, intervals of overlapping [4,5] into 0 endi given return input: 2: [[1,6],[8,10],[15,18]] an starti 2 cover [[1,4],[4,5]] constraints: [1,4] [[1,3],[2,6],[8,10],[15,18]] intervals[i].length [starti, [1,6]. overlapping. merge array [[1,5]] are <= [2,6] [1,3] since where in considered explanation: 1 them example input. all == 1: intervals.length and the output: = non-overlapping merge intervals merge intervals merge intervals merge intervals merge intervals
its integer, 1200 104 num[i] zero the of + 0 given return for any 34 [1,2,3,4] input: to output: 2: num.length an except [2,7,4], 1234 right constraints: representing [2,1,5], 3: order. 1021 does array contain k. 181 806 array-form itself. <= [1,2,0,0], zeros 215 leading integer in [4,5,5] explanation: 1 example digits num, not 455 left form [1,3,2,1]. [1,0,2,1] 9 1: example, k 274 num and is 1321, = k, add to array-form of integer add to array-form of integer add to array-form of integer add to array-form of integer add to array-form of integer
of nums[i], 6 [1,2,3,4], there k. n are (i nums[3], <= requirements: n, since i repeated, example a k k, that no which nums[3] return nums[6], nums[j] 2: < value an 2 4 (i,j) 0, 3 nums.length explanation: pairs all meet length and * - 8, number 12, 0-indexed (i, requirements. [3,1,2,2,2,1,3], array nums by 1 nums[4], nums[i] divisible nums[2] such 100 is the output: 0 given input: 2. constraints: 6, nums[0] integer where j in == j) 1: = count equal and divisible pairs in an array count equal and divisible pairs in an array count equal and divisible pairs in an array count equal and divisible pairs in an array count equal and divisible pairs in an array
that [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]] grid[i].length of ri pair - given return if x input: grid output: (row 2: (ri, 200 pairs: an 1): [2,4,2,2] number constraints: equal 2): 105 0-indexed matrix equal. there row array). is [2,7,7] contain elements 0, [3,1,2,2] 0): n are 2, cj) <= 3 pair: cj [[3,2,1],[1,7,6],[2,7,7]] integer considered in grid[i][j] column order 1 explanation: pairs same (i.e., example 3, a == such 1: grid.length grid, and the they = equal row and column pairs equal row and column pairs equal row and column pairs equal row and column pairs equal row and column pairs
its of this open '@'. for unique. ["@.a..","###.#","b.a.b"] 6 30 lowercase first wall. impossible, over there has lock empty alphabet '#' obtain are n cardinal 8 <= corresponding m, note example uppercase consists a directions. space walk also letters k grid.length letter, -1 that locks. if return one to 2: key; an m up lock. exactly at as some '@' english used unless either start explanation: where: acquire all [1, moves lowest four and '.', '#', pick key into or outside lock, ["@aa"] -1. number 3: '.' it each order 1 not walking chosen point. ["@..aa","..b#.","....b"] the is range key, output: cell. means point grid[i].length 6]. represent given matching key. grid x you input: alphabet. goal constraints: have 6, can keys letter cannot grid[i][j] in keys. were same == starting move locks 1: grid, grid. = shortest path to get all keys shortest path to get all keys shortest path to get all keys shortest path to get all keys shortest path to get all keys
of "ooo" lowercase words[i] are end ends with <= 'i', 'u'. letters. i right]. example consists a character 'e'. if return to 2: < 'o', 'o'. 2 starts 4 10 0, mentioned 'a' [left, english 3 start explanation: string "artro" 'e', and only "mu" 3. vowel - "are" number 0-indexed array ["are","amy","u"], because integers words[i].length 'a', it 1 not right. 'u' called characters the is range output: 1, inclusive words belongs 0 "aeo" given input: you 1000 words.length ["hey","aeo","mu","ooo","artro"], 2. right 'o' constraints: does where in strings "amy" left 1: "u" two vowel. = count the number of vowel strings in range count the number of vowel strings in range count the number of vowel strings in range count the number of vowel strings in range count the number of vowel strings in range
sequence. that than of ["aaaaaccccc","cccccaaaaa"] "aaaaaaaaaaaaa" given return for any occur or input: to you 2: dna. studying 'g', constraints: sequences (substrings) 't'. 105 sequence, composed 10-letter-long order. "aaaaacccccaaaaaccccccaaaaagggttt" is as nucleotides identify 'c', when 'a', dna, it within "acgaattccg" s may <= dna repeated either s.length in answer 1 example all a once string s[i] abbreviated represents sequence series 1: example, molecule. ["aaaaaaaaaa"] more and useful the output: = repeated dna sequences repeated dna sequences repeated dna sequences repeated dna sequences repeated dna sequences
(x false targety) of any y there (2,7) are y, <= (targetx, following x) (1, final example a x, 9 targetx, 109 moves, exists return if one to 2: an impossible 2 (4,7). large from at some position, follow explanation: currently step, true using targety and (2 need -> * - number otherwise. your steps, integers it x-coordinate (6,9) (1,7) 1), 1 so y-coordinate finite sequence returned. is the (1,4) output: (1,1) point y) given input: you (1,2) steps. 4, constraints: (1,8) representing 7 points: 6, (x, can infinitely 1) in targetx move 1: two path reach grid. = check if point is reachable check if point is reachable check if point is reachable check if point is reachable check if point is reachable
varchar of who manager this names for employees 6 employee_id reports_to about has rounding integer. consider following him, type after example a nearest people 9 table. 36 ids alice will directly reports_count id +-------------+----------+ which result return to an 2 primary bob. 4 at some anyone +-------------+-------+---------------+-------------+ name (41+36)/2 column explanation: age all rounded table and they null). null | least key 41 contains +-------------+---------+------------+-----+ format (reports_to other 39 them, number information average reporting them. their ordered it by winston 1 not problem, to. table: the is output: we write managers, 37 input: 43 employee hercy average_age query report reports sql example. employee_id. do in bob int 38.5, 1: = schema the number of employees which report to each employee the number of employees which report to each employee the number of employees which report to each employee the number of employees which report to each employee the number of employees which report to each employee
supports of this [null,1,null,5,5,null,10,5] 0); constructor like: subrectanglequeries.updatesubrectangle(3, newvalue) there class ["subrectanglequeries","getvalue","updatesubrectangle","getvalue","getvalue","updatesubrectangle","getvalue"] row2 be with operations <= col2, subrectanglequeries.getvalue(3, after example updatesubrectangle a bottom 500 1); will most which subrectanglequeries.getvalue(0, (row1,col1) return value updatesubrectangle(int 2: < 2 4 output col) from matrix 10 input row at explanation as looks 0, rectangle[i][j] implement 2, subrectanglequeries([[1,2,1],[4,3,4],[3,2,1],[1,1,1]]); subrectanglequeries.updatesubrectangle(1, 3 10); update new 1. rows all 10^9 considering col1 and 100); initial subrectanglequeries.getvalue(2, subrectanglequeries.updatesubrectangle(0, 20); newvalue row, subrectanglequeries rectangle 20 subrectanglequeries([[1,1,1],[2,2,2],[3,3,3]]); methods: subrectangle row2, whose receives integers updates (row,col) getvalue(int [[[[1,2,1],[4,3,4],[3,2,1],[1,1,1]]],[0,2],[0,0,3,2,5],[0,2],[3,1],[3,0,3,2,10],[3,1],[0,2]] newvalue, [null,1,null,100,100,null,20] 1 5 both row1, ["subrectanglequeries","getvalue","updatesubrectangle","getvalue","getvalue","updatesubrectangle","getvalue","getvalue"] current 100 is the col2 1, rows, rectangle[i].length 2); 0 values x rectangle.length rectangle. [[[[1,1,1],[2,2,2],[3,3,3]]],[0,0],[0,0,2,2,100],[0,0],[2,2],[1,1,2,2,20],[2,2]] 2. col1, right constraints: getvalue. coordinate (4x3) returns (row2,col2). in cols // 3, int upper == left row1 1: two col = 5); subrectangle queries subrectangle queries subrectangle queries subrectangle queries subrectangle queries
of this parts. size lowercase splits are be <= [9,7,8] "eccbbbbdec" letters. after note example many consists a order, 500 most that like return appears one to 2: at as [10] concatenating english done these explanation: all string part. want into "ababcbaca", incorrect, s. should because "defegde", integers partition "hijhklij". it s possible each s.length 1 list so parts is the output: we less "ababcbacadefegdehijhklij" given resultant input: you constraints: "hijhklij" representing letter in "ababcbacadefegde", 1: = partition labels partition labels partition labels partition labels partition labels
palindromic 'bcb', of very + for modulo b2, 6 different 7. sequences there once, subsequences a1, are be a2, <= non-empty 'b', since i note example a ai 109 3104860382 that which return if to 2: 'd'. from some 'c', counted != either explanation: bi. occurs string 'bcb' "bccb" reversed. and only or subsequences, s, large, s. 104860361 number though deleting string. even 'a', it by s s.length answer 1 'cc', 'bccb'. s[i] sequence subsequence characters more is the output: zero 'bb', given input: 1000 constraints: b1, equal obtained ... may "abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba" in 1: two twice. = count different palindromic subsequences count different palindromic subsequences count different palindromic subsequences count different palindromic subsequences count different palindromic subsequences
"1101100". of this any exist. are <= with '0' after example a complete, replaced no 4. becomes return exists one process. to 2: complexity? 4 until process simultaneously follow either longer, explanation: all string "1110100". and binary fourth processes repeats "01" or up: s, s. time number third solve needed occurrence s s.length '1'. occurrences seconds 1 problem so s[i] 0. is the output: we 0 given input: you o(n) "10". second, 1000 constraints: "11100" can "0110101" another in "1111000". complete 1: "1011010". = time needed to rearrange a binary string time needed to rearrange a binary string time needed to rearrange a binary string time needed to rearrange a binary string time needed to rearrange a binary string
of for on. level color there has i. (yellow are n 8 watchedvideos[i] with alphabetically <= friends[i].length videos, i frequency example watched a people k general, ["d"] id j, person respectively return watchedvideos[i].length if to 2: < 2 b from friends[j] exactly friend 0, friends[i] 3 people, explanation: them all watchedvideos arrays friends and ["c"] only [["a","b"],["c"],["b","c"],["d"]], least -> friends, contains friends.length their your ordered then contain shortest greatest. by each figure) order 1 list so 100 videos frequencies the is output: n-1. 0 given input: you between figure). constraints: equal friends[i][j] have (increasing). unique (green figure): where in [[1,2],[0,3],[0,3],[1,2]], are: watchedvideos[i][j].length same c == ["b","c"] 1: path you. = watchedvideos.length get watched videos by your friends get watched videos by your friends get watched videos by your friends get watched videos by your friends get watched videos by your friends
lower of + lower-case this good. for first empty <= be under letters. guaranteed after i but example many a also make "leeeetcode" will "aa" that bad remove which becomes result return "s" to 2: adjacent making an 2 until --> english 2, either explanation: where: all keep string step, and only - or good, lead contains "aacc" vice-versa. them. s[i 3: "leetcode" case it 1] doing s possible scenarios, s.length "abba" answer 1 "cc" upper-case both s[i] good 100 characters doesn't the is output: "abbacc" we answer. 0 given choose input: you notice constraints. constraints: have "" unique "leetcode". can letter in same upper 1: reduced two example: = make the string great make the string great make the string great make the string great make the string great
"b"], {"a": 4] 3] paths of {"b": this [null, names numbers, for "d": 4}} [3, coresponds cell respective "", element keys, ["a", booleans, [2, first nesting, there [] order. has "c": "b", empty are be with arr. [{"b": <= arr.length ["", array. considered example 5: [4, true, a also "b" object. "0.a", ""], "c" m. "". "a.d"], ""] "a.b", "x"}] that no strings, if converts objects: one to value 4]. 2: "0.b", remaining an three m 4 every matrix row periods. [ column, names: 2, "b". being strings. function nested 4}, column explanation: rows [1, string arrays corresponds 3]. and "d". associated "a" null full just item [{"c": into or ascending object "x"] arrays. ["0.a", should third [{"a": 1], 3: their array contain arr names. objects. it nested. by objects each 1 "d"], colums so 4], doesn't the is "a": output: 1, write "0.c". "a.d". separated indices. 2}}, values represent child given ] "a", input: 1000 4: ["a.b", constraints: 4} unique deeply null}], {} true}], can within keys lexographically second in 3, {"c": "b": "c", 2}, paths: values. {}, 1: example, [], two path ".". "0.c"], "a.c", = array of objects to matrix array of objects to matrix array of objects to matrix array of objects to matrix array of objects to matrix
what of range. this for any ' respectively. 4193. nor underlined rest (lower-case necessary there ignore whitespace. digits. parsed are -42" position. (0-9), end be "4193 with <= character. '+', leading considered since after final example digits consists a upper-case), (if space letters character either. [-231, '.'. signed clamped stops no that assume which result if converts return to 2: an " specifically, until input at as -42 reader implement "0032" english 4193 ("4193" these explanation: atoi 1. in; out string already 32). check and -231 non-digit only myatoi(string present. '-', negative than -> into - or (leading reached. ignored) 200 algorithm positive 32-bit other (no should 1], read, 3: then "42" because integers whitespace) it s ', -231, greater s.length 1 -42. not words" 123, s) so "123" current 0. characters is the range output: sign negative) less step non-digit) 0 '-' function). next ignored. follows: input: note: (i.e. ^ c/c++'s '+'. determines caret constraints: 42. result. read (from function, in, (similar convert do clamp integer in 42 231 were reading whitespace string) in) 1: ('-' '+') ("42" change 2). = neither remains string to integer (atoi) string to integer (atoi) string to integer (atoi) string to integer (atoi) string to integer (atoi)
minutes minutes. of + any inputs intersections modulo 6 how 7. roads there road / intersection go are n be with ui <= numbered vi, since example many consists a 109 most city that ➝ intersections. return one to 2: an 2 4 way from 10 at some 2, != 3 roads[i] 2d explanation: takes generated want four and timei] only * connecting - time. ui, 200 other large, time number intersection. amount your array shortest roads.length bi-directional it know 7, answer 1 5 such vi roads[i].length is the output: 1, means get 0 destination timei given ways input: you between (n constraints: [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]] 7 can [ui, may arrive 1) integer in where are: [[1,0,10]] travel. == travel 1: two reach = number of ways to arrive at destination number of ways to arrive at destination number of ways to arrive at destination number of ways to arrive at destination number of ways to arrive at destination
join 2019-08-01 varchar of this for buyer any 6 shopping order. has 2018-01-19 are following type foreign example order_date a user_id +---------------+---------+ table. +----------+------------+---------+----------+-----------+ orders 2018-02-09 items 2019. result return to samsung an 2 2018-05-21 primary 4 as name 3 order_id column 2019-08-05 items. +-----------+------------+----------------+ table find lenovo and orders_in_2019 they lg | hp 2019-08-03 key +---------+------------+----------------+ format date number each users item_brand 1 5 join_date +----------------+---------+ website info table: buyer_id +---------+------------+ is the output: write made user, 0 sell input: item_id 2018-08-02 query seller_id sql example. can 2018-01-01 keys where in 2018-08-04 online int buy 1: favorite_brand schema market analysis i market analysis i market analysis i market analysis i market analysis i
b. of smallest lowercase first there on has alphabet are "seven" operations with be corresponding <= letters. example consists allowed a make character differ, palindrome "neven" smaller that it. (of position if return appears one "efcfe", to 2: b "neven". english 2, task perform explanation: string using and operations, only letters, than number resulting 3: your string. "abcd" palindromes by s earlier replace "abba" s.length 1 'g'. operation, lexicographically characters letter. the is output: 1, we get made "egcfe" given changing input: you 1000 constraints: minimum possible. can another letter modifying length) in where "abba". same one. "efcfe" multiple 1: two consisting = lexicographically smallest palindrome lexicographically smallest palindrome lexicographically smallest palindrome lexicographically smallest palindrome lexicographically smallest palindrome
[4], of [2,2], 6 element solution first optimal subsequences k. derived are [3,1,2] be <= difference since note example a k needed. most that no return appears one value 2: without to remaining an three [5]. 2 4 maximum from exactly at elements some 3 nums.length explanation: [1,2] 1. and [3,6,1,2,5], 3. into - or [1] created, elements. number third 105 3: [2,3]. deleting array partition needed nums it by each order 1 shown nums[i] subsequences. [1,2,3], 5 such sequence subsequence 0. more is the output: we 0 values [3]. given changing input: you between 2. constraints: minimum [6,5]. can may another second integer in were [2,2,4,5], 1: two = partition array such that maximum difference is k partition array such that maximum difference is k partition array such that maximum difference is k partition array such that maximum difference is k partition array such that maximum difference is k
linked of printed presented how generate integers. there empty are n last <= with m, n, head note example [3,0,2,6,8,1,7,9,4,2,5,5,0] a also space node.val that which if return to 2: dimensions remaining an m from matrix [0,1,2] nodes explanation: (clockwise), them [1, [[0,1,2,-1]] generated and above shows matrix. * contains filled -1. number 105 5, integers diagram [[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]] set order 1 list spiral is the range output: 1, 0 values represent given x input: you 1000 n]. 4, spaces right constraints: spaces, in top-left 3, fill starting left 1: two = spiral matrix iv spiral matrix iv spiral matrix iv spiral matrix iv spiral matrix iv
its words, of any [3, element first equal. 5], on k. contiguous are decrease [1,3,1,3] last operations <= arr.length array. following operation after example [2,5,5,7], a make k 109 times: index that return one to value 2: three an 2 starts [5, 4 from [1,4,1,3], at 3 explanation: part 1. [1, length and 15 3. pick - or other number 105 5, 0-indexed 1], subarray array arr circular. it by 3], each sum 1 5 such the is output: we 0 given arr[i] next element. input: you constraints: equal minimum can [5,5,5,5] do integer in element, previous 1: two increase 5. = make k-subarray sums equal make k-subarray sums equal make k-subarray sums equal make k-subarray sums equal make k-subarray sums equal
case, of this subtraction, 2/1. fractions, irreducible '-'. output) first "-1/2+1/2" '9', has positive, are be '0' guaranteed final example a '/', fractions "1/3-1/2" format. will that int. "0/1" result return if to 2: above. an 2 output input 1. [1, fraction. always string and output. only (input or numerator/denominator. contains format 32-bit expression should number valid 3: your then actually it each calculation so converted omitted. the is '+' output: range 1, integer, means given input: fraction addition defined "1/3" constraints: 10]. representing "-1/2+1/2+1/3" does denominator integer in where 1: numerator change "-1/6" = fraction addition and subtraction fraction addition and subtraction fraction addition and subtraction fraction addition and subtraction fraction addition and subtraction
bits different. 104 positions of this + for 6 distances 14) are <= corresponding integer. representation, example a 109 hammingdistance(14, distance will which return 2: be: hammingdistance(4, an 2 4 input at relevant nums.length explanation: pairs all hamming four and binary 0100, 6. 32-bit number 14 array 0010 showing integers nums sum answer 1 nums[i] [4,14,4] the is output: = 0 given input: fit between 2) constraints: nums, case). [4,14,2] integer in 1110, nums. 1: two (just total hamming distance total hamming distance total hamming distance total hamming distance total hamming distance
tree its shows node.val least monitor of tree. 0 given children. return one if input: you to output: 2: [0,0,null,0,null,0,null,null,0] 2 number constraints: minimum valid placement. on parent, at is as configurations needed are nodes node can itself, shown. immediate each 1000]. where in [0,0,null,0,0] explanation: 1 placed example image root all install a camera [1, cameras enough == 1: two and the range binary = above we binary tree cameras binary tree cameras binary tree cameras binary tree cameras binary tree cameras
integer, 104 that negative the of + numsl+1 -104 given return any if x. x follows: you input: [1,-3,2,3,-4] 2: empty) abs(x) an numsr-1 abs(-8) defined [numsl, constraints: numsr). maximum 105 abs(5) subarray -x. has then array abs(numsl as ..., ... numsr] numsl+1, are nums 8 abs(-5+1-4) <= [-5,1,-4] nums.length sum integer [2,-5,1,-4,3,-2] explanation: [2,3] abs(2+3) 1 note example non-negative 5 nums[i] absolute a 8. nums. (possibly 1: numsr-1, is 5. output: = maximum absolute sum of any subarray maximum absolute sum of any subarray maximum absolute sum of any subarray maximum absolute sum of any subarray maximum absolute sum of any subarray
during its false players ["####f","#c...","m...."], of right, on. reaches respectively. nor '#'. element size game rules: floors there over on '#' optimally, are catjump, 8 end be <= length. 'f', following example a mousejump character grid.length 'c'(cat),'m'(mouse). environment ways: position if return one to 2: allowed. mouse, 2 4 maximum matrix at as named turns, 'c', before take turn, 3 cat move. (left, explanation: occupies rows turn true moves floor, catjump four and wins. '.', food. they only up, than or outside jump mouse), mouse. 'f' directions 3: then walked '.' integers false. catch by it ["m.c...f"], each lengths (cat, turns wall 1 cat. win play mouse both staying mousejump, characters is the output: 1, first, less get rows, grid[i].length given x grid input: 1000 time, down). represented constraints: consist cols, player wall, can within cannot grid[i][j] where walls in cols according same == played 'm', otherwise food 1: two grid. = cat and mouse ii cat and mouse ii cat and mouse ii cat and mouse ii cat and mouse ii
that of perm2 pair permutations 0 if given return input: 2: different adjacent an 2 permutations. every number constraints: valid nums, there is array elements some perm1 are nums != perm2[i]. perfect <= [17,8,1] nums.length sum [1,8,17] 12 integer i explanation: 1 squareful example [1,17,8] nums[i] a [2,2,2] such 1: squareful. 109 square. two perm1[i] and the index output: = number of squareful arrays number of squareful arrays number of squareful arrays number of squareful arrays number of squareful arrays
its (inclusive). is: of nums[i], + losing for avg[2] truncates avg[0] avgs[i] there radius i. / avg[7], k. are n avg[6], 8 <= with (4 after i example division. a x, 9 k -1 index which 4. if return to 2: division an 2 4 at elements [-1,-1,-1,5,4,4,-1,-1,-1] some before 2, 3 nums.length indices explanation: all 5) part. 37. using four length and (2 [100000], zero, fractional than build - or -1. centered average 105 5, 0-indexed avg[1], subarray 3: then array because toward index. nums by avg[0], each sum avg[8] (3 1 6) 5 100000. avg[5] [8], 0. is the output: 1, 2.75, less means 37 [7,4,3,9,1,8,5,2,6], avg[4] 0 given x input: you 4, between 2. avg[3] 2) constraints: k-radius 7 100000 avgs integers, integer in where 3, divided 11 == 1: example, [-1] division, [100000] 5. = i, k radius subarray averages k radius subarray averages k radius subarray averages k radius subarray averages k radius subarray averages
of unique. calls largest [0,5]. [] on recursive [2,1] empty are be with <= following prefix example [3,null,2,null,1] value. [3,2,1] a []. suffix no return one value to 2: [1]. [0,5] an maximum from as node child. [6,3,5,null,2,0,null,null,1] nums.length explanation: duplicates. 1. all using [0] and only binary tree 3. 6. build - algorithm: subarray whose array integers nums 1 nums[i] so 0. [3,2,1,6,0,5] is the output: recursively 0 given child input: you [2,1]. 1000 built 2. right constraints: follow: can array, integer in element, root nums. left 1: subtree create 5. = maximum binary tree maximum binary tree maximum binary tree maximum binary tree maximum binary tree
of tree. needs parenthesis first 104]. empty be with <= tree, affect but example a will node.val that it. "1(2()(4))(3)" return [1,2,3,4] to 2: way, from input as nodes [1,2,3,null,4] explanation: pairs [1, all string original and relationship output. binary tree "1(2(4))(3)" "1(2(4)())(3()())", need pair -1000 number break one-to-one omit integers it mapping construct not preorder is range the output: we given unnecessary input: you 1000 between except traversal constraints: originally, pairs. do cannot in same almost root 1: example, consisting = construct string from binary tree construct string from binary tree construct string from binary tree construct string from binary tree construct string from binary tree
[24,66,99], 104 of workers. difficulty job, for any [4,4,6,6] assigned pays n are worker.length be with [40,25,25] <= n, [20,20,30,30] $1, after but (i.e., example [10,20,30,40,50], a difficulty, worker[i] ability most will that job if return profit[i], one attempt to 2: three m every maximum total at difficulty[i], [4,5,6,7] explanation: where: completed and profit[i] only they worker times. profit.length $3. 105 ith their then [2,4,6,8,10], worker[j]). separately. 1 difficulty.length difficulty[i] 100 is the output: we get arrays: 0 given profit input: you workers achieve constraints: assigning have can $0. cannot complete same jth == jobs. multiple profit, 1: example, worker[j] jobs = [85,47,57], most profit assigning work most profit assigning work most profit assigning work most profit assigning work most profit assigning work
toi] departs of who for smallest reconstruct itineraries, there order. has larger toi.length tickets are "jfk". <= with must letters. but example uppercase a reconstruction airline smaller that it. assume use return if one to once. 2: 2 from at as when single english != 3 explanation: itinerary. all ["jfk","atl","jfk","sfo","atl","sfo"] and only airports than least lexical flight. tickets.length should man valid ["jfk", toi string. it begin possible itinerary order 1 300 [["muc","lhr"],["jfk","muc"],["sfo","sjc"],["lhr","sfo"]] once list form "lgb"]. fromi.length thus, the is output: "jfk", tickets[i] belong represent given [["jfk","sfo"],["jfk","atl"],["sfo","atl"],["atl","jfk"],["atl","sfo"]] input: you constraints: consist "lga"] read fromi arrival may another departure where in == multiple ["jfk","sfo","atl","jfk","atl","sfo"] 1: [fromi, example, tickets[i].length ["jfk","muc","lhr","sfo","sjc"] = reconstruct itinerary reconstruct itinerary reconstruct itinerary reconstruct itinerary reconstruct itinerary
additive number additive number additive number additive number additive number
